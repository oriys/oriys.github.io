<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Miscs on Y.CH.Y</title><link>/misc/</link><description>Recent content in Miscs on Y.CH.Y</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Y.CH.Y</copyright><lastBuildDate>Sat, 18 Feb 2023 15:36:08 +0800</lastBuildDate><atom:link href="/misc/index.xml" rel="self" type="application/rss+xml"/><item><title>笔记::Go编程语言</title><link>/misc/tgpl/</link><pubDate>Sat, 18 Feb 2023 15:36:08 +0800</pubDate><guid>/misc/tgpl/</guid><description>程序结构 名称 Go 有 25 个关键字，包括 if 和 switch，只能在语法允许的情况下使用；不能作为名称使用。
break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type 此外，还有大约三十多个预留的名称，如 int 和 true，用于内置常量、类型和函数。
常量：
true false iota nil 类型：
int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error 函数:
make len cap new append copy close delete complex real imag panic recover 这些名称没有被保留，可以用在声明中，但是要注意潜在可能造成的困惑。</description></item><item><title>Learn_databases</title><link>/misc/learn_databases/</link><pubDate>Sun, 12 Feb 2023 22:07:08 +0800</pubDate><guid>/misc/learn_databases/</guid><description>关系型数据库 键值数据库 文档数据库 图数据库 列式数据库 分布式数据库 时序数据库 Elasticsearch</description></item><item><title>Kubernetes 101</title><link>/misc/learn_k8s/</link><pubDate>Sun, 12 Feb 2023 15:37:04 +0800</pubDate><guid>/misc/learn_k8s/</guid><description>介绍 定义： Kubernetes 是一个开源的容器编排系统，可以自动部署，自动扩展，自动管理容器化的应用。它提供了一个通用的平台，使得开发人员和运维人员能够快速而简单地创建和管理分布式应用程序。
背景： Kubernetes 诞生于 Google，是在 Google 的 Borg 项目的基础上开发的。它于 2014 年开源，并且很快就获得了广泛的支持。随着容器技术的发展，Kubernetes 已经成为云原生应用程序的领导者，并且在全球范围内得到了广泛的应用。
特点： 可扩展性：Kubernetes 支持在活动状态下扩展和缩小集群规模，并且可以随着业务需求的变化动态调整资源分配。 高可用性：Kubernetes 提供了自动故障恢复，自动滚动升级等功能，确保了应用程序的高可用性。 简单管理：Kubernetes 提供了一个统一的接口来管理容器化的应用程序，使得管理变得简单方便。 强大的生态系统：Kubernetes 的生态系统是一个庞大的生态系统，其中包含了众多的插件和工具，可以帮助用户更好地管理 Kubernetes 集群。 架构 集群架构： Kubernetes 集群由多个节点组成，其中每个节点都运行着一组容器。在集群中，有两种类型的节点：主节点和工作节点。主节点负责管理整个集群，而工作节点负责执行容器。
核心组件： Kubernetes 核心组件包括 API 服务器，控制器管理器，调度器，etcd 数据存储，网络插件等。这些组件协同工作，以提供集群管理和容器调度的功能。
对象模型： Kubernetes 的对象模型包括各种类型的对象，如 Pod，ReplicationController，Service 等。这些对象通过 API 服务器与集群交互，以实现对应用程序和资源的管理。
Kubernetes 工作流 应用程序部署： Kubernetes 提供了多种方法来部署应用程序，包括使用命令行工具，YAML 文件等。在部署应用程序时，Kubernetes 会使用 ReplicationController 和 Service 来管理容器。
自动伸缩： Kubernetes 提供了强大的自动伸缩功能，可以根据应用程序的资源需求动态调整容器数量。这样，您可以确保应用程序总是在适当的资源范围内运行。
滚动更新： Kubernetes 提供了滚动更新功能，使您可以在不影响用户体验的情况下更新应用程序。在更新过程中，Kubernetes 会逐渐替换旧的容器，并在更新完成后恢复全部容器。
开发人员和运维人员的工作 开发人员： 开发人员可以使用 Kubernetes 来部署和管理分布式应用程序。开发人员可以使用 Kubernetes API 和 CLI 工具来编写和测试应用程序，并使用 Kubernetes 来管理容器生命周期。</description></item><item><title>gin-vue-admin 代码学习</title><link>/misc/learn_gin_vue_admin/</link><pubDate>Sat, 04 Feb 2023 20:42:10 +0800</pubDate><guid>/misc/learn_gin_vue_admin/</guid><description>gin-vue-admin 项目学习 项目结构 ├── deploy： 部署相关的文件 ├── docs： 项目文档 ├── server： 后端代码 └── web： 前端代码 项目分为两个部分，使用 vue 框架的前端部分和使用 gin 框架的后端部分，前端部分在web 目录下，后端部分在server目录下。我们主要关注 server 后端部分。了解一下目前 github 排名第一的 golang admin 项目是怎么设计的。
后端结构 ├── api │ └── v1: v1 版本的 api，相当于java中的 controller ├── config: 配置类，包括数据库配置，jwt 配置，redis 配置等 ├── core │ └── internal: 服务启动方法 ├── docs: swagger 文档 ├── global: 全局对象 ├── initialize │ └── internal: 初始化方法，日志，数据库，redis，jwt，定时任务等 ├── middleware: 中间件,包括跨域，jwt，casbin，日志，全局异常处理等,使用了 gin.handleFunc 的特性 ├── model: 数据库模型，请求参数，响应参数 │ ├── common │ └── system ├── packfile ├── plugin: │ ├── email: email 插件，是个完整的小项目，里面结构和外部类似 │ ├── plugin-tool: │ └── ws ├── resource: 资源文件，包括自动生成代码的模板，页面模板，插件模板等 │ ├── autocode_template: 代码模板，从结构体生成代码 │ ├── page: 前端静态资源 │ └── plug_template: 插件代码模板 ├── router:路由代码 │ └── system: ├── service: 业务代码，相当于 java 中的 service │ └── system ├── source: 数据库的初始数据 │ └── system └── utils: 公共的工具类 ├── captcha ├── plugin ├── timer └── upload 项目启动 func main() { global.</description></item><item><title>2022::书单</title><link>/misc/books_2022/</link><pubDate>Sat, 31 Dec 2022 17:12:59 +0800</pubDate><guid>/misc/books_2022/</guid><description> 书名 分类 Pulsar in Action 编程 第三时效 推理 设计模式之禅（第 2 版） 编程 深入理解 Kafka：核心设计与实践原理 编程 领域驱动设计 编程 UNIX 环境高级编程（第 3 版） 编程 Linux/UNIX 系统编程手册 编程 发布！设计与部署稳定的分布式系统（第 2 版） 编程 是我把你蠢哭了吗 认知 饱食穷民 社会 妻子们的思秋期 社会 流星之绊 推理 你的孩子不是你的孩子 教育</description></item><item><title>程序员修炼之道摘录</title><link>/misc/the_pragmatic_programmer/</link><pubDate>Sat, 19 Feb 2022 23:43:39 +0800</pubDate><guid>/misc/the_pragmatic_programmer/</guid><description> 关注你的技艺 如果你不关心怎么把软件开发好，那么软件开发领域就再也没什么好谈的事情了 思考！思考你的工作 对每天里每一个项目所做的每一个决定进行的批判性评估 我们，采集的只是石头，却必须始终展望着未来的大教堂 每一天都要努力打磨你的技能，并往技能库里添加新的工具 不断地做出许多小的改进 务实的哲学 你的事业是你自己的，更重要的是，你的人生是你的 务实的程序员的特质是什么 在解决方案中透出的态度、风格及理念 试着将问题放在更宽泛的上下文中综合考虑，从大局着想 为所做的一切负责</description></item><item><title>发布！设计与部署稳定的分布式系统</title><link>/misc/release_it_design_and_deploy_proudction_ready_software/</link><pubDate>Sun, 13 Feb 2022 22:51:56 +0800</pubDate><guid>/misc/release_it_design_and_deploy_proudction_ready_software/</guid><description>生产环境的生存法则 瞄准正确的目标 今天的软件设计在与现实相差甚远的环境中进行，其目标在于通过 QA 部门的验收，不能保证在未来三五年的适用性。另一方面，制造业的产品设计师一直在追求能够让人们以低成本和高质量的方式制造产品的“可制造性设计”。软件行业的“可制造性设计”，就是“为生产环境而设计”。我们既需要设计一个个彼此独立的软件系统，也需要设计由相互依赖的系统所组成的整个生态系统，从而以低成本和高质量的方式进行运维工作。
应对不断扩大的挑战范围 是随着用户触点的增加和系统规模的扩大，系统遭到破坏的方式也会翻新，环境会变得更加恶劣，人们对缺陷的容忍度会变得更低。这个正在不断扩大的挑战范围，即以低成本快速构建和运维对用户有益的软件，要求我们持续改进架构和设计技术。
多花 5 万美元来节省 100 万美元 设计决策和架构决策，也是财务决策。在选择时，必须着眼于实施成本和下游成本。在假设可以投资 5 万美元来创建不停机发布的构建流水线和部署过程。这样做至少可以避免 100 万美元的停机部署损失，而且大有可能提高系统部署频率，占领更多市场份额。
让&amp;quot;原力&amp;quot;与决策同在 早期决策会对系统的最终形态产生巨大的影响。最早做出的决定可能是最难以反悔的。非常具有讽刺意味的是，早期决策恰恰是在信息最不完备的时候做出的。团队在启动项目时，往往最不了解软件的最终架构，却偏偏要在那时必须做出一些最不可能更改的决定。富有远见的决策将会大大减少整个软件声明周期的总成本。
设计务实的架构 务实的架构中，其中每个组件都足以满足的当前的负荷，并且，当符合随着时间发生变化时，架构师知道要替换那些组件。</description></item><item><title>2021::书单</title><link>/misc/books_2021/</link><pubDate>Fri, 31 Dec 2021 17:12:59 +0800</pubDate><guid>/misc/books_2021/</guid><description> 书名 分类 绝叫 推理 软技能 编程 MySQL 技术内幕 编程 Redis 设计与实现 编程 System Design Interview 编程 东方快车谋杀案 推理 凤凰架构 编程 屍人莊殺人事件 推理 白夜行 推理 嫌疑人 X 的献身 推理 字母表谜案 推理 密室收藏家 推理 尸体变化图鉴 科普 深入理解 Java 虚拟机（第 3 版） 编程 心灵侦探城塚翡翠 推理 恶意 推理 操作系统导论 编程 数据密集型应用系统设计 编程 编码 编程 现代操作系统（原书第 4 版） 编程 绝对不在场证明 推理 编程之道 编程 被讨厌的勇气 心理 计算机网络（原书第 7 版） 编程 金色麦田 推理 乌合之众 心理 诡计博物馆 推理 许三观卖血记 文学 活着 文学</description></item><item><title>数据库::高性能MySQL第四版</title><link>/misc/high_performance_mysql_4th/</link><pubDate>Sun, 19 Dec 2021 16:11:52 +0800</pubDate><guid>/misc/high_performance_mysql_4th/</guid><description>MySQL 架构 MySQL 的逻辑架构 MySQL 的架构分为三层
最上面一层是客户端，它们是大多数基于网络的客户/服务器工具或服务器需要的服务：连接处理、认证、安全，等等。
第二层包含 MySQL 的大多数功能，包括提供查询解析、分析、优化的代码，以及所有的内置函数。任何跨存储引擎提供的功能都在这一层：例如，存储过程、触发器和视图。
第三层包含存储引擎。它们负责存储和检索 &amp;ldquo;在 &amp;ldquo;MySQL 中存储的所有数据。像 GNU/Linux 的各种文件系统一样，每个存储引擎都有自己的好处和缺点。服务器通过存储引擎 API 与它们进行通信。
连接管理和安全 默认情况，每个客户端连接都有单独的处理线程，服务器缓存了就绪的线程，避免了每次连接创建和销毁的开销。
当客户端连接到服务器，服务器会进行登录信息鉴权和操作权限校验。
优化和执行 MySQL 解析查询以创建一个内部结构（解析树），然后应用各种优化。这些可能包括重写查询，确定它将读取表的顺序，选择使用哪些索引，等等。你可以通过查询中的特殊关键字向优化器传递提示，影响其决策过程。你还可以要求服务器解释优化的各个环节，以便重新修改查询、模式和设置，使一切尽可能有效地运行。
优化器并不真正关心一个特定的表使用什么存储引擎，但存储引擎确实影响到服务器如何优化查询。例如，一些存储引擎支持索引类型，这对某些查询是有帮助的。
MySQL 的内部缓存随着并发的增加成为了瓶颈，所以在 MySQL8.0 中已经彻底去掉。
并发控制 任何时候，只要有一个以上的查询需要同时改变数据，就会出现并发控制的问题。MySQL 必须在两个层面上做到这一点：服务器层面和存储引擎层面。
读写锁 处理并发读/写访问的系统通常实现一个由两种锁类型组成的锁系统。这些锁通常被称为共享锁和独占锁，或者读锁和写锁。一个资源上的读锁是共享的，或者说是相互不阻塞的：许多客户可以同时从一个资源上读取，而不会相互干扰。另一方面，写锁是排他性的&amp;ndash;也就是说，它们同时阻止读锁和其他写锁&amp;ndash;因为唯一安全的策略是在给定的时间内只有一个客户在向资源写，并且在客户写的时候阻止所有的读。
锁的粒度 每一个锁操作都有开销，包括获取锁、检查锁是否空闲、释放锁，等等。如果系统花费太多的时间来管理锁，而不是存储和检索数据，性能就会受到影响。管理锁是存储引擎设计中的一个非常重要的决定；将粒度固定在某一水平上可以提高某些用途的性能，但使该引擎不适合其他用途。
表锁
MySQL 中最基本的锁策略，也是开销最小的策略，是表锁。当一个客户希望对一个表进行写操作时（插入、删除、更新等），它获得一个写锁。这使得所有其他的读和写操作都无法进行。当没有人写时，读者可以获得读锁，这不会与其他读锁冲突。
表锁在特定情况下有一些变化以提高性能。例如，READ LOCAL 表锁允许某些类型的并发写操作。写和读锁队列是分开的，写队列的优先级完全高于读队列。 行锁
提供最大并发性的锁定方式（也有最大的开销）是使用行锁。这使得服务器可以进行更多的并发写操作，但代价是必须跟踪谁拥有每一个行锁，它们被打开了多长时间，它们是什么样的行锁，以及在不再需要时清理锁的开销。
推荐阅读：MySQL :: MySQL 8.0 Reference Manual :: 15.7.1 InnoDB Locking 事务 事务是一组被原子化处理的 SQL 语句，是一个单一的工作单位。所有操作应该被包裹在一个事务中，这样，如果任何一个步骤失败，任何已完成的步骤都需要回滚。
事务需要满足 ACID 特性。
原子性
事务必须作为一个单一的不可分割的工作单元来运作，这样整个事务要么被应用，要么永远不会提交。当事务是原子性的，就不存在部分完成的事务：要么全部完成，要么什么都没有。 一致性
数据库应该总是从一个一致的状态移动到下一个一致的状态。 隔离性
一个事务的结果通常对其他事务是不可见的，直到该事务完成。 持久性
一旦提交，事务的变化就是永久性的。这意味着这些变化必须被记录下来，以便在系统崩溃时数据不会丢失。 隔离级别 ANSI SQL 标准定义了四个隔离级别。这个标准的目标是定义在事务内部和外部哪些变化是可见的，哪些是不可见的规则。较低的隔离级别通常允许较高的并发性，并具有较低的开销。</description></item><item><title>基础::计算机系统中的时间</title><link>/misc/computer_time/</link><pubDate>Tue, 26 Oct 2021 22:32:54 +0800</pubDate><guid>/misc/computer_time/</guid><description>背景 时间是计算机系统中一个非常重要的概念，很多系统调用与时间有关，很多定时任务依赖时间，甚至内核本身也需要定时器按照一定频率来产生时钟中断来驱动它能够正常运行下去。
硬件时间 操作系统需要在硬件的帮助下才能管理时间，体系结构主要提供了两种硬件设备，一个是时钟源设备，位于主板上的一小块存储空间，有单独的供电，即使断电也可以保持计时。当操作系统启动时，会从这里读取时间，把系统时间与硬件时间设置成一致，此后两个时钟独立，操作系统维护自己的时钟，因为查看硬件既慢又复杂。另一个硬件是时钟事件设备，用于单次或周期性触发系统中断，每次中断，操作系统会进行刷新系统时间，管理进程时间片等操作。
系统时间 计算机科学与计算机编程中, 系统时间表示在计算机系统中的时间与日期。通常用系统时钟从某个时间起点的嘀嗒数。时间起点就是上文提到的在启动时读取的硬件时间，滴答数则是每次中断的累加，定时器是按照一定频率产生中断的，所以系统是可以知道两次中断之间过去了多久的。类 Unix 系统通常采用 Unix Epoch 来表示时间。
时间同步 因为操作系统采用了自己维护时间的方式，所以在运行一段时间后必然会产生硬件时间和软件时间不一致的情况，系统时钟会开始落后。这时候可以使用“hwclock“将两者进行同步，通过指定不同的参数将硬件时间同步到系统时间或者把系统时间同步到硬件时间。
NTP 协议 在单机系统中尚且可以解决时间不一致的问题，但是无法解决时间不准确的问题。于是就有了 NTP 协议，全称网络时间协议（Network Time protocol）。通过与另一台保持准确时间的设备通信来调整自身的系统时间，这就是 NTP 协议所做的事情，协议基于 UDP 实现，通过该协议，可以将时间误差保持在 UTC 时间的毫秒级误差。操作系统会周期性通过 NTP 协议更新系统时间。
UTC 时间 协调世界时是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林威治标准时间。因为在英国的缩写是 CUT，而法国的缩写是 TUC，所以双方妥协一下，缩写统一成 UTC 时间。协调世界时是世界上调节时钟和时间的主要时间标准，它与 0 度经线的平太阳时相差不超过 1 秒，并不遵守夏令时。协调世界时是最接近格林威治标准时间（GMT）的几个替代时间系统之一。对于大多数用途来说，UTC 时间被认为能与 GMT 时间互换，但 GMT 时间已不再被科学界所确定。这套时间系统被应用于许多互联网和万维网的标准中，例如，网络时间协议（NTP, Network Time Protocol）就是协调世界时在互联网中使用的一种方式。
GMT 时间 格林尼治平均时间（英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台当地的平太阳时，因为本初子午线被定义为通过那里的经线。目前使用的世界时测算标准又称 UT1。在 UT1 之前人们曾使用过 UT0，但由于 UT0 没有考虑极移导致的天文台地理坐标变动的问题，因此测出的世界时不准确，现在已经不再被使用。在 UT1 之后，由于人们发现，因为地球自转本身不均匀的问题，UT1 定义的时间的流逝仍然不均匀，于是人们又发展了一些对 UT1 进行平滑处理后的时间标准，包括 UT1R 和 UT2，但它们都未能彻底解决定义的时间的流逝不均匀的问题，这些时间标准现在都不再被使用。
后来的人们为了解决地球自转产生了时间流逝不均匀的问题，开始采用原子钟定义时间。人们首先用全世界的原子钟共同为地球确立了一个均匀流动的时间，称为国际原子时（International Atomic Time, TAI）。然后，为了使定义的时间与地球自转相配合，人们通过在 TAI 的基础上不定期增减闰秒的方式，使定义的时间与世界时（UT1）保持差异在 0.</description></item><item><title>翻译::了解Facebook是如何从互联网上消失的</title><link>/misc/understanding_how_facebook_disappeared_from_the_internet/</link><pubDate>Tue, 05 Oct 2021 15:54:34 +0800</pubDate><guid>/misc/understanding_how_facebook_disappeared_from_the_internet/</guid><description>原文: Understanding How Facebook Disappeared from the Internet
翻译: DeepL 翻译 和我
&amp;ldquo;Facebook 不可能瘫痪，对吗？&amp;quot;，让我们思考一秒钟。
今天 16:51UTC，我们开了一个内部事件，题为 &amp;ldquo;Facebook DNS 查询返回 SERVFAIL&amp;rdquo;，因为我们担心我们的 DNS 解析器 1.1.1.1 出了问题。但当我们准备在我们的公共状态页面上发布时，我们意识到发生了其他更严重的事情。
社交媒体迅速爆发，报道了我们的工程师也迅速确认的情况。事实上，Facebook 及其附属服务 WhatsApp 和 Instagram 都已瘫痪。他们的 DNS 名称停止解析，他们的基础设施 IP 也无法访问。这就像有人一下子从他们的数据中心 &amp;ldquo;拔掉了电缆&amp;rdquo;，并将他们与互联网断开连接。
这怎么可能呢？
来自 Facebook 的更新 Facebook 现在发表了一篇博文，介绍了内部发生的一些细节。在外部，我们看到了这篇文章中概述的 BGP 和 DNS 问题，但问题实际上始于一个影响整个内部骨干网的配置变化。这导致了 Facebook 和其他属性的消失，而 Facebook 内部的员工也很难再获得服务。
现在来看看我们从外面看到的情况。
认识 BGP BGP 是边界网关协议的缩写。它是一种在互联网上的自治系统（AS）之间交换路由信息的机制。使互联网运行的大型路由器拥有庞大的、不断更新的可能路由列表，这些路由可用于将每个网络数据包传送到其最终目的地。没有 BGP，互联网路由器就不知道该怎么做，互联网也就无法运行。
互联网实际上是一个网络的网络，它是由 BGP 捆绑在一起的。BGP 允许一个网络（例如 Facebook）向构成互联网的其他网络宣传其存在。当我们写到 Facebook 没有宣传它的存在时，ISP 和其他网络就找不到 Facebook 的网络，因此它就不可用。
各个网络都有一个 ASN：一个自治系统号码。一个自治系统（AS）是一个具有统一的内部路由策略的单独网络。一个 AS 可以发起前缀（说他们控制着一组 IP 地址），以及过境前缀（说他们知道如何到达特定的 IP 地址组）。</description></item><item><title>软技能::代码之外的生存指南</title><link>/misc/soft_skills/</link><pubDate>Tue, 28 Sep 2021 16:13:44 +0800</pubDate><guid>/misc/soft_skills/</guid><description>职业 你所能犯的最大错误就是相信自己是在为别人工作。这样一来你对工作的安全感已然尽失。职业发展的驱动力一定是来自个体本身。记住：工作是属于公司的，而职业生涯却是属于你自己的。 成功的软件开发人员之所以能成功都不是偶然的。他们目标明确，为了达成目标，他们制订了坚实可靠而又深思熟虑的计划。 要做什么，什么时候做，以及如何义无反顾。 从非同凡响开始：绝不要做他人都在做的事 只有你开始把自己当作一个企业去思考时，你才能开始做出良好的商业决策。 软件开发人员售卖的就是他们把一个想法变成一个数字化的现实产品的能力。 专注于你正在提供怎样的服务，以及如何营销这项服务； 想方设法提升你的服务； 思考你可以专注为哪一特定类型的客户或行业提供特定的服务； 集中精力成为一位专家，专门为某一特定类型的客户提供专业的整体服务（记住，作为一个软件开发人员，你只有真正专注于一类客户，才能找到非常好的工作）。 我的服务是管理开发人员，招聘培训人才，建立流程，发现问题，提供解决方案，和其他部门合作，保证结果 大多数成功的公司都会开发出让客户主动上门购买的产品或服务，它们才不会一个接一个地追逐客户。 优秀的人才是被主动挖掘而不是自我寻找 思考未来：你的目标是什么 起步阶段最简单的就是在心中树立一个大目标，然后再建立能帮你达成这个大目标的小目标。 人际交往能力：远比你想象的重要 如果你希望人们接受你的想法，并认可其中的价值，首先你最好先主动给他人相同的礼遇。如果你不能保全他人的自尊，那你永远也不可能赢得他的心。 聚精会神地聆听，当轮到你发言的时候，娓娓道来，一语中的。（实际运用中，你可以提前排练一下这种场景，提前准备好如何进行这种谈话。） 直截了当地告诉老板为什么你喜欢想用某种方式实现某个功能，这并不明智。更好的办法是从对方的心态出发提出建议，阐明为什么采用你建议的方法实现该功能对老板非常有用。理由可能是“让软件更稳定”，或者“能让软件按时交付”。 我们必须要不惜一切代价避免争吵。 在小事情上，任何放弃立场或承认错误的机会对你而言可能没什么大不了的，但对他人却可能是举足轻重的，这么做不仅能为你赢得不可估量的尊重，也能为你的未来积蓄财富，形势逆转时即可兑现使用。 破解面试之道 通过面试的最快捷的方式是让面试官对你怀有好感。 事先就确定我要为这家公司工作的 面试开始之前就思考应对面试的策略。 你必须要突破常规，想尽办法与公司内部人员建立联系。 看看能不能在面试之前得到预面试的机会 能够自发地、无需过问就能做事的员工通常能增加公司的净收入，此外，他们也让老板少操心，只占用少量的管理资源。 与雇用技术高超但需要生拉硬拽才能干活的人相比，我宁愿雇用这样的开发人员：知道的东西可以少一点，但是明确知道要做什么，以及怎样去做。从某种程度上，在你可控的范围之内，面试的时候你要集中精力证明自己就是无需督促也能自动自发做好事情的员工。 集中精力推销自己会对你大有裨益 就业选择：列出你的选择 选择 1：雇员 选择 2：独立咨询师 选择 3：创业者 你是哪类软件开发人员 只要你专业能力雄厚，市场没有过渡饱和，与那些自称为“软件开发人员”的人相比，你能更轻松地找到工作或者赢得客户。 成为这个领域的专家，你就会获得大量业务。 攀登晋升阶梯 在任何公司里能让你脱颖而出的最重要法宝就是承担更多的责任。 没有人愿意涉足的领域是搜寻机会最好的地方。 另一种间接承担责任的方式是成为团队中其他人的导师，自愿帮助新人加速成长，为任何有需要的人提供帮助。 保证“曝光度”——定期与老板会面，确保你经常被注意到。 千万不要忘记分享自己学到的东西。 你要成为那个永远能为各种问题找到解决方案的人，要成为勇于执行这些解决方案以获得成果的人。 你应该对所在组织的政治气候保持警觉。尽管不能完全避开政治，但至少应该知道会发生什么，哪种人需要避开，哪种人永远不要有交集。 确定要自学的最有价值的东西是什么，制订一份下一年的自学计划。 成为专业人士 成为专业人士是一种心态。如果我们总是与恐惧、自毁、拖延和自我怀疑作斗争，那么问题就是：我们正在像外行那样思考问题。外行毫不起眼，外行人废话连篇，外行屈从于逆境。专业人士可不这么想。不管怎样，他引人注目，他恪尽职守，他始终如一。成为专业人士的全部在于：引人注目，恪尽职守，以及不屈服于挫折。成为专业人士，需要你克服自身的缺点，静下心来创作出尽可能最好的作品。 专业人士会坦承自己不知道答案，但是你可以信赖他会找到答案。 每天提前做好计划，就能养成有效管理时间的习惯。专业人士知道每天必须要做什么工作，并且能估算出每项工作大约要花多长时间。 成为自由职业者：开启自己的一片天地 “吸引式营销”基本上就是让潜在的客户主动送上门，而不是你去找他们。你要做的事情就是免费提供有价值的东西。 创建你的第一个产品 在创建产品之前，先筛选出一组特定的受众，他们也是你的解决方案的目标用户。 你打算开始创业吗 很好的创业候选是能够申请专利或受保护的新技术和新方法，而糟糕的创业候选则包括餐厅或其他缺乏独创、很容易被复制的服务。 好的创业项目要有规模扩张的潜力——想想 Twitter、Dropbox 和 Facebook 等。 假装自己能成功 有目的地将自己置于困境，演练一下自己既定的应对策略。 单调乏味的简历——如何修改 beautiful-resumes 上列出了许多漂亮、充满创意的简历，你可以从中得到一些启发。 自我营销 营销就是一场争夺人们注意力的竞赛。 针对“码农”的营销基础课 营销的核心在于将一些人所需要的所期待的产品或者服务与产品或服务本身连接起来。 成功进行自我营销的关键在于：如果想让别人喜欢你，想和你一起工作，你就必须要为他们提供价值。 无论你身在何处都要营销。 自我营销的基本机制是，要想让人们追随你、倾听你，你就要带给他们价值：你能为他们的问题提供答案，甚至是给他们带去欢乐。 打造引人注目的品牌 但品牌不只是商标，更是一项承诺。品牌树立了客户对你的期望，而且这些期望也必须能够实现。 品牌所要传递的信息、品牌的视觉符号、品牌的一致性和品牌的曝光率。 明确要传达的品牌信息。挑选细分市场。创建品牌口号。创建电梯内销售概要。创建视觉符号（即标识）。 接下来，你应该创建所谓“电梯内销售概要”。电梯内销售概要是一段能够快速描述你是谁、能做什么的宣传文字，乘坐电梯的工夫就可以浏览完毕。想想在晚宴上，或者就在电梯里，当有人问起来“你是做什么的”的时候你该怎样回答人家。 创建大获成功的博客 提高你的沟通技巧。组织自己的思想，并将其转化为文字，是一项颇具难度却也极具价值的技能。 持之以恒地坚持写作，坚持不懈地产生高品质的内容，如果你做到了这两点，基本上你就成功了。 你的主要目标：为他人增加价值 不要努力成为一个成功的人，而要努力成为一个有价值的人。——阿尔伯特·爱因斯坦 要想让自我营销的所有努力奏效，基本的方法就是帮助他人获得成功。 你提供的内容应该直接瞄准你所选定的研究领域，为该领域带来价值。 免费内容比付费内容更容易被分享。 最富有创造力的人也是最乐于助人的人。 善于运用社交媒体 发布你认为有用或有趣的。你自己觉得有价值东西，在很大概率上别人也会认同。 演讲、报告和培训：做“说话的极客” 演讲也是一种互动媒介，或者至少你能将其作为媒介使用。 最好从小规模的场合做起，逐渐完善你的演讲技能。要想能在公众面前从容自如地发表演说，需要很长时间的刻苦练习。 作为人类，我们拥有良好的适应能力。只要你把一件事情重复足够多次，你自然就会接纳它。如果你一直坚持在公共场合发表演说，你一定会应对自如，恐惧感终将消散。 著书立说，吸引追随者 要想让自己有机会出书，最好的办法就是明确一个有市场需求的主题，同时也能够充分展示你作为该领域专家的学识。 最后，你应当准备一份翔实的写作提纲（文章摘要），清晰地概括自己的写作目的，明确本书的目标读者，以及你为何认为这本书会成功，为何你是写作这本书的最佳人选。你的提纲写得越好，它被出版商接受的可能性就越大。 百折不挠，越挫越勇 如果你想成功，你必须要学会收起自己脆弱的自尊心，勇敢走出去，别害怕让自己出丑。 学习 教育就是当一个人把在学校所学全部忘光之后剩下的东西。 学习怎样学习：如何自我教育 如果我告诉你该怎么做，你可能会忘掉，但如果你自己动手做一次，你可能就记住了。如果你能将自己所学的东西教给别人，你不仅能记住，还能理解得更深刻。 我的“十步学习法” 要对自己要学的内容有个基本的了解——了解自己不知道什么就足矣。然后，利用这些信息勾勒出学习的范围，即需要学哪些内容，以及学成之后又会获得什么。 第 1 步到第 6 步：这些步骤只做一次 在这一步，你要做的就是了解自己将要学习的主题的全局。这个主题宏观上什么样？你能从中学到足够丰富的知识以了解自己所不知道的吗？以及自己所不知道的有多少？ 研究。通常你可以使用网络搜索来完成大部分研究。如果你碰巧有一本关于该主题的书，那么你就可以只读一下其中的介绍性章节，粗略浏览一下内容，但是不要在这一步上花费太多时间。 了解如何设置和安装 Ubuntu Linux，以及如何使用它的基本特性 为了学习该主题下的不同子主题，你可能会扩张你的学习范围而不够聚焦，但是请务必抵制住这个诱惑，尽可能地保持专注。 最后，在这一步中一定要注意：明确学习范围的时候要考虑时间因素。如果你只有一周时间，你需要本着实事求是的态度确定自己能在这段时间内学到什么。如果你有几个月的时间，你也许能攻克一个更大的主题。你的学习范围务必大小适当，既能符合你的学习理由，又能符合你的时间限制。 在全力以赴启动之前，明确“成功”的含义极为重要。如果不知道成功是什么样子，很难找准目标，也很难知道自己什么时候已经真正达到目标。 在尝试学习任何东西之前，你都应该在自己脑海中清晰地描绘出成功的样子。当你知道自己的目标是什么的时候，你就可以更轻松地使用倒推的方式，明确实现目标所需的步骤。 好的成功标准应该是具体的、无二义性的。不要对自己想要完成的任务进行含糊不清的描述。相反，要列出某一特定的结果，或者一旦实现自己所能达到的目标你应该能够做到的事情。 要尝试收集到多种多样的资源以帮助你学习，而不是只读一本关于这一主题的书。 在这一步中，你会想找到尽可能多的与自己所选主题相关的资源。此时你无需考虑这些资源的质量。这一步与头脑风暴类似。稍后你会对你找到的这些资源进行过滤，去伪存真，但是目前还是想先获得尽可能多的不同类型的资源。 图书博客文章在线视频专家，或者对你所想要学习的内容已经熟知的人播客源代码示例项目在线文档 对于大多数学科而言，学习是一个自然的过程。从 A 开始，前进到 B，最后到达 Z。这个顺序对你掌握随机的碎片化知识价值不大。你需要找出在最短的时间内从 A 到 Z 的正确路径，并且到达沿途的重要地标。 打造自己的学习计划，一个好方法就是观察别人是如何教你感兴趣的主题的。就我自己而言，在这一步我通常会翻看自己在第 4 步中找来的图书的目录。如果五位不同的作者都把内容都分解为相同的模块和顺序，那我就会遵循这样的方法制订自己的学习计划。 把你在第 4 步中收集的全部资源浏览一遍，找出哪些内容能够覆盖你的学习计划。 挑选你想要了解的一项课题，实际经演练一下上述这六个步骤。你可以从一些规模较小的课题开始，以便让自己习惯于这一过程。但是注意，一定要实际运用。如果你只是把这些步骤当作是阅读内容，那么它们对你不会有太大用处。 第 7 步到第 10 步：循环往复 现在开始最有趣的部分。接下来的四个步骤会在你的学习计划所定义的各个模块中循环往复。步骤 7 到步骤 10 的目标是通过“学习—实践—掌握—教授”（LDLT）的方式真正领会知识。 你从掌握恰到好处可以开始的基础知识开始，然后通过操作来学习，同时也通过自我探索收集问题。之后，你掌握了足够多的有用的知识。最后，你能将自己学到的教给他人，以此来弥补自己在学习过程中的不足，同时通过深入思考巩固知识。 在学习过程中通常会犯两类错误：第一类错误是在知之不多的情况下就盲目开始，即行动太快；第二类错误是在行动之前准备过多，即行动太晚。要想在这二者之间取得平衡，你掌握的知识要恰到好处，足以能让你开始学习，但又不会多到让你无力探索，这样你的学习效果最佳。 在第 8 步中，你通过动手操作发现了一些尚未找到答案的问题。现在，是时候来回答这些问题了。在这一步中，你要利用先前收集到的所有资料，进行深入学习。 不过请记住，你依然没有必要把收集到的所有资料全部仔细看一遍。你只需要阅读或观看与当前所学相关的部分。我们很少能有足够的时间把一本书从头读到尾。这些资料只是帮你自学，基本上你可以以解决在动手操作中发现的问题为主要目的。 你告诉我的，我都忘了。你教会我的，我都记得。让我乐在其中，我就一定能学会。 如果你想深入地掌握一门学问，想对这门学问做到融会贯通，那么你必须要做到“好为人师”。除此之外别无他法。 在现实中，你只需要超前别人一步，就可以成为他们的老师。 在这一步中，我会要求你走出自己的舒适区，将自己学到的知识教给别人。 要想确定你确实掌握了某些知识，这是唯一的办法；同时，在你将自己所学介绍给他人时，这也是查缺补漏的好办法。 寻找导师：找到你的尤达 在这一章中，我会教给你一些小窍门，包括寻找怎样的导师，如何找到导师，以及如何说服你的导师让他相信你值得他投入，从而真正实现双赢。 想想我们是怎样学习游泳的。当你第一次学游泳的时候，你的大脑里充斥着关于如何游泳和水很危险的虚假信息。你可能觉得自己不能漂起来，最后会被淹死。你必须要信赖你的游泳教练，对于游泳，他知道的比你多，而你对于游泳的认知都是错的。 学习方法，十步。先了解游戏开发，细化干什么，定目标，准备知识，学习，达成目标，帮助其他人。博客，github，都会觉得自己蠢，离开舒适区。高一点的人适合当老师。写简历，认识公司的人，找一个老师。 他们做到了我想要去做的？他们曾经帮助他人做到了我想做的？他们现在取得了什么可以展示的成就？你能和这个人和睦相处？他充满智慧吗？ 你最好的选择就是去自己认识的人中找，自己的朋友的朋友、家人的朋友等。如果你愿意做一点儿功课，再四处打听一下，无论你努力追求的目标是什么，你极有可能在由家人和朋友组成的关系网中找到适合做你导师的人。 如果你想在一家公司里获得晋升，那么在公司内部给自己寻找一位导师无疑是明智之举。你的老板或者你老板的老板这样的资深人士是导师的不二人选，你很可能会提前接受晋升所需要的各种教育。此外，与高管做朋友对你的职业生涯毫无害处。 我找来一些房地产投资方面最好的书，从这些“虚拟导师”身上我学会很多东西。除了阅读他们所写的内容，我还尝试去理解他们是如何决策的以及为什么做这样的决策的。 可以考虑请他吃午餐或者晚餐，在吃饭的时候让他给你一些建议。 一定要有耐心！大部分人在第一次听到“不”的时候就止步不前。别做这样的人。恰恰相反，要做一个别人用棍子赶才能赶走的人——即便如此，过一会儿也还要回来。你的顽强不会总有回报，但是你可能会惊讶地发现回报来得很频繁。 在寻找导师之前，你必须要明确，你需要导师帮你解决什么问题。坐下来，仔细想想你为什么需要一位导师，你希望从这段师徒经历中获得什么。 列出所有你认识的人中可以做自己的导师的人。请其他人在你的列表上再列出他们认识的人，用好你的人际网络。想一想，为了能够换取导师的帮助，你能给他提供什么？ 开山收徒：成为尤达一样的大师 教授是学习的最佳途径之一。 做导师还会让你感觉良好。这件事情还是值得去了解的——你所做的能够对其他人的生活产生积极的影响，这本身就是一种报偿，特别是当此人无法报答你的时候。指导别人能让你发现人生的新目标和新意义，帮助别人可以给自己带来真正的幸福。 做导师的好处帮助他人时的成就感。深入学习和领悟知识的途径。你的徒弟有朝一日会帮到你。自身的成长。帮助别人成长的过程也就是自己成长的过程。 传道授业：若要学知识，必得为人师 我发现最好的教学方式就是以谦虚的视角来观察问题，以权威的口吻去诠释问题。 你需要一个学位吗，还是可以对此忽略不计 许多计算机科学课程中包含的算法、操作系统、关系型数据库理论和其他主题都是永恒的。 身为软件开发人员，我们所做的大部分工作，都是如何使用新技术，学会如何用它们完成工作。我们很少需要回溯到计算机科学的本源。 学历有用，但是主要还是工作经验。学的过程中的东西很少用 学历教育可以确保你在软件开发方面获得全面的教育。 拥有一个学位也可以帮你即使毫无经验也能踏入职场。 学位还可以给你更多的选择。如果你没有获得过相关学位，有一些职位你是永远不会得到的，尤其是在大公司中。没有学位，做到一定的行政岗位之后就会有一个困难期。 如果没有学历，你就不得不更多地依靠经验来证明自己的能力。学位至少可以让雇主相信你具了解某些软件开发的知识，那么如果你没有学位的话，你就要能够证明自己有这些能力。 证明自己的能力的最好的办法就是以往的工作经验。如果在过去五年中你一直从事软件开发的工作，那么即使没有学位也能说明你会写代码。但是，如果你刚刚踏入职场，那你的求职之路会很艰难，你不得不去证明自己确实能够做到你自己所说的那些。因此准备一份作品集是最好的方法。 不管你是拥有学位还是拥有经验，我都建议你将自己的工作成果总结为作品集。 发现自己的知识短板 我们总是倾向于掩饰自己的短板，而且我们也总是太忙，忙到无暇去填补它们。结果，我们要么不能真正明白自己在做什么，要么为了避开自己的短板而采取低效的方法。 知识短板会阻碍你进步。准确识别它们的最佳方式之一就是看看自己在哪些工作上花费了大量的时间，或者一直进行重复性劳动。 重复性工作也是如此。任何你所做的重复性工作都值得彻查一番，看看是否有自己不理解的地方，如果你这样做了，可能会提高你的工作效率。 另一种识别知识短板的方法就是，时刻都要试图了解自己不理解或不清楚的事物。你可以维护一份清单，列出自己需要去研究或者自己不清楚的所有事物，追踪有哪些主题总是不断出现在这个清单上。你会惊讶地发现这份清单的增长速度有多快。 假如你在准备面试，需要明确自己要学什么，这一方法最管用。尽量找出尽可能多的你在面试中可能会被问到的问题。 知识短板高发区，你的短板在哪些，工作上花费时间最多？可以改进的重复性劳动，自己没有完全理解的东西，你回答不出来的面试题 一切始于专注 生产效率高并不能保证你是高效的。产量多只表明生产效率高，只有完成正确的工作才会成为高效的人。 这一切都源于专注。 但我们所承担的很多任务都有“环境切换”的成本。当我们从一个任务切换到另一个任务时，我们必须要唤醒某些记忆之后才可以重新开始工作。 时不时实践一下专注。选一项大概需要占用你半小时或者更长时间的任务，给完成这项任务分配一个完整的时间段，完全专注于这项任务。迫使自己只集中精力在这一项任务上。当你进入专注状态时，在心里记住是什么感觉。 我的私房“生产力提升计划” 我试过 GTD（GettingThingsDone），也花时间用过“番茄工作法”。我还用过 Seinfeld 的“不要打破链条”（Don’t break the chain）方法的各种版本。（在“不要打破链条”方法中，每天成功完成某项任务，你就在日历上做个标记。这种方法的基本思想就是，让连续工作的势头保持的时间尽可能长。） 我的生产力提升计划的基本思路就是，我把一周的时间分配给一个一个用时不超过两小时的小任务。我使用看板来安排自己的一周活动。看板是一个简单的白板，它有几个列，你可以轻松地在各列之间移动任务项。在敏捷方法的世界里，看板通常还包含展示这些任务项所处的不同状态，典型的状态有“未启动”“进行中”和“已完成”。但是在我的看板中，每一列就是一周中的每一天。 在工作时我会使用番茄工作法来保持专注，并且用番茄工作法估算和衡量每一项任务要花多长时间。 我的计划都是从“季度”开始的。我把我的一年分成 4 个季度，每个季度 3 个月。在做季度计划时，我会尽力列出我想在本季度完成的每一个大项目，我还会制订一些较小的目标。 我也会创建一个宏观计划，将本季度我想要完成的工作列入其中。这让我清楚地了解自己的主要目标是什么，也知道该如何实现它。同时，它还会让我保持专注。 每个月的第一天我会打印出当月的月历，并且规划出每天要完成的工作。 每周一的早晨，我会做我的周计划。我原来使用名为 Trello 的工具作为看板来组织我一周的工作，但最近我一直在用 Kanbanflow 创建自己的看板，因为 Kanban flow 有一个内置的番茄钟定时器。 每天，在坐下来工作之前，我都会做一些健身活动。之所以这样做，是因为我不希望中途有事情打断我专注的状态。一旦我做好准备坐下来工作，我做的第一件事就是计划我的这一天。 要计划好这一天，我首先要把对应日期里的卡片移到“今天”这一栏，并把它们按照重要性排序。我要保证自己优先完成最重要的事情。我也会对当天的任务进行调整，如果卡片上对该项任务的描述不够细致，我还会添加细节。我要确保自己在开始工作之前就确切地知道 知道自己在做什么，这项任务完成的标准又是什么。 为了免受干扰，另一件大事就是，在白天我基本上会忽略电子邮件。我只在休息的时候检查电子邮件，这也只是为了确保不会耽搁必须要马上处理的紧急邮件。但是，除非一些事情确实紧急，否则我一般只在晚上统一回复电子邮件。通过在集中的时间段内统一回复邮件，我可以大幅提升邮件回复效率。（如果能彻底摆脱检查电子邮件的习惯，我可能会生产效率更高。但可惜，我只是个普通人。） 要确保自己有一些休息时间，或者有那么几周我会称之为“无工作周”，基本上在这几周里，我不会使用番茄钟，也不会把整周都排满。在无工作周里，我只做一些我喜欢的工作。 番茄工作法 它的基本思路是：你规划出打算一天之内完成的工作，然后设置一个时长 25 分钟的定时器，去完成计划中的第一项任务；在这 25 分钟之内，你只专注于这一项任务，心无旁骛。一旦有干扰，可以用各种方法屏蔽掉干扰，但是通常你要努力保证自己完全不被打扰。总之，你不希望自己的专注的工作状态被打断。 在 25 分钟结束的时候，设置一个 5 分钟的定时器，休息一下。这就是所谓的一个“番茄钟”。每 4 个番茄钟后，你都需要休息一会儿，通常为 15 分钟。 番茄工作法只有被当作估算和评估工作的工具使用时，才能发挥它的真正威力。 通过计算自己完成的番茄钟的数量，可以确切知道自己一周完成了多少任务，也就不会觉得自己没完成足够量的任务。如果你没能完成自己设定的任务，但是却用完了足够数量的番茄钟，那么问题就不是工作量是否饱满，而是给某个任务项设置的优先级是否正确。 正确使用番茄工作法教会我“设置优先级”的真正价值。当每周我只有这么多番茄钟可分配的时候，我必须小心翼翼地使用这些宝贵的番茄钟。 我的“定额工作法”：我是如何做到超额完成工作的 确立一个明确的目标，规定自己要在预先确定的时间段内需要取得多大的进展。 完成自己承诺的定额。我非常严肃地对待这些定额。 挑选一些需要重复去做的任务，设定的一个定额，即明确自己在一个给定的时间段内完成该项任务的频率。 承诺是“定额工作法”的核心。除了想方设法完成自己的工作，不给自己留下任何其他的选择。 选择可实现、可持续的定额。 挑选一项重复性任务。明确有效时限，在此期间该任务被重复执行。明确在给定的有效时限内该任务应该完成的次数的定额。给自己承诺：一定要达成定额。调整。调高或者调低定额，但是不能在有效时间段之内调整。 以缓慢但稳定的节奏工作，要优于快速但缺乏持久和坚持的工作方式。 我们中的大多数人在长期高生产效率地工作中时都会面临如何保持始终如一的节奏的问题。随着时间的推移，只要每天都能保证完全落实到位，小砖头终会筑成高墙。只关注高墙（手边的大任务）很容易让人泄气，如果每天只是砌砖（小任务）就会容易很多。关键是要保证将方法落实到位，保证自己每天、每周、每月都在“砌砖”。 定额工作法还可以帮你克服意志力薄弱的问题，通过预先设定好的必须要遵循的过程，消除需要做出决策的部分。因为已经预先承诺在规定时间段内完成同一任务很多次，所以就不需要再判断要不要做某事——你知道必须要做。 对自己负责 让人们完成工作主要有两大动机——内部动机（来自内心的动机）和外部动机（来自外部奖励或惩罚的动机）。 内部动机要比外部动机有效得多。在内部动机的激励下工作时，我们能完成更多的工作，也更倾向于把工作做得更好。所以，秘诀是让你的主要动机来自内心而非外部。 我们中大多数人之所以会每天按时上下班，至少在某种程度上是因为我们要对自己的雇主负责。拥有一份工作的责任感会促使我们去做一些如果我们可以自主决定是绝对不会做的事情。 培养出在没有人监督自己的时候也能高效工作的自我责任感非常重要。你也可以把这称为是具有一种性格或者具有一种素质， 要培养“对自己负责”的精神，首先要让自己的生活井然有序。如果不知道应该做的事情是什么，就不能真正为自己所做的任何事情承担责任。 你必须通过为自己设定规则，将这种条理性自愿地应用于自己的生活中。你需要创建自己的规则来管理自己的生活，并且要在自己思维清晰、大脑尚未被错误的判断蒙蔽的时候，提前制订好这些规则。 你可以告诉他你给自己制订的规则，或者你想达成的目标，通过定期互相汇报进度（不论成败），可以互相帮助对方强化责任感。 通常，想到要告诉自己的责任监督伙伴自己没能完成设定的目标，就足以阻止自己不够自律的行为。在关键点作出正确的选择还是错误的选择会有极大的区别。 我自己就加入了一个智囊团，它的功能就像一个责任监督小组。我们小组每周都会开例会，每个人都要讲讲自己在这周做了什么和计划做什么。通过在小组内部讨论每个人各自的计划，我们互相监督计划的落实情况。没人希望因为自己不遵守计划而令组员失望。自从我加入了这个小组，工作效率大幅提升。 公开自己的日常活动也是一个好主意。 最重要的是要确保自己对自己的行为带有某种责任感。坚守自己设定的标准时，生产效率会高很多。 抉择一下：你想如何度过自己的一生。花点儿时间创建一些自己的规则，确保自己朝着正确的方向前进。创建自己的责任制度，帮助自己严格执行规则。 要不要多任务并行 多任务导致效率低下的根本原因似乎在于，我们根本没有能力真正去践行多任务并行。 是的，如果你每天都因为有多个任务要完成就深陷多任务并行的泥潭，最好学会如何批量处理这些任务，一次性完成一系列互相关联的任务，而不是将它们拆分完成。批量处理电子邮件就是非常好的起点，任何在短时间可以完成的任务也都适合批量处理。 潜在的适合批量处理的领域处理电子邮件。打电话。修复 bug。开短会。 比起在不同时间段分别处理相关任务，批量处理相关任务拥有两大优点。第一，你不会打破自己对正在处理的大任务的专注。第二，你会更专注于自己平常没有足够的时间进入专注状态去处理的任务。 最有可能的就是，将一项不费脑筋的任务和一项一定程度上需要精神专注才能完成的任务组合起来。 停止任何并非真正的多任务并行的多任务并行。每天力争在一个时间段内只做一件事。番茄工作法对此有很大帮助。一次性批量处理小任务，而不是每天或每周里做许多次。找出能够真正实现多任务并行的领域。任何不需要耗费脑力的活动都可以跟其他活动结合起来。只要进行任何需要耗费脑力的活动，就将其与体育运动结合起来。 职业倦怠：我已找到解药 提高生产力的最大障碍之一就是身体和心理上的倦怠。 你越是努力工作，完成的工作就越多，这种倦怠感来得就会越快。这就是难以取得工作成效的原因。工作效率越高，你从中体会到的愉悦感就越少。 为自己设定了一个时间表，并且坚决执行。 你可以采用类似的方法来帮自己突破阻挡了你的那堵围墙。想学会弹夏威夷四弦琴？每天留出一定的时间练习。在上第一堂课之前就制订好这样的计划——那时你的兴趣和动机都处于最高点。当你不可避免地撞到这样一堵墙的时候，这个计划能帮助你穿过它。 时间是怎样被浪费掉的 看电视 召开会议 一些常见的时间杀手看电视。社交媒体。新闻网站。不必要的会议。烹饪。玩电子游戏（尤其是网络游戏）。工间喝咖啡休息。 要想消灭时间杀手，最好的方法就是先找出它们。在找回被浪费的时间之前，你需要了解自己的时间都浪费在哪儿了。 下一周，精心地跟踪一下自己的时间花费情况。获取精确的数字，了解每天的每小时你都是怎样花掉的。 形成惯例的重要性 生产力的真正秘诀在于：长期坚持做一些小事。 一个好的惯例始于一个大的目标。你想要达成的目标是什么？通常你一次只能专注于实现一个大目标，因此选择当下对你最重要的目标。你知道，为了这个目标你已经准备了好久，但你从来没有时间着手去实现它。 一旦挑选好了大目标，接下来就要弄清楚怎样才能每天或每周前进，最终实现目标。如果你想写一本书，每天要写多少字才能在一年内完成？如果你想减肥，每周要减掉几斤才能达到目标？ 我建议你把每天最开始的一两个小时投入到最重要的目标上。你可能需要早起一两个小时，但是通过有效利用每天最开始的一两个小时，你不仅更容易坚持想要做的事情，还会精力更充沛。 强烈建议你安排好每个工作日的时间，以便自己知道每天、每周要做什么。 刚开始工作的时候你就要决定好自己打算做什么。它可能会是查看和回复电子邮件，但也许更好的选择是从每天必须要做的最重要的事情开始。（电子邮件可以晚点儿处理。）选出每天或每周都要重复的几个任务（ 当我在办公室工作的时候，每天我会抽出 30 分钟时间学习自己工作中会用到的技术，我习惯将其称为“研究时间”。 你还应该安排自己的食谱，甚至围绕着每天吃什么来形成惯例。我知道这听起来有点儿不可思议，但我们的确为了决定吃什么和做什么饭浪费了大量的时间，如果这些事情不能提前计划，最终我们就会吃得很差。 培养习惯：刷新你的代码 成就我们的恰恰就是那些不断重复做的事情。因此，优秀不是一种行为，而是一种习惯。 习惯主要由三个要素构成：暗示，惯例和奖励。 暗示是导致习惯被触发的某样东西。它可能是某一天的某个特定时刻、某种形式的社交场合、某个特定的环境或者其他任何东西。例如，只要我们进入电影院，我们就获得了买爆米花的暗示。 接下来是惯例。惯例就是你做的事情，也就是习惯的本质。惯例可能是抽烟、跑步，也可能是在检查代码之前运行所有的单元测试。 最后，还有奖励。奖励就是让习惯真正保持下去的“锚”。这是一种你从执行习惯中获得的良好感觉。 我们会根据周围的事物自发地养成习惯。一件事情做的越多，越可能形成习惯。习惯的力量往往基于奖励的价值。 如果我早起之后的第一件事情不再是浏览网站，我会制订当日计划，并挑出当天自己最喜欢的事情。这样我就可以完成更多的工作，我也可以从自己最喜欢的工作开始，而不是从最不喜欢的工作开始。 习惯。要找出坏习惯，最好的办法就是设法找到日常生活中令你感到内疚的事情或惯例。 选一个你找出来的坏习惯，不要试图马上就改变它。相反，尽量找出这个习惯被什么触发，你这么做有什么表现，以及是什么奖励激励你产生冲动要这样做。 最后也是最困难的部分是，强迫自己坚持足够长的时间，以使新习惯取代旧习惯。只要你能在新的习惯上坚持足够长的时间，新习惯最终一定会变得很轻松且是自发的。 养成习惯的方法与形成惯例的过程很相似。试想，你要完成的大目标是什么，看看你是否能养成某种习惯，推动你在奔向大目标的方向上前进。你的习惯越积极，你向着自己的目标前进的过程就越轻松。 接下来，为你的新习惯找出暗示。是什么触发了你的这个习惯？让暗示固定不变，让你可以依赖。一天中某一个特定时间，或者一周中特定的某一天，都是很好的暗示， 它将确保你不会把行动推迟到另一个时间。 跟踪你的习惯。哪些习惯对你目前的生活影响最大？你认为其中有多少是好习惯，又有多少是坏习惯？挑选一项你的坏习惯，试着把它转变为好习惯。在开始做之前，先在自己脑海中设想一下从现在起一周之后、一个月之后、乃至于一年之后你会有什么成果。 分解任务：如何吃掉一头大象 分解任务。通过将大任务分解为小任务，你会发现自己更有动力去完成它们，也更加稳妥地向着目标前进。 任务越大，越难明确定义。任务容易，你正确完成任务的概率也很高。 大型任务是一种智力挑战，与小任务相比，大任务更可能导致拖延，通常描述也更少，更容易出错，也更难估算完成时间。 你首先需要明确完成这项任务需要哪些步骤。 把大任务分解为小任务的关键步骤就是确定出因为缺失了哪些信息而导致你无法创建更小、更明确的任务。如果你在把大任务拆分成小任务的时候遇到问题，很可能是由于缺少信息。 单独一行代码的复杂度绝对不会超过任何一位程序员的理解能力和编码水平，所以，如果你愿意将问题分解得足够小，只凭借写出单行代码的能力你就能写好任何应用程序。 努力工作的价值，以及为什么你总是逃避努力工作 被我们认为困难的事情，实际上都是我们不想做的事情，因为它们不那么激动人心，也不那么光彩照人。 成功会带来更多的成功。越成功就越容易获得成功。 养成雷厉风行的习惯，并且立即在需要做的工作中付诸行动。 任何行动都比不采取行动好 任何行动往往都比没有行动好，特别是当你一直停滞在不愉快的情势下很长时间的时候。如果这是一个错误，至少你学到了一些东西。这样一来，它就不再是一个错误。如果你仍然选择停滞不前，那么你就学不到任何东西。</description></item><item><title>经济::经济机器是怎样运行的</title><link>/misc/how_the_economic_machine_works/</link><pubDate>Thu, 23 Sep 2021 07:17:30 +0800</pubDate><guid>/misc/how_the_economic_machine_works/</guid><description>经济机器是怎样运行的 经济就像一部简单的机器那样运行，但很多人不懂得这一点，或是对经济的运行方式持有不同观点，于是导致很多不必要的经济损失，我深感有责任与大家分享，我的简单但是实用的经济分析模式。这个模式虽然不符合常规传统经济学，但是已经帮助我预测和躲避了全球金融危机，30 多年来对我一直很有用，我们开始吧！
经济虽然可能看起来复杂，但其实是以简单和机械的方式运行。经济由几个简单的零部件和无数次重复的简单交易组成，这些交易首先是由人的天性所驱动的，因而形成三股主要的经济动力。
1、生产率的提高
2、短期债务周期
3、长期债务周期
下面我们谈一下这三股动力，并介绍如何把他们组合在一起得出一个良好的模型，便于我们跟踪经济走势，并理解当前正在发生的事情。我们先来说一下经济中最简单的部分 — — 交易。
交易 经济不过是无数交易的总和，而交易是一件非常简单的事情，交易时刻都在发生，你每次买东西都是进行一笔交易。在每次交易中，买方使用货币或信用向卖方交换商品、服务或金融资产。信用在使用时和货币一样，因此把花费的货币和信用加在一起就可以得出支出总额。
支出总额是经济的驱动力，如果用支出金额除以销量就得出价格，就是这么简单，这就是交易。交易是经济机器的最基本零件，所有的经济周期和动力都是交易造成的，所以理解了交易就理解了整个经济。
一个市场由买卖同一种商品的所有买方和卖方组成，例如小麦市场、汽车市场、股票市场和千百万种其他市场，经济就是由所有市场内的全部交易构成。把全部市场的总支出和销量加在一起就得到了了解经济运行所需要的全部信息，就这么简单。
个人、企业、银行和政府都在以上述方式从事交易，用货币和信用交换商品、服务和金融资产。政府是最大的买方和卖方，而政府有两个组成部分，即收税和花钱的中央政府和中央银行。央行控制着经济中的货币和信贷数量，因此不同于其他买方和卖方，央行通过影响利率和发行更多货币来实行这种控制。我们在下面会看到，正因如此，央行在信贷流通当中发挥着重要作用。
信贷 请诸位注意信贷，信贷是经济中最重要的组成部分，但也许是人们最不了解的部分，它之所以最重要是因为它是经济中最大且最为变幻莫测的一部分，贷款人和借款人与在市场中进行交易的买方和卖方没有两样。通常贷款人希望自己的钱生出更多的钱，而借款人则想购买当前无法负担的某种东西，比如房子、汽车或是进行投资，比如开办企业，借贷可以同时满足贷款人和借款人的需要。
借款人保证偿还借款称为本金，并支付额外的款额称为利息。利率高时借贷就会减少，因为贷款变得昂贵，当利率低时借贷就会增加，因为贷款变得便宜。如果借款人保证偿还债务而且贷款人相信这一承诺，信贷就产生了。任何两个人都可以通过协定凭空创造出信贷，信贷看似简单实则复杂，因为信贷还有其它名称，信贷一旦产生，立即成为债务。债务是贷款人的资产，是借款人的负债，等到借款人今后偿还了贷款并支付了利息，这些资产和负债将消失，交易得以完成。
那么为什么信贷如此重要？这是因为，借款人一旦获得信贷，便可以增加自己的支出。不要忘记，支出是经济的驱动力，这是因为一个人的支出是另一个人的收入。想想看，你每花一块钱另一个人就挣了一块钱，而你每挣一块钱，必定有别人花了一块钱，所以你花的越多，别人挣的就越多。如果某人收入增加，其信用度就会提高，贷款人就更愿意把钱借给他。信用良好的借款人具备两个条件，偿还能力和抵押物。收入债务比率高，借款人就具备偿还能力，如果无法偿还，借款人还可以用有价值可以出售的资产作为抵押物，这样贷款人可以放心的把钱借给他们。所以收入增加使得借贷也增加，从而能够增加支出。由于一个人的支出是另一个人的收入，这将导致借贷进一步增加，并不断循环，这一自我驱动的模式导致经济增长，也正是因为如此才产生了经济周期。
经济周期 在一项交易中，为了获得某样东西，你必须付出另一样东西，长期来看你得到多少取决于你生产多少。我们的知识随时间而逐渐增多，知识的积累会提高我们的生活水平，我们将此称为生产率的提高。一个善于创新和勤奋的人，将比那些自满和懒惰的人，更快的提高生产率和生活水平，但在短期内不一定体现出来，生产率在长期内最关键，但信贷在短期内最重要。这是因为生产率的提高不会剧烈波动，因此不是经济起伏的一个重要动力，但是债务是这种动力。因为我们能够通过借贷让消费超过产出，但是在还贷时不得不让消费低于产出。
债务量的波动有两大周期，其中一个周期持续大约 5–8 年，另一个持续大约 75–100 年。大部分人虽然能够感受到波动，但由于离波动太近，每天每周都身临其境，通常比不认为这是周期，我们将在本章考察这三股主要动力，并观察它们如何相互作用，以及它们在日常经济中的表现。
如上所述，经济的上下起伏，不是取决于人们多么善于创新或是勤奋工作，而是主要看信贷的总量。
我们先想象一下一个没有信贷的经济运行。在这样的经济运行中，增加支出的唯一办法是增加收入。因此，需要提高生产率和工作量，提高生产率是经济增长的唯一途径，由于我的支出是另一个人的收入，当我或者另一个人提高生产率的时候，经济就会增长。我们如果观察各种交易加以总结，就会发现一条类似于生产率增长轨迹的渐进线，但是由于我们借贷于是产生了周期。原因并不是任何法规，而是人的天性和信贷的运作方式。
借债不过是提前消费，为了购买现在买不起的东西，你的支出必然超过收入，因此你需要借钱，实质上是向未来的自己借钱。你给自己设定了一个未来的时间，到那个时候你的支出必须少于收入，以便偿还债务，这样马上就形成了一个周期。通常一旦你借钱就制造了一个周期，对于个人是这样，对于整个经济运行也是这样。这就是为什么必须理解信贷，因为信贷触发了一系列机械和可以预料的将在未来发生的事件。这就是信贷不同于货币的地方。
完成交易需要使用货币，当在酒吧用货币买一瓶啤酒时，交易立即完成。但是如果你用信用来买一瓶啤酒，比如赊账，你相当于承诺今后为这瓶啤酒付钱，你和酒吧一起创造了一笔资产和一笔负债，你们凭空制造出了信贷。只有在你今后清偿了这笔赊账之后，上述资产和负债才会消失，债务才会还清，交易才会了结。
现实生活中大部分所谓钱实际上是信贷，美国国内的信贷总额大约 50 万亿美元，而货币总额只有大约 3 万亿美元。不要忘记，在没有信贷的经济运行中，增加支出的唯一办法是增加生产，但是在有信贷的经济运行中，还可以通过借债来增加支出。因此，有信贷的经济运行能增加支出，使得收入的增长速度在短期内超过生产率的增长，但在长期内并非如此。但是请不要误解我的意思，信贷不一定是坏事，只是会导致周期性变化。
信贷如果造成超过偿还能力的过度消费就是不良信贷，但是信贷如果高效率的分配资源和产生收入，让你能偿还债务就是良性信贷。
例如如果你借钱买一台大彩电，电视机不会带来任何收入让你偿还债务，但是你如果借钱买一台拖拉机，用它来收获更多的庄稼，赚更多的钱，你就能偿还债务，提高生活水平。
在有信贷的经济运行中，我们可以跟踪各种交易，观察信贷如何带来经济增长。
我举一个例子，假设你每年挣 10 万美元，没有任何债务，你有不错的信用可以借 1 万美元，比如用信用卡借。因此你每年可以花 11 万美元，即时你的收入只有 10 万美元。由于你的支出是别人的收入，另一个人因此挣了 11 万美元，这个挣了 11 万美元的人如果没有任何债务，可以借 1.1 万美元，他可以消费 12.1 万美元，即使他的年收入只有 11 万美元。由于他的支出是另一个人的收入，而我们通过跟踪个人的交易可以看到这个过程不断自我强化。但不要忘记借债形成，周期会上升最终也会下降。
短期债务周期 下面我们谈谈短期债务周期，随着经济活动的增加，出现了扩张，这是短期债务周期的第一阶段。支出继续增加，价格开始上涨，原因是导致支出增加的是信贷，而信贷可以即刻凭空产生。如果支出和收入的增长速度超过所出售商品的生产速度，价格就会上涨，我们把价格的上涨称为通货膨胀。
央行不希望通货膨胀过高，因为这会导致许多问题。央行在看到价格上涨时就会提高利率，随着利率上升，有能力借钱的人就会减少，同时现有的债务成本也会上升，就等于你每个月的信用卡还款额会增加。由于人们减少借债，还款额度增长，剩下来用于支出的资金就减少，因此支出速度放慢，而由于一个人的支出是另一个人的收入，环环相扣，人们的收入将下降。由于支出减少价格将下跌，我们称之为通货紧缩，经济活动减少，经济便进入衰退。
如果衰退过于严重，而且通货膨胀不再成为问题，央行将降低利率，使经济活动重新加速。随着利率降低，偿债成本下降，借债和支出增加，出现另一次经济扩张。可见经济像一部机器一样运行，在短期债务周期中，限制支出的唯一因素是贷款人和借款人的贷款和借款意愿。如果信贷易于获得，经济就会扩张，如果信贷不易获得，经济就会衰退。请注意这个周期主要由央行控制，短期债务周期通常持续 5–8 年，在几十年里不断重复。
但是请注意在每个周期的低谷和高峰后，经济增长和债务都超过前一个周期。为什么会这样，这是人促成的，人具有借更多钱和花更多钱的倾向，而不喜欢偿还债务。这是人的天性，因此在长期内债务增加的速度超过收入，从而形成长期债务周期。
长期债务周期 尽管人们的债务增加，但贷款人会提供更宽松的信贷条件，这是为什么？这是因为，大家都以为形式一片大好，人们仅注意最近出现的情况，最近的情况是什么呢？收入一直在增加，资产价值不断上升，股票市场欣欣向荣，现在是繁荣时期，用借来的钱购买商品、服务和金融资产很划算，当人们过度借贷消费时，泡沫便产生了。因此尽管债务一直增加，但收入也以相近的速度增加，从而抵消了债务。我们把债务与收入比例称为债务负担，只要收入继续上升，债务负担就可以承受。
与此同时，资产价值迅猛上升，人们大量借钱来购买资产，因为投资促使资产价格日益升高。人们感觉自己很富有，因此尽管积累了大量债务，收入和资产价值的上升帮助借贷人在长期内保持良好的信用度。
但是这种情况显然无法永久持续下去，也确实没有持续下去，几十年来债务负担缓慢增加使偿债成本越来越高，到了一定的时候，偿债成本的增加速度超过收入，迫使人们削减支出。由于一个人的支出是另一个人的收入，收入开始下降。人们的信用因此降低，致使借贷减少，偿债成本继续增加，使得支出进一步减少。周期开始逆转，这时到达长期债务的顶峰，债务负担变得过重。
美国、欧洲和世界上很多其他地区在 2008 年发生了这一情况，日本在 1989 年和美国在 1929 年因同样原因发生这一情况，现在经济进入去杠杆化时期。</description></item><item><title>Linux/UNIX系统编程手册::基础</title><link>/misc/tlpi_basic/</link><pubDate>Tue, 21 Sep 2021 18:04:51 +0800</pubDate><guid>/misc/tlpi_basic/</guid><description>第 1 章：历史与标准 UNIX 和 C 语言简史 1969 年，在 AT&amp;amp;T 电话公司下辖的 bell 实验室中， Ken Thompson 开发出了首个 UNIX 实现。 1970 年， AT&amp;amp;T 的工程师们又在刚购进的 Digital PDP-11 小型机上，以汇编语言重写了 UNIX。 1972 年，Dennis Ritchie（Thompson 在 bell 实验室的同事， UNIX 开发的早期合作者） 设计并实现出了 C 编程语言。 1973 年， C 语言步入了成熟期，人们能够使用这一新语言重写几乎整个 UNIX 内核。 1974 年的 UNIX 第五版开始， AT&amp;amp;T 准许高校在支付象征性的发布费用后使用 UNIX 系统，UNIX 开始在高校流行。 1979 年 1 月的 UNIX 第七版改善了系统的可靠性，配备了增强型的文件系统。从该版本起， UNIX 分裂为了两 大分支：BSD 和 System V。 1979 年 12 月，诞生了首个完整的 UNIX 发布版 3BSD。 1983 年，加州大学伯克利分校的计算机系统研究组（Computer Systems Research Group）发布 了 4.</description></item><item><title>MySQL技术内幕::InnoDB存储引擎</title><link>/misc/inside_mysql/</link><pubDate>Sat, 11 Sep 2021 10:03:18 +0800</pubDate><guid>/misc/inside_mysql/</guid><description>MySQL 体系结构和存储引擎 定义数据库和实例 数据库 物理操作系统文件和其他形式文件类型的集合 frm、MYD、MYI、ibd 结尾的文件 实例 MySQL 数据库由后台线程和一个共享内存组成 数据库实例才是真正用来操作数据库的 实例与数据库一一对应 MySQL 数据库实例在系统上的表现就是一个进程 配置加载顺序 /etc/my.cnf =&amp;gt; /etc/mysql/my.cnf =&amp;gt; /usr/local/mysql/etc/my.cnf =&amp;gt; $HOME/.my.cnf MySQL 体系结构 组成 连接池组建 管理服务和工具组建 SQL 接口组件 查询分析器组件 优化器组件 缓冲组件 插件式存储引擎 物理文件 存储引擎是基于表的，而不是数据库 存储引擎 InnoDB 存储引擎 支持事务，面向 OLTP 应用 行锁，外键 支持裸设备 多版本并发控制，四种隔离级别 next-key locking 避免幻读 插入缓冲、二次写、自适应哈希索引、预读 采用索引组织表，每张表的存储都是按照转的顺序存放的 MyISAM 存储引擎 不支持事务 表锁设计 支持全文索引 面向 OLAP 只缓存索引文件 MyISAM 存储引擎表由 MYD 和 MYI 组成 MYD 存放数据文件 MYI 存放索引文件 NDB 存储引擎 集群存储引擎 share nothing 架构 Memory 存储引擎 表数据放在内存 使用哈希索引 用于存放临时结果集 Archive 存储引擎 只支持 INSERT 和 SELECT 使用 zlib 压缩数据，有较好的压缩率 适合归档数据 Federated 存储引擎 指向一台远程 MySQL 数据库服务器上的表 Maria 存储引擎 目标取代 MyISAM 特性同 InnoDB 存储引擎 其他存储引擎 Merge CSV Sphinx Infobright 存储引擎比较 MySQL :: 16 Alternative Storage Engines 连接 MySQL TCP/IP 不同机器之间 在客户端和服务器端连接 命名管道和共享内存 在同一台机器上 通过 &amp;ndash;enable-named-pipe 启用 UNIX 域套接字 同一台机器上使用 通过 &amp;ndash;socket=/etc/mysql.</description></item><item><title>大纲::分布式系统</title><link>/misc/distsys_outline/</link><pubDate>Fri, 10 Sep 2021 03:39:50 +0800</pubDate><guid>/misc/distsys_outline/</guid><description>分布式系统大纲 介绍分布式系统基础。直观地了解关键的分布式系统术语，概述算法领域，并探索生产环境的问题。
转载 分布式系统大纲 - iswade&amp;rsquo;s blog，补充了落后的部分以及部分翻译和格式修正
分布式系统大纲 - XMind
为什么需要分布式? Lamport, 1987:
分布式系统是：你不知道存在计算机故障会导致您自己的计算机无法使用的系统。
首先，在托管中心运行*nix 的盒子，进程通过 TCP 或者 UDP 通信。 或者 EC2, Rackspace 的盒子等等 也许通过 InfiniBand 通信 以短距离的局域网分割 或者以数千公里互联网分割 许多移动应用也参与分布式系统 通过糟糕的网络进行通信 桌面 Web 浏览器也是如此 这不仅仅是服务器 —— 它也是客户端 更一般地说，分布式系统具有如下特征 由交互的组件构成 很慢 不可靠 无论那些对你意味着什么 还有： 飞机上的冗余 CPU ATM 和销售点终端 太空探测器 支付账单 医生进行推荐 醉酒的朋友试图通过短信制定计划 每次商务会议 节点和网络 我们将分布式系统中的每个部分叫做 节点 也称之为 进程，代理，参与者 节点 延迟特征 在一个节点内部的操作很快 节点之间的操作很慢 快和慢取决于系统的目的 节点是可靠的 作为一个故障单元 你知道什么时候发生问题 状态是连贯的 状态转换以优雅有序的方式进行 典型的模型是某种类型的单线程状态机 节点可以自己组成一个分布式系统 但只要该系统作为一个整体提供“快速，连贯”的操作，我们就可以将其视为单个节点。 进程模型 顺序进程通信模型 Pi-演算 Ambient 演算 Actor 模型 节点故障模型 故障停止 Crash-stop 故障恢复 Crash-recover 故障遗忘 Crash-amnesia 拜占庭 Byzantine 消息流通的网络 节点通过网络交互 人类通过口头语言进行交互 粒子通过磁场交互 计算机通过 IP，TCP，UDP，SCTP 或者其它协议交互 在节点之间发送的离散 消息 消息需要 时间 来传播 这是分布式系统中比较慢的部分 我们称之为 延迟 消息可能会丢失 这是分布式系统中另一个不可靠的部分。 网络几乎不会是同构的 一些连接比其它的连接速度更慢、带宽更小、更容易出错 因果关系图 我们可以将节点和网络交互表示为图表 时间从左到右或者从上到下表示 节点是时间方向上的线（因为它们保持不动） 消息通过倾斜的路径 连接 节点 同步网络 节点以锁步方式执行：节点步骤之间的时间始终为 1 消息延迟有限 有效的完美的全球时钟 易于证明的 你可能没有 半同步网络 像同步一样，但时钟只是近似的，例如在 [c，1] 异步网络 独立执行，无论何时：步进时间在[0,1]中的任何位置 无限制的消息延迟 没有全球时钟 比半同步或同步网络弱 意味着某些算法效率不高 意味着某些算法是 不可能的 参见例如 Attiya＆Mavronicolas，“半同步与异步网络的效率“ IP 网络肯定是异步的 但 在实践中 真正的病态事情不会发生 大多数网络在几秒到几周内恢复，而不是“从不” 相反，人类的时间尺度大约为几秒到几周 所以我们不能臆想不存在的问题 当网络出错时 异步网络允许 重复 延迟 丢失 重排 丢失和延迟是很难区分的 拜占庭网络被允许随意乱序 包括重写内容 在真实的网络中几乎不会出现 大多数情况 https://www.</description></item><item><title>论文::如何阅读一篇论文</title><link>/misc/how_to_read_a_paper/</link><pubDate>Wed, 01 Sep 2021 04:45:33 +0800</pubDate><guid>/misc/how_to_read_a_paper/</guid><description>原始论文 HowtoReadPaper.pdf
摘要 研究人员花了大量的时间阅读研究论文。然而，这种技能很少被传授，导致了浪费了很多精力。本文概述了一种实用而有效的阅读研究论文的三段式方法。我还描述了如何使用这种方法来进行文献调查。
类别和主题描述符。A.1 [介绍性和调查]。
一般术语。文档。
关键词: 论文，阅读，提示。
1 介绍 研究人员必须阅读论文的原因有几个：为会议或课程审阅论文，在他们的领域保持领先，或对一个新领域进行文献调查。一个典型的研究人员每年可能要花数百个小时来阅读论文。
学会有效地阅读论文是一项重要的技能，但却很少有人教。因此，初学的研究生必须通过试验和错误来自学。在这个过程中，学生们浪费了大量的精力，而且经常被逼得灰心丧气。
多年来，我一直使用一种简单的方法来有效地阅读论文。本文介绍了 &amp;ldquo;三段式 &amp;ldquo;方法及其在进行文献调查时的应用。
2 三段式方法 关键的想法是，你应该最多分三遍来阅读论文，而不是从头开始，一路耕耘到最后。每一遍都要达到特定的目标，并在前一遍的基础上进行。第一遍让你对这篇论文有一个大致的了解。第二遍让你掌握论文的内容，但不是其细节。第三遍帮助你深入了解该论文。
2.1 第一遍 第一遍是快速扫描，以获得纸张的一个概览。你也可以决定是否需要做更多的扫描。这一遍应该需要大约 5 到 10 分钟，包括以下步骤。
仔细阅读标题、摘要和导言 阅读章节和分节的标题，但忽略其他内容 阅读结论 扫一眼参考资料，在心里勾出你已经读过的资料 在第一遍结束时，你应该能够回答这五个问题
类别。这是什么类型的论文？一份测量论文？对一个现有系统的分析？对一个研究原型的描述？ 背景。它与哪些其他论文有关？使用了哪些理论基础来分析问题？ 正确性。假设是有效的吗？ 贡献。该论文的主要贡献是什么？ 清晰度。论文写得好吗？ 利用这些信息，你可以选择不再继续阅读。这可能是因为你对该论文不感兴趣，或者你对该领域的了解不足以理解该论文，或者作者做出了无效的假设。对于那些不属于你的研究领域，但有一天可能被证明是相关的论文，第一遍就足够了。
顺便提一下，当你写一篇论文时，你可以期望大多数审稿人（和读者）只看一遍。请注意选择连贯的章节和分节标题，并写出简明而全面的摘要。如果审稿人在看完一遍后不能理解要点，论文很可能会被拒绝；如果读者在五分钟后不能理解论文的重点，论文很可能永远不会被阅读。
2.2 第二遍 在第二遍时，要更仔细地阅读论文，但忽略诸如证明等细节。在阅读过程中，记下关键点，或在空白处做评论，会有帮助。
仔细观察论文中的数字、图表和其他插图。要特别注意图表。轴的标记是否正确？显示的结果是否有误差条，从而使结论具有统计学意义？诸如此类的常见错误会将仓促的、低劣的工作与真正优秀的工作区分开来。 记得标记相关的未读参考文献以便进一步阅读（这是了解论文背景的一个好方法） 第二遍应该花上一个小时。经过这一关，你应该能够掌握论文的内容。 你应该能够向别人总结论文的主旨，并提供支持性证据。这种详细程度适合于你感兴趣的论文，但不属于你的研究专长。
有时，即使在第二遍结束时，你也无法理解一篇论文。这可能是因为该主题对你来说是新的，有不熟悉的术语和缩略语。或者作者可能使用了你不理解的证明或实验技术，因此，论文的大部分内容是无法理解的。论文可能写得很差，没有事实依据的断言和大量的参考文献。也可能只是因为现在是深夜，你很累。你现在可以选择。(a)把论文放在一边，希望你不需要理解这些材料就能在事业上取得成功，(b)以后再回来看这篇论文，也许是在阅读背景材料之后，或者(c)坚持下去，进入第三关。
2.3 第三遍 要完全理解一篇论文，特别是如果你是审稿人，需要第三遍。第三遍的关键是试图重现该论文：也就是说，在与作者相同的假设下，重新创造该工作。通过比较这种再创造和实际的论文，你不仅可以很容易地发现论文的创新，还可以发现其隐藏的失败和假设。
这一关需要非常注意细节。你应该找出并挑战每一个陈述中的假设。此外，你应该思考你自己会如何陈述一个特定的想法。这种实际与虚拟的比较使你对论文中的证明和表述技巧有了敏锐的洞察力，你很可能将其加入你的工具库。在这个过程中，你还应该记下对未来工作的想法。
这一关对于初学者来说可能需要四五个小时，而对于有经验的读者来说则需要一个小时左右。在这一阶段结束时，你应该能够根据记忆重建论文的整个结构，并能够确定其强点和弱点。特别是，你应该能够指出隐含的假设、缺少对相关工作的引用，以及实验或分析技术的潜在问题。
3 进行文献调查 在做文献调查时，论文阅读能力受到考验。这将要求你阅读数十篇论文，也许是在一个不熟悉的领域。你应该阅读哪些论文？以下是你如何使用三段式方法来帮助。
首先，使用学术搜索引擎，如 Google Scholar 或 CiteSeer 和一些精心选择的关键词，找到该领域的三到五篇最新论文。对每篇论文进行一次检索以了解其工作情况，然后阅读其相关工作部分。你会发现最近工作的缩略图，如果你幸运的话，也许会有一个指向最近的调查报告的指针。如果你能找到这样一份调查报告，你就完成了。阅读调查报告，祝贺自己的好运气。
否则，在第二步，在书目中找到共同的引文和重复的作者名字。这些是该领域的关键论文和研究人员。下载关键论文并将其放在一边。然后进入关键研究人员的网站，看看他们最近在哪里发表过文章。这将帮助你确定该领域的顶级会议，因为最好的研究人员通常在顶级会议上发表文章。
第三步是进入这些顶级会议的网站，查看他们最近的会议记录。快速扫描通常会发现最近的高质量相关工作。这些论文，连同你之前搁置的论文，构成了你调查的第一个版本。对这些论文进行两次扫描。如果他们都引用了你之前没有发现的关键论文，那么就获取并阅读它，必要时进行迭代。
4 经验之谈 在过去的 15 年里，我一直使用这种方法来阅读会议记录，写评论，做背景研究，以及在讨论前快速审查论文。这种有规律的方法可以防止我在得到一个概览之前迷失在细节中。它使我能够估计审查一组论文所需的时间。此外，我可以根据自己的需要和时间的多少来调整论文评估的深度。
5 相关工作 如果你阅读论文是为了做评论，你还应该阅读 Timothy Roscoe 关于 &amp;ldquo;为系统会议撰写评论 &amp;ldquo;的论文[2]。如果你打算写一篇技术论文，你应该同时参考 Henning Schulzrinne 的综合网站[3]和 George Whitesides 对这个过程的出色概述[4]。最后，Simon Peyton Jones 有一个涵盖整个研究技能的网站 [1]。</description></item><item><title>编程::编程之道</title><link>/misc/tao_of_programming/</link><pubDate>Sun, 22 Aug 2021 21:58:06 +0800</pubDate><guid>/misc/tao_of_programming/</guid><description>第 1 册 - 寂静的虚空 主程序员如是说：
“当你学会了从陷阱帧中抓取错误代码时，你就该离开了。“
1.1 某种神秘的东西形成，在寂静的虚空中诞生。独自等待，一动不动，它既静止又不断运动。它是所有程序的来源。我不知道它的名字，所以我称之为编程之道。
如果道是美好的，那么操作系统是美好的。如果操作系统是美好的，那么编译器也是美好的。如果编译器是美好的，那么应用程序也是美好的。用户满意，世界和谐。
编程之道远流归于晨风。
1.2 道催生了机器语言。机器语言催生了汇编程序。
汇编器催生了编译器。现在有一万种语言。
每种语言都有其目的，无论多么卑微。每种语言都表达了软件的阴阳。每种语言在道中都有它的位置。
但是，如果可以避免，请不要在 COBOL 中编程。
1.3 起初是道。道催生出了空间和时间。所以空间和时间是编程的阴阳。
不懂道的程序员总是没有时间和空间来编写他们的程序。懂道的程序员总有足够的时间和空间来实现他们的目标。
不然呢？
1.4 聪明的程序员被告知道并遵循它。普通程序员被告知道并搜索它。愚蠢的程序员被告知道并嘲笑它。
若非欢笑，便无道。
曲高和寡。
进亦是退。
大器晚成。
即使是完美的程序仍然存在错误。
第 2 册 - 古代大师 主程序员如是说：
&amp;ldquo;三天没有编程，生活变得毫无意义。&amp;rdquo;
2.1 古代的程序员是神秘而深刻的。我们无法揣摩他们的想法，所以我们所做的只是描述他们的外表。
谨觉，就像一只过水的狐狸。机警，就像战场上的将军。亲切，就像一位女大师迎接她的客人。简单，就像未雕刻的木块。浑浊，就像黑暗洞穴中的黑色水池。
谁能说出他们内心深处的秘密？
答案只存在于道中。
2.2 图灵大师曾经梦想自己是一台机器。当他醒来时，他惊呼道：
&amp;ldquo;我不知道我是图灵在梦想我是机器，还是机器在梦想我是图灵！&amp;rdquo;
2.3 一个很大的电脑公司的程序员去参加了一个软件会议，然后回来向他的经理汇报，他说：“什么样的程序员在其他公司工作？他们行为恶劣，对外表漠不关心。他们的头发又长又乱，衣服又皱又旧。他们毁了我们的招待大厅，并在我的演讲中发出粗鲁的声音。”
经理说：“我不应该派你去参加会议。那些程序员生活在物理世界之外。他们认为生活是荒谬的，是偶然的巧合。他们来来去去，不受限制。毫无顾虑，他们只为自己的程序而活。他们为什么要为社会习俗而烦恼？
&amp;ldquo;他们活在道中。&amp;rdquo;
2.4 一个新手问大师：“这是一个从不设计、记录或测试他的程序的程序员。然而，所有认识他的人都认为他是世界上最好的程序员之一。这是为什么？&amp;quot;
师父回答：“那个程序员已经掌握了道。他已经超越了设计的需要；当系统崩溃时，他不会生气，而是毫无顾虑地接受宇宙。他已经超越了对文件的需求；他不再关心其他人是否看到他的代码。他已经超越了测试的需要；他的每一个程序都是完美的，宁静而优雅，其目的不言而喻。的确，他进入了道的奥秘。”
第 3 册 - 设计 主程序员如是说：
&amp;ldquo;当程序正在测试时，进行设计更改为时已晚。&amp;rdquo;
3.1 从前有一个人参加了一个电脑贸易展。每天他一进门，就对门口的守卫说：
“我是个大盗，以入店行窃闻名。预先警告，因为这个贸易展不会逃脱不受掠夺。”
这番话让守卫大为不安，因为里面有数百万美元的电脑设备，所以他小心翼翼地看着那人。但那人只是在一个摊位间徘徊，自言自语地低声哼唱着。
男人走后，守卫把他拉到一边，搜了遍他的衣服，却一无所获。
交易会的第二天，那个人回来责备看守说：“我昨天带着一大笔赃物逃了出来，但今天会更好。”于是看守更密切地看着他，但无济于事.
展销会的最后一天，守卫再也抑制不住好奇了。“小偷先生，”他说，“我很困惑，我无法平静地生活。请赐教。你偷的是什么？”
男人笑了。“我在窃取想法，”他说。
3.2 曾经有一位编写非结构化程序的大师级程序员。一个想模仿他的新手程序员也开始编写非结构化程序。当新手要求大师评价他的进步时，大师批评他编写非结构化程序，说：“适合大师的东西不适合新手。在超越结构之前，您必须了解道。”
3.3 从前有一个程序员，隶属于吴军的朝廷。军阀问程序员：“哪个更容易设计：会计软件包还是操作系统？”</description></item><item><title>APUE::Threads</title><link>/misc/advanced_programming_in_the_unix_environment_threads/</link><pubDate>Wed, 11 Aug 2021 00:43:37 +0800</pubDate><guid>/misc/advanced_programming_in_the_unix_environment_threads/</guid><description>Threads Thread Concepts simplify code that deals with asynchronous events by assigning a separate thread to handle each event type Threads automatically have access to the same memory address space and file descriptors Some problems can be partitioned so that overall program throughput can be improved interactive programs can realize improved response time by using multiple threads The benefits of a multithreaded programming model can be realized even if your program is running on a uniprocessor A thread consists of the information necessary to represent an execution context within a process a thread ID that identifies the thread within a process a set of register values a stack a scheduling priority and policy a signal mask an errno variable thread-specific data Everything within a process is sharable among the threads in a process text of the executable program the program’s global and heap memory, the stacks the file descriptors Thread Identification every thread has a thread ID the thread ID has significance only within the context of the process to which it belongs A thread ID is represented by the pthread_t data type Thread Creation When a thread is created, there is no guarantee which will run first: the newly created thread or the calling thread The memory location pointed to by tidp is set to the thread ID of the newly created thread when pthread_create returns successfully pthread functions usually return an error code when they fail.</description></item><item><title>APUE::UNIX System Overview</title><link>/misc/advanced_programming_in_the_unix_environment_overview/</link><pubDate>Sun, 01 Aug 2021 00:43:37 +0800</pubDate><guid>/misc/advanced_programming_in_the_unix_environment_overview/</guid><description>UNIX System Overview an operating system can be defined as the software that controls the hardware resources of the computer and provides an environment under which programs can run Kernel is relatively small and resides at the core of the environment The interface to the kernel is a layer of software called the system calls Libraries of common functions are built on top of the system call interface, but applications are free to use both The shell is a special application that provides an interface for running other applications In a broad sense, an operating system consists of the kernel and all the other software that makes a computer useful and gives the computer its personality.</description></item><item><title>心理学::被讨厌的勇气</title><link>/misc/the_courage_to_be_disliked/</link><pubDate>Sun, 28 Mar 2021 17:14:37 +0800</pubDate><guid>/misc/the_courage_to_be_disliked/</guid><description>被讨厌的勇气 我们的不幸是谁的错 如果我们一直依赖原因论，就会永远止步不前。
任何经历本身并不是成功或者失败的原因。我们并非因为自身经历中的刺激——所谓的心理创伤——而痛苦，事实上我们会从经历中发现符合自己目的的因素。决定我们自身的不是过去的经历，而是我们自己赋予经历的意义。
我们大家都是在为了某种“目的”而活着。这就是目的论。
所谓愤怒其实只是可放可收的一种“手段”而已。
答案不应该是从别人那里得到，而应该是自己亲自找出来。
重要的不是被给予了什么，而是如何去利用被给予的东西。
无视现实的是你。一味执著于“被给予了什么”，现实就会改变？我们不是可以更换的机械。我们需要的不是更换而是更新。
比如现在你感觉不到幸福。有时还会觉得活得很痛苦，甚至想要变成别人。但是，现在的你之所以不幸正是因为你自己亲手选择了“不幸”，而不是因为生来就不幸。
行为之恶的确有很多。但无论什么样的犯罪者，都没有因为纯粹想要作恶而去干坏事的，所有的犯罪者都有其犯罪的内在的“相应理由”。假设有人因为金钱纠纷而杀了人。即使如此，对其本人来说也是有“相应理由”的行为，换句话说就是“善”的行动。当然，这不是指道德意义上的善，而是指“利己”这一意义上的善。
你在人生的某个阶段里选择了“不幸”。这既不是因为你生在了不幸的环境中，也不是因为你陷入了不幸的境地中，而是因为你认为“不幸”对你自身而言是一种“善”。
人时常在选择着自己的生活方式，即使像现在这样促膝而谈的瞬间也在进行着选择。你把自己说成不幸的人，还说想要马上改变，甚至说想要变成别人。尽管如此还是没能改变，这是为什么呢？那是因为你在不断地下着不改变自己生活方式的决心。
如果选择新的生活方式，那就既不知道新的自己会遇到什么问题，也不知道应该如何应对眼前的事情。未来难以预测，生活就会充满不安，也可能有更加痛苦、更加不幸的生活在等着自己。也就是说，即使人们有各种不满，但还是认为保持现状更加轻松、更能安心。
阿德勒心理学就是勇气心理学。你之所以不幸并不是因为过去或者环境，更不是因为能力不足，你只不过是缺乏“勇气”，可以说是缺乏“获得幸福的勇气”。
的确。你现在首先应该做的是什么呢？那就是要有“摈弃现在的生活方式”的决心。
无论之前的人生发生过什么，都对今后的人生如何度过没有影响。”决定自己人生的是活在“此时此刻”的你自己。
一切烦恼都来自人际关系 你为什么讨厌自己呢？为什么只盯着缺点就是不肯去喜欢自己呢？那是因为你太害怕被他人讨厌、害怕在人际关系中受伤。
那么，如何实现这种目的呢？答案很简单。只要变成一个只看自己的缺点、极其厌恶自我、尽量不涉入人际关系的人就可以了。如此一来，只要躲在自己的壳里就可以不与任何人发生关联，而且万一遭到别人的拒绝，还可以以此为理由来安慰自己。心里就会想：因为我有这样的缺点才会遭人拒绝，只要我没有这个缺点也会很讨人喜欢。
但是，请你不要忘记，在人际关系中根本不可能不受伤。只要涉入人际关系就会或大或小地受伤，也会伤害别人。
一切烦恼都是人际关系的烦恼
困扰我们的自卑感不是“客观性的事实”而是“主观性的解释”？
我们无法改变客观事实，但可以任意改变主观解释。并且，我们都活在主观世界中。
也就是说，价值必须建立在社会意义之上。即使 1 美元纸币所承载的价值是一种常识（共通感觉），那它也不是客观意义上的价值。如果从印刷成本考虑的话，它根本不等于 1 美元。
自卑感本身并不是坏事。这一点你能够理解吧？就像阿德勒说过的那样，自卑感也可以成为促成努力和进步的契机。例如，虽然对学历抱有自卑感，但若是正因为如此，才下定“我学历低所以更要付出加倍的努力”之类的决心，那反而成了好事。而另一方面，自卑情结是指把自己的自卑感当作某种借口使用的状态。具体就像“我因为学历低所以无法成功”或者“我因为长得不漂亮所以结不了婚”之类的想法。像这样在日常生活中大肆宣扬“因为有 A 所以才做不到 B”这样的理论，这已经超出了自卑感的范畴，它是一种自卑情结。
简单地说就是害怕向前迈进或者是不想真正地努力。不愿意为了改变自我而牺牲目前所享受的乐趣——比如玩乐或休闲时间。也就是拿不出改变生活方式的“勇气”，即使有些不满或者不自由，也还是更愿意维持现状。
如果真正地拥有自信，就不会自大。正因为有强烈的自卑感才会骄傲自大，那其实是想要故意炫耀自己很优秀。担心如果不那么做的话，就会得不到周围的认可。这完全是一种优越情结。这是一种通过把自卑感尖锐化来实现异常优越感的模式。具体就是指夸耀不幸。
以自己的不幸为武器来支配对方。通过诉说自己如何不幸、如何痛苦来让周围的人——比如家人或朋友——担心或束缚支配其言行。刚开始提到的那些闭门不出者就常常沉浸在以不幸为武器的优越感中。阿德勒甚至指出：“在我们的文化中，弱势其实非常强大而且具有特权。
不与任何人竞争，只要自己不断前进即可
健全的自卑感不是来自与别人的比较，而是来自与“理想的自己”的比较。
好吧，我们都不一样。性别、年龄、知识、经验、外貌，没有完全一样的人。我们应该积极地看待自己与别人的差异。但是，我们“虽然不同但是平等”。
不是。无论是走在前面还是走在后面都没有关系，我们都走在一个并不存在纵轴的水平面上，我们不断向前迈进并不是为了与谁竞争。价值在于不断超越自我。
这与竞争有关。请你记住。如果在人际关系中存在“竞争”，那人就不可能摆脱人际关系带来的烦恼，也就不可能摆脱不幸。
竞争的可怕之处就在于此。即便不是败者、即便一直立于不败之地，处于竞争之中的人也会一刻不得安心、不想成为败者。而为了不成为败者就必须一直获胜、不能相信他人。之所以有很多人虽然取得了社会性的成功，但却感觉不到幸福，就是因为他们活在竞争之中。因为他们眼中的世界是敌人遍布的危险所在。
把他人的幸福看作“我的失败”，所以才无法给予祝福。
如果能够体会到“人人都是我的伙伴”，那么对世界的看法也会截然不同。不再把世界当成危险的所在，也不再活在不必要的猜忌之中，你眼中的世界就会成为一个安全舒适的地方。人际关系的烦恼也会大大减少。
这种情况下，对方的目的是什么呢？是纯粹想要讨论政治吗？不是。对方只是想要责难挑衅你，通过权力之争来达到让不顺眼的你屈服的目的。这个时候你如果发怒的话，那就是正中其下怀，关系会急剧转入权力之争。所以，我们不能上任何挑衅的当。
不是不能发怒，而是“没必要依赖发怒这一工具”。
那就是无论认为自己多么正确，也不要以此为理由去责难对方。这是很多人都容易陷落进去的人际关系圈套。
原本主张的对错与胜负毫无关系。如果你认为自己正确的话，那么无论对方持什么意见都应该无所谓。但是，很多人都会陷入权力之争，试图让对方屈服。正因为如此，才会认为“承认自己的错误”就等于“承认失败”。
承认错误、赔礼道歉、退出权力之争，这些都不是“失败”。
那么你为什么把别人看成是“敌人”而不能认为是“伙伴”呢？那是因为勇气受挫的你在逃避“人生的课题”。
行为方面的目标有以下两点：
自立。 与社会和谐共处。 而且，支撑这种行为的心理方面的目标也有以下两点：
“我有能力”的意识。 “人人都是我的伙伴”的意识。 阿德勒心理学不是改变他人的心理学，而是追求自我改变的心理学。不能等着别人发生变化，也不要等着状况有所改变，而是由你自己勇敢迈出第一步。
当人能够感觉到“与这个人在一起可以无拘无束”的时候，才能够体会到爱。既没有自卑感也不必炫耀优越性，能够保持一种平静而自然的状态。真正的爱应该是这样的。
现阶段能说的就是不能够逃避。无论多么困难的关系都不可以选择逃避，必须勇敢去面对。即使最终发展成用剪刀剪断，也要首先选择面对。最不可取的就是在“这样”的状态下止步不前。
人就是这么任性而自私的生物，一旦产生这种想法，无论怎样都能发现对方的缺点。即使对方是圣人君子一样的人物，也能够轻而易举地找到对方值得讨厌的理由。正因为如此，世界才随时可能变成危险的所在，人们也就有可能把所有他人都看成“敌人”。
让干涉你生活的人见鬼去 阿德勒心理学否定寻求他人的认可。
你不是为了满足别人的期待而活着，我也不是为了满足别人的期待而活着。我们没必要去满足别人的期待。
如果一味寻求别人的认可、在意别人的评价，那最终就会活在别人的人生中。
基本上，一切人际关系矛盾都起因于对别人的课题妄加干涉或者自己的课题被别人妄加干涉。
辨别究竟是谁的课题的方法非常简单，只需要考虑一下“某种选择所带来的结果最终要由谁来承担？”
这一点需要注意。阿德勒心理学并不是推崇放任主义。放任是一种不知道也不想知道孩子在做什么的态度。而阿德勒心理学的主张不是如此，而是在了解孩子干什么的基础上对其加以守护。如果就学习而言，告诉孩子这是他自己的课题，在他想学习的时候父母要随时准备给予帮助，但绝不对孩子的课题妄加干涉。在孩子没有向你求助的时候不可以指手画脚。
接受心理咨询辅导之后，被辅导者下什么样的决心、是否改变生活方式，这都是被辅导者本人的课题，辅导顾问不能干涉。
可以把马带到水边，但不能强迫其喝水
能够改变自己的只有自己。</description></item></channel></rss>