<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Y.CH.Y</title>
    <link>/</link>
      <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <description>Y.CH.Y</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Y.CH.Y</copyright><lastBuildDate>Wed, 25 Aug 2021 17:32:29 +0800</lastBuildDate>
    <item>
      <title>食谱::黑椒鸡胸肉</title>
      <link>/notes/black_pepper_chicken_breast/</link>
      <pubDate>Wed, 25 Aug 2021 17:32:29 +0800</pubDate>
      <guid>/notes/black_pepper_chicken_breast/</guid>
      <description>&lt;h2 id=&#34;黑椒鸡胸肉-version-20210825&#34;&gt;黑椒鸡胸肉 version 2021.08.25&lt;/h2&gt;
&lt;p&gt;参考视频 &lt;a href=&#34;https://www.youtube.com/watch?v=LTY46EWzUSw&#34;&gt;嫩煎黑椒鸡胸肉，我家孩子最喜欢，鲜嫩多汁，营养不流失【我是马小坏】 - YouTube&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原版配料：鸡胸肉 2 块，黑胡椒粉 3 克，蒜蓉 10 克， 生抽 20 克，蚝油 10 克，料酒 20 克，淀粉 10 克， 老抽 5 克，食用油 5 克，西兰花适量&lt;/p&gt;
&lt;p&gt;因为我没有可以称的工具以及蒜蓉，所以配料：鸡胸肉 2 块，黑胡椒粉撒了大概有两克我猜，生抽两勺，蚝油一勺，料酒两勺，小麦粉一勺，老抽一勺&lt;/p&gt;
&lt;p&gt;结论：鸡肉在做好切的时候散掉了，中间用筷子翻面的时候也很散，应该是水加多了或者冷冻鸡肉的关系，味道一般。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>多线程::哲学家就餐</title>
      <link>/leetcode/1226/</link>
      <pubDate>Tue, 24 Aug 2021 19:36:59 +0800</pubDate>
      <guid>/leetcode/1226/</guid>
      <description>&lt;h2 id=&#34;解法一semaphore&#34;&gt;解法一：Semaphore&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;DiningPhilosophers&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;semaphore&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;DiningPhilosophers&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;// call the run() method of any runnable to execute its code
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;wantsToEat&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;philosopher&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;pickLeftFork&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;pickRightFork&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;eat&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;putLeftFork&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;putRightFork&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;semaphore&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;acquire&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;pickLeftFork&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;pickRightFork&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;eat&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;putLeftFork&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;putRightFork&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;semaphore&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;release&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>辛丑::处暑</title>
      <link>/flow/2021_09_23/</link>
      <pubDate>Mon, 23 Aug 2021 21:35:08 +0800</pubDate>
      <guid>/flow/2021_09_23/</guid>
      <description>&lt;h2 id=&#34;处暑&#34;&gt;处暑&lt;/h2&gt;
&lt;h3 id=&#34;七月十七&#34;&gt;七月十七&lt;/h3&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;开始写日志，日志的分类叫做 Flow，来自一个番茄钟 App &lt;a href=&#34;https://flowapp.info/&#34;&gt;Flow&lt;/a&gt;，都是时间在流逝，在流逝的时间希望能记录一些事情，一些思考&lt;/p&gt;
&lt;p&gt;看完了 &lt;a href=&#34;https://book.douban.com/subject/10484692/&#34;&gt;Java 并发编程实战&lt;/a&gt; 的第一部分，基础部分，做了笔记 &lt;a href=&#34;../../notes/java_concurrency_in_practice_basic/&#34;&gt;并发编程实战::基础知识&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;写了一道 leetcode 的题目 &lt;a href=&#34;https://leetcode-cn.com/problems/the-dining-philosophers/&#34;&gt;1226. 哲学家进餐 - 力扣（LeetCode）&lt;/a&gt;，只写了&lt;a href=&#34;../../leetcode/1226/&#34;&gt;信号量&lt;/a&gt;的版本，所有哲学家同时只有一个人能进餐的版本&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java::Java并发编程实战::基础知识</title>
      <link>/notes/java_concurrency_in_practice_basic/</link>
      <pubDate>Mon, 23 Aug 2021 15:55:20 +0800</pubDate>
      <guid>/notes/java_concurrency_in_practice_basic/</guid>
      <description>&lt;h2 id=&#34;线程安全性&#34;&gt;线程安全性&lt;/h2&gt;
&lt;p&gt;线程安全性的定义：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类时线程安全的。在线程安全性的定义中，最核心的概念就是正确性。&lt;/p&gt;
&lt;h3 id=&#34;原子性&#34;&gt;原子性&lt;/h3&gt;
&lt;p&gt;在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件(Race Condition).&lt;/p&gt;
&lt;p&gt;数据争用，线程分析器可检测多线程进程执行期间发生的数据争用。满足以下所有条件时，就会发生数据争用：一个进程内的两个或多个线程同时访问同一内存位置 ，至少其中一个访问是用于写入 ，线程未使用任何互斥锁来控制它们对该内存的访问&lt;/p&gt;
&lt;h3 id=&#34;加锁机制&#34;&gt;加锁机制&lt;/h3&gt;
&lt;h4 id=&#34;内置锁&#34;&gt;内置锁&lt;/h4&gt;
&lt;p&gt;Java 提供了一种内置的锁机制来支持原子性：同步代码块 (Synchronized Block)。同步代码块包括两部分： 一个作为锁的对象引用， 一个作为由这个锁保护的代码块。以关键字 synchronized 来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的 synchronized 方法以 Class 对象作为锁。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;synchronized&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
 &lt;span style=&#34;color:#75715e&#34;&gt;// 访问或修改由锁保护的共享状态
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每个 Java 对象都可以用做一个实现同步的锁，这些锁被称为内置锁 (Intrinsic Lock) 或监视器锁 (Monitor Lock)。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过从代码块中抛出昇常退出。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。&lt;/p&gt;
&lt;p&gt;Java 的内置锁相当于一种互斥体（或互斥锁），这意味着最多只有一个线程能持有这种锁。当线程 A 尝试获取一个由线程 B 持有的锁时，线程 A 必须等待或者阻塞，直到线程 B 释放这个锁。如果 B 永远不释放锁，那么 A 也将永远地等下去。&lt;/p&gt;
&lt;p&gt;由于每次只能有一个线程执行内置锁保护的代码块，因此，由这个锁保护的同步代码块会以原子方式执行，多个线程在执行该代码块时也不会相互干扰。并发环境中的原子性与事务应用程序中的原子性有着相同的含义，一组语句作为一个不可分割的单元被执行。任何一个执行同步代码块的线程，都不可能看到有其他线程正在执行由同一个锁保护的同步代码块。&lt;/p&gt;
&lt;h4 id=&#34;可重入&#34;&gt;可重入&lt;/h4&gt;
&lt;p&gt;当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。 “重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”。重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为口时，这个锁就被认为是没有被任何线程持有。当线程请求一个木被持有的锁时，JVM 将记下锁的持有者，并且将获取计数值置为 1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为 0 时，这个锁将被释放。&lt;/p&gt;
&lt;h3 id=&#34;用锁来保护状态&#34;&gt;用锁来保护状态&lt;/h3&gt;
&lt;p&gt;访问共享状态的复合操作，例如命中计数器的递增操作（读取一修改一写入）或者延迟初始化（先检查后执行），都必须是原子操作以避免产生竞态条件。如果在复合操作的执行过程中持有一个锁，那么会使复合操作成为原子操作。然而，仅仅将复合操作封装到一个同步代码块中是不够的。如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁&lt;/p&gt;
&lt;p&gt;对于可能被多个线程同时访问的可交状态变量，在访问它时都需要特看同一个锁，在这种情况下；我们称状态变量是由这个锁保护的&lt;/p&gt;
&lt;p&gt;虽然 synchronized 方法可以确保单个操作的原子性，但如果要把多个操作合并为一个复合操作，还是需要额外的加锁机制&lt;/p&gt;
&lt;h3 id=&#34;活跃性与性能&#34;&gt;活跃性与性能&lt;/h3&gt;
&lt;p&gt;当使用锁时，你应该请楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间。无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题&lt;/p&gt;
&lt;h2 id=&#34;对象的共享&#34;&gt;对象的共享&lt;/h2&gt;
&lt;p&gt;我们已经知道了同步代码块和同步方法可以确保以原子的方式执行操作，但一种常见的误解是，认为关键字 synchronized 只能用于实现原子性或者确定“临界区 (Ctitical Section)”。同步还有另一个重要的方面：内存可见性 (Memory Visibility)。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后其他线程能够看到发生的状态变化。如果没有同步，那么这种情况就无法实现。你可以通过显式的同步或者类库中内置的同步来保证对象被安全地发布。&lt;/p&gt;
&lt;h3 id=&#34;可见性&#34;&gt;可见性&lt;/h3&gt;
&lt;p&gt;可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。在单线程环境中，如果向某个变量先写入值，然后在没有其他写入操作的情况下读取这个变量，那么总能得到相同的值。这看起来很自然。然而，当读操作和写操作在不同的线程中执行时，情况却并非如此，这听起来或许有些难以接受。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。&lt;/p&gt;
&lt;p&gt;在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。&lt;/p&gt;
&lt;h4 id=&#34;失效数据&#34;&gt;失效数据&lt;/h4&gt;
&lt;p&gt;当读线程查看变量时，可能会得到一个已经失效的值。除非在每次访问变量时都使用同步，否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。&lt;/p&gt;
&lt;h4 id=&#34;非原子的-64-位操作&#34;&gt;非原子的 64 位操作&lt;/h4&gt;
&lt;p&gt;当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性(out-of-thin-air safety).&lt;/p&gt;
&lt;p&gt;最低安全性适用于绝大多数变量，但是存在一个例外：非 volatile 类型的 64 位数值娈量。Java 内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非 volatile 类型的 long 和 double 变量，JVM 允许将 64 位的读操作或写操作分解为两个 32 位的操作。当读取一个非 volatile 类型的 long 变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高 32 位和另一个值的低 32 位。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的 long 和 double 等类型的量也是不安全的，除非用关键宇 volatile 来声明它们，或者用锁保护起来。&lt;/p&gt;
&lt;h4 id=&#34;加锁与可见性&#34;&gt;加锁与可见性&lt;/h4&gt;
&lt;p&gt;加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或写操作的线程都必须在统一个锁上同步。&lt;/p&gt;
&lt;h4 id=&#34;volatile-变量&#34;&gt;Volatile 变量&lt;/h4&gt;
&lt;p&gt;Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为 volatile 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile 变量不会被缓存在奇存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。&lt;/p&gt;
&lt;p&gt;volatile 的语义不足以确保递增操作 count++ 的原子性，除非你能确保只有一个线程对变量执行写操作。&lt;/p&gt;
&lt;p&gt;当且仅当满足以下所有条件时，才应该使用 volatile 变量： 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值，该变量不会与其他状态变量一起纳入不变性条件中，在访问变量时不需要加锁&lt;/p&gt;
&lt;p&gt;加锁机制既可以确保可见性又可以确保原子性，而 volatile 变量只能确保可见性&lt;/p&gt;
&lt;h4 id=&#34;发布与逸出&#34;&gt;发布与逸出&lt;/h4&gt;
&lt;p&gt;“发布（Publish）“一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。例如，将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者將引用传递到其他类的方法中。在许多情况中，我们要确保对象及其内部状态不被发布。而在某些情况下，我们又需要发布某个对象，但如果在发布时要确保线程安全性，则可能需要同步。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。例如，如果在对象构造完成之前就发布该对象，就会破坏线程安全性。当某个不应该发布的对象被发布时，这种情况就被称为逸出(Escape)。&lt;/p&gt;
&lt;p&gt;当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。&lt;/p&gt;
&lt;p&gt;不要在构造过程中使 this 引用逸出。&lt;/p&gt;
&lt;h3 id=&#34;线程封闭&#34;&gt;线程封闭&lt;/h3&gt;
&lt;p&gt;当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭，它是实现线程安全性的最简单方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的&lt;/p&gt;
&lt;p&gt;在 Java 语言中并没有强制规定某个变量必须由锁来保护，同样在 Java 语言中也无法强制将对象封闭在某个线程中。线程封闭是在程序设计中的一个考虑因素，必须在程序中实现 Java 语言及其核心库提供了一些机制来帮助维持线程封闭性，例如局部变量和 ThreadLocal 类但即便如此，程序员仍然需要负责确保封闭在线程中的对象不会从线程中逸出&lt;/p&gt;
&lt;h4 id=&#34;ad-hoc-线程封闭&#34;&gt;Ad-hoc 线程封闭&lt;/h4&gt;
&lt;p&gt;Ad-hoc 线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc 线程封闭是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。事实上，对线程封闭对象（例如，GUI 应用程序中的可视化组件或数据模型等）的引用通常保存在公有变量中&lt;/p&gt;
&lt;h4 id=&#34;栈封闭&#34;&gt;栈封闭&lt;/h4&gt;
&lt;p&gt;栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。正如封装能使得代码更容易维持不变性条件那样，同步变量也能使对象更易于封闭在线程中。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭比 Ad-hoc 线程封闭更易于维护，世更加健壯。&lt;/p&gt;
&lt;h4 id=&#34;threadlocal&#34;&gt;ThreadLocal&lt;/h4&gt;
&lt;p&gt;维持线程封闭性的一种更规范方法是使用 Threadlocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 提供了 get 与 set 等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此 get 总是返回由当前执行线程在调用 set 时设置的最新值．&lt;/p&gt;
&lt;p&gt;ThreadLocal 对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享&lt;/p&gt;
&lt;p&gt;当某个线程初次调用 ThreadLocal.get 方法时，就会调用 initialValue 来获取初始值。从概念上看，你可以将 &lt;code&gt;ThreadLocal&amp;lt;T&amp;gt;&lt;/code&gt;视为包含了&lt;code&gt;Map&amp;lt;Thread,T&amp;gt;&lt;/code&gt;对象，其中保存了特定于该线程的值，但&lt;code&gt;ThreadLocal&lt;/code&gt;的实现并非如此。这些特定于线程的值保存在&lt;code&gt;Thread&lt;/code&gt;对象中，当线程终止后，这些值会作为垃圾回收。&lt;/p&gt;
&lt;p&gt;假设你需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转換为 ThreadLocal 对象，可以维持线程安全性。然而，如果将应用程序范围内的缓存转换为线程局部的缓存，就不会有太大作用。&lt;/p&gt;
&lt;h4 id=&#34;不变性&#34;&gt;不变性&lt;/h4&gt;
&lt;p&gt;如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。线程安全性是不可变对象的固有属性之一，它们的不变性条件是由构造函数创建的，只要它们的状态不改变，那么这些不变性条件就能得以维持&lt;/p&gt;
&lt;p&gt;不可变对象一定是线程安全的。&lt;/p&gt;
&lt;p&gt;当满足一下条件时，对象才是不可变的：对象创建以后其状态就不能改变，对象的所有域都是 final 类型，对象是正确创建的。&lt;/p&gt;
&lt;h4 id=&#34;安全发布&#34;&gt;安全发布&lt;/h4&gt;
&lt;p&gt;要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在静态初始化函数中初始化一个对象引用&lt;/li&gt;
&lt;li&gt;将对象的引用保存到 volatile 类型的域或者 AtomicReferaace 对象中。&lt;/li&gt;
&lt;li&gt;将对象的引用保存到某个正确构造对象的 final 类型域中。&lt;/li&gt;
&lt;li&gt;将对象的引用保存到一个由锁保护的域中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。&lt;/p&gt;
&lt;p&gt;对象的发布需求取决于它的可变性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可变对象可以通过任意机制来发布&lt;/li&gt;
&lt;li&gt;事实不可变对象必须通过安全方式来发布&lt;/li&gt;
&lt;li&gt;可变对象必须通过安全方式来发布，而且必须是线程安全的或者由某个锁保护起来。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;对象的组合&#34;&gt;对象的组合&lt;/h3&gt;
&lt;p&gt;通过使用封装技术，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否是线程安全的。&lt;/p&gt;
&lt;p&gt;在设计线程安全类的过程中，需要包含一下三个基本要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找出构成对象状态的所有变量&lt;/li&gt;
&lt;li&gt;找出约束状态变量的不可变条件&lt;/li&gt;
&lt;li&gt;建立对象状态的并发访问管理策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;收集同步需求&#34;&gt;收集同步需求&lt;/h4&gt;
&lt;p&gt;要确保类的线程安全性，就需要确保它的不变性条件不会在并发访问的情况下被破坏，这就需要对其状态进行推断。&lt;/p&gt;
&lt;p&gt;同步策略(Synchronization Policy）定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性、线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。&lt;/p&gt;
&lt;p&gt;类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件&lt;/p&gt;
&lt;p&gt;在单线程程序中，如果某个操作无法满足先验条件，那么就只能失败。但在并发程序中先验条件可能会由于其他线程执行的操作而变成真。在并发程序中要一直等到先验条件为真，然后再执行该操作．&lt;/p&gt;
&lt;p&gt;要想实现某个等待先验条件为真时才执行的操作，一种更简单的方法是通过现有库中的类实现依赖状态的行为，例如阻塞队列或者信号量。&lt;/p&gt;
&lt;p&gt;如果以某个对象为根节点构造一张对象图，那么该对象的状态将是对象图中所有对象包含的域的一个子集。&lt;/p&gt;
&lt;p&gt;为了防止多个线程在并发访问同一个对象时产生的相互干扰，这些对象应该要么是线程安全的对象，要么是事实不可变的对象，或者由锁来保护的对象。&lt;/p&gt;
&lt;h4 id=&#34;实例封闭&#34;&gt;实例封闭&lt;/h4&gt;
&lt;p&gt;如果某对象不是线程安全的，那么可以通过多种技术使其在多线程程序中安全地使用. 你可以确保该对象只能由单个线程访问（线程封闭），或者通过一个锁来保护对该对象的所有访问。&lt;/p&gt;
&lt;p&gt;将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在 访问数据时总能持有正确的锁。&lt;/p&gt;
&lt;p&gt;封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全时就无需检查整个程序。&lt;/p&gt;
&lt;p&gt;从线程封闭原则及其逻辑推论可以得出 Java 监视器模式。遵循 Java 监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;PrivateLock&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Object&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Object&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;():&lt;/span&gt;

    &lt;span style=&#34;color:#75af00&#34;&gt;@GuardedBy&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;myLock&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Widget&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;widget&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;someMethod&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#75715e&#34;&gt;// 修改或者访问widget的状态
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;线程安全性的委托&#34;&gt;线程安全性的委托&lt;/h4&gt;
&lt;p&gt;将线程安全委托给 ConcurrentMap&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#75af00&#34;&gt;@ThreadSafe&lt;/span&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;DelegatingVehicleTracker&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;ConcurrentMap&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;String&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Point&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;locations&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Map&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;String&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Point&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;unmodifiableMap&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;DelegatingVehicleTracker&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Map&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;String&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Point&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;points&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;locations&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;ConcurrentHashMap&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;points&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;unmodifiableMap&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Collections&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unmodifiableMap&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;locations&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Map&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;String&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Point&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;getLocations&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;unmodifiableMap&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Point&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;getLocation&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;locations&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;setLocation&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;locations&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;replace&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Point&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;IllegalArgumentException&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;invalid vehicle name: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;独立的状态变量&lt;/p&gt;
&lt;p&gt;将线程安全性委托给名个状态变量&lt;/p&gt;
&lt;p&gt;在鼠标事件监听器与键盘事件监听器之间不存在任何关联二者是彼此独立的，因此 VisualComponent 可以将其线程安全性委托给这两个线程安全的监听器列表&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;VisualComponent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;List&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;KeyListener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;keyListeners&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;CopyOnWriteArrayList&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;KeyListener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;List&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;MouseListener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;mouseListeners&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;CopyOnWriteArrayList&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;addKeyListener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;KeyListener&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;listener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;keyListeners&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;listener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;addMouseListener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;MouseListener&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;listener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;mouseListeners&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;listener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;removeKeyListener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;KeyListener&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;keyListener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;keyListeners&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;remove&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;keyListener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;removeMouseListener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;MouseListener&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;listener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;mouseListeners&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;remove&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;listener&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当委托失效时&lt;/p&gt;
&lt;p&gt;如果一个类是由多个独立且线程安全的状态变量组成，养且在所有的操作中都不包含无效状态转换，那么可以将线程安全性麥托给底层的状态变量。&lt;/p&gt;
&lt;p&gt;发布底层的状态变量&lt;/p&gt;
&lt;p&gt;如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。&lt;/p&gt;
&lt;h4 id=&#34;在现有的线程安全类中添加功能&#34;&gt;在现有的线程安全类中添加功能&lt;/h4&gt;
&lt;p&gt;要添加一个新的原子操作，最安全的方法是修改原始的类，但这通常无法做到，因为你可能无法访问或修改类的源代码。要想修改原始的类，就需要理解代码中的同步策略，这样增加的功能才能与原有的设计保持一致。如果直接将新方法添加到类中，那那么意味着实现同步策略的所有代码仍然处于一个源代码文件中，从而更容易理解与维护。&lt;/p&gt;
&lt;p&gt;另一种方法是扩展这个类，假定在设计这个类时考虑了可扩展性。&lt;/p&gt;
&lt;p&gt;扩展 Vector 井增加一个“若没有则添加” 方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;BetterVector&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;E&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Vector&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;E&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;putIfAbsent&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;E&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;absent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;contains&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;absent&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;absent&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;客户端加锁机制&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;ListHelper&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;E&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;List&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;E&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;list&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Collections&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;synchronizedList&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;ArrayList&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;E&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;());&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;putIfAbsent&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;E&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;absent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;list&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;contains&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;absent&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;list&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;absent&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过组合来加锁&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;ImprovedList&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;implements&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;List&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;List&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;list&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;ImprovedList&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;List&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;list&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;list&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;list&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;putIfAbsent&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;absent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;list&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;contains&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;absent&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;list&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;absent&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;clean&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(){&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;list&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;clear&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;// 按照类似方法实现接口中的其他方法
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;将同步策略文档化&#34;&gt;将同步策略文档化&lt;/h4&gt;
&lt;p&gt;在文档中说明容产代码需要了解的线程安全性保证，以及代码维护员需要了解的同步策略。&lt;/p&gt;
&lt;p&gt;如果某个类没有明确说明是线程安全的，就不要假设它是线程安全的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>多线程::H2O 生成</title>
      <link>/leetcode/1117/</link>
      <pubDate>Mon, 23 Aug 2021 02:23:00 +0800</pubDate>
      <guid>/leetcode/1117/</guid>
      <description>&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/building-h2o/&#34;&gt;1117. H2O 生成 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;解法一semaphore&#34;&gt;解法一：Semaphore&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;H2O&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;hydrogen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;oxygen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;H2O&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;hydrogen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;releaseHydrogen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// releaseHydrogen.run() outputs &amp;#34;H&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;hydrogen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;acquire&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;releaseHydrogen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;oxygen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;release&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;oxygen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;releaseOxygen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// releaseOxygen.run() outputs &amp;#34;O&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#111&#34;&gt;oxygen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;acquire&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;releaseOxygen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;hydrogen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;release&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>多线程::交替打印字符串</title>
      <link>/leetcode/1195/</link>
      <pubDate>Mon, 23 Aug 2021 02:23:00 +0800</pubDate>
      <guid>/leetcode/1195/</guid>
      <description>&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/fizz-buzz-multithreaded/&#34;&gt;1195. 交替打印字符串 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;解法一spin-lock&#34;&gt;解法一：Spin Lock&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;FizzBuzz&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;FizzBuzz&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;// printFizz.run() outputs &amp;#34;fizz&amp;#34;.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;fizz&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFizz&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                    &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;yield&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;continue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printFizz&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;// printBuzz.run() outputs &amp;#34;buzz&amp;#34;.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;buzz&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printBuzz&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                    &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;yield&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;continue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printBuzz&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;// printFizzBuzz.run() outputs &amp;#34;fizzbuzz&amp;#34;.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;fizzbuzz&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFizzBuzz&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;15&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                    &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;yield&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;15&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;continue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printFizzBuzz&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;// printNumber.accept(x) outputs &amp;#34;x&amp;#34;, where x is an integer.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;number&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                    &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;yield&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;continue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>编程::编程之道</title>
      <link>/reading/tao_of_programming/</link>
      <pubDate>Sun, 22 Aug 2021 21:58:06 +0800</pubDate>
      <guid>/reading/tao_of_programming/</guid>
      <description>&lt;h2 id=&#34;第-1-册---寂静的虚空&#34;&gt;第 1 册 - 寂静的虚空&lt;/h2&gt;
&lt;p&gt;主程序员如是说：&lt;/p&gt;
&lt;p&gt;“当你学会了从陷阱帧中抓取错误代码时，你就该离开了。“&lt;/p&gt;
&lt;h3 id=&#34;11&#34;&gt;1.1&lt;/h3&gt;
&lt;p&gt;某种神秘的东西形成，在寂静的虚空中诞生。独自等待，一动不动，它既静止又不断运动。它是所有程序的来源。我不知道它的名字，所以我称之为编程之道。&lt;/p&gt;
&lt;p&gt;如果道是美好的，那么操作系统是美好的。如果操作系统是美好的，那么编译器也是美好的。如果编译器是美好的，那么应用程序也是美好的。用户满意，世界和谐。&lt;/p&gt;
&lt;p&gt;编程之道远流归于晨风。&lt;/p&gt;
&lt;h3 id=&#34;12&#34;&gt;1.2&lt;/h3&gt;
&lt;p&gt;道催生了机器语言。机器语言催生了汇编程序。&lt;/p&gt;
&lt;p&gt;汇编器催生了编译器。现在有一万种语言。&lt;/p&gt;
&lt;p&gt;每种语言都有其目的，无论多么卑微。每种语言都表达了软件的阴阳。每种语言在道中都有它的位置。&lt;/p&gt;
&lt;p&gt;但是，如果可以避免，请不要在 COBOL 中编程。&lt;/p&gt;
&lt;h3 id=&#34;13&#34;&gt;1.3&lt;/h3&gt;
&lt;p&gt;起初是道。道催生出了空间和时间。所以空间和时间是编程的阴阳。&lt;/p&gt;
&lt;p&gt;不懂道的程序员总是没有时间和空间来编写他们的程序。懂道的程序员总有足够的时间和空间来实现他们的目标。&lt;/p&gt;
&lt;p&gt;不然呢？&lt;/p&gt;
&lt;h3 id=&#34;14&#34;&gt;1.4&lt;/h3&gt;
&lt;p&gt;聪明的程序员被告知道并遵循它。普通程序员被告知道并搜索它。愚蠢的程序员被告知道并嘲笑它。&lt;/p&gt;
&lt;p&gt;若非欢笑，便无道。&lt;/p&gt;
&lt;p&gt;曲高和寡。&lt;/p&gt;
&lt;p&gt;进亦是退。&lt;/p&gt;
&lt;p&gt;大器晚成。&lt;/p&gt;
&lt;p&gt;即使是完美的程序仍然存在错误。&lt;/p&gt;
&lt;h2 id=&#34;第-2-册---古代大师&#34;&gt;第 2 册 - 古代大师&lt;/h2&gt;
&lt;p&gt;主程序员如是说：&lt;/p&gt;
&lt;p&gt;&amp;ldquo;三天没有编程，生活变得毫无意义。&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;21&#34;&gt;2.1&lt;/h3&gt;
&lt;p&gt;古代的程序员是神秘而深刻的。我们无法揣摩他们的想法，所以我们所做的只是描述他们的外表。&lt;/p&gt;
&lt;p&gt;谨觉，就像一只过水的狐狸。机警，就像战场上的将军。亲切，就像一位女大师迎接她的客人。简单，就像未雕刻的木块。浑浊，就像黑暗洞穴中的黑色水池。&lt;/p&gt;
&lt;p&gt;谁能说出他们内心深处的秘密？&lt;/p&gt;
&lt;p&gt;答案只存在于道中。&lt;/p&gt;
&lt;h3 id=&#34;22&#34;&gt;2.2&lt;/h3&gt;
&lt;p&gt;图灵大师曾经梦想自己是一台机器。当他醒来时，他惊呼道：&lt;/p&gt;
&lt;p&gt;&amp;ldquo;我不知道我是图灵在梦想我是机器，还是机器在梦想我是图灵！&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;23&#34;&gt;2.3&lt;/h3&gt;
&lt;p&gt;一个很大的电脑公司的程序员去参加了一个软件会议，然后回来向他的经理汇报，他说：“什么样的程序员在其他公司工作？他们行为恶劣，对外表漠不关心。他们的头发又长又乱，衣服又皱又旧。他们毁了我们的招待大厅，并在我的演讲中发出粗鲁的声音。”&lt;/p&gt;
&lt;p&gt;经理说：“我不应该派你去参加会议。那些程序员生活在物理世界之外。他们认为生活是荒谬的，是偶然的巧合。他们来来去去，不受限制。毫无顾虑，他们只为自己的程序而活。他们为什么要为社会习俗而烦恼？&lt;/p&gt;
&lt;p&gt;&amp;ldquo;他们活在道中。&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;24&#34;&gt;2.4&lt;/h3&gt;
&lt;p&gt;一个新手问大师：“这是一个从不设计、记录或测试他的程序的程序员。然而，所有认识他的人都认为他是世界上最好的程序员之一。这是为什么？&amp;quot;&lt;/p&gt;
&lt;p&gt;师父回答：“那个程序员已经掌握了道。他已经超越了设计的需要；当系统崩溃时，他不会生气，而是毫无顾虑地接受宇宙。他已经超越了对文件的需求；他不再关心其他人是否看到他的代码。他已经超越了测试的需要；他的每一个程序都是完美的，宁静而优雅，其目的不言而喻。的确，他进入了道的奥秘。”&lt;/p&gt;
&lt;h2 id=&#34;第-3-册---设计&#34;&gt;第 3 册 - 设计&lt;/h2&gt;
&lt;p&gt;主程序员如是说：&lt;/p&gt;
&lt;p&gt;&amp;ldquo;当程序正在测试时，进行设计更改为时已晚。&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;31&#34;&gt;3.1&lt;/h3&gt;
&lt;p&gt;从前有一个人参加了一个电脑贸易展。每天他一进门，就对门口的守卫说：&lt;/p&gt;
&lt;p&gt;“我是个大盗，以入店行窃闻名。预先警告，因为这个贸易展不会逃脱不受掠夺。”&lt;/p&gt;
&lt;p&gt;这番话让守卫大为不安，因为里面有数百万美元的电脑设备，所以他小心翼翼地看着那人。但那人只是在一个摊位间徘徊，自言自语地低声哼唱着。&lt;/p&gt;
&lt;p&gt;男人走后，守卫把他拉到一边，搜了遍他的衣服，却一无所获。&lt;/p&gt;
&lt;p&gt;交易会的第二天，那个人回来责备看守说：“我昨天带着一大笔赃物逃了出来，但今天会更好。”于是看守更密切地看着他，但无济于事.&lt;/p&gt;
&lt;p&gt;展销会的最后一天，守卫再也抑制不住好奇了。“小偷先生，”他说，“我很困惑，我无法平静地生活。请赐教。你偷的是什么？”&lt;/p&gt;
&lt;p&gt;男人笑了。“我在窃取想法，”他说。&lt;/p&gt;
&lt;h3 id=&#34;32&#34;&gt;3.2&lt;/h3&gt;
&lt;p&gt;曾经有一位编写非结构化程序的大师级程序员。一个想模仿他的新手程序员也开始编写非结构化程序。当新手要求大师评价他的进步时，大师批评他编写非结构化程序，说：“适合大师的东西不适合新手。在超越结构之前，您必须了解道。”&lt;/p&gt;
&lt;h3 id=&#34;33&#34;&gt;3.3&lt;/h3&gt;
&lt;p&gt;从前有一个程序员，隶属于吴军的朝廷。军阀问程序员：“哪个更容易设计：会计软件包还是操作系统？”&lt;/p&gt;
&lt;p&gt;“一个操作系统，”程序员回答。&lt;/p&gt;
&lt;p&gt;军阀发出了难以置信的惊呼。“与操作系统的复杂性相比，会计软件包肯定是微不足道的，”他说。&lt;/p&gt;
&lt;p&gt;“并非如此，”程序员说，“在设计会计包时，程序员充当具有不同想法的人之间的中介：它必须如何运作，它的报告必须如何出现，以及它必须如何符合税收法律。相比之下，操作系统不受外观的限制。在设计操作系统时，程序员寻求机器和思想之间最简单的和谐。这就是操作系统更容易设计的原因。”&lt;/p&gt;
&lt;p&gt;武将点点头，笑了笑。&amp;ldquo;这一切都很好，但哪个更容易调试？&amp;rdquo;&lt;/p&gt;
&lt;p&gt;程序员没有回答。&lt;/p&gt;
&lt;h3 id=&#34;34&#34;&gt;3.4&lt;/h3&gt;
&lt;p&gt;一位经理去找主程序员并向他展示了一个新应用程序的需求文档。经理问师傅：“如果我给它指派五个程序员，设计这个系统需要多长时间？”&lt;/p&gt;
&lt;p&gt;“这需要一年的时间，”大师立即说道。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;但我们立即甚至更早地需要这个系统！如果我给它分配十个程序员需要多长时间？&amp;rdquo;&lt;/p&gt;
&lt;p&gt;程序员大师皱了皱眉。“那样的话，需要两年时间。”&lt;/p&gt;
&lt;p&gt;&amp;ldquo;如果我给它分配一百个程序员呢？&amp;rdquo;&lt;/p&gt;
&lt;p&gt;程序员大师耸了耸肩。“那么设计将永远无法完成，”他说。&lt;/p&gt;
&lt;h2 id=&#34;第-4-册---编码&#34;&gt;第 4 册 - 编码&lt;/h2&gt;
&lt;p&gt;主程序员如是说：&lt;/p&gt;
&lt;p&gt;&amp;ldquo;一个编写好的程序是它自己的天堂；一个写得不好的程序是它自己的地狱。&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;41&#34;&gt;4.1&lt;/h3&gt;
&lt;p&gt;一个程序应该轻巧灵活，它的子程序就像一串珍珠一样连接在一起。该计划的精神和意图应贯穿始终。既不应该太少也不应该太多，既不应该有不必要的循环，也不应该有无用的变量，既不缺乏结构，也不应该过于僵化。&lt;/p&gt;
&lt;p&gt;程序应遵循“最小惊讶法则”。这是什么法律？很简单，程序应该始终以最不让用户惊讶的方式响应用户。&lt;/p&gt;
&lt;p&gt;一个程序，无论多么复杂，都应该作为一个单元。程序应该由内在的逻辑而不是由外表来指导。&lt;/p&gt;
&lt;p&gt;如果程序不符合这些要求，就会处于混乱和混乱的状态。解决这个问题的唯一方法是重写程序。&lt;/p&gt;
&lt;h3 id=&#34;42&#34;&gt;4.2&lt;/h3&gt;
&lt;p&gt;一个新手问大师：“我有一个程序，有时运行有时中止。我遵循了编程规则，但我完全感到困惑。这是什么原因？&amp;quot;&lt;/p&gt;
&lt;p&gt;师曰：“不知道而迷惑。只有傻瓜才会期望他的人类同胞做出理性的行为。为什么你期望从人类制造的机器中得到它？计算机模拟确定性；只有道是完美的。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;编程规则是暂时的；只有道是永恒的。因此，你必须先思道，然后才能开悟。”&lt;/p&gt;
&lt;p&gt;“但是我怎么知道我什么时候得到了证悟呢？”新手问道。&lt;/p&gt;
&lt;p&gt;“然后你的程序将正确运行，”大师回答说。&lt;/p&gt;
&lt;h3 id=&#34;43&#34;&gt;4.3&lt;/h3&gt;
&lt;p&gt;一位大师正在向他的一个新手解释道的本质。“道体现在所有软件中——无论多么微不足道，”大师说。&lt;/p&gt;
&lt;p&gt;“道在手持计算器中吗？”新手问道。&lt;/p&gt;
&lt;p&gt;“是的，”回答说。&lt;/p&gt;
&lt;p&gt;“道在电子游戏中吗？”新手继续说道。&lt;/p&gt;
&lt;p&gt;“它甚至在电子游戏中，”大师说。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;而且是个人电脑的 DOS 中的道吗？&amp;rdquo;&lt;/p&gt;
&lt;p&gt;师父咳嗽了一声，微微挪了挪位置。“今天的课到此结束，”他说。&lt;/p&gt;
&lt;h3 id=&#34;44&#34;&gt;4.4&lt;/h3&gt;
&lt;p&gt;王太子的程序员是编写软件的。他的手指在键盘上翩翩起舞。程序编译没有报错，程序运行起来像一阵风。&lt;/p&gt;
&lt;p&gt;“太棒了！”太子赞叹道，“你的技术无懈可击！”&lt;/p&gt;
&lt;p&gt;“技术？”程序员从他的终端转过来，“我追随的是道——超越所有技术！当我第一次开始编程时，我会在我面前看到整个巨大的问题。三年后，我再也看不到这个巨大的大问题了。相反，我使用了子程序。但现在我什么也看不到。我存在于无形的虚空中。我的感官是空闲的。我的精神，没有计划地自由工作，遵循自己的本能。简而言之，我的程序编写它自身。的确，有时会遇到一些棘手的问题。我看到他们来了，我放慢了速度，我静静地看着。然后我更改了一行代码，困难就如烟消云散了。然后我编译程序。我静静地坐着，让工作的快乐充满我的存在。我闭上眼睛片刻，然后注销。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;王太子说：“我的程序员都这么聪明吗！”&lt;/p&gt;
&lt;h2 id=&#34;第-5-册---维护&#34;&gt;第 5 册 - 维护&lt;/h2&gt;
&lt;p&gt;主程序员如是说：&lt;/p&gt;
&lt;p&gt;&amp;ldquo;虽然一个程序只有三行，但总有一天它必须被维护。&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;51&#34;&gt;5.1&lt;/h3&gt;
&lt;p&gt;使用良好的门不需要在铰链上涂油。&lt;/p&gt;
&lt;p&gt;湍急的溪流不会停滞。&lt;/p&gt;
&lt;p&gt;声音和思想都不能在真空中传播。&lt;/p&gt;
&lt;p&gt;如果不使用，软件会腐烂。&lt;/p&gt;
&lt;p&gt;这些都是很大的谜团。&lt;/p&gt;
&lt;h3 id=&#34;52&#34;&gt;5.2&lt;/h3&gt;
&lt;p&gt;一位经理问一位程序员，他需要多长时间才能完成他正在编写的程序。“明天就会完成，”程序员立即回答。&lt;/p&gt;
&lt;p&gt;“我认为你不切实际，”经理说，“说实话，需要多长时间？”&lt;/p&gt;
&lt;p&gt;程序员想了想。&amp;ldquo;我有一些我想添加的功能。这至少需要两周时间，”他最后说。&lt;/p&gt;
&lt;p&gt;“即使这也太出乎意料了，”经理坚持说，“如果你在程序完成时告诉我，我会很满意的。”&lt;/p&gt;
&lt;p&gt;程序员同意了这一点。&lt;/p&gt;
&lt;p&gt;几年后，这位经理退休了。在去参加退休午餐的路上，他发现程序员在他的终端睡着了。他整晚都在编程。&lt;/p&gt;
&lt;h3 id=&#34;53&#34;&gt;5.3&lt;/h3&gt;
&lt;p&gt;一位新手程序员曾经被指派编写一个简单的财务软件。&lt;/p&gt;
&lt;p&gt;新手疯狂地工作了很多天，但当他的大师检查他的程序时，他发现它包含一个屏幕编辑器、一组通用图形程序、一个人工智能界面，但没有丝毫提及任何财务方面的内容。&lt;/p&gt;
&lt;p&gt;师父问起此事，新手顿时愤愤不平。“别那么不耐烦，”他说，“我最终会开始写财务相关的东西的”&lt;/p&gt;
&lt;h3 id=&#34;54&#34;&gt;5.4&lt;/h3&gt;
&lt;p&gt;一个好农民会忽视他种下的庄稼吗？&lt;/p&gt;
&lt;p&gt;一个好老师会忽略最谦虚的学生吗？&lt;/p&gt;
&lt;p&gt;一个好父亲会允许一个孩子挨饿吗？&lt;/p&gt;
&lt;p&gt;一个好的程序员会拒绝维护他的代码吗？&lt;/p&gt;
&lt;h2 id=&#34;第-6-册---管理&#34;&gt;第 6 册 - 管理&lt;/h2&gt;
&lt;p&gt;主程序员如是说：&lt;/p&gt;
&lt;p&gt;&amp;ldquo;让程序员多，经理少&amp;ndash;然后一切都会变得富有成效。&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;61&#34;&gt;6.1&lt;/h3&gt;
&lt;p&gt;当经理们开无休止的会议时，程序员编写游戏。当会计师谈论季度利润时，开发预算即将被削减。当资深科学家谈论蓝天时，乌云即将滚滚而来。&lt;/p&gt;
&lt;p&gt;确实，这不是编程之道。&lt;/p&gt;
&lt;p&gt;当管理者做出承诺时，游戏程序被忽略。当会计师制定长远计划时，和谐与秩序即将恢复。当资深科学家解决手头的问题时，问题很快就会得到解决。&lt;/p&gt;
&lt;p&gt;确实，这就是编程之道。&lt;/p&gt;
&lt;h3 id=&#34;62&#34;&gt;6.2&lt;/h3&gt;
&lt;p&gt;为什么程序员没有生产力？&lt;/p&gt;
&lt;p&gt;因为他们的时间浪费在会议上。&lt;/p&gt;
&lt;p&gt;程序员为什么叛逆？&lt;/p&gt;
&lt;p&gt;因为管理层干预太多。&lt;/p&gt;
&lt;p&gt;程序员为何一一辞职？&lt;/p&gt;
&lt;p&gt;因为他们已经焦头烂额。&lt;/p&gt;
&lt;p&gt;由于管理不善，他们不再重视自己的工作。&lt;/p&gt;
&lt;h3 id=&#34;63&#34;&gt;6.3&lt;/h3&gt;
&lt;p&gt;一位经理即将被解雇，但一位为他工作的程序员发明了一个流行并畅销的新程序。结果，经理保住了他的工作。&lt;/p&gt;
&lt;p&gt;经理试图给程序员奖金，但程序员拒绝了，他说：“我写这个程序是因为我认为这是一个有趣的概念，因此我不希望得到任何回报。”&lt;/p&gt;
&lt;p&gt;经理听了说：“这个程序员虽然地位低下，但很了解员工的应有职责。让我们将他提升到管理顾问的崇高地位！”&lt;/p&gt;
&lt;p&gt;但是当被告知这一点时，程序员再次拒绝了，他说：“我存在是为了我可以编程。如果我升职了，我只会浪费大家的时间。我现在可以走了吗？我有一个正在开发的程序。”&lt;/p&gt;
&lt;h3 id=&#34;64&#34;&gt;6.4&lt;/h3&gt;
&lt;p&gt;一位经理去找他的程序员，告诉他们：“关于你的工作时间：你必须早上九点进来，下午五点离开。” 说到这里，他们都生气了并有几人当场辞职。&lt;/p&gt;
&lt;p&gt;于是经理说：“那好，那你可以自己定工作时间，只要你按时完成你的项目。” 程序员们现在很满意，中午就开始工作到凌晨早上的几个小时。&lt;/p&gt;
&lt;h2 id=&#34;第-7-册---企业智慧&#34;&gt;第 7 册 - 企业智慧&lt;/h2&gt;
&lt;p&gt;主程序员如是说：&lt;/p&gt;
&lt;p&gt;&amp;ldquo;你可以为公司高管演示一个程序，但你不能让他精通计算机。&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;71&#34;&gt;7.1&lt;/h3&gt;
&lt;p&gt;一个新手问大师：“在东方有一个巨大的树状结构，人们称之为‘公司总部’。它与副总裁和会计师一起臃肿不堪。它发布了大量备忘录，每个备忘录都说“去吧，因此！” 或“去，到这儿来！” 没有人知道这是什么意思。每年都有新的名字挂在树枝上，但都无济于事。怎么会有这么不自然的存在？”&lt;/p&gt;
&lt;p&gt;上师回答说：“你感知到这个巨大的结构，并因为它没有合理的目的而感到不安。你不能从它无尽的旋转中获得乐趣吗？您不喜欢在其庇护分支下轻松编程吗？为什么你会因为它的无用而烦恼？”&lt;/p&gt;
&lt;h3 id=&#34;72&#34;&gt;7.2&lt;/h3&gt;
&lt;p&gt;在东方有一条鲨鱼，它比所有其他鱼都大。它变成了一只鸟，它的翅膀像满天的云彩。当这只鸟在陆地上移动时，它带来了来自公司总部的信息。这条消息落入了程序员的心中，就像海鸥在沙滩上留下自己的印记。然后小鸟乘风而上，背着蓝天，回家了。&lt;/p&gt;
&lt;p&gt;新手程序员惊奇地盯着那只鸟，因为他不明白。普通程序员害怕鸟的到来，因为他害怕它的信息。主程序员继续在他的终端工作，因为他不知道这只鸟来了又去。&lt;/p&gt;
&lt;h3 id=&#34;73&#34;&gt;7.3&lt;/h3&gt;
&lt;p&gt;象牙塔魔术师带来了他的最新发明，供程序员大师检验。魔术师将一个大黑匣子推入了大师的办公室，而大师则默默地等待着。&lt;/p&gt;
&lt;p&gt;“这是一个集成的、分布式的、通用的工作站，&amp;ldquo;魔术师开始说，”符合人体工程学地设计有专有操作系统、第六代语言和多种最先进的用户界面。我的助手们花了几百年的时间来建造。是不是很神奇？”&lt;/p&gt;
&lt;p&gt;大师微微挑眉。“这确实令人惊奇，”他说。&lt;/p&gt;
&lt;p&gt;“公司总部已经下令，”魔术师继续说道，“每个人都使用这个工作站作为新程序的平台。你同意吗？&amp;rdquo;&lt;/p&gt;
&lt;p&gt;“当然，”大师回答道，“我会立即将它运送到数据中心！”魔术师很高兴地回到了他的塔。&lt;/p&gt;
&lt;p&gt;几天后，一个新手走进主程序员的办公室，说：“我找不到我的新程序的列表。你知道它可能在哪里吗？”&lt;/p&gt;
&lt;p&gt;“是的，”大师答道，“列表堆放在数据中心的平台上。”&lt;/p&gt;
&lt;h3 id=&#34;74&#34;&gt;7.4&lt;/h3&gt;
&lt;p&gt;大师级程序员无所畏惧地从一个程序移动到另一个程序。管理层的任何变化都不会伤害他。即使项目被取消，他也不会被解雇。这是为什么？他充满了道。&lt;/p&gt;
&lt;h2 id=&#34;第-8-册---硬件和软件&#34;&gt;第 8 册 - 硬件和软件&lt;/h2&gt;
&lt;p&gt;主程序员如是说：&lt;/p&gt;
&lt;p&gt;&amp;ldquo;没有风，草不会动。没有软件，硬件就毫无用处。”&lt;/p&gt;
&lt;h3 id=&#34;81&#34;&gt;8.1&lt;/h3&gt;
&lt;p&gt;一个新手问大师：“我认为一家电脑公司比其他所有公司都大得多。它像矮人中的巨人一样凌驾于竞争对手之上。它的任何一个部门都可以构成一个完整的业务。为什么会这样？&amp;rdquo;&lt;/p&gt;
&lt;p&gt;上人说：“你怎么问这么蠢的问题？那家公司很大，因为它很大。如果只做硬件，没人会买。如果它只制作软件，没有人会使用它。如果它只维护系统，人们会像对待仆人一样对待它。但因为它结合了所有这些东西，人们认为它是神之一！不寻求奋斗，它不费吹灰之力就征服了。”&lt;/p&gt;
&lt;h3 id=&#34;82&#34;&gt;8.2&lt;/h3&gt;
&lt;p&gt;有一天，一位程序员大师走过一位新手程序员身旁。大师注意到新手对手持电脑游戏的专注。“对不起，”他说，“我可以检查一下吗？”&lt;/p&gt;
&lt;p&gt;新手立马注意到，把设备递给了大师。“我看到该设备声称具有三个级别的游戏：简单、中等和困难，”大师说。“然而，每一个这样的设备都有另一个层次的游戏，其中设备不寻求征服人类，也不被人类征服。”&lt;/p&gt;
&lt;p&gt;“请教，大师，”新手恳求道，“如何找到这个神秘的场景？”&lt;/p&gt;
&lt;p&gt;大师把设备扔到地上，把它压在脚下。突然间，新手开悟了。&lt;/p&gt;
&lt;h3 id=&#34;83&#34;&gt;8.3&lt;/h3&gt;
&lt;p&gt;从前有一个程序员研究微处理器。“看看我在这里过得有多好，”他对一位前来参观的大型机程序员说，“我有自己的操作系统和文件存储设备。我不必与任何人分享我的资源。该软件具有自我一致性且易于使用。你为什么不辞掉现在的工作，和我一起来这里？”&lt;/p&gt;
&lt;p&gt;然后，大型机程序员开始向他的朋友描述他的系统，他说：“大型机就像一位古老的圣人坐在数据中心中间沉思。它的磁盘驱动器像一个巨大的机器海洋一样端到端。该软件像钻石一样多面，又像原始丛林一样错综复杂。每个程序都是独一无二的，就像一条湍急的河流一样穿过系统。这就是为什么我很高兴我在哪里。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;微机程序员听到这话，沉默了。但是这两个程序员一直是朋友，直到他们的日子结束。&lt;/p&gt;
&lt;h3 id=&#34;84&#34;&gt;8.4&lt;/h3&gt;
&lt;p&gt;硬件遇上软件在去昌则的路上。软件说：“你是阴，我是阳。如果我们一起旅行，我们就会出名，赚大钱。&amp;ldquo;于是一起出发，想征服世界。&lt;/p&gt;
&lt;p&gt;不久，他们遇到了固件，他穿着破破烂烂的破布，靠在一根带刺的棍子上蹒跚前行。固件对他们说：“道在阴阳之外。它像一潭水一样寂静无声。它不求名利，所以没有人知道它的存在。它不寻求财富，因为它本身是完整的。它存在于时空之外。”&lt;/p&gt;
&lt;p&gt;软件和硬件，惭愧，回到了自己的家。&lt;/p&gt;
&lt;h2 id=&#34;第-9-册---结语&#34;&gt;第 9 册 - 结语&lt;/h2&gt;
&lt;p&gt;主程序员如是说：&lt;/p&gt;
&lt;p&gt;&amp;ldquo;是时候离开了。&amp;rdquo;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>多线程::打印零与奇偶数</title>
      <link>/leetcode/1116/</link>
      <pubDate>Sun, 22 Aug 2021 17:13:46 +0800</pubDate>
      <guid>/leetcode/1116/</guid>
      <description>&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/print-zero-even-odd//&#34;&gt;1116. 打印零与奇偶数 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;解法一spin-lock&#34;&gt;解法一：Spin Lock&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;ZeroEvenOdd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;ZeroEvenOdd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;// printNumber.accept(x) outputs &amp;#34;x&amp;#34;, where x is an integer.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;yield&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;odd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;yield&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;even&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;yield&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法二semaphore&#34;&gt;解法二：Semaphore&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;ZeroEvenOdd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;even&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;odd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;ZeroEvenOdd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;// printNumber.accept(x) outputs &amp;#34;x&amp;#34;, where x is an integer.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;acquire&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;odd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;release&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;even&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;release&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;even&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;even&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;acquire&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;release&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;odd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;odd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;acquire&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;release&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法三cyclicbarrier&#34;&gt;解法三：CyclicBarrier&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;ZeroEvenOdd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;CyclicBarrier&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;CyclicBarrier&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;CyclicBarrier&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;even&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;CyclicBarrier&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;CyclicBarrier&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;odd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;CyclicBarrier&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;ZeroEvenOdd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;// printNumber.accept(x) outputs &amp;#34;x&amp;#34;, where x is an integer.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                    &lt;span style=&#34;color:#111&#34;&gt;odd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                    &lt;span style=&#34;color:#111&#34;&gt;even&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;BrokenBarrierException&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;printStackTrace&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;even&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;even&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;BrokenBarrierException&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;printStackTrace&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;odd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;odd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;BrokenBarrierException&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;printStackTrace&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法四locksupport&#34;&gt;解法四：LockSupport&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;ZeroEvenOdd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;odd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;even&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;ZeroEvenOdd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;// printNumber.accept(x) outputs &amp;#34;x&amp;#34;, where x is an integer.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;currentThread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#75715e&#34;&gt;// 不判空在leetcode上会出现超时，一直要到odd和even初始化完再往下走
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;odd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;even&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;yield&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;LockSupport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unpark&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;odd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;LockSupport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unpark&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;even&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;LockSupport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;park&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;even&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;even&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;currentThread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;LockSupport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;park&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;LockSupport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unpark&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;odd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;odd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;currentThread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;LockSupport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;park&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;LockSupport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unpark&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法五synchroinzed--waitnotifyall&#34;&gt;解法五：Synchroinzed + wait/notifyAll&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;ZeroEvenOdd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Object&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Object&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;ZeroEvenOdd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;// printNumber.accept(x) outputs &amp;#34;x&amp;#34;, where x is an integer.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                    &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;wait&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;notifyAll&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;even&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                    &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;wait&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;notifyAll&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;odd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                    &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;wait&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;notifyAll&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;解法六lock--condition&#34;&gt;解法六：Lock + Condition&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;ZeroEvenOdd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;ReentrantLock&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;ReentrantLock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;newCondition&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;odd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;newCondition&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;even&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;newCondition&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;ZeroEvenOdd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;// printNumber.accept(x) outputs &amp;#34;x&amp;#34;, where x is an integer.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;odd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;signal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;even&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;signal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unlock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;even&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;even&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;signal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unlock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;odd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;IntConsumer&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;odd&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printNumber&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;accept&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;zero&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;signal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unlock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>多线程::交替打印FooBar</title>
      <link>/leetcode/1115/</link>
      <pubDate>Sun, 22 Aug 2021 13:40:26 +0800</pubDate>
      <guid>/leetcode/1115/</guid>
      <description>&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/print-foobar-alternately/&#34;&gt;1115. 交替打印 FooBar - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;解法一-semaphore&#34;&gt;解法一： Semaphore&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;FooBar&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;bar&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;FooBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFoo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

            &lt;span style=&#34;color:#75715e&#34;&gt;// printFoo.run() outputs &amp;#34;foo&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#111&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;acquire&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printFoo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;bar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;release&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;bar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

            &lt;span style=&#34;color:#75715e&#34;&gt;// printBar.run() outputs &amp;#34;bar&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#111&#34;&gt;bar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;acquire&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();;&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;release&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法二spin-lock&#34;&gt;解法二：Spin Lock&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;FooBar&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;FooBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFoo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

            &lt;span style=&#34;color:#75715e&#34;&gt;// printFoo.run() outputs &amp;#34;foo&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 如果while的循环体里面不加yield会导致超时，它可能不会自己让出cpu
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;yield&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printFoo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;bar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#75715e&#34;&gt;// printBar.run() outputs &amp;#34;bar&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;yield&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法三lock--conditon&#34;&gt;解法三：Lock + Conditon&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;FooBar&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;ReentrantLock&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;ReentrantLock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;newCondition&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;bar&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;newCondition&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;FooBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFoo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

            &lt;span style=&#34;color:#75715e&#34;&gt;// printFoo.run() outputs &amp;#34;foo&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printFoo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;bar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;signal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unlock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;bar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

            &lt;span style=&#34;color:#75715e&#34;&gt;// printBar.run() outputs &amp;#34;bar&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;bar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;signal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unlock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法四locksupport&#34;&gt;解法四：LockSupport&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;FooBar&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;bar&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;FooBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFoo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#111&#34;&gt;foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;currentThread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;LockSupport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;park&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#75715e&#34;&gt;// printFoo.run() outputs &amp;#34;foo&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#111&#34;&gt;printFoo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;LockSupport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unpark&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;bar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;bar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#111&#34;&gt;bar&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;currentThread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

            &lt;span style=&#34;color:#75715e&#34;&gt;// printBar.run() outputs &amp;#34;bar&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;LockSupport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;park&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;LockSupport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unpark&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法五synchronized--waitnotifyall&#34;&gt;解法五：Synchronized + wait/notifyAll&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;FooBar&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Object&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Object&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;FooBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFoo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#75715e&#34;&gt;// printFoo.run() outputs &amp;#34;foo&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#00a8c8&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                    &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;wait&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;printFoo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;notifyAll&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;bar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

            &lt;span style=&#34;color:#75715e&#34;&gt;// printBar.run() outputs &amp;#34;bar&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#00a8c8&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;){&lt;/span&gt;
                    &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;wait&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;printBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;notifyAll&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法六cyclicbarrier&#34;&gt;解法六：CyclicBarrier&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;FooBar&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;CyclicBarrier&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;barrier&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;CyclicBarrier&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;FooBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFoo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#75715e&#34;&gt;// printFoo.run() outputs &amp;#34;foo&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;yield&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printFoo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;barrier&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;BrokenBarrierException&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;printStackTrace&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;bar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#00a8c8&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

            &lt;span style=&#34;color:#75715e&#34;&gt;// printBar.run() outputs &amp;#34;bar&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#00a8c8&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;barrier&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;BrokenBarrierException&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;printStackTrace&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printBar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;flag&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>推理::字母表谜案</title>
      <link>/reading/douban_35390390/</link>
      <pubDate>Sat, 21 Aug 2021 17:14:37 +0800</pubDate>
      <guid>/reading/douban_35390390/</guid>
      <description></description>
    </item>
    
    <item>
      <title>算法::二分查找::第一个错误的版本</title>
      <link>/leetcode/278/</link>
      <pubDate>Sat, 21 Aug 2021 09:59:43 +0800</pubDate>
      <guid>/leetcode/278/</guid>
      <description>&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/first-bad-version/submissions/&#34;&gt;278. 第一个错误的版本 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;解法&#34;&gt;解法&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Solution&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;firstBadVersion&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;):&lt;/span&gt;
        &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;span style=&#34;color:#d88200&#34;&gt;        :type n: int
&lt;/span&gt;&lt;span style=&#34;color:#d88200&#34;&gt;        :rtype: int
&lt;/span&gt;&lt;span style=&#34;color:#d88200&#34;&gt;        &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;n&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;isBadVersion&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;):&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;else&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>算法::二分查找::二分查找</title>
      <link>/leetcode/704/</link>
      <pubDate>Sat, 21 Aug 2021 09:39:35 +0800</pubDate>
      <guid>/leetcode/704/</guid>
      <description>&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/binary-search/&#34;&gt;704. 二分查找 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;解法&#34;&gt;解法&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;typing&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;List&lt;/span&gt;

&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Solution&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;search&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;nums&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;List&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;],&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;target&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;nums&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;nums&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;target&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;elif&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;nums&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;target&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;else&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>算法::二分查找::搜索插入位置</title>
      <link>/leetcode/35/</link>
      <pubDate>Sat, 21 Aug 2021 09:39:35 +0800</pubDate>
      <guid>/leetcode/35/</guid>
      <description>&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/search-insert-position/&#34;&gt;35. 搜索插入位置 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;解法&#34;&gt;解法&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;typing&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;List&lt;/span&gt;

&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Solution&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;searchInsert&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;nums&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;List&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;],&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;target&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;nums&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;nums&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;target&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
                &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;nums&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;target&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;else&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;mid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;left&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>多线程::按需打印</title>
      <link>/leetcode/1114/</link>
      <pubDate>Fri, 20 Aug 2021 22:48:32 +0800</pubDate>
      <guid>/leetcode/1114/</guid>
      <description>&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/print-in-order/&#34;&gt;1114. 按序打印 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;解法一synchronized--waitnotifyall&#34;&gt;解法一：synchronized + wait/notifyAll&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Object&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Object&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;first&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printFirst.run() outputs &amp;#34;first&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;wait&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;notifyAll&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printSecond.run() outputs &amp;#34;second&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;wait&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;notifyAll&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printThird.run() outputs &amp;#34;third&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;wait&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;notifyAll&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法二semaphore&#34;&gt;解法二：Semaphore&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;second&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;third&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Semaphore&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;first&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printFirst.run() outputs &amp;#34;first&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;release&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printSecond.run() outputs &amp;#34;second&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#111&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;acquire&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;release&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printThird.run() outputs &amp;#34;third&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#111&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;acquire&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法三spin-lock&#34;&gt;解法三：Spin Lock&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;first&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printFirst.run() outputs &amp;#34;first&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printSecond.run() outputs &amp;#34;second&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printThird.run() outputs &amp;#34;third&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;解法四countdownlatch&#34;&gt;解法四：CountDownLatch&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;CountDownLatch&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;second&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;CountDownLatch&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;CountDownLatch&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;third&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;CountDownLatch&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;first&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printFirst.run() outputs &amp;#34;first&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;countDown&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printSecond.run() outputs &amp;#34;second&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#111&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;countDown&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printThird.run() outputs &amp;#34;third&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#111&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法五lock--conditon&#34;&gt;解法五：Lock + Conditon&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;ReentrantLock&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;ReentrantLock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;first&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;newCondition&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;second&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;newCondition&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;third&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;newCondition&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;first&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printFirst.run() outputs &amp;#34;first&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;first&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;signal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unlock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printSecond.run() outputs &amp;#34;second&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;signal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unlock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printThird.run() outputs &amp;#34;third&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;first&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;signal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unlock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法六cyclicbarrier&#34;&gt;解法六：CyclicBarrier&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;CyclicBarrier&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;first&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;CyclicBarrier&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;CyclicBarrier&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;second&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;CyclicBarrier&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;first&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printFirst.run() outputs &amp;#34;first&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;first&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;BrokenBarrierException&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;printStackTrace&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printSecond.run() outputs &amp;#34;second&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;first&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;BrokenBarrierException&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;printStackTrace&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printThird.run() outputs &amp;#34;third&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;BrokenBarrierException&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;printStackTrace&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法七locksupport&#34;&gt;解法七：LockSupport&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;first&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;second&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;third&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;first&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#111&#34;&gt;first&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;currentThread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;// printFirst.run() outputs &amp;#34;first&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;LockSupport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unpark&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#111&#34;&gt;second&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;currentThread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;// printSecond.run() outputs &amp;#34;second&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;LockSupport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;park&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;LockSupport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;unpark&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#111&#34;&gt;third&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;Thread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;currentThread&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;// printThird.run() outputs &amp;#34;third&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;LockSupport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;park&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法八atomic&#34;&gt;解法八：Atomic&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;AtomicInteger&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;AtomicInteger&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;first&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printFirst.run() outputs &amp;#34;first&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;getAndIncrement&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printSecond.run() outputs &amp;#34;second&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;getAndIncrement&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printThird.run() outputs &amp;#34;third&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;解法九longaddr&#34;&gt;解法九：LongAddr&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;LongAdder&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;LongAdder&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;Foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;first&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printFirst.run() outputs &amp;#34;first&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;longValue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printFirst&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;increment&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;second&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printSecond.run() outputs &amp;#34;second&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;longValue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printSecond&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;increment&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;third&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;Runnable&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;InterruptedException&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// printThird.run() outputs &amp;#34;third&amp;#34;. Do not change or remove this line.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#00a8c8&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;longValue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;printThird&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>面试::八股文::Java</title>
      <link>/notes/interview_questions_java/</link>
      <pubDate>Thu, 19 Aug 2021 21:51:33 +0800</pubDate>
      <guid>/notes/interview_questions_java/</guid>
      <description>&lt;h2 id=&#34;java&#34;&gt;Java&lt;/h2&gt;
&lt;h3 id=&#34;-和-equals-的区别&#34;&gt;== 和 equals() 的区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;equals()&lt;/code&gt;方法和 == 运算符之间的主要区别在于，一个是方法，另一个是运算符。&lt;/li&gt;
&lt;li&gt;我们可以用==运算符进行引用比较（地址比较），用&lt;code&gt;equals()&lt;/code&gt;方法进行内容比较。简单地说，== 检查两个对象是否指向相同的内存位置，而&lt;code&gt;equals()&lt;/code&gt;则是对对象中的值进行评估比较。&lt;/li&gt;
&lt;li&gt;如果一个类没有覆盖 &lt;code&gt;equals()&lt;/code&gt; 方法，那么默认情况下，它使用最接近的父类的 &lt;code&gt;equals(Object o)&lt;/code&gt;方法，该父类已经覆盖了这个方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aqs-在-countdownlatch-等类中的应用原理是什么&#34;&gt;AQS 在 CountDownLatch 等类中的应用原理是什么？&lt;/h3&gt;
&lt;h3 id=&#34;aqs-的内部原理是什么样的&#34;&gt;AQS 的内部原理是什么样的？&lt;/h3&gt;
&lt;h3 id=&#34;atomicinteger-和-synchronized-的异同点&#34;&gt;AtomicInteger 和 synchronized 的异同点？&lt;/h3&gt;
&lt;h3 id=&#34;atomicinteger-在高并发下性能不好如何解决为什么&#34;&gt;AtomicInteger 在高并发下性能不好，如何解决？为什么？&lt;/h3&gt;
&lt;h3 id=&#34;cas-和乐观锁的关系什么时候会用到-cas&#34;&gt;CAS 和乐观锁的关系，什么时候会用到 CAS？&lt;/h3&gt;
&lt;h3 id=&#34;cas-实现原理是什么&#34;&gt;CAS 实现原理是什么？&lt;/h3&gt;
&lt;h3 id=&#34;cas-有什么缺点&#34;&gt;CAS 有什么缺点？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ABA 问题&lt;/li&gt;
&lt;li&gt;自旋时间过长&lt;/li&gt;
&lt;li&gt;不能控制范围&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;callable-和-runnable-的不同&#34;&gt;Callable 和 Runnable 的不同？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Callable 规定的方法是 call(),Runnable 规定的方法是 run().&lt;/li&gt;
&lt;li&gt;Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值得&lt;/li&gt;
&lt;li&gt;call 方法可以抛出异常，run 方法不可以&lt;/li&gt;
&lt;li&gt;运行 Callable 任务可以拿到一个 Future 对象，Future 表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。计算完成后只能使用 get 方法来获取结果，如果线程没有执行完，Future.get()方法可能会阻塞当前线程的执行；如果线程出现异常，Future.get()会 throws InterruptedException 或者 ExecutionException；如果线程已经取消，会跑出 CancellationException。取消由 cancel 方法来执行。isDone 确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&amp;lt;?&amp;gt; 形式类型、并返回 null 作为底层任务的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;concurrenthashmap-在-java7-和-8-有何不同&#34;&gt;ConcurrentHashMap 在 Java7 和 8 有何不同？&lt;/h3&gt;
&lt;h3 id=&#34;conditionobjectwait-和-notify-的关系&#34;&gt;Condition、object.wait() 和 notify() 的关系？&lt;/h3&gt;
&lt;h3 id=&#34;cookie-和-session-的关系和区别是什么&#34;&gt;Cookie 和 Session 的关系和区别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;session 在服务器端，cookie 在客户端（浏览器）&lt;/li&gt;
&lt;li&gt;session 默认被存在在服务器的一个文件里（不是内存）&lt;/li&gt;
&lt;li&gt;session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）&lt;/li&gt;
&lt;li&gt;session 可以放在 文件、数据库、或内存中都可以。&lt;/li&gt;
&lt;li&gt;用户验证这种场合一般会用 session&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;copyonwritearraylist-有什么特点&#34;&gt;CopyOnWriteArrayList 有什么特点？&lt;/h3&gt;
&lt;h3 id=&#34;countdownlatch-是如何安排线程执行顺序的&#34;&gt;CountDownLatch 是如何安排线程执行顺序的？&lt;/h3&gt;
&lt;h3 id=&#34;cyclicbarrier-和-countdownlatch-有什么异同&#34;&gt;CyclicBarrier 和 CountdownLatch 有什么异同？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的&lt;/li&gt;
&lt;li&gt;CountDownLatch 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。CyclicBarrier 参与的线程职责是一样的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;future-的主要功能是什么&#34;&gt;Future 的主要功能是什么？&lt;/h3&gt;
&lt;h3 id=&#34;hashmap-与-concurrenthashmap-的实现原理是怎样的concurrenthashmap-是如何保证线程安全的&#34;&gt;HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？&lt;/h3&gt;
&lt;h3 id=&#34;hashmap-为什么是线程不安全的&#34;&gt;HashMap 为什么是线程不安全的？&lt;/h3&gt;
&lt;h3 id=&#34;hashmap-实现原理为什么使用红黑树&#34;&gt;HashMap 实现原理，为什么使用红黑树？&lt;/h3&gt;
&lt;h3 id=&#34;java-创建多线程的方法有哪些&#34;&gt;JAVA 创建多线程的方法有哪些？&lt;/h3&gt;
&lt;h3 id=&#34;jdk-18-有什么新特性&#34;&gt;JDK 1.8 有什么新特性？&lt;/h3&gt;
&lt;h3 id=&#34;jvm-中内存模型是怎样的哪些区域是线程安全的&#34;&gt;JVM 中内存模型是怎样的，哪些区域是线程安全的？&lt;/h3&gt;
&lt;h3 id=&#34;jvm-中内存模型是怎样的简述新生代与老年代的区别&#34;&gt;JVM 中内存模型是怎样的，简述新生代与老年代的区别？&lt;/h3&gt;
&lt;h3 id=&#34;jvm-内存是如何对应到操作系统内存的&#34;&gt;JVM 内存是如何对应到操作系统内存的？&lt;/h3&gt;
&lt;h3 id=&#34;jvm-对锁进行了哪些优化&#34;&gt;JVM 对锁进行了哪些优化？&lt;/h3&gt;
&lt;h3 id=&#34;jvm-是怎么去调优的简述过程和调优的结果&#34;&gt;JVM 是怎么去调优的？简述过程和调优的结果&lt;/h3&gt;
&lt;h3 id=&#34;java-8-中-adder-和-accumulator-有什么区别&#34;&gt;Java 8 中 Adder 和 Accumulator 有什么区别？&lt;/h3&gt;
&lt;h3 id=&#34;java-中-arrayblockingqueue-与-linkedblockingqueue-的用途和区别&#34;&gt;Java 中 arrayblockingqueue 与 linkedblockingqueue 的用途和区别&lt;/h3&gt;
&lt;h3 id=&#34;java-中-int-的最大值是多少&#34;&gt;Java 中 int 的最大值是多少？&lt;/h3&gt;
&lt;h3 id=&#34;java-中-sleep-与-wait-的区别&#34;&gt;Java 中 sleep() 与 wait() 的区别&lt;/h3&gt;
&lt;h3 id=&#34;java-中垃圾回收机制中如何判断对象需要回收&#34;&gt;Java 中垃圾回收机制中如何判断对象需要回收？&lt;/h3&gt;
&lt;h3 id=&#34;常见的-gc-回收算法有哪些&#34;&gt;常见的 GC 回收算法有哪些？&lt;/h3&gt;
&lt;h3 id=&#34;java-中如何进行-gc-调优&#34;&gt;Java 中如何进行 GC 调优？&lt;/h3&gt;
&lt;h3 id=&#34;java-中接口和抽象类的区别&#34;&gt;Java 中接口和抽象类的区别&lt;/h3&gt;
&lt;p&gt;抽象类：如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用 abstract 关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。如果一个类继承抽象类，那么就必须为基类中的抽象方法提供定义。如果不这么做，那导出类也为抽象类。&lt;/p&gt;
&lt;p&gt;抽象类和普通类的主要有三点区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;抽象方法必须为 public 或者 protected（因为如果为 private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为 public。&lt;/li&gt;
&lt;li&gt;抽象类不能用来创建对象；&lt;/li&gt;
&lt;li&gt;如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为 abstract 类。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接口：可以含有变量和方法。但是要注意，接口中的变量会被隐式地指定为 public static final 变量（并且只能是 public static final 变量，用 private 修饰会报编译错误），而方法会被隐式地指定为 public abstract 方法且只能是 public abstract 方法（用其他关键字，比如 private、protected、static、final 等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。&lt;/p&gt;
&lt;p&gt;抽象类与接口区别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个 interface。&lt;/li&gt;
&lt;li&gt;在 abstract class 中可以有自己的数据成员，也可以有非 abstract 的成员方法，而在 interface 中，只能够有静态的不能被修改的数据成员（也就是必须是 static final 的，不过在 interface 中一般不定义数据成员），所以的成员方法都是 abstract 的。&lt;/li&gt;
&lt;li&gt;实现抽象类和接口的类必须实现其中的所有方法，如果子类没有实现抽象类的所有抽象方法，那么子类也必须是抽象类；但是子类实现接口，则必须把接口的所有抽象方法实现。接口也可以继承接口，此时不需要实现父类接口。抽象类中可以有非抽象方法。接口中则不能有实现方法。&lt;/li&gt;
&lt;li&gt;接口中定义的变量默认都是 public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。&lt;/li&gt;
&lt;li&gt;接口中的方法默认都是 public abstract 类型的，也只能是这个类型不能是 static 方法。static 方法是类方法，它是不允许子类覆写（override）的。但是抽象类允许有 static 方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;java-中的原子操作有哪些注意事项&#34;&gt;Java 中的原子操作有哪些注意事项？&lt;/h3&gt;
&lt;h3 id=&#34;java-多线程有几种实现方式&#34;&gt;Java 多线程有几种实现方式&lt;/h3&gt;
&lt;h3 id=&#34;java-如何高效进行数组拷贝&#34;&gt;Java 如何高效进行数组拷贝&lt;/h3&gt;
&lt;p&gt;Arrays.copyOf 或 System.arraycopy，System.arraycopy 是系统的 native 方法，Arrays.copyOf 底层调用 System.arraycopy 方法&lt;/p&gt;
&lt;h3 id=&#34;java-常见锁有哪些reetrantlock-是怎么实现的&#34;&gt;Java 常见锁有哪些？ReetrantLock 是怎么实现的？&lt;/h3&gt;
&lt;h3 id=&#34;java-异常有哪些类型&#34;&gt;Java 异常有哪些类型？&lt;/h3&gt;
&lt;h3 id=&#34;java-怎么防止内存溢出&#34;&gt;Java 怎么防止内存溢出&lt;/h3&gt;
&lt;h3 id=&#34;java-是如何实现线程安全的哪些数据结构是线程安全的&#34;&gt;Java 是如何实现线程安全的，哪些数据结构是线程安全的？&lt;/h3&gt;
&lt;h3 id=&#34;java-有几种基本数据类型分别占多少字节&#34;&gt;Java 有几种基本数据类型，分别占多少字节？&lt;/h3&gt;
&lt;h3 id=&#34;java-的线程有哪些状态转换关系是怎么样的&#34;&gt;Java 的线程有哪些状态，转换关系是怎么样的？&lt;/h3&gt;
&lt;h3 id=&#34;java-类的加载流程是怎样的什么是双亲委派机制&#34;&gt;Java 类的加载流程是怎样的？什么是双亲委派机制？&lt;/h3&gt;
&lt;h3 id=&#34;java-线程和操作系统的线程是怎么对应的java-线程是怎样进行调度的&#34;&gt;Java 线程和操作系统的线程是怎么对应的？Java 线程是怎样进行调度的?&lt;/h3&gt;
&lt;h3 id=&#34;java-线程池里的-arrayblockingqueue-与-linkedblockingqueue-的使用场景和区别&#34;&gt;Java 线程池里的 arrayblockingqueue 与 linkedblockingqueue 的使用场景和区别&lt;/h3&gt;
&lt;h3 id=&#34;java-线程间有多少通信方式&#34;&gt;Java 线程间有多少通信方式？&lt;/h3&gt;
&lt;h3 id=&#34;java-缓冲流-buffer-的用途和原理是什么&#34;&gt;Java 缓冲流 buffer 的用途和原理是什么？&lt;/h3&gt;
&lt;h3 id=&#34;java-编译后的-class-文件包含了什么内容&#34;&gt;Java 编译后的 .class 文件包含了什么内容？&lt;/h3&gt;
&lt;h3 id=&#34;linux-实现虚拟内存有什么方式&#34;&gt;Linux 实现虚拟内存有什么方式？&lt;/h3&gt;
&lt;h3 id=&#34;lock-有哪几个常用方法分别有什么用&#34;&gt;Lock 有哪几个常用方法？分别有什么用？&lt;/h3&gt;
&lt;h3 id=&#34;mvc-模型和-mvvm-模型的区别&#34;&gt;MVC 模型和 MVVM 模型的区别&lt;/h3&gt;
&lt;h3 id=&#34;spring-mvc-如何处理一个请求&#34;&gt;Spring MVC 如何处理一个请求？&lt;/h3&gt;
&lt;h3 id=&#34;spring-mvc-的原理和流程&#34;&gt;Spring MVC 的原理和流程&lt;/h3&gt;
&lt;h3 id=&#34;spring-是怎么解析-json-数据的&#34;&gt;Spring 是怎么解析 JSON 数据的？&lt;/h3&gt;
&lt;h3 id=&#34;springboot-是如何进行自动配置的&#34;&gt;SpringBoot 是如何进行自动配置的？&lt;/h3&gt;
&lt;h3 id=&#34;string-为什么是-final&#34;&gt;String 为什么是 final？&lt;/h3&gt;
&lt;h3 id=&#34;string-类能不能被继承为什么&#34;&gt;String 类能不能被继承？为什么？&lt;/h3&gt;
&lt;h3 id=&#34;stringstringbufferstringbuilder-之间有什么区别&#34;&gt;String，StringBuffer，StringBuilder 之间有什么区别？&lt;/h3&gt;
&lt;h3 id=&#34;synchronized-关键字底层是如何实现的它与-lock-相比优缺点分别是什么&#34;&gt;Synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？&lt;/h3&gt;
&lt;h3 id=&#34;threadlocal-实现原理是什么&#34;&gt;ThreadLocal 实现原理是什么？&lt;/h3&gt;
&lt;h3 id=&#34;threadlocal-是用来解决共享资源的多线程访问的问题吗&#34;&gt;ThreadLocal 是用来解决共享资源的多线程访问的问题吗？&lt;/h3&gt;
&lt;h3 id=&#34;threadlocal-适合用在哪些实际生产的场景中&#34;&gt;ThreadLocal 适合用在哪些实际生产的场景中？&lt;/h3&gt;
&lt;h3 id=&#34;error-和-exception-的区别是什么&#34;&gt;error 和 exception 的区别是什么？&lt;/h3&gt;
&lt;h3 id=&#34;final-的三种用法是什么&#34;&gt;final 的三种用法是什么？&lt;/h3&gt;
&lt;h3 id=&#34;hashmap-17--18-的实现区别&#34;&gt;hashMap 1.7 / 1.8 的实现区别&lt;/h3&gt;
&lt;h3 id=&#34;hashcode-和-equals-方法的联系&#34;&gt;hashcode 和 equals 方法的联系&lt;/h3&gt;
&lt;h3 id=&#34;hashmap-和-hashtable-的区别是什么&#34;&gt;hashmap 和 hashtable 的区别是什么？&lt;/h3&gt;
&lt;h3 id=&#34;synchronized-和-lock-孰优孰劣如何选择&#34;&gt;synchronized 和 Lock 孰优孰劣，如何选择？&lt;/h3&gt;
&lt;h3 id=&#34;volatile-关键字解决了什么问题它的实现原理是什么&#34;&gt;volatile 关键字解决了什么问题，它的实现原理是什么？&lt;/h3&gt;
&lt;h3 id=&#34;volatile-的作用是什么与-synchronized-有什么异同&#34;&gt;volatile 的作用是什么？与 synchronized 有什么异同？&lt;/h3&gt;
&lt;h3 id=&#34;wait-notify-notifyall-方法的使用注意事项&#34;&gt;wait notify notifyAll 方法的使用注意事项？&lt;/h3&gt;
&lt;h3 id=&#34;一共有哪几种类线程安全问题&#34;&gt;一共有哪几种类线程安全问题？&lt;/h3&gt;
&lt;h3 id=&#34;为什么-map-桶中超过-8-个才转为红黑树&#34;&gt;为什么 Map 桶中超过 8 个才转为红黑树？&lt;/h3&gt;
&lt;h3 id=&#34;为什么-string-被设计为是不可变的&#34;&gt;为什么 String 被设计为是不可变的？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;字符串常量&lt;/li&gt;
&lt;li&gt;用作 HashMap 的 key&lt;/li&gt;
&lt;li&gt;天然线程安全&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么不应该自动创建线程池&#34;&gt;为什么不应该自动创建线程池？&lt;/h3&gt;
&lt;h3 id=&#34;为什么加了-final-却依然无法拥有不变性&#34;&gt;为什么加了 final 却依然无法拥有“不变性”？&lt;/h3&gt;
&lt;h3 id=&#34;为什么多线程会带来性能问题&#34;&gt;为什么多线程会带来性能问题？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;调度开销：上下文切换&lt;/li&gt;
&lt;li&gt;缓存失效：线程在不同 CPU 上执行，导致 CPU 缓存失效&lt;/li&gt;
&lt;li&gt;协作开销：线程之间共享数据，为了数据一致性，不得不把数据刷回主存再读回来&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么需要-aqsaqs-的作用和重要性是什么&#34;&gt;为什么需要 AQS？AQS 的作用和重要性是什么？&lt;/h3&gt;
&lt;h3 id=&#34;主内存和工作内存的关系&#34;&gt;主内存和工作内存的关系？&lt;/h3&gt;
&lt;h3 id=&#34;什么情况下会发生死锁如何解决死锁&#34;&gt;什么情况下会发生死锁，如何解决死锁？&lt;/h3&gt;
&lt;h3 id=&#34;什么是-java-泛型有什么作用&#34;&gt;什么是 Java 泛型，有什么作用？&lt;/h3&gt;
&lt;h3 id=&#34;什么是-spring-容器有什么作用&#34;&gt;什么是 Spring 容器，有什么作用？&lt;/h3&gt;
&lt;h3 id=&#34;什么是-happens-before-规则&#34;&gt;什么是 happens-before 规则？&lt;/h3&gt;
&lt;h3 id=&#34;什么是内存可见性问题&#34;&gt;什么是“内存可见性”问题？&lt;/h3&gt;
&lt;h3 id=&#34;什么是公平锁什么是非公平锁&#34;&gt;什么是公平锁？什么是非公平锁？&lt;/h3&gt;
&lt;h3 id=&#34;什么是内存泄漏怎么确定内存泄漏&#34;&gt;什么是内存泄漏，怎么确定内存泄漏？&lt;/h3&gt;
&lt;h3 id=&#34;什么是堆内存异常&#34;&gt;什么是堆内存异常？&lt;/h3&gt;
&lt;h3 id=&#34;什么是指令重排序为什么要重排序&#34;&gt;什么是指令重排序？为什么要重排序？&lt;/h3&gt;
&lt;h3 id=&#34;什么是自旋锁自旋的好处和后果是什么呢&#34;&gt;什么是自旋锁？自旋的好处和后果是什么呢？&lt;/h3&gt;
&lt;h3 id=&#34;什么是设计模式描述几个常用的设计模式&#34;&gt;什么是设计模式，描述几个常用的设计模式&lt;/h3&gt;
&lt;h3 id=&#34;什么是重写和重载&#34;&gt;什么是重写和重载？&lt;/h3&gt;
&lt;h3 id=&#34;什么是阻塞队列&#34;&gt;什么是阻塞队列？&lt;/h3&gt;
&lt;h3 id=&#34;你知道什么是-cas-吗&#34;&gt;你知道什么是 CAS 吗？&lt;/h3&gt;
&lt;h3 id=&#34;你知道哪几种锁分别有什么特点&#34;&gt;你知道哪几种锁？分别有什么特点？&lt;/h3&gt;
&lt;h3 id=&#34;使用-future-有哪些注意点future-产生新的线程了吗&#34;&gt;使用 Future 有哪些注意点？Future 产生新的线程了吗？&lt;/h3&gt;
&lt;h3 id=&#34;使用线程池比手动创建线程好在哪里&#34;&gt;使用线程池比手动创建线程好在哪里？&lt;/h3&gt;
&lt;h3 id=&#34;信号量能被-fixedthreadpool-替代吗&#34;&gt;信号量能被 FixedThreadPool 替代吗？&lt;/h3&gt;
&lt;h3 id=&#34;内存泄漏为何每次用完-threadlocal-都要调用-remove&#34;&gt;内存泄漏——为何每次用完 ThreadLocal 都要调用 remove()？&lt;/h3&gt;
&lt;h3 id=&#34;单例模式的双重检查锁模式为什么必须加-volatile&#34;&gt;单例模式的双重检查锁模式为什么必须加 volatile？&lt;/h3&gt;
&lt;h3 id=&#34;原子类和-volatile-有什么异同&#34;&gt;原子类和 volatile 有什么异同？&lt;/h3&gt;
&lt;h3 id=&#34;原子类是如何利用-cas-保证线程安全的&#34;&gt;原子类是如何利用 CAS 保证线程安全的？&lt;/h3&gt;
&lt;h3 id=&#34;发生死锁必须满足哪-4-个条件&#34;&gt;发生死锁必须满足哪 4 个条件？&lt;/h3&gt;
&lt;h3 id=&#34;合适的线程数量是多少cpu-核心数和线程数的关系&#34;&gt;合适的线程数量是多少？CPU 核心数和线程数的关系？&lt;/h3&gt;
&lt;h3 id=&#34;同样是线程安全concurrenthashmap-和-hashtable-的区别&#34;&gt;同样是线程安全，ConcurrentHashMap 和 Hashtable 的区别&lt;/h3&gt;
&lt;h3 id=&#34;哪些场景需要额外注意线程安全问题&#34;&gt;哪些场景需要额外注意线程安全问题？&lt;/h3&gt;
&lt;h3 id=&#34;在一个静态方法内调用一个非静态成员为什么是非法的&#34;&gt;在一个静态方法内调用一个非静态成员为什么是非法的？&lt;/h3&gt;
&lt;h3 id=&#34;多个-threadlocal-在-thread-中的-threadlocals-里是怎么存储的&#34;&gt;多个 ThreadLocal 在 Thread 中的 threadlocals 里是怎么存储的？&lt;/h3&gt;
&lt;h3 id=&#34;如何优化-jvm-频繁-minor-gc&#34;&gt;如何优化 JVM 频繁 minor GC&lt;/h3&gt;
&lt;h3 id=&#34;如何停止一个线程&#34;&gt;如何停止一个线程？&lt;/h3&gt;
&lt;h3 id=&#34;如何写一个必然死锁的例子&#34;&gt;如何写一个必然死锁的例子？&lt;/h3&gt;
&lt;h3 id=&#34;如何判断一个-hash-函数好不好&#34;&gt;如何判断一个 Hash 函数好不好？&lt;/h3&gt;
&lt;h3 id=&#34;如何利用-completablefuture-实现旅游平台问题&#34;&gt;如何利用 CompletableFuture 实现“旅游平台”问题？&lt;/h3&gt;
&lt;h3 id=&#34;如何回收循环依赖的对象&#34;&gt;如何回收循环依赖的对象&lt;/h3&gt;
&lt;h3 id=&#34;如何根据实际需要定制自己的线程池&#34;&gt;如何根据实际需要，定制自己的线程池？&lt;/h3&gt;
&lt;h3 id=&#34;如何正确停止线程为什么-volatile-标记位的停止方法是错误的&#34;&gt;如何正确停止线程？为什么 volatile 标记位的停止方法是错误的？&lt;/h3&gt;
&lt;h3 id=&#34;如何正确关闭线程池shutdown-和-shutdownnow-的区别&#34;&gt;如何正确关闭线程池？shutdown 和 shutdownNow 的区别？&lt;/h3&gt;
&lt;h3 id=&#34;如何用命令行和代码定位死锁&#34;&gt;如何用命令行和代码定位死锁？&lt;/h3&gt;
&lt;h3 id=&#34;如何看到-synchronized-背后的monitor-锁&#34;&gt;如何看到 synchronized 背后的“monitor 锁”？&lt;/h3&gt;
&lt;h3 id=&#34;如何确定-eden-区的对象何时进入老年代&#34;&gt;如何确定 eden 区的对象何时进入老年代？&lt;/h3&gt;
&lt;h3 id=&#34;如何解决-spring-的循环依赖问题&#34;&gt;如何解决 Spring 的循环依赖问题？&lt;/h3&gt;
&lt;h3 id=&#34;如何设计-java-的异常体系&#34;&gt;如何设计 Java 的异常体系？&lt;/h3&gt;
&lt;h3 id=&#34;如何设计一个无锁队列&#34;&gt;如何设计一个无锁队列&lt;/h3&gt;
&lt;h3 id=&#34;如何设计一个线程池&#34;&gt;如何设计一个线程池&lt;/h3&gt;
&lt;h3 id=&#34;如何选择适合自己的阻塞队列&#34;&gt;如何选择适合自己的阻塞队列？&lt;/h3&gt;
&lt;h3 id=&#34;实现单例模式&#34;&gt;实现单例模式&lt;/h3&gt;
&lt;h3 id=&#34;实现单例设计模式懒汉饿汉&#34;&gt;实现单例设计模式（懒汉，饿汉）&lt;/h3&gt;
&lt;h3 id=&#34;实现线程的方法&#34;&gt;实现线程的方法？&lt;/h3&gt;
&lt;h3 id=&#34;常用的排序方式有哪些时间复杂度是多少&#34;&gt;常用的排序方式有哪些，时间复杂度是多少？&lt;/h3&gt;
&lt;h3 id=&#34;悲观锁和乐观锁的本质是什么&#34;&gt;悲观锁和乐观锁的本质是什么？&lt;/h3&gt;
&lt;h3 id=&#34;成员变量和方法的区别&#34;&gt;成员变量和方法的区别？&lt;/h3&gt;
&lt;h3 id=&#34;手写生产者消费者模型&#34;&gt;手写生产者消费者模型&lt;/h3&gt;
&lt;h3 id=&#34;数组与链表有什么区别&#34;&gt;数组与链表有什么区别？&lt;/h3&gt;
&lt;h3 id=&#34;有哪-6-种常见的线程池什么是-java8-的-forkjoinpool&#34;&gt;有哪 6 种常见的线程池？什么是 Java8 的 ForkJoinPool？&lt;/h3&gt;
&lt;h3 id=&#34;有哪些解决哈希表冲突的方式&#34;&gt;有哪些解决哈希表冲突的方式？&lt;/h3&gt;
&lt;h3 id=&#34;有哪些解决死锁问题的策略&#34;&gt;有哪些解决死锁问题的策略？&lt;/h3&gt;
&lt;h3 id=&#34;有哪几种实现生产者消费者模式的方法&#34;&gt;有哪几种实现生产者消费者模式的方法？&lt;/h3&gt;
&lt;h3 id=&#34;有哪几种常见的阻塞队列&#34;&gt;有哪几种常见的阻塞队列？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ArrayBlockingQueue:有界队列，其内部是用数组存储元素的，利用 ReentrantLock 实现线程安全。&lt;/li&gt;
&lt;li&gt;LinkedBlockingQueue:内部用链表实现的 BlockingQueue。如果我们不指定它的初始容量，那么它容量默认就为整型的最大值 Integer.MAX_VALUE，由于这个数非常大，我们通常不可能放入这么多的数据，所以 LinkedBlockingQueue 也被称作无界队列，代表它几乎没有界限。&lt;/li&gt;
&lt;li&gt;SynchronousQueue:它的容量为 0，所以没有一个地方来暂存元素，导致每次取数据都要先阻塞，直到有数据被放入；同理，每次放数据的时候也会阻塞，直到有消费者来取。&lt;/li&gt;
&lt;li&gt;PriorityBlockingQueue:PriorityBlockingQueue 是一个支持优先级的无界阻塞队列，可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。同时，插入队列的对象必须是可比较大小的，也就是 Comparable 的，否则会抛出 ClassCastException 异常。它的 take 方法在队列为空的时候会阻塞，但是正因为它是无界队列，而且会自动扩容，所以它的队列永远不会满，所以它的 put 方法永远不会阻塞，添加操作始终都会成功，也正因为如此，它的成员变量里只有一个 Condition：&lt;/li&gt;
&lt;li&gt;DelayQueue:具有“延迟”的功能。我们可以设定让队列中的任务延迟多久之后执行，比如 10 秒钟之后执行，这在例如“30 分钟后未付款自动取消订单”等需要延迟执行的场景中被大量使用。它是无界队列，放入的元素必须实现 Delayed 接口，而 Delayed 接口又继承了 Comparable 接口，所以自然就拥有了比较和排序的能力&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;深拷贝与浅拷贝区别是什么&#34;&gt;深拷贝与浅拷贝区别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。&lt;/li&gt;
&lt;li&gt;深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简单介绍-mybatismybatis-是如何实现-orm-映射的&#34;&gt;简单介绍 mybatis，mybatis 是如何实现 ORM 映射的&lt;/h3&gt;
&lt;h3 id=&#34;简述-arraylist-与-linkedlist-的底层实现以及常见操作的时间复杂度&#34;&gt;简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度&lt;/h3&gt;
&lt;h3 id=&#34;简述-bio-nio-aio-的区别&#34;&gt;简述 BIO, NIO, AIO 的区别&lt;/h3&gt;
&lt;h3 id=&#34;简述-cas-原理什么是-aba-问题怎么解决&#34;&gt;简述 CAS 原理，什么是 ABA 问题，怎么解决？&lt;/h3&gt;
&lt;h3 id=&#34;简述-dubbo-服务调用过程&#34;&gt;简述 Dubbo 服务调用过程&lt;/h3&gt;
&lt;h3 id=&#34;简述-gc-引用链g1-收集器原理&#34;&gt;简述 GC 引用链，G1 收集器原理&lt;/h3&gt;
&lt;h3 id=&#34;简述-hashmap-和-treemap-的实现原理以及常见操作的时间复杂度&#34;&gt;简述 HashMap 和 TreeMap 的实现原理以及常见操作的时间复杂度&lt;/h3&gt;
&lt;h3 id=&#34;简述-hashset-与-hashmap-的异同&#34;&gt;简述 HashSet 与 HashMap 的异同&lt;/h3&gt;
&lt;h3 id=&#34;简述-hashset-实现原理&#34;&gt;简述 HashSet 实现原理&lt;/h3&gt;
&lt;h3 id=&#34;简述-java-aqs-的原理以及使用场景&#34;&gt;简述 Java AQS 的原理以及使用场景&lt;/h3&gt;
&lt;h3 id=&#34;简述-java-中-final-关键字的作用&#34;&gt;简述 Java 中 final 关键字的作用&lt;/h3&gt;
&lt;p&gt;final 修饰变量：一旦被赋值就不能被修改了
final 修饰方法：被 final 修饰的方法不可以被重写，不能被 override
final 修饰类：不能被继承&lt;/p&gt;
&lt;h3 id=&#34;简述-java-中的自动装箱与拆箱&#34;&gt;简述 Java 中的自动装箱与拆箱&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;自动装箱就是 Java 自动将原始类型值转换成对应的对象，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱，反之将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。&lt;/li&gt;
&lt;li&gt;原始类型 byte,short,char,int,long,float,double 和 boolean 对应的封装类为 Byte,Short,Character,Integer,Long,Float,Double,Boolean。&lt;/li&gt;
&lt;li&gt;自动装箱时编译器调用 valueOf 将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似 intValue(),doubleValue()这类的方法将对象转换成原始类型值。&lt;/li&gt;
&lt;li&gt;自动装箱是将 boolean 值转换成 Boolean 对象，byte 值转换成 Byte 对象，char 转换成 Character 对象，float 值转换成 Float 对象，int 转换成 Integer，long 转换成 Long，short 转换成 Short，自动拆箱则是相反的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简述-java-内置排序算法的实现原理&#34;&gt;简述 Java 内置排序算法的实现原理&lt;/h3&gt;
&lt;h3 id=&#34;简述-java-的-happen-before-原则&#34;&gt;简述 Java 的 happen before 原则&lt;/h3&gt;
&lt;h3 id=&#34;简述-java-的反射机制及其应用场景&#34;&gt;简述 Java 的反射机制及其应用场景&lt;/h3&gt;
&lt;h3 id=&#34;简述-java-的序列化和使用场景&#34;&gt;简述 Java 的序列化和使用场景&lt;/h3&gt;
&lt;h3 id=&#34;简述-java-的逃逸分析机制&#34;&gt;简述 Java 的逃逸分析机制&lt;/h3&gt;
&lt;p&gt;1.逃逸分析的定义&lt;/p&gt;
&lt;p&gt;逃逸分析：是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。&lt;/p&gt;
&lt;p&gt;通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。&lt;/p&gt;
&lt;p&gt;Java 在 Java SE 6u23 以及以后的版本中支持并默认开启了逃逸分析的选项。Java 的 HotSpot JIT 编译器，能够在方法重载或者动态加载代码的时候对代码进行逃逸分析。&lt;/p&gt;
&lt;p&gt;逃逸分析的基本行为就是分析对象的动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用。&lt;/p&gt;
&lt;p&gt;方法逃逸：例如作为调用参数传递到其他方法中。&lt;/p&gt;
&lt;p&gt;线程逃逸：有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量。&lt;/p&gt;
&lt;p&gt;2.逃逸分析的理论基础&lt;/p&gt;
&lt;p&gt;基于 Jong-Deok Choi, Manish Gupta, Mauricio Seffano,Vugranam C. Sreedhar, Sam Midkiff 等在论文《Escape Analysis for Java》中描述的算法进行逃逸分析。&lt;/p&gt;
&lt;p&gt;该算法引入了连通图，用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。由于该算法是上下文相关和流敏感的，并且模拟了对象任意层次的嵌套关系，所以分析精度较高，只是运行时间和内存消耗相对较大。&lt;/p&gt;
&lt;p&gt;绝大多数逃逸分析的实现都基于“封闭世界(closed world)”的前提：所有可能被执行的，方法在做逃逸分析前都已经得知，并且，程序的实际运行不会改变它们之间的调用关系 。但当真实的 Java 程序运行时，这样的假设并不成立。Java 程序拥有的许多特性，例如动态类加载、调用本地函数以及反射程序调用等等，都将打破所谓“封闭世界”的约定。&lt;/p&gt;
&lt;p&gt;逃逸分析之后的处理操作&lt;/p&gt;
&lt;p&gt;经过逃逸分析之后，可以得到对象三种可能的逃逸状态：&lt;/p&gt;
&lt;p&gt;GlobalEscape(全局逃逸)： 即一个对象的引用逃出了方法或者线程。例如，一个对象的引用是复制给了一个类变量，或者存储在在一个已经逃逸的对象当中，或者这个对象的引用作为方法的返回值返回给了调用方法。&lt;/p&gt;
&lt;p&gt;ArgEscape(参数级逃逸)：即在方法调用过程当中传递对象的应用给一个方法。这种状态可以通过分析被调方法的二进制代码确定。&lt;/p&gt;
&lt;p&gt;NoEscape(没有逃逸)：一个可以进行标量替换的对象。该对象可以不被分配在传统的堆上。&lt;/p&gt;
&lt;p&gt;编译器可以使用逃逸分析的结果，对程序进行优化。&lt;/p&gt;
&lt;p&gt;堆分配对象变成栈分配对象：一个方法当中的对象，对象的引用没有发生逃逸，那么这个方法可能会被分配在栈内存上而非常见的堆内存上。&lt;/p&gt;
&lt;p&gt;消除同步：线程同步的代价是相当高的，同步的后果是降低并发性和性能。逃逸分析可以判断出某个对象是否始终只被一个线程访问，如果只被一个线程访问，那么对该对象的同步操作就可以转化成没有同步保护的操作，这样就能大大提高并发程度和性能。&lt;/p&gt;
&lt;p&gt;矢量替代：逃逸分析方法如果发现对象的内存存储结构不需要连续进行的话，就可以将对象的部分甚至全部都保存在 CPU 寄存器内，这样能大大提高访问速度。&lt;/p&gt;
&lt;h3 id=&#34;简述-java-锁升级的机制&#34;&gt;简述 Java 锁升级的机制&lt;/h3&gt;
&lt;h3 id=&#34;简述-netty-线程模型netty-为什么如此高效&#34;&gt;简述 Netty 线程模型，Netty 为什么如此高效？&lt;/h3&gt;
&lt;h3 id=&#34;简述-sortedset-实现原理&#34;&gt;简述 SortedSet 实现原理&lt;/h3&gt;
&lt;p&gt;底层是基于&lt;code&gt;TreeMap&lt;/code&gt;来实现的，所以底层结构也是红黑树，因为他和&lt;code&gt;HashSet&lt;/code&gt;不同的是不需要重写&lt;code&gt;hashCode()&lt;/code&gt;和&lt;code&gt;equals()&lt;/code&gt;方法，因为它去重是依靠比较器来去重，因为结构是红黑树，所以每次插入都会遍历比较来寻找节点插入位置，如果发现某个节点的值是一样的那就会直接覆盖。&lt;/p&gt;
&lt;h3 id=&#34;简述-spring-aop-的原理&#34;&gt;简述 Spring AOP 的原理&lt;/h3&gt;
&lt;h3 id=&#34;简述-spring-bean-的生命周期&#34;&gt;简述 Spring bean 的生命周期&lt;/h3&gt;
&lt;h3 id=&#34;简述-spring-注解的实现原理&#34;&gt;简述 Spring 注解的实现原理&lt;/h3&gt;
&lt;h3 id=&#34;简述-spring-的-ioc-机制&#34;&gt;简述 Spring 的 IOC 机制&lt;/h3&gt;
&lt;h3 id=&#34;简述-spring-的初始化流程&#34;&gt;简述 Spring 的初始化流程&lt;/h3&gt;
&lt;h3 id=&#34;简述-synchronizedvolatile可重入锁的不同使用场景及优缺点&#34;&gt;简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点&lt;/h3&gt;
&lt;h3 id=&#34;简述-synchronizedvolatile可重入锁的不同使用场景及优缺点-1&#34;&gt;简述 Synchronized，volatile，可重入锁的不同使用场景及优缺点&lt;/h3&gt;
&lt;h3 id=&#34;简述-web-socket-与-http-的使用场景&#34;&gt;简述 Web socket 与 Http 的使用场景&lt;/h3&gt;
&lt;h3 id=&#34;简述-zookeeper-基础原理以及使用场景&#34;&gt;简述 Zookeeper 基础原理以及使用场景&lt;/h3&gt;
&lt;h3 id=&#34;简述-thread-和-runable-区别&#34;&gt;简述 thread 和 runable 区别&lt;/h3&gt;
&lt;h3 id=&#34;简述使用协程的优点&#34;&gt;简述使用协程的优点&lt;/h3&gt;
&lt;h3 id=&#34;简述偏向锁以及轻量级锁的区别&#34;&gt;简述偏向锁以及轻量级锁的区别&lt;/h3&gt;
&lt;h3 id=&#34;简述动态代理与静态代理&#34;&gt;简述动态代理与静态代理&lt;/h3&gt;
&lt;h3 id=&#34;简述封装继承多态的特性及使用场景&#34;&gt;简述封装、继承、多态的特性及使用场景？&lt;/h3&gt;
&lt;h3 id=&#34;简述常见的工厂模式以及单例模式的使用场景&#34;&gt;简述常见的工厂模式以及单例模式的使用场景&lt;/h3&gt;
&lt;h3 id=&#34;简述并实现工厂模式工厂模式有什么常见问题&#34;&gt;简述并实现工厂模式，工厂模式有什么常见问题？&lt;/h3&gt;
&lt;h3 id=&#34;简述有哪些同步锁以及它们的实现原理&#34;&gt;简述有哪些同步锁以及它们的实现原理&lt;/h3&gt;
&lt;h3 id=&#34;简述标记清除算法的流程&#34;&gt;简述标记清除算法的流程&lt;/h3&gt;
&lt;h3 id=&#34;简述生产者消费者模型&#34;&gt;简述生产者消费者模型&lt;/h3&gt;
&lt;h3 id=&#34;简述装饰者模式以及适配器模式&#34;&gt;简述装饰者模式以及适配器模式&lt;/h3&gt;
&lt;h3 id=&#34;简述读写屏障底层原理&#34;&gt;简述读写屏障底层原理&lt;/h3&gt;
&lt;h3 id=&#34;线程是如何在-6-种状态之间转换的&#34;&gt;线程是如何在 6 种状态之间转换的？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/NNL4TSl.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;线程池实现线程复用的原理&#34;&gt;线程池实现“线程复用”的原理？&lt;/h3&gt;
&lt;p&gt;线程池可以把线程和任务进行解耦，线程归线程，任务归任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制。在线程池中，同一个线程可以从 BlockingQueue 中不断提取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中，不停地检查是否还有任务等待被执行，如果有则直接去执行这个任务，也就是调用任务的 run 方法，把 run 方法当作和普通方法一样的地位去调用，相当于把每个任务的 run() 方法串联了起来，所以线程数量并不增加。&lt;/p&gt;
&lt;h3 id=&#34;线程池常用的阻塞队列有哪些&#34;&gt;线程池常用的阻塞队列有哪些？&lt;/h3&gt;
&lt;h3 id=&#34;线程池是如何实现的简述线程池的任务策略&#34;&gt;线程池是如何实现的？简述线程池的任务策略&lt;/h3&gt;
&lt;h3 id=&#34;线程池有哪-4-种拒绝策略&#34;&gt;线程池有哪 4 种拒绝策略？&lt;/h3&gt;
&lt;h3 id=&#34;线程池的各个参数的含义&#34;&gt;线程池的各个参数的含义？&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数名&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;corePoolSize&lt;/td&gt;
&lt;td&gt;核心线程数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;maxPoolSize&lt;/td&gt;
&lt;td&gt;最大线程数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;keepAliveTime + 时间单位&lt;/td&gt;
&lt;td&gt;空闲线程的存活时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ThreadFactory&lt;/td&gt;
&lt;td&gt;线程工厂、用来创建新线程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;workQueue&lt;/td&gt;
&lt;td&gt;用于存放任务的队列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Handler&lt;/td&gt;
&lt;td&gt;处理被拒绝的任务&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;讲一讲什么是-java-内存模型&#34;&gt;讲一讲什么是 Java 内存模型？&lt;/h3&gt;
&lt;h3 id=&#34;讲一讲公平锁和非公平锁为什么要非公平&#34;&gt;讲一讲公平锁和非公平锁，为什么要“非公平”？&lt;/h3&gt;
&lt;h3 id=&#34;讲一讲经典的哲学家就餐问题&#34;&gt;讲一讲经典的哲学家就餐问题&lt;/h3&gt;
&lt;h3 id=&#34;读写锁-readwritelock-获取锁有哪些规则&#34;&gt;读写锁 ReadWriteLock 获取锁有哪些规则？&lt;/h3&gt;
&lt;h3 id=&#34;读锁应该插队吗什么是读写锁的升降级&#34;&gt;读锁应该插队吗？什么是读写锁的升降级？&lt;/h3&gt;
&lt;h3 id=&#34;阻塞和非阻塞队列的并发安全原理是什么&#34;&gt;阻塞和非阻塞队列的并发安全原理是什么？&lt;/h3&gt;
&lt;h3 id=&#34;阻塞队列包含哪些常用的方法addofferput-等方法的区别&#34;&gt;阻塞队列包含哪些常用的方法？add、offer、put 等方法的区别？&lt;/h3&gt;
&lt;h3 id=&#34;阻塞队列都有哪几种有什么区别&#34;&gt;阻塞队列都有哪几种，有什么区别？&lt;/h3&gt;
&lt;h3 id=&#34;集合类中的-list-和-map-的线程安全版本是什么如何保证线程安全的&#34;&gt;集合类中的 List 和 Map 的线程安全版本是什么，如何保证线程安全的？&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>TLPI::select</title>
      <link>/notes/tlpi_select/</link>
      <pubDate>Wed, 18 Aug 2021 21:09:19 +0800</pubDate>
      <guid>/notes/tlpi_select/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Redis::基础::字符串</title>
      <link>/notes/redis_basic_strings/</link>
      <pubDate>Sun, 15 Aug 2021 06:48:14 +0800</pubDate>
      <guid>/notes/redis_basic_strings/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Redis 字符串类型是你能与 Redis key 关联的最简单的 value 类型。它是 Memcached 中唯一的数据类型，所以对于新人来说，在 Redis 中使用它也是非常自然的。&lt;/p&gt;
&lt;p&gt;由于 Redis 的 key 是字符串，当我们把字符串类型也作为一个 value 时，我们是把一个字符串映射到另一个字符串。字符串数据类型对很多用例都很有用，比如缓存 HTML 片段或页面。&lt;/p&gt;
&lt;h2 id=&#34;相关命令&#34;&gt;相关命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;APPEND key value&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将一个 value 附加到一个 key 上&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DECR key&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将一个 key 的整数 value 递减 1&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DECRBY key decrement&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将一个 key 的整数 value 按给定的数字递减。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GET key&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取一个 key 的 value&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GETDEL key&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取一个 key 的 value 并删除该 key&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GETEX key [EX seconds|PX milliseconds|EXAT timestamp|PXAT milliseconds-timestamp|PERSIST]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取一个 key 的 value ，并可选择设置其过期时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选项
&lt;ul&gt;
&lt;li&gt;EX seconds &amp;ndash; 设置指定的过期时间，单位是秒。&lt;/li&gt;
&lt;li&gt;PX milliseconds &amp;ndash; 设置指定的过期时间，单位是毫秒。&lt;/li&gt;
&lt;li&gt;EXAT timestamp-seconds &amp;ndash; 设置指定的 Unix 时间，以秒为单位， key 将在该时间失效。&lt;/li&gt;
&lt;li&gt;PXAT timestamp-milliseconds &amp;ndash; 设置指定的 Unix 时间， key 将在该时间过期，单位是毫秒。&lt;/li&gt;
&lt;li&gt;PERSIST &amp;ndash; 删除与 key 相关的生存时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;GETRANGE key start end&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取存储在一个 key 上的字符串的子串&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GETSET key value&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置一个 key 的字符串 value 并返回其旧 value&lt;/p&gt;
&lt;p&gt;&lt;code&gt;INCR key&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将一个 key 的整数 value 递增 1&lt;/p&gt;
&lt;p&gt;&lt;code&gt;INCRBY key increment&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将一个 key 的整数 value 按给定的数额递增&lt;/p&gt;
&lt;p&gt;&lt;code&gt;INCRBYFLOAT key increment&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将一个 key 的浮动 value 按给定的量增加。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MGET key [key ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取所有给定 key 的 value&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MSET key value [key value ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将多个 key 设置为多个 value&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MSETNX key value [key value ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将多个 key 设置为多个 value ，只有在 key 都不存在的情况下才会这样做&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PSETEX key milliseconds value&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置一个 key 的 value 和过期时间，单位为毫秒&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SET key value [EX seconds|PX milliseconds|EXAT timestamp|PXAT milliseconds-timestamp|KEEPTTL] [NX|XX] [GET]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置一个 key 的字符串 value&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选项
&lt;ul&gt;
&lt;li&gt;EX seconds &amp;ndash; 设置指定的过期时间，单位是秒。&lt;/li&gt;
&lt;li&gt;PX milliseconds &amp;ndash; 设置指定的过期时间，单位是毫秒。&lt;/li&gt;
&lt;li&gt;EXAT timestamp-seconds &amp;ndash; 设置指定的 Unix 时间，以秒为单位， key 将在该时间失效。&lt;/li&gt;
&lt;li&gt;PXAT timestamp-milliseconds &amp;ndash; 设置指定的 Unix 时间， key 将在该时间过期，单位是毫秒。&lt;/li&gt;
&lt;li&gt;NX &amp;ndash; 只有在 key 不存在的情况下才会设置它。&lt;/li&gt;
&lt;li&gt;XX &amp;ndash; 只设置已经存在的 key 。&lt;/li&gt;
&lt;li&gt;KEEPTTL &amp;ndash; 保留与钥匙相关的生存时间。&lt;/li&gt;
&lt;li&gt;GET &amp;ndash; 返回存储在 key 的旧字符串，如果 key 不存在，则返回 nil。如果存储在 key 上的 value 不是字符串，将返回一个错误，并中止 SET。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;SETEX key seconds value&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置一个 key 的 value 和过期时间&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SETNX key value&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置一个 key 的 value ，只在该 key 不存在的情况下使用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SETRANGE key 的偏移 value&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从指定的偏移量开始，覆盖 key 上的部分字符串&lt;/p&gt;
&lt;p&gt;&lt;code&gt;STRALGO LCS algo-specific-argument [algo-specific-argument ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;针对字符串运行算法（目前是 LCS）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;STRLEN key&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取存储在 key 中的 value 的长度&lt;/p&gt;
&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;
&lt;p&gt;sds 的定义在 &lt;code&gt;src/sds.h&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sds&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从定义上看 sds 等价于字符数组，实际上还有一部分头信息在 s[0]地址的前面。因此完整的 sds 定义由 sdshdr 头信息和一个字符数组 buf 前后两部分组成，其中 sds 的地址就是 buf 的地址。&lt;/p&gt;
&lt;p&gt;根据字符长长度不同，Redis 提供了五种头信息，以节省内存。头信息定义如下，里面包含了数组长度，已使用长度和一个标记位，其中的 &lt;code&gt;__attribute__ ((__packed__))&lt;/code&gt; 是告诉编译器取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐，是 GCC 提供的语法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* Note: sdshdr5 is never used, we just access the flags byte directly.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * However is here to document the layout of type 5 SDS strings. */&lt;/span&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;__attribute__&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;__packed__&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdshdr5&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* 3 lsb of type, and 5 msb of string length */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;buf&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[];&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;};&lt;/span&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;__attribute__&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;__packed__&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdshdr8&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;uint8_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* used */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;uint8_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;alloc&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;buf&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[];&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;};&lt;/span&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;__attribute__&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;__packed__&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdshdr16&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;uint16_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* used */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;uint16_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;alloc&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;buf&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[];&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;};&lt;/span&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;__attribute__&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;__packed__&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdshdr32&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;uint32_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* used */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;uint32_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;alloc&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;buf&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[];&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;};&lt;/span&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;__attribute__&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;__packed__&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdshdr64&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;uint64_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* used */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;uint64_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;alloc&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;buf&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[];&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;};&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;关键函数&#34;&gt;关键函数&lt;/h2&gt;
&lt;h2 id=&#34;创建字符串&#34;&gt;创建字符串&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;color:#111&#34;&gt;sds&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;_sdsnewlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;init&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;size_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;trymalloc&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 声明 sdshdr
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 声明 sds
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;sds&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 根据字符数组长度判断头类型
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdsReqType&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 空字符串通常会在创建后追加，使用 sdshdr8 是更好的选择，sdshdr5 已经弃用
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;SDS_TYPE_5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;SDS_TYPE_8&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 获取 sdshdr 的内存占用大小
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;hdrlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdsHdrSize&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 声明 flags 指针
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;fp&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* flags pointer. */&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 未使用量
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;size_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 断言信息头的大小至少大于等于 0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;assert&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;hdrlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* Catch size_t overflow */&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 根据参数尝试决定是否分配内容
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;trymalloc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;
         &lt;span style=&#34;color:#111&#34;&gt;s_trymalloc_usable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;hdrlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
         &lt;span style=&#34;color:#111&#34;&gt;s_malloc_usable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;hdrlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 分配失败返回 NULL
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;NULL&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;NULL&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 如果没有分配过，整个 sds 包括头全部初始化成 0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;init&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;SDS_NOINIT&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;init&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;NULL&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;init&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;memset&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;hdrlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// flags 指针在 s 起始地址的前一位
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;fp&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 计算使用量
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;hdrlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdsTypeMaxSize&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;))&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdsTypeMaxSize&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 根据，初始化 sdshdr 结构体
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;switch&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;SDS_TYPE_5&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;fp&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;SDS_TYPE_BITS&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;SDS_TYPE_8&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;SDS_HDR_VAR&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;alloc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;fp&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;SDS_TYPE_16&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;SDS_HDR_VAR&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;alloc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;fp&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;SDS_TYPE_32&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;SDS_HDR_VAR&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;alloc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;fp&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;SDS_TYPE_64&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;SDS_HDR_VAR&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;alloc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;fp&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#00a8c8&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 将 init 的内容复制到 s 上
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;init&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;memcpy&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;init&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 末尾置为0，表示结束
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;initlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;字符串拼接&#34;&gt;字符串拼接&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#111&#34;&gt;sds&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;sdscatlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sds&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;t&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;size_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;//获得当前长度
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;size_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;curlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdslen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;//按照字符t的长度扩容
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdsMakeRoomFor&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;NULL&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;NULL&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;//拷贝t到s的后面
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;memcpy&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;curlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;t&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;//重新设置s的长度
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;sdssetlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;curlen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 末尾置为0，表示结束
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;curlen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#111&#34;&gt;sds&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;sdsMakeRoomFor&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sds&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;size_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;addlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 声明 shshdr 和新的 sdshdr
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;newsh&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;size_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;avail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdsavail&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;size_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;newlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;oldtype&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;SDS_TYPE_MASK&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;hdrlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;size_t&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;/* Return ASAP if there is enough space left. */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;avail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;addlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdslen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sdsHdrSize&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;oldtype&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;newlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;addlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;assert&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;newlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;/* Catch size_t overflow */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;newlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;SDS_MAX_PREALLOC&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;newlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;else&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;newlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;SDS_MAX_PREALLOC&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdsReqType&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;newlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;/* Don&amp;#39;t use type 5: the user is appending to the string and type 5 is
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * not able to remember empty space, so sdsMakeRoomFor() must be called
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * at every appending operation. */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;SDS_TYPE_5&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;SDS_TYPE_8&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;hdrlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdsHdrSize&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;assert&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;hdrlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;newlen&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;/* Catch size_t overflow */&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;oldtype&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;newsh&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s_realloc_usable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;hdrlen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;newlen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;newsh&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;NULL&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;NULL&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;newsh&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;hdrlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;/* Since the header size changes, need to move the string forward,
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;         * and can&amp;#39;t use realloc */&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;newsh&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s_malloc_usable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;hdrlen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;newlen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;newsh&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;NULL&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;NULL&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;memcpy&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;newsh&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;hdrlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;s_free&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sh&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;newsh&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;hdrlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;sdssetlen&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;hdrlen&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdsTypeMaxSize&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;))&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sdsTypeMaxSize&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;sdssetalloc&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;usable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Kafka::基础</title>
      <link>/notes/kafka_basic/</link>
      <pubDate>Wed, 11 Aug 2021 03:52:05 +0800</pubDate>
      <guid>/notes/kafka_basic/</guid>
      <description>&lt;h2 id=&#34;入门&#34;&gt;入门&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;定义
&lt;ul&gt;
&lt;li&gt;Apache Kafka 是一款开源的消息引擎系统。根据维基百科的定义，消息引擎系统是一组规范。企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特点
&lt;ul&gt;
&lt;li&gt;消息引擎传输的对象是消息&lt;/li&gt;
&lt;li&gt;传输消息属于消息引擎设计机制的一部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消息编码格式
&lt;ul&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;XML&lt;/li&gt;
&lt;li&gt;JSON&lt;/li&gt;
&lt;li&gt;Google 的 Protocol Buffer&lt;/li&gt;
&lt;li&gt;Facebook 的 Thrift&lt;/li&gt;
&lt;li&gt;结构化的二进制字节序列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消息传输协议
&lt;ul&gt;
&lt;li&gt;点对点模型&lt;/li&gt;
&lt;li&gt;发布/订阅模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;功能
&lt;ul&gt;
&lt;li&gt;削峰填谷：缓冲上下游瞬时突发流量，使其更平滑过度给下游&lt;/li&gt;
&lt;li&gt;发送方和接收方的松耦合：简化应用开发，减少了系统不必要的交互&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;术语
&lt;ul&gt;
&lt;li&gt;消息：Record。Kafka 是消息引擎嘛，这里的消息就是指 Kafka 处理的主要对象。&lt;/li&gt;
&lt;li&gt;主题：Topic。主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。&lt;/li&gt;
&lt;li&gt;分区：Partition。一个有序不变的消息序列。每个主题下可以有多个分区。&lt;/li&gt;
&lt;li&gt;消息位移：Offset。表示分区中每条消息的位置信息，是一个单调递增且不变的值。&lt;/li&gt;
&lt;li&gt;副本：Replica。Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。&lt;/li&gt;
&lt;li&gt;生产者：Producer。向主题发布新消息的应用程序。&lt;/li&gt;
&lt;li&gt;消费者：Consumer。从主题订阅新消息的应用程序。&lt;/li&gt;
&lt;li&gt;消费者位移：Consumer Offset。表征消费者消费进度，每个消费者都有自己的消费者位移。&lt;/li&gt;
&lt;li&gt;消费者组：Consumer Group。多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。&lt;/li&gt;
&lt;li&gt;重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分布式流处理平台
&lt;ul&gt;
&lt;li&gt;研发背景
&lt;ul&gt;
&lt;li&gt;数据正确性不足，Polling 导致数据偏差&lt;/li&gt;
&lt;li&gt;系统高度定制化，维护成本高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特性
&lt;ul&gt;
&lt;li&gt;提供一套 API 实现生产者和消费者&lt;/li&gt;
&lt;li&gt;降低网络传输和磁盘存储开销&lt;/li&gt;
&lt;li&gt;实现高伸缩性架构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优势
&lt;ul&gt;
&lt;li&gt;更容易实现端到端的正确性，Kafka 可以实现端到端的精确一次处理语义&lt;/li&gt;
&lt;li&gt;更开放的流式计算定位，Kafka Streams 是一个用于搭建实时流处理的客户端库而非是一个完整的功能系统&lt;/li&gt;
&lt;li&gt;用作分布式存储&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;版本选择
&lt;ul&gt;
&lt;li&gt;Apache Kafka，也称社区版 Kafka。优势在于迭代速度快，社区响应度高，使用它可以让你有更高的把控度；缺陷在于仅提供基础核心组件，缺失一些高级的特性。&lt;/li&gt;
&lt;li&gt;Confluent Kafka，Confluent 公司提供的 Kafka。优势在于集成了很多高级特性且由 Kafka 原班人马打造，质量上有保证；缺陷在于相关文档资料不全，普及率较低，没有太多可供参考的范例。&lt;/li&gt;
&lt;li&gt;CDH/HDP Kafka，大数据云公司提供的 Kafka，内嵌 Apache Kafka。优势在于操作简单，节省运维成本；缺陷在于把控度低，演进速度较慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基本使用&#34;&gt;基本使用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;部署环境
&lt;ul&gt;
&lt;li&gt;操作系统
&lt;ul&gt;
&lt;li&gt;Linux：高效的 I/O 性能、Linux 实现了零拷贝的数据传输、Kafka 更重视 Linux 社区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;磁盘
&lt;ul&gt;
&lt;li&gt;追求性价比的公司可以不搭建 RAID，使用普通磁盘组成存储空间即可&lt;/li&gt;
&lt;li&gt;使用机械磁盘完全能够胜任 Kafka 线上环境&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;磁盘容量
&lt;ul&gt;
&lt;li&gt;新增消息数&lt;/li&gt;
&lt;li&gt;消息留存时间&lt;/li&gt;
&lt;li&gt;平均消息大小&lt;/li&gt;
&lt;li&gt;备份数&lt;/li&gt;
&lt;li&gt;是否启用压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;带宽
&lt;ul&gt;
&lt;li&gt;预留三分一空闲带宽&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重要的配置
&lt;ul&gt;
&lt;li&gt;Broker 端参数
&lt;ul&gt;
&lt;li&gt;log.dirs: Broker 需要使用的若干个文件目录路径，逗号分隔的多个路径&lt;/li&gt;
&lt;li&gt;log.dir: 表示单个路径，它是补充上一个参数用的&lt;/li&gt;
&lt;li&gt;zookeeper.connect: 负责协调管理并保存 Kafka 集群的所有元数据信息，逗号分隔，chroot 只写一次，添加到最后&lt;/li&gt;
&lt;li&gt;listeners：学名叫监听器，其实就是告诉外部连接者要通过什么协议访问指定主机名和端口开放的 Kafka 服务。&lt;/li&gt;
&lt;li&gt;advertised.listeners：和 listeners 相比多了个 advertised。Advertised 的含义表示宣称的、公布的，就是说这组监听器是 Broker 用于对外发布的。&lt;/li&gt;
&lt;li&gt;listener.security.protocol.map：自定义协议声明&lt;/li&gt;
&lt;li&gt;auto.create.topics.enable：是否允许自动创建 Topic。&lt;/li&gt;
&lt;li&gt;unclean.leader.election.enable：是否允许 Unclean Leader 选举。&lt;/li&gt;
&lt;li&gt;auto.leader.rebalance.enable：是否允许定期进行 Leader 选举。&lt;/li&gt;
&lt;li&gt;log.retention.{hour|minutes|ms}：控制一条消息数据被保存多长时间。从优先级上来说 ms 设置最高、minutes 次之、hour 最低。&lt;/li&gt;
&lt;li&gt;log.retention.bytes：这是指定 Broker 为消息保存的总磁盘容量大小，-1 表示不限制。&lt;/li&gt;
&lt;li&gt;message.max.bytes：控制 Broker 能够接收的最大消息大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Topic 端参数
&lt;ul&gt;
&lt;li&gt;retention.ms：规定了该 Topic 消息被保存的时长&lt;/li&gt;
&lt;li&gt;retention.bytes：规定了要为该 Topic 预留多大的磁盘空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JVM 参数
&lt;ul&gt;
&lt;li&gt;-XX:+UseParallelGC：启用 CMS 收集器&lt;/li&gt;
&lt;li&gt;KAFKA_HEAP_OPTS：指定堆大小。&lt;/li&gt;
&lt;li&gt;KAFKA_JVM_PERFORMANCE_OPTS：指定 GC 参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统参数
&lt;ul&gt;
&lt;li&gt;文件描述符限制：ulimit -n，每次连接会打开一个文件，可以设置大一点&lt;/li&gt;
&lt;li&gt;文件系统选择：XFS 性能强于 ext3、ext4&lt;/li&gt;
&lt;li&gt;SWAP：预留一些以免耗尽内存触发系统 OOM killer&lt;/li&gt;
&lt;li&gt;调整 Flush 落盘时间：已经有了副本冗余，可以延长一点，换取性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实践与原理&#34;&gt;实践与原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;生产者消息分区原理
&lt;ul&gt;
&lt;li&gt;主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份。&lt;/li&gt;
&lt;li&gt;分区的作用就是提供负载均衡的能力，实现系统的高伸缩性&lt;/li&gt;
&lt;li&gt;分区策略
&lt;ul&gt;
&lt;li&gt;轮询策略：轮询策略有非常优秀的负载均衡表现，它总是能保证消息最大限度地被平均分配到所有分区上，故默认情况下它是最合理的分区策略&lt;/li&gt;
&lt;li&gt;随机策略：从实际表现来看，它要逊于轮询策略，所以如果追求数据的均匀分布，还是使用轮询策略比较好&lt;/li&gt;
&lt;li&gt;Key-ordering 策略：Kafka 允许为每条消息定义消息键，简称为 Key。这个 Key 的作用非常大，它可以是一个有着明确业务含义的字符串，比如客户代码、部门编号或是业务 ID 等；也可以用来表征消息元数据。特别是在 Kafka 不支持时间戳的年代，在一些场景中，工程师们都是直接将消息创建时间封装进 Key 里面的。一旦消息被定义了 Key，那么你就可以保证同一个 Key 的所有消息都进入到相同的分区里面，由于每个分区下的消息处理都是有顺序的，故这个策略被称为 Key-Ordering 保序策略&lt;/li&gt;
&lt;li&gt;其他分区策略：基于地理位置的分区等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生产者压缩算法
&lt;ul&gt;
&lt;li&gt;V2 版本的 Kafka 提取了消息中的公共部分到外面消息集合里，对整个消息集合进行压缩，V1 版本压缩消息队列后再放入消息集合中，获得了更好的压缩效果。&lt;/li&gt;
&lt;li&gt;何时压缩
&lt;ul&gt;
&lt;li&gt;在生产端和 Broker 端都可以压缩，一般在生产端压缩&lt;/li&gt;
&lt;li&gt;Broker 端压缩的场景：
&lt;ul&gt;
&lt;li&gt;Broker 端指定了和 Producer 端不同的压缩算法&lt;/li&gt;
&lt;li&gt;Broker 端发生了消息格式转换：出于兼容不同版本消费者程序，丧失了零拷贝抽象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;何时解压缩
&lt;ul&gt;
&lt;li&gt;在 Consumer 和 Broker 都可以解压缩，每个压缩过的消息集合在 Broker 端写入时都要发生解压缩操作，目的就是为了对消息执行各种验证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;压缩算法
&lt;ul&gt;
&lt;li&gt;根据压缩比和压缩/解压吞吐量来选择压缩算法&lt;/li&gt;
&lt;li&gt;如果 Producer 端服务器 CPU 资源充足，可以在 Producer 端开启压缩&lt;/li&gt;
&lt;li&gt;尽量避免解压缩操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无消息丢失配置
&lt;ul&gt;
&lt;li&gt;Kafka 只对“已提交”的消息（committed message）做有限度的持久化保证。
&lt;ul&gt;
&lt;li&gt;当 Kafka 的若干个 Broker 成功地接收到一条消息并写入到日志文件后，它们会告诉生产者程序这条消息已成功提交。此时，这条消息在 Kafka 看来就正式变为“已提交”消息了。&lt;/li&gt;
&lt;li&gt;消息保存在 N 个 Kafka Broker 上，那么这个前提条件就是这 N 个 Broker 中至少有 1 个存活。只要这个条件成立，Kafka 就能保证你的这条消息永远不会丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消息丢失的场景
&lt;ul&gt;
&lt;li&gt;异步发送消息：丢包，队列阻塞，Broker 因为格式错误不接受，改正方法采用 callback&lt;/li&gt;
&lt;li&gt;消费者丢失数据：先更新位移再消费，中间中断了消费，重新消费时从位移点开始，丢失了一部分数据。维持先消费消息（阅读），再更新位移（书签）的顺序即可。这样就能最大限度地保证消息不丢失。&lt;/li&gt;
&lt;li&gt;多线程消费更新位移丢失消息。如果是多线程异步处理消费消息，Consumer 程序不要开启自动提交位移，而是要应用程序手动提交位移。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最佳实践
&lt;ul&gt;
&lt;li&gt;不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。&lt;/li&gt;
&lt;li&gt;设置 acks = all。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。&lt;/li&gt;
&lt;li&gt;设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &amp;gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。&lt;/li&gt;
&lt;li&gt;设置 unclean.leader.election.enable = false。这是 Broker 端的参数，它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。&lt;/li&gt;
&lt;li&gt;设置 replication.factor &amp;gt;= 3。这也是 Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。&lt;/li&gt;
&lt;li&gt;设置 min.insync.replicas &amp;gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。&lt;/li&gt;
&lt;li&gt;确保 replication.factor &amp;gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。&lt;/li&gt;
&lt;li&gt;确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Kafka 拦截器
&lt;ul&gt;
&lt;li&gt;可以在消息处理的前后多个时点动态植入不同的处理逻辑，比如在消息发送前或者在消息被消费后。&lt;/li&gt;
&lt;li&gt;Kafka 拦截器分为生产者拦截器和消费者拦截器。生产者拦截器允许你在发送消息前以及消息提交成功后植入你的拦截器逻辑；而消费者拦截器支持在消费消息前以及提交位移后编写特定逻辑。&lt;/li&gt;
&lt;li&gt;生产者拦截器继承&lt;code&gt;org.apache.kafka.clients.producer.ProducerInterceptor&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;onSend&lt;/code&gt;：该方法会在消息发送之前被调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onAcknowledgement&lt;/code&gt;：该方法会在消息成功提交或发送失败之后被调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消费者拦截器继承&lt;code&gt;org.apache.kafka.clients.consumer.ConsumerInterceptor&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;onConsume&lt;/code&gt; ：该方法在消息返回给 Consumer 程序之前调用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onCommit&lt;/code&gt;：Consumer 在提交位移之后调用该方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;场景
&lt;ul&gt;
&lt;li&gt;客户端监控&lt;/li&gt;
&lt;li&gt;端到端系统性能检测&lt;/li&gt;
&lt;li&gt;消息审计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生产者 TCP 连接管理
&lt;ul&gt;
&lt;li&gt;KafkaProducer 实例创建时启动 Sender 线程，从而创建与 bootstrap.servers 中所有 Broker 的 TCP 连接。&lt;/li&gt;
&lt;li&gt;KafkaProducer 实例首次更新元数据信息之后，还会再次创建与集群中所有 Broker 的 TCP 连接。&lt;/li&gt;
&lt;li&gt;如果 Producer 端发送消息到某台 Broker 时发现没有与该 Broker 的 TCP 连接，那么也会立即创建连接。&lt;/li&gt;
&lt;li&gt;如果设置 Producer 端 connections.max.idle.ms 参数大于 0，则步骤 1 中创建的 TCP 连接会被自动关闭；如果设置该参数 =-1，那么步骤 1 中创建的 TCP 连接将无法被关闭，从而成为“僵尸”连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可靠性保障
&lt;ul&gt;
&lt;li&gt;处理消息常见承诺
&lt;ul&gt;
&lt;li&gt;最多一次（at most once）：消息可能会丢失，但绝不会被重复发送。&lt;/li&gt;
&lt;li&gt;至少一次（at least once）：消息不会丢失，但有可能被重复发送。&lt;/li&gt;
&lt;li&gt;精确一次（exactly once）：消息不会丢失，也不会被重复发送。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;幂等 Producer:enable.idempotence 被设置成 true 后，Producer 自动升级成幂等性 Producer，其他所有的代码逻辑都不需要改变。Kafka 自动帮你做消息的重复去重。底层具体的原理很简单，就是经典的用空间去换时间的优化思路，即在 Broker 端多保存一些字段。当 Producer 发送了具有相同字段值的消息后，Broker 能够自动知晓这些消息已经重复了，于是可以在后台默默地把它们“丢弃”掉。&lt;/li&gt;
&lt;li&gt;事务 Producer：和普通 Producer 代码相比，事务型 Producer 的显著特点是调用了一些事务 API，如 initTransaction、beginTransaction、commitTransaction 和 abortTransaction，它们分别对应事务的初始化、事务开始、事务提交以及事务终止。在 Consumer 端设置事务级别 read_committed，它只处理事务型 Producer 写入的消息。&lt;/li&gt;
&lt;li&gt;幂等性 Producer 只能保证单分区、单会话上的消息幂等性；而事务能够保证跨分区、跨会话间的幂等性。从交付语义上来看，自然是事务型 Producer 能做的更多，但是性能更差。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消费者组
&lt;ul&gt;
&lt;li&gt;Consumer Group 是 Kafka 提供的可扩展且具有容错性的消费者机制&lt;/li&gt;
&lt;li&gt;Consumer Group 下可以有一个或多个 Consumer 实例。这里的实例可以是一个单独的进程，也可以是同一进程下的线程。在实际场景中，使用进程更为常见一些。&lt;/li&gt;
&lt;li&gt;Group ID 是一个字符串，在一个 Kafka 集群中，它标识唯一的一个 Consumer Group。&lt;/li&gt;
&lt;li&gt;Consumer Group 下所有实例订阅的主题的单个分区，只能分配给组内的某个 Consumer 实例消费。这个分区当然也可以被其他的 Group 消费。&lt;/li&gt;
&lt;li&gt;理想情况下，Consumer 实例的数量应该等于该 Group 订阅主题的分区总数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;位移主题
&lt;ul&gt;
&lt;li&gt;新版本 Consumer 的位移管理机制将 Consumer 的位移数据作为一条条普通的 Kafka 消息，提交到 __consumer_offsets 中。可以这么说，__consumer_offsets 的主要作用是保存 Kafka 消费者的位移信息。&lt;/li&gt;
&lt;li&gt;位移主题的消息格式却是 Kafka 自己定义的&lt;/li&gt;
&lt;li&gt;位移主题的 Key 中应该保存 3 部分内容：&amp;lt;Group ID，主题名，分区号&amp;gt;&lt;/li&gt;
&lt;li&gt;当 Kafka 集群中的第一个 Consumer 程序启动时，Kafka 会自动创建位移主题。&lt;/li&gt;
&lt;li&gt;如果位移主题是 Kafka 自动创建的，那么该主题的分区数是 50，副本数是 3。&lt;/li&gt;
&lt;li&gt;Consumer 提交位移的方式有两种：自动提交位移和手动提交位移。&lt;/li&gt;
&lt;li&gt;Kafka 使用 Compact 策略来删除位移主题中的过期消息，避免该主题无限期膨胀。&lt;/li&gt;
&lt;li&gt;Kafka 提供了专门的后台线程定期地巡检待 Compact 的主题，看看是否存在满足条件的可删除数据。这个后台线程叫 Log Cleaner。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重平衡
&lt;ul&gt;
&lt;li&gt;Rebalance 就是让一个 Consumer Group 下所有的 Consumer 实例就如何消费订阅主题的所有分区达成共识的过程。&lt;/li&gt;
&lt;li&gt;在 Rebalance 过程中，所有 Consumer 实例共同参与，在协调者组件的帮助下，完成订阅主题分区的分配。但是，在整个过程中，所有实例都不能消费任何消息，因此它对 Consumer 的 TPS 影响很大。&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;Rebalance 影响 Consumer 端 TPS。&lt;/li&gt;
&lt;li&gt;Rebalance 很慢。&lt;/li&gt;
&lt;li&gt;Rebalance 效率不高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rebalance 发生时机
&lt;ul&gt;
&lt;li&gt;组成员数量发生变化&lt;/li&gt;
&lt;li&gt;订阅主题数量发生变化&lt;/li&gt;
&lt;li&gt;订阅主题的分区数发生变化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;避免 Rebalance
&lt;ul&gt;
&lt;li&gt;第一类非必要 Rebalance 是因为未能及时发送心跳，导致 Consumer 被“踢出”Group 而引发的&lt;/li&gt;
&lt;li&gt;第二类非必要 Rebalance 是 Consumer 消费时间过长导致的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;位移提交
&lt;ul&gt;
&lt;li&gt;Consumer 需要向 Kafka 汇报自己的位移数据，这个汇报过程被称为提交位移&lt;/li&gt;
&lt;li&gt;Consumer 需要为分配给它的每个分区提交各自的位移数据。&lt;/li&gt;
&lt;li&gt;位移提交的语义保障是由开发者来负责的，Kafka 只会“无脑”地接受你提交的位移&lt;/li&gt;
&lt;li&gt;从用户的角度来说，位移提交分为自动提交和手动提交；从 Consumer 端的角度来说，位移提交分为同步提交和异步提交。&lt;/li&gt;
&lt;li&gt;手动提交也无法完全避免重复消费&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CommitFailedException
&lt;ul&gt;
&lt;li&gt;所谓 CommitFailedException，顾名思义就是 Consumer 客户端在提交位移时出现了错误或异常，而且还是那种不可恢复的严重异常&lt;/li&gt;
&lt;li&gt;优化方法
&lt;ul&gt;
&lt;li&gt;缩短单条消息处理的时间&lt;/li&gt;
&lt;li&gt;增加 Consumer 端允许下游系统消费一批消息的最大时长&lt;/li&gt;
&lt;li&gt;减少下游系统一次性消费的消息总数&lt;/li&gt;
&lt;li&gt;下游系统使用多线程来加速消费&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消费者 TCP 管理
&lt;ul&gt;
&lt;li&gt;构建 KafkaConsumer 实例时是不会创建任何 TCP 连接的&lt;/li&gt;
&lt;li&gt;TCP 连接是在调用 KafkaConsumer.poll 方法时被创建的
&lt;ul&gt;
&lt;li&gt;发起 FindCoordinator 请求时&lt;/li&gt;
&lt;li&gt;连接协调者时&lt;/li&gt;
&lt;li&gt;消费数据时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3 类 TCP 连接
&lt;ul&gt;
&lt;li&gt;确定协调者和获取集群元数据。&lt;/li&gt;
&lt;li&gt;连接协调者，令其执行组成员管理操作。&lt;/li&gt;
&lt;li&gt;执行实际的消息获取。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消费进度监控
&lt;ul&gt;
&lt;li&gt;对于 Kafka 消费者来说，最重要的事情就是监控它们的消费进度了，或者说是监控它们消费的滞后程度。这个滞后程度有个专门的名称：消费者 Lag 或 Consumer Lag。&lt;/li&gt;
&lt;li&gt;在实际业务场景中必须时刻关注消费者的消费进度。一旦出现 Lag 逐步增加的趋势，一定要定位问题，及时处理，避免造成业务损失。&lt;/li&gt;
&lt;li&gt;几种监控方式
&lt;ul&gt;
&lt;li&gt;使用 Kafka 自带的命令行工具 kafka-consumer-groups 脚本。&lt;/li&gt;
&lt;li&gt;使用 Kafka Java Consumer API 编程。&lt;/li&gt;
&lt;li&gt;使用 Kafka 自带的 JMX 监控指标。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kafka-内核&#34;&gt;Kafka 内核&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;副本机制
&lt;ul&gt;
&lt;li&gt;好处
&lt;ul&gt;
&lt;li&gt;提供数据冗余。即使系统部分组件失效，系统依然能够继续运转，因而增加了整体可用性以及数据持久性。&lt;/li&gt;
&lt;li&gt;提供高伸缩性。支持横向扩展，能够通过增加机器的方式来提升读性能，进而提高读操作吞吐量。&lt;/li&gt;
&lt;li&gt;改善数据局部性。允许将数据放入与用户地理位置相近的地方，从而降低系统延时。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定义
&lt;ul&gt;
&lt;li&gt;所谓副本（Replica），本质就是一个只能追加写消息的提交日志&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据一致性
&lt;ul&gt;
&lt;li&gt;在 Kafka 中，副本分成两类：领导者副本（Leader Replica）和追随者副本（Follower Replica）。每个分区在创建时都要选举一个副本，称为领导者副本，其余的副本自动称为追随者副本。&lt;/li&gt;
&lt;li&gt;追随者副本是不对外提供服务，它唯一的任务就是从领导者副本异步拉取消息，并写入到自己的提交日志中，从而实现与领导者副本的同步。&lt;/li&gt;
&lt;li&gt;当领导者副本挂掉了，或者说领导者副本所在的 Broker 宕机时，Kafka 依托于 ZooKeeper 提供的监控功能能够实时感知到，并立即开启新一轮的领导者选举，从追随者副本中选一个作为新的领导者。老 Leader 副本重启回来后，只能作为追随者副本加入到集群中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In-sync Replicas（ISR）
&lt;ul&gt;
&lt;li&gt;ISR 副本集合。ISR 中的副本都是与 Leader 同步的副本，相反，不在 ISR 中的追随者副本就被认为是与 Leader 不同步的&lt;/li&gt;
&lt;li&gt;Leader 副本天然就在 ISR 中。也就是说，ISR 不只是追随者副本集合，它必然包括 Leader 副本。甚至在某些情况下，ISR 只有 Leader 这一个副本。&lt;/li&gt;
&lt;li&gt;允许 Follower 副本在一段时间内落后 Leader 副本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Unclean 领导者选举
&lt;ul&gt;
&lt;li&gt;Kafka 把所有不在 ISR 中的存活副本都称为非同步副本。通常来说，非同步副本落后 Leader 太多，因此，如果选择这些副本作为新 Leader，就可能出现数据的丢失。毕竟，这些副本中保存的消息远远落后于老 Leader 中的消息。在 Kafka 中，选举这种副本的过程称为 Unclean 领导者选举。Broker 端参数 unclean.leader.election.enable 控制是否允许 Unclean 领导者选举。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;请求处理
&lt;ul&gt;
&lt;li&gt;所有的请求都是通过 TCP 网络以 Socket 的方式进行通讯的。&lt;/li&gt;
&lt;li&gt;Reactor 模式
&lt;ul&gt;
&lt;li&gt;Reactor 模式是事件驱动架构的一种实现方式，特别适合应用于处理多个客户端并发向服务器端发送请求的场景&lt;/li&gt;
&lt;li&gt;Acceptor，它会将不同的请求下发到多个工作线程中处理。只是用于请求分发，不涉及具体的逻辑处理，非常得轻量级，因此有很高的吞吐量表现。而这些工作线程可以根据实际业务处理需要任意增减，从而动态调节系统负载能力。&lt;/li&gt;
&lt;li&gt;网络线程池：专门处理客户端发送的请求。Acceptor 线程采用轮询的方式将入站请求公平地发到所有网络线程中，因此，在实际使用过程中，这些线程通常都有相同的几率被分配到待处理请求。&lt;/li&gt;
&lt;li&gt;IO 线程池：当网络线程拿到请求后，它不是自己处理，而是将请求放入到一个共享请求队列中。Broker 端还有个 IO 线程池，负责从该队列中取出请求，执行真正的处理。如果是 PRODUCE 生产请求，则将消息写入到底层的磁盘日志中；如果是 FETCH 请求，则从磁盘或页缓存中读取消息。&lt;/li&gt;
&lt;li&gt;Purgatory 的组件：缓存一时未满足条件不能立刻处理的请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消费者重平衡流程
&lt;ul&gt;
&lt;li&gt;触发与通知
&lt;ul&gt;
&lt;li&gt;组成员数量发生变化。&lt;/li&gt;
&lt;li&gt;订阅主题数量发生变化。&lt;/li&gt;
&lt;li&gt;订阅主题的分区数发生变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重平衡的通知机制正是通过心跳线程来完成的。当协调者决定开启新一轮重平衡后，它会将“REBALANCE_IN_PROGRESS”封装进心跳请求的响应中，发还给消费者实例。当消费者实例发现心跳响应中包含了“REBALANCE_IN_PROGRESS”，就能立马知道重平衡又开始了，这就是重平衡的通知机制。&lt;/li&gt;
&lt;li&gt;重平衡一旦开启，Broker 端的协调者组件就要开始忙了，主要涉及到控制消费者组的状态流转。当前，Kafka 设计了一套消费者组状态机（State Machine），来帮助协调者完成整个重平衡流程。&lt;/li&gt;
&lt;li&gt;Kafka 为消费者组定义了 5 种状态，它们分别是：Empty、Dead、PreparingRebalance、CompletingRebalance 和 Stable。
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/olufDkY.png&#34; alt=&#34;img&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;状态机
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://i.imgur.com/WCfD5sp.png&#34; alt=&#34;img&#34;&gt;&lt;/li&gt;
&lt;li&gt;一个消费者组最开始是 Empty 状态，当重平衡过程开启后，它会被置于 PreparingRebalance 状态等待成员加入，之后变更到 CompletingRebalance 状态等待分配方案，最后流转到 Stable 状态完成重平衡。&lt;/li&gt;
&lt;li&gt;当有新成员加入或已有成员退出时，消费者组的状态从 Stable 直接跳到 PreparingRebalance 状态，此时，所有现存成员就必须重新申请加入组。当所有成员都退出组后，消费者组状态变更为 Empty。Kafka 定期自动删除过期位移的条件就是，组要处于 Empty 状态。因此，如果你的消费者组停掉了很长时间（超过 7 天），那么 Kafka 很可能就把该组的位移数据删除了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消费者端重平衡流程
&lt;ul&gt;
&lt;li&gt;在消费者端，重平衡分为两个步骤：分别是加入组和等待领导者消费者（Leader Consumer）分配方案。这两个步骤分别对应两类特定的请求：JoinGroup 请求和 SyncGroup 请求。
&lt;ul&gt;
&lt;li&gt;当组内成员加入组时，它会向协调者发送 JoinGroup 请求。在该请求中，每个成员都要将自己订阅的主题上报，这样协调者就能收集到所有成员的订阅信息。一旦收集了全部成员的 JoinGroup 请求后，协调者会从这些成员中选择一个担任这个消费者组的领导者。通常情况下，第一个发送 JoinGroup 请求的成员自动成为领导者。你一定要注意区分这里的领导者和之前我们介绍的领导者副本，它们不是一个概念。这里的领导者是具体的消费者实例，它既不是副本，也不是协调者。领导者消费者的任务是收集所有成员的订阅信息，然后根据这些信息，制定具体的分区消费分配方案。&lt;/li&gt;
&lt;li&gt;选出领导者之后，协调者会把消费者组订阅信息封装进 JoinGroup 请求的响应体中，然后发给领导者，由领导者统一做出分配方案后，进入到下一步：发送 SyncGroup 请求。在这一步中，领导者向协调者发送 SyncGroup 请求，将刚刚做出的分配方案发给协调者。值得注意的是，其他成员也会向协调者发送 SyncGroup 请求，只不过请求体中并没有实际的内容。这一步的主要目的是让协调者接收分配方案，然后统一以 SyncGroup 响应的方式分发给所有成员，这样组内所有成员就都知道自己该消费哪些分区了。&lt;/li&gt;
&lt;li&gt;JoinGroup 请求的主要作用是将组成员订阅信息发送给领导者消费者，待领导者制定好分配方案后，重平衡流程进入到 SyncGroup 请求阶段。&lt;/li&gt;
&lt;li&gt;SyncGroup 请求的主要目的，就是让协调者把领导者制定的分配方案下发给各个组内成员。当所有成员都成功接收到分配方案后，消费者组进入到 Stable 状态，即开始正常的消费工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Broker 端重平衡场景
&lt;ul&gt;
&lt;li&gt;新成员入组
&lt;ul&gt;
&lt;li&gt;新成员入组是指组处于 Stable 状态后，有新成员加入。如果是全新启动一个消费者组，Kafka 是有一些自己的小优化的，流程上会有些许的不同。我们这里讨论的是，组稳定了之后有新成员加入的情形。当协调者收到新的 JoinGroup 请求后，它会通过心跳请求响应的方式通知组内现有的所有成员，强制它们开启新一轮的重平衡。具体的过程和之前的客户端重平衡流程是一样的。现在，我用一张时序图来说明协调者一端是如何处理新成员入组的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;组成员主动离组。
&lt;ul&gt;
&lt;li&gt;何谓主动离组？就是指消费者实例所在线程或进程调用 close() 方法主动通知协调者它要退出。这个场景就涉及到了第三类请求：LeaveGroup 请求。协调者收到 LeaveGroup 请求后，依然会以心跳响应的方式通知其他成员&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;组成员崩溃离组。
&lt;ul&gt;
&lt;li&gt;崩溃离组是指消费者实例出现严重故障，突然宕机导致的离组。它和主动离组是有区别的，因为后者是主动发起的离组，协调者能马上感知并处理。但崩溃离组是被动的，协调者通常需要等待一段时间才能感知到，这段时间一般是由消费者端参数 session.timeout.ms 控制的。也就是说，Kafka 一般不会超过 session.timeout.ms 就能感知到这个崩溃。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;场景四：重平衡时协调者对组内成员提交位移的处理。
&lt;ul&gt;
&lt;li&gt;正常情况下，每个组内成员都会定期汇报位移给协调者。当重平衡开启时，协调者会给予成员一段缓冲时间，要求每个成员必须在这段时间内快速地上报自己的位移信息，然后再开启正常的 JoinGroup/SyncGroup 请求发送。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Kafka 控制器
&lt;ul&gt;
&lt;li&gt;控制器组件（Controller），是 Apache Kafka 的核心组件。它的主要作用是在 Apache ZooKeeper 的帮助下管理和协调整个 Kafka 集群。&lt;/li&gt;
&lt;li&gt;在运行过程中，只能有一个 Broker 成为控制器，行使其管理和协调的职责。换句话说，每个正常运转的 Kafka 集群，在任意时刻都有且只有一个控制器。&lt;/li&gt;
&lt;li&gt;控制器是重度依赖 ZooKeeper 的，ZooKeeper 常被用来实现集群成员管理、分布式锁、领导者选举等功能&lt;/li&gt;
&lt;li&gt;Kafka 当前选举控制器的规则是：第一个成功创建 /controller 节点的 Broker 会被指定为控制器。&lt;/li&gt;
&lt;li&gt;控制器职责
&lt;ul&gt;
&lt;li&gt;主题管理（创建、删除、增加分区）
&lt;ul&gt;
&lt;li&gt;这里的主题管理，就是指控制器帮助我们完成对 Kafka 主题的创建、删除以及分区增加的操作。换句话说，当我们执行 kafka-topics 脚本时，大部分的后台工作都是控制器来完成的。关于 kafka-topics 脚本，我会在专栏后面的内容中，详细介绍它的使用方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2.分区重分配
&lt;ul&gt;
&lt;li&gt;分区重分配主要是指，kafka-reassign-partitions 脚本（关于这个脚本，后面我也会介绍）提供的对已有主题分区进行细粒度的分配功能。这部分功能也是控制器实现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3.Preferred 领导者选举
&lt;ul&gt;
&lt;li&gt;Preferred 领导者选举主要是 Kafka 为了避免部分 Broker 负载过重而提供的一种换 Leader 的方案。在专栏后面说到工具的时候，我们再详谈 Preferred 领导者选举，这里你只需要了解这也是控制器的职责范围就可以了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;4.集群成员管理（新增 Broker、Broker 主动关闭、Broker 宕机）
&lt;ul&gt;
&lt;li&gt;这是控制器提供的第 4 类功能，包括自动检测新增 Broker、Broker 主动关闭及被动宕机。这种自动检测是依赖于前面提到的 Watch 功能和 ZooKeeper 临时节点组合实现的。 比如，控制器组件会利用 Watch 机制检查 ZooKeeper 的 /brokers/ids 节点下的子节点数量变更。目前，当有新 Broker 启动后，它会在 /brokers 下创建专属的 znode 节点。一旦创建完毕，ZooKeeper 会通过 Watch 机制将消息通知推送给控制器，这样，控制器就能自动地感知到这个变化，进而开启后续的新增 Broker 作业。 侦测 Broker 存活性则是依赖于刚刚提到的另一个机制：临时节点。每个 Broker 启动后，会在 /brokers/ids 下创建一个临时 znode。当 Broker 宕机或主动关闭后，该 Broker 与 ZooKeeper 的会话结束，这个 znode 会被自动删除。同理，ZooKeeper 的 Watch 机制将这一变更推送给控制器，这样控制器就能知道有 Broker 关闭或宕机了，从而进行“善后”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;5.数据服务
&lt;ul&gt;
&lt;li&gt;控制器的最后一大类工作，就是向其他 Broker 提供数据服务。控制器上保存了最全的集群元数据信息，其他所有 Broker 会定期接收控制器发来的元数据更新请求，从而更新其内存中的缓存数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控制器维护数据
&lt;ul&gt;
&lt;li&gt;所有主题信息。包括具体的分区信息，比如领导者副本是谁，ISR 集合中有哪些副本等。&lt;/li&gt;
&lt;li&gt;所有 Broker 信息。包括当前都有哪些运行中的 Broker，哪些正在关闭中的 Broker 等。&lt;/li&gt;
&lt;li&gt;所有涉及运维任务的分区。包括当前正在进行 Preferred 领导者选举以及分区重分配的分区列表。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控制器故障转移
&lt;ul&gt;
&lt;li&gt;故障转移指的是，当运行中的控制器突然宕机或意外终止时，Kafka 能够快速地感知到，并立即启用备用控制器来代替之前失败的控制器。&lt;/li&gt;
&lt;li&gt;最开始时，Broker 0 是控制器。当 Broker 0 宕机后，ZooKeeper 通过 Watch 机制感知到并删除了 /controller 临时节点。之后，所有存活的 Broker 开始竞选新的控制器身份。Broker 3 最终赢得了选举，成功地在 ZooKeeper 上重建了 /controller 节点。之后，Broker 3 会从 ZooKeeper 中读取集群元数据信息，并初始化到自己的缓存中。至此，控制器的 Failover 完成，可以行使正常的工作职责了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内部设计
&lt;ul&gt;
&lt;li&gt;多线程的方案改成了单线程加事件队列的方案。控制器缓存中保存的状态只被一个线程处理，因此不再需要重量级的线程同步机制来维护线程安全，Kafka 不用再担心多线程并发访问的问题，非常利于社区定位和诊断控制器的各种问题。&lt;/li&gt;
&lt;li&gt;将之前同步操作 ZooKeeper 全部改为异步操作。ZooKeeper 本身的 API 提供了同步写和异步写两种方式。之前控制器操作 ZooKeeper 使用的是同步的 API，性能很差，集中表现为，当有大量主题分区发生变更时，ZooKeeper 容易成为系统的瓶颈。新版本 Kafka 修改了这部分设计，完全摒弃了之前的同步 API 调用，转而采用异步 API 写入 ZooKeeper，性能有了很大的提升。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CMU::15-445/645::Tree Indexes 笔记</title>
      <link>/notes/cmu_15_445_06_note/</link>
      <pubDate>Thu, 05 Aug 2021 08:41:54 +0800</pubDate>
      <guid>/notes/cmu_15_445_06_note/</guid>
      <description>&lt;h2 id=&#34;树形索引第一部分&#34;&gt;树形索引第一部分&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/RK21nhh.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;表索引&#34;&gt;表索引&lt;/h3&gt;
&lt;p&gt;在数据库系统中，有许多不同的数据结构，可以用于内部元数据、核心数据存储、临时数据结构或表索引等目的。对于表索引，可能涉及到带有范围扫描的查询。&lt;/p&gt;
&lt;p&gt;表索引是一个表的列的子集的副本，它被组织和(或)排序，以使用这些属性的子集进行有效的访问。因此，DBMS 可以查询表索引的辅助数据结构，而不是进行顺序扫描，以更快地找到元组。DBMS 确保表和索引的内容在逻辑上总是同步的。&lt;/p&gt;
&lt;p&gt;在每个数据库要创建的索引数量之间存在着一个权衡。尽管更多的索引使得查询速度更快，但索引也会使用存储空间并需要维护。DBMS 的工作是找出用于执行查询的最佳索引。&lt;/p&gt;
&lt;h3 id=&#34;b树&#34;&gt;B+树&lt;/h3&gt;
&lt;p&gt;B+Tree 是一种自平衡的树形数据结构，它可以保持数据的分类，并允许在 O(log(n))中进行搜索、顺序访问、插入和删除。它为面向磁盘的 DBMS 的读/写大型数据块而优化。&lt;/p&gt;
&lt;p&gt;几乎所有支持保序索引的现代 DBMS 都使用 B+Tree。有一种特定的数据结构叫做 B-Tree，但是人们也用这个词来泛指一类数据结构。原始的 B-Tree 和 B+Tree 之间的主要区别是，B-Tree 在所有节点中存储键和值，而 B+Tree 只在叶节点中存储值。现代 B+Tree 的实现结合了其他 B-Tree 变体的特征，例如 B\(^{link}\)-Tree 中使用的兄弟姐妹指针。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/W8jH3GU.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;从形式上看，B+树是一棵具有以下特性的 M-way 搜索树。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它是完全平衡的（即，每个叶子节点都在相同的深度）。&lt;/li&gt;
&lt;li&gt;除根以外的每个内部节点至少有一半是满的（M/2 - 1 &amp;lt;= 键的数量 &amp;lt;= M - 1）。&lt;/li&gt;
&lt;li&gt;每个有 k 个键的内部节点都有 k+1 个非空子节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;B+Tree 中的每个节点都包含一个键/值对数组。这些对中的键是由索引所基于的属性派生的。这些值将根据一个节点是内部节点还是叶子节点而有所不同。对于内部节点，值数组将包含指向其他节点的指针。叶子节点值的两种方法是记录 ID 和元组数据。记录 ID 指的是一个指向元组位置的指针。有元组数据的叶子节点在每个节点中存储元组的实际内容。&lt;/p&gt;
&lt;p&gt;每个节点的数组都（几乎）是按键排序的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/gerdPnT.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;实践中节点中键和值是分开存储的&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/qa9zakg.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;插入&#34;&gt;插入&lt;/h4&gt;
&lt;p&gt;要在 B+树中插入一个新的条目，必须沿着树向下遍历，并使用内部节点来确定将值插入哪个叶子节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到正确的叶子 L。&lt;/li&gt;
&lt;li&gt;按排序顺序将新条目添加到 L 中。
&lt;ul&gt;
&lt;li&gt;如果 L 有足够的空间，操作就完成了。&lt;/li&gt;
&lt;li&gt;否则将 L 分成两个结点 L 和 L2。均匀地重新分配条目，并将中间的键复制上去。 将指向 L2 的索引条目插入 L 的父节点中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;要分割一个内部节点，均匀地重新分配条目，但要把中间的键向上推。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html&#34;&gt;可视化演示网址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;删除&#34;&gt;删除&lt;/h4&gt;
&lt;p&gt;在插入过程中，当树变得太满时，我们偶尔不得不分割叶子，而如果删除导致树少于半满，我们必须进行合并，以重新平衡树。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到正确的叶子 L。&lt;/li&gt;
&lt;li&gt;删除条目。
&lt;ul&gt;
&lt;li&gt;如果 L 至少有一半是满的，那么操作就完成了。&lt;/li&gt;
&lt;li&gt;否则，你可以尝试重新分配，从兄弟姐妹那里借用。&lt;/li&gt;
&lt;li&gt;如果重新分配失败，则合并 L 和同胞。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果合并发生了，你必须删除父类中指向 L 的条目。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html&#34;&gt;可视化演示网址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;条件选择&#34;&gt;条件选择&lt;/h4&gt;
&lt;p&gt;因为 B+Tree 是按排序的，查找时遍历速度很快，也不需要整个键。如果查询提供了搜索键的任何属性，DBMS 可以使用 B+Tree 索引。这与散列索引不同，散列索引需要搜索键中的所有属性。&lt;/p&gt;
&lt;h4 id=&#34;非唯一索引&#34;&gt;非唯一索引&lt;/h4&gt;
&lt;p&gt;像散列表一样，B+Trees 可以通过重复键或存储值列表来处理非唯一的索引。在重复键的方法中，使用相同的叶子节点布局，但重复的键被多次存储。 在值列表的方法中，每个键只存储一次，并保持一个唯一值的链接列表。&lt;/p&gt;
&lt;h4 id=&#34;重复键&#34;&gt;重复键&lt;/h4&gt;
&lt;p&gt;在 B+Tree 中，有两种方法来重复键。&lt;/p&gt;
&lt;p&gt;第一种方法是将记录 ID 作为键的一部分来附加。由于每个元组的记录 ID 是唯一的，这将确保所有的键都是可识别的。DBMS 可以根据部分键来查找元组。&lt;/p&gt;
&lt;p&gt;第二种方法是允许叶子节点溢出到包含重复键的溢出节点。 虽然没有多余的信息被存储，但这种方法的维护和修改更加复杂。&lt;/p&gt;
&lt;h4 id=&#34;聚簇索引&#34;&gt;聚簇索引&lt;/h4&gt;
&lt;p&gt;表按照主键指定的排序顺序存储，作为堆组织的或索引组织的存储。 由于一些 DBMS 总是使用聚簇索引，如果一个表没有明确的主键，它们会自动地将隐藏的行 ID 作为主键，但是其他的 DBMS 根本就不能使用它们。&lt;/p&gt;
&lt;h4 id=&#34;堆聚簇&#34;&gt;堆聚簇&lt;/h4&gt;
&lt;p&gt;元组在堆的页面中使用聚簇索引指定的顺序进行排序。如果聚类索引的属性被用来访问元组，DBMS 可以直接跳到这些页面。&lt;/p&gt;
&lt;h4 id=&#34;索引扫描页排序&#34;&gt;索引扫描页排序&lt;/h4&gt;
&lt;p&gt;由于直接从非聚簇索引中检索元组的效率很低，DBMS 可以首先找出它所需要的所有元组，然后根据它们的页面 id 进行排序。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CMU::15-445/645::Hash Tables 笔记</title>
      <link>/notes/cmu_15_445_05_note/</link>
      <pubDate>Wed, 04 Aug 2021 16:20:16 +0800</pubDate>
      <guid>/notes/cmu_15_445_05_note/</guid>
      <description>&lt;h2 id=&#34;散列表&#34;&gt;散列表&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/4jDQyjR.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据结构&#34;&gt;数据结构&lt;/h3&gt;
&lt;p&gt;DBMS 为系统内部的许多不同部分使用各种数据结构。一些例子包括。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部元数据。这是对数据库和系统状态信息进行跟踪的数据。&lt;/li&gt;
&lt;li&gt;核心数据存储。数据结构被用来作为数据库中元组的基础存储。&lt;/li&gt;
&lt;li&gt;临时数据结构。DBMS 可以在处理查询的过程中即时建立数据结构，以加快执行速度（例如，用于连接的哈希表）。&lt;/li&gt;
&lt;li&gt;表索引。可以使用辅助数据结构来使其更容易找到特定的元组。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实现 DBMS 的数据结构时，有两个主要的设计决定需要考虑。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据组织。我们需要弄清楚如何布局内存，以及在数据结构内存储哪些信息以支持有效的访问。&lt;/li&gt;
&lt;li&gt;并发。我们还需要考虑如何使多个线程访问数据结构而不造成问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;散列表-hash-tables&#34;&gt;散列表 Hash Tables&lt;/h3&gt;
&lt;p&gt;哈希表实现了一个关联数组的抽象数据类型，它将键映射到值。它提供了平均 O(1) 的操作复杂度（最坏情况下为 O(n)）和 O(n)的存储复杂度。请注意，即使平均操作复杂度为 O(1)，也有一些常数系数的优化这在现实实践中需要考虑，这些很重要的。&lt;/p&gt;
&lt;h4 id=&#34;哈希函数&#34;&gt;哈希函数&lt;/h4&gt;
&lt;p&gt;这告诉我们如何将一个大的键空间映射到一个较小的领域。它被用来计算进入一个桶或槽阵列的索引。我们需要考虑快速执行和碰撞率之间的权衡。在一个极端，我们有一个总是返回一个常数的哈希函数（非常快，但一切都会发生碰撞）。在另一个极端，我们有一个&amp;quot;完美&amp;quot;的散列函数，其中没有碰撞，但需要极长的时间来计算。理想的设计是介于两者之间。&lt;/p&gt;
&lt;h4 id=&#34;散列方案&#34;&gt;散列方案&lt;/h4&gt;
&lt;p&gt;这告诉我们如何处理散列后的键值冲突。在这里，我们需要考虑分配一个大的哈希表以减少碰撞和在发生碰撞时必须执行额外的指令之间的权衡。&lt;/p&gt;
&lt;h3 id=&#34;散列函数&#34;&gt;散列函数&lt;/h3&gt;
&lt;p&gt;散列函数接受任何键作为其输入。然后它返回该键的整数表示（即&amp;quot;哈希&amp;quot;）。该函数的输出是确定的（即，相同的键值应该总是产生相同的哈希输出）。&lt;/p&gt;
&lt;p&gt;DBMS 不需要使用加密安全的哈希函数（例如 SHA-256），因为我们不需要担心保护键值的内容。这些哈希函数主要由 DBMS 内部使用，因此信息不会被泄露。&lt;/p&gt;
&lt;p&gt;一般来说，我们只关心哈希函数的速度和碰撞率。 目前最先进的哈希函数是 Facebook XXHash3。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/2nim4p4.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;静态散列方案&#34;&gt;静态散列方案&lt;/h4&gt;
&lt;p&gt;静态散列方案是指散列表的大小是固定的。这意味着如果 DBMS 在哈希表中的存储空间用完了，那么它就必须从头开始重建一个更大的哈希表，这非常昂贵。通常，新的哈希表是原始哈希表的两倍。&lt;/p&gt;
&lt;p&gt;为了减少浪费的比较次数，避免哈希键的碰撞很重要。通常情况下，我们使用两倍于预期元素数量的槽位。&lt;/p&gt;
&lt;p&gt;以下假设在现实中通常是不成立的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元素的数量是提前知道的。&lt;/li&gt;
&lt;li&gt;键值是唯一的。&lt;/li&gt;
&lt;li&gt;存在一个完美的哈希函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，我们需要适当地选择散列函数和散列模式。&lt;/p&gt;
&lt;h4 id=&#34;线性探测散列&#34;&gt;线性探测散列&lt;/h4&gt;
&lt;p&gt;这是最基本的散列方案。它通常也是最快的。它使用一个数组槽的循环缓冲区。 散列函数将键映射到槽。当发生碰撞时，我们线性地搜索相邻的槽，直到找到一个开放的槽。对于查找，我们可以检查键的哈希值，然后线性搜索，直到找到所需的条目（或一个空槽，在这种情况下，键不在表中）。请注意，这意味着我们必须在槽中存储密钥，以便我们能够检查一个条目是否是所需的。删除是比较棘手的。我们必须小心翼翼地从槽中删除条目，因为这可能会阻止未来的查询找到被放在现在空槽下面的条目。这个问题有两个解决方案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最常见的方法是使用 &amp;ldquo;墓碑&amp;rdquo;。我们不删除这个条目，而是用一个 &amp;ldquo;墓碑 &amp;ldquo;条目取代它，告诉未来的查找要继续扫描。&lt;/li&gt;
&lt;li&gt;另一种方法是在删除一个条目后移动相邻的数据以填补现在的空槽。然而，我们必须注意只移动最初被移位的条目。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非唯一键。在同一个键可能与多个不同的值或元组相关的情况下，有两种方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单独的链表。我们不将数值与键一起存储，而是将一个指针指向一个单独的存储区域，该区域包含所有数值的链接列表。&lt;/li&gt;
&lt;li&gt;冗余的键。更常见的方法是简单地在表中多次存储相同的键。即使我们这样做，所有具有线性探测功能的东西仍然可以工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;插入&#34;&gt;插入&lt;/h4&gt;
&lt;p&gt;有 A B C D E F 六个值和一个缓冲区&lt;/p&gt;
&lt;p&gt;计算 A 的散列值，落在第三个槽&lt;/p&gt;
&lt;p&gt;计算 B 的散列值，落在第一个槽&lt;/p&gt;
&lt;p&gt;计算 C 的散列值，落在第 3 个槽，被占用，向下继续寻找找到第一个空闲的槽插入&lt;/p&gt;
&lt;p&gt;计算 D 的散列值，落在第三个槽，已经被占用，向下寻找第四个槽，也被占用，继续向下找，找到空闲的，插入&lt;/p&gt;
&lt;p&gt;E F 的散列冲突以此类推，如果，对应位置后面的槽都被占用，那么从头开始找，缓冲区是环形的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/NZasO4X.gif&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;删除&#34;&gt;删除&lt;/h4&gt;
&lt;p&gt;把第四个槽的数据删除后出现了一个空位&lt;/p&gt;
&lt;p&gt;一个做法是把那个位置标记为“墓碑”，当后面的散列值对应到这个位置的时候，就会继续向后寻找。&lt;/p&gt;
&lt;p&gt;另一个做法是，把删除位后面的数据往前移动一格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/zMnGdSa.gif&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;罗宾霍德散列&#34;&gt;罗宾霍德散列&lt;/h3&gt;
&lt;p&gt;这是线性探测散列的一个扩展，旨在减少每个键值在散列表中的最佳位置（即它们被散列到的原始槽）的最大距离。这种策略从 &amp;ldquo;富 &amp;ldquo;键中窃取槽位，并把它们给 &amp;ldquo;穷 &amp;ldquo;键。
在这个变体中，每个条目也记录了它们与最佳位置的 &amp;ldquo;距离&amp;rdquo;。然后，在每次插入时，如果被插入的钥匙与它们在当前槽的最佳位置的距离比当前条目的距离更远，我们就替换当前条目，并继续尝试在表中更远的位置插入旧条目。&lt;/p&gt;
&lt;h4 id=&#34;插入-1&#34;&gt;插入&lt;/h4&gt;
&lt;p&gt;插入 A 在第三个槽&lt;/p&gt;
&lt;p&gt;插入 B 在第一个槽&lt;/p&gt;
&lt;p&gt;插入 C 到第三个槽，此时与 A 冲突，往后一个，记录最佳位置的距离为 1&lt;/p&gt;
&lt;p&gt;插入 D 到第四个槽，与 C 冲突，比较两个的最佳距离都是 1，D 继续往后，插入，记录最佳距离为 1。&lt;/p&gt;
&lt;p&gt;插入 E 到第三个槽，冲突，往后继续，到第五个槽，此时最佳位置 2，比 D 的最佳位置更大，E 插入到第五个槽，记录最佳位置 2，D 往后移动一个位置，记录最佳位置 2&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/H2CC5Ot.gif&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;cuckoo-散列&#34;&gt;Cuckoo 散列&lt;/h3&gt;
&lt;p&gt;这种方法不是使用单一的哈希表，而是用不同的哈希函数维护多个哈希表。 这些哈希函数是相同的算法（例如，XXHash，CityHash）；它们通过使用不同的种子值为同一个键生成不同的哈希值。
当我们插入时，我们检查每一个表，并选择一个有空闲槽的表（如果多个表都有空闲槽，我们可以比较诸如负载率之类的东西，或者更常见的，只是选择一个随机表）。如果没有表有空闲的槽，我们就选择（通常是随机的）并驱逐旧条目。然后，我们将旧的条目重新洗牌到一个不同的表中。在极少数情况下，我们可能会在一个循环中结束。如果发生这种情况，我们可以用新的哈希函数种子重建所有的哈希表（不太常见）或者用更大的表重建哈希表（更常见）。
Cuckoo 散列保证了 O（1）的查找和删除，但插入可能更昂贵。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/chHAKD6.gif&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;动态散列方案&#34;&gt;动态散列方案&lt;/h3&gt;
&lt;p&gt;静态散列方案要求 DBMS 知道它要存储的元素的数量。否则，如果需要增加/缩小表的大小，它就必须重建表。&lt;/p&gt;
&lt;p&gt;动态散列方案能够根据需要调整散列表的大小，而不需要重建整个表。这些方案以不同的方式执行这种大小调整，可以最大限度地提高读取或写入。&lt;/p&gt;
&lt;h3 id=&#34;链式散列&#34;&gt;链式散列&lt;/h3&gt;
&lt;p&gt;这是最常见的动态散列方案。DBMS 为哈希表中的每个槽维护一个桶的链接列表。对同一槽位进行散列的键被简单地插入到该槽位的链表中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/fE0Io5h.gif&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;可扩展散列&#34;&gt;可扩展散列&lt;/h3&gt;
&lt;p&gt;链式散列的改进版本，它将桶拆分，而不是让链永远增长。这种方法允许哈希表中的多个槽位指向同一个桶链。&lt;/p&gt;
&lt;p&gt;重新平衡哈希表的核心思想是在分割时移动桶的条目，并增加检查的位数来寻找哈希表中的条目。这意味着 DBMS 只需要在分割链的桶内移动数据，其他所有的桶都不需要动。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DBMS 维护着一个全局和局部的深度位数，决定了在槽阵列中寻找桶所需的位数。&lt;/li&gt;
&lt;li&gt;当一个 bucket 满了，DBMS 会分割 bucket 并重新排列其元素。如果分割后的水桶的本地深度小于全局深度，那么新的 bucket 就只是添加到现有的槽阵列中。否则，DBMS 将槽阵列的大小增加一倍以容纳新的槽，并增加全局深度计数器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/d8ajBM0.gif&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;线性散列&#34;&gt;线性散列&lt;/h3&gt;
&lt;p&gt;当一个桶溢出时，这个方案并不立即分割，而是保持一个分割指针，跟踪下一个要分割的桶。无论这个指针是否指向一个溢出的桶，DBMS 都会进行分割。溢出的标准是由实现者决定的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当任何一个桶溢出时，通过添加一个新的槽项来分割指针位置的桶，并创建一个新的哈希函数。&lt;/li&gt;
&lt;li&gt;如果哈希函数映射到以前被指针指向的槽，则应用新的哈希函数。&lt;/li&gt;
&lt;li&gt;当指针到达最后一个槽时，删除原来的哈希函数，用新的哈希函数替换它。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查找 6，hash1 计算结果是 2，对应找到 2 指向的阵列&lt;/p&gt;
&lt;p&gt;插入 17，hash1 计算结果是 1，插入到 1 指向的阵列，此时，1 的阵列满了，所以 17 通过溢出的方式跟在后面，并看是否需要分裂指针指向的阵列&lt;/p&gt;
&lt;p&gt;对于被分类的阵列，在哈希表的键值部分生成一个 n+1 的键值，然后把这个陈列的值用 hash2 重新分布&lt;/p&gt;
&lt;p&gt;当我们要查找 20 的时候，首先用 hash1 计算出结果，发现落到了 0，0 此时在指针指向的分割线上面，所以要应用 hash2，再次查找，当指针遍历完第一轮之后，删除 hash1 函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/1aLp0Dw.gif&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CMU::15-445/645::Buffer Pools 笔记</title>
      <link>/notes/cmu_15_445_04_note/</link>
      <pubDate>Tue, 03 Aug 2021 23:17:58 +0800</pubDate>
      <guid>/notes/cmu_15_445_04_note/</guid>
      <description>&lt;h2 id=&#34;缓冲池和内存管理&#34;&gt;缓冲池和内存管理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/whxG5l3.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;介绍&#34;&gt;介绍&lt;/h3&gt;
&lt;p&gt;DBMS 负责管理其内存并从磁盘上来回移动数据。由于在大多数情况下，数据不能直接在磁盘上操作，任何数据库都必须能够有效地将其磁盘上以文件形式表示的数据移动到内存中，以便能够使用。DBMS 面临的一个障碍是尽量减少移动数据的速度问题。理想情况下，数据应该&amp;quot;看起来&amp;quot;是已经在内存中了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/DZFIdeg.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;从空间控制和时间控制的角度来思考这个问题。&lt;/p&gt;
&lt;p&gt;空间控制是指页面在磁盘上的物理写入位置，目标是使经常一起使用的页面在磁盘上尽可能地保持物理上的接近。&lt;/p&gt;
&lt;p&gt;时间控制是指何时将页面读入内存，何时将其写入磁盘，目的是尽量减少从磁盘上读取数据的停顿次数。&lt;/p&gt;
&lt;h3 id=&#34;locks-vs-latches&#34;&gt;Locks vs. Latches&lt;/h3&gt;
&lt;p&gt;Locks: Locks 是一个更高层次的逻辑元语，它保护数据库的内容（如元组、表、数据库）不受其他事务的影响。事务将在整个持续时间内持有一个 Locks。数据库系统可以在运行查询时向用户披露哪些 Locks 正在被持有。Locks 需要能够回滚。概念上接近于操作系统中的 Latches。&lt;/p&gt;
&lt;p&gt;Latches: Latches 是一种底层的保护元语，DBMS 将其用于内部数据结构的关键部分（例如，哈希表，内存区域）。Latches 只在所进行的操作的时间内保持。Latches 不需要支持回滚。概念上接近与操作系统的 Mutex。&lt;/p&gt;
&lt;h3 id=&#34;缓冲池&#34;&gt;缓冲池&lt;/h3&gt;
&lt;p&gt;缓冲池是一个从磁盘上读取页面的内存缓存。它本质上是在数据库内部分配的一个大的内存区域，用来存储从磁盘获取的页面。&lt;/p&gt;
&lt;p&gt;缓冲池的内存区域被组织成一个固定大小的页面阵列。每个数组条目被称为一个帧。当 DBMS 请求一个页面时，一个精确的副本被放置到缓冲池的一个帧中。然后，当一个页面被请求时，数据库系统可以首先搜索缓冲池。如果没有找到该页，那么系统就会从磁盘上获取该页的副本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/pxyMuES.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;缓冲池元数据&#34;&gt;缓冲池元数据&lt;/h4&gt;
&lt;p&gt;缓冲池必须维护某些元数据，以便有效和正确地使用。首先，页表是一个内存中的哈希表，用于跟踪当前内存中的页面。它将页面 ID 映射到缓冲池中的帧位置。由于缓冲池中的页面顺序不一定反映磁盘上的顺序，这个额外的中介层允许识别缓冲池中的页面位置。请注意，页面表不能与页面目录混淆，后者是从页面 ID 到数据库文件中的页面位置的映射。&lt;/p&gt;
&lt;p&gt;页面表还维护着每个页面的额外元数据，一个脏页标志和一个固定/引用计数器。&lt;/p&gt;
&lt;p&gt;每当一个线程修改一个页面时，就会设置脏页标记。这表明存储管理程序必须将该页写回磁盘。&lt;/p&gt;
&lt;p&gt;固定/引用计数器跟踪当前访问该页的线程数量（无论是读取还是修改）。一个线程在访问该页之前必须递增该计数器。如果一个页面的计数大于零，那么存储管理器就不允许将该页面从内存中替换出去。&lt;/p&gt;
&lt;h4 id=&#34;内存分配策略&#34;&gt;内存分配策略&lt;/h4&gt;
&lt;p&gt;数据库中的内存是根据两个策略分配给缓冲池的。&lt;/p&gt;
&lt;p&gt;全局策略处理 DBMS 应该做出的决定，以有利于正在执行的整个工作负载。 它考虑所有活动的事务，以找到分配内存的最佳决策。&lt;/p&gt;
&lt;p&gt;另一个选择是局部策略，它做出的决定将使单个查询或事务运行得更快，即使它对整个工作负载不利。对整个工作负载有利。局部策略将帧分配给特定的事务，而不考虑并发事务的行为。并发事务的行为。但是需要考虑共享页面。&lt;/p&gt;
&lt;p&gt;大多数系统使用全局策略和局部策略的组合。&lt;/p&gt;
&lt;h3 id=&#34;缓冲池优化&#34;&gt;缓冲池优化&lt;/h3&gt;
&lt;h4 id=&#34;多个缓冲池&#34;&gt;多个缓冲池&lt;/h4&gt;
&lt;p&gt;DBMS 可以为不同的目的维护多个缓冲池（即每个数据库缓冲池、每个页面类型的缓冲池）。然后，每个缓冲池可以采用为其内部存储的数据定制的本地策略。这种方法可以帮助减少锁的竞争，并提高定位性。&lt;/p&gt;
&lt;p&gt;将所需页面映射到缓冲池的两种方法是对象 ID 和散列。&lt;/p&gt;
&lt;p&gt;对象 ID 涉及到扩展记录 ID，以包括关于每个缓冲池管理的数据库对象的元数据。然后通过对象标识符，可以维护对象到特定缓冲池的映射。&lt;/p&gt;
&lt;p&gt;另一种方法是散列，DBMS 对页面 ID 进行散列，以选择访问哪个缓冲池。&lt;/p&gt;
&lt;h4 id=&#34;预取&#34;&gt;预取&lt;/h4&gt;
&lt;p&gt;DBMS 也可以通过基于查询计划的预取页面来进行优化。然后，当第一组页面被处理时，第二组可以被预取到缓冲池中。这种方法是 DBMS 在连续访问许多页面时常用的。&lt;/p&gt;
&lt;h4 id=&#34;扫描共享&#34;&gt;扫描共享&lt;/h4&gt;
&lt;p&gt;查询游标可以重复使用从存储或操作计算中获取的数据。这允许多个查询附加到一个扫描表的游标上。如果一个查询开始扫描，如果已经有一个在做这个，那么 DBMS 会跟踪第二个查询与第一个查询的连接位置，这样它就可以在到达数据结构的末端时完成扫描。第二个查询还可以复用第一个查询的结果或者中间结果。&lt;/p&gt;
&lt;h4 id=&#34;缓冲池旁路&#34;&gt;缓冲池旁路&lt;/h4&gt;
&lt;p&gt;顺序扫描操作不将获取的页面存储在缓冲池中来避免开销。如果操作需要读取磁盘上连续的大序列页面，这就很好用，在后面不需要用到这些原始数据，可以在内存中计算完成后就可以丢掉。缓冲池旁路也可用于临时数据（排序、连接）。&lt;/p&gt;
&lt;h3 id=&#34;操作系统页面缓存&#34;&gt;操作系统页面缓存&lt;/h3&gt;
&lt;p&gt;大多数磁盘操作是通过操作系统的 API 进行的。除非被明确告知，操作系统会维护自己的文件系统缓存。&lt;/p&gt;
&lt;p&gt;大多数 DBMS 使用 direct I/O 来绕过操作系统的缓存，以避免页面的冗余拷贝和不得不管理不同的驱逐策略。&lt;/p&gt;
&lt;h3 id=&#34;缓冲替换策略&#34;&gt;缓冲替换策略&lt;/h3&gt;
&lt;p&gt;当 DBMS 需要释放一个帧来为一个新的页面腾出空间时，它必须决定从缓冲池中驱逐哪个页面。&lt;/p&gt;
&lt;p&gt;替换策略是 DBMS 实现的一种当它需要空间时决定从缓冲池中驱逐哪些页面的算法。&lt;/p&gt;
&lt;p&gt;替换策略的实现目标是提高正确性、准确性、速度和元数据的开销。&lt;/p&gt;
&lt;h4 id=&#34;最近使用最少lru&#34;&gt;最近使用最少（LRU）&lt;/h4&gt;
&lt;p&gt;最近最少使用的替换策略保留了每个页面最后被访问的时间戳。这个时间戳可以存储在一个单独的数据结构中，比如一个队列，以便进行排序和提高效率。该 DBMS 会选择驱逐具有最古老时间戳的页面。此外，页面被保存在排序的顺序中，以减少排序驱逐的时间。&lt;/p&gt;
&lt;h4 id=&#34;时钟算法&#34;&gt;时钟算法&lt;/h4&gt;
&lt;p&gt;CLOCK 策略是 LRU 的一个近似值，不需要每页有单独的时间戳。在 CLOCK 策略中，每个页面被赋予一个引用位。当一个页面被访问时，设置为 1。&lt;/p&gt;
&lt;p&gt;为了直观地了解这一点，可以将页面组织在一个带有&amp;quot;时钟指针&amp;quot;的圆形缓冲区中。当扫到一个页面，参考位如果是 1，则设置为 0，如果不是，则驱逐它。通过这种方式，时钟指针通过驱逐操作记住了位置。&lt;/p&gt;
&lt;p&gt;然而，LRU 和 CLOCK 很容易受到顺序泛滥的影响，即缓冲池的内容由于顺序扫描而被破坏。由于顺序扫描会读取每一页，所以读取的页面的时间戳可能并不反映我们真正想要的页面。换句话说，最近使用的页面实际上可能是最不需要的页面。&lt;/p&gt;
&lt;p&gt;有三种解决方案可以解决 LRU 和 CLOCK 策略的缺点。&lt;/p&gt;
&lt;p&gt;一种解决方案是 LRU-K，它以时间戳的形式跟踪最后 K 个引用的历史，并计算出后续访问的间隔时间。这个历史记录被用来预测一个页面下次被访问的时间。&lt;/p&gt;
&lt;p&gt;另一个优化是局部化每个查询。通过持续跟踪被查询读取过的页面，DBMS 在每个事务/查询的基础上选择哪些页面要被驱逐。这使得每次查询对缓冲池的污染最小化。&lt;/p&gt;
&lt;p&gt;最后，优先级提示允许事务在查询执行过程中根据每个页面的上下文告诉缓冲池页面是否重要。&lt;/p&gt;
&lt;h3 id=&#34;脏页&#34;&gt;脏页&lt;/h3&gt;
&lt;p&gt;有两种方法来处理有脏位的页面。最快的方法是丢弃缓冲池中任何不脏的页面。一个较慢的方法是将脏页写回磁盘，以确保其变化被持久化。&lt;/p&gt;
&lt;p&gt;这两种方法说明了快速驱逐与脏写页之间的权衡，脏写页在未来不会被再次读取。&lt;/p&gt;
&lt;p&gt;避免不必要地写页面的问题的一种方法是后台写入。通过后台写入，DBMS 可以周期性地走过页表并将脏页写入磁盘。当一个脏页被安全地写入时，DBMS 可以驱逐该页或者直接取消脏页标志。&lt;/p&gt;
&lt;h3 id=&#34;其他内存池&#34;&gt;其他内存池&lt;/h3&gt;
&lt;p&gt;DBMS 需要内存来处理元组和索引以外的事情。这些其他的内存池可能并不总是由磁盘支持，这取决于实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sorting + Join Buffers&lt;/li&gt;
&lt;li&gt;Query Caches&lt;/li&gt;
&lt;li&gt;Maintenance Buffers&lt;/li&gt;
&lt;li&gt;Log Buffers&lt;/li&gt;
&lt;li&gt;Dictionary Caches&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CMU::15-445/645::Database Storage 笔记</title>
      <link>/notes/cmu_15_445_03_note/</link>
      <pubDate>Mon, 02 Aug 2021 09:07:42 +0800</pubDate>
      <guid>/notes/cmu_15_445_03_note/</guid>
      <description>&lt;h2 id=&#34;数据库存储第一部分&#34;&gt;数据库存储第一部分&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/qhTvXK1.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;存储&#34;&gt;存储&lt;/h3&gt;
&lt;p&gt;我们将关注一个 &amp;ldquo;面向磁盘 &amp;ldquo;的 DBMS 架构，它假定数据库的主要存储位置是在非易失性磁盘上。&lt;/p&gt;
&lt;p&gt;数据库的主要存储位置是在非易失性磁盘上。&lt;/p&gt;
&lt;p&gt;在存储层次结构的顶端，最接近 CPU 的位置，这是最快的但它也是容量小和最昂贵的存储。离 CPU 越远，存储设备的容量就越大。设备有更大的容量，但速度更慢，离 CPU 更远。这些设备每 GB 的价格也越来越便宜。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/S473W6q.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;易失性设备。
&lt;ul&gt;
&lt;li&gt;易失性意味着如果你从机器上拔掉电源，那么数据就会丢失。&lt;/li&gt;
&lt;li&gt;易失性存储支持快速的随机访问，具有字节寻址的位置。这意味着程序可以跳转到任何字节地址，并获得其中的数据。&lt;/li&gt;
&lt;li&gt;为了我们的目的，我们将始终把这种存储类别称为 &amp;ldquo;存储器&amp;rdquo;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非易失性设备。
&lt;ul&gt;
&lt;li&gt;非易失性意味着存储设备不需要持续供电，以便以保留它所存储的比特。&lt;/li&gt;
&lt;li&gt;它也是块/页可寻址的。这意味着，为了读取一个特定偏移量的数值，程序首先要加载 4KB 的页面加载到内存中，以提供程序想要读取的值。&lt;/li&gt;
&lt;li&gt;非易失性存储在传统上更擅长顺序访问（同时读取多块数据）。&lt;/li&gt;
&lt;li&gt;我们将把它称为 &amp;ldquo;磁盘&amp;rdquo;。我们将不对固态硬盘或机械硬盘进行区分。
(SSD)或旋转式硬盘(HDD)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有一类新的存储设备即将问世，称为非易失存储器，定位介于 DRAM 于 SSD 之间。它几乎和 DRAM 一样快，但具有磁盘的持久性。(英特尔傲腾)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对非易失性存储的随机访问通常比顺序访问要慢得多。
&lt;ul&gt;
&lt;li&gt;算法试图减少对随机页的写入次数，以便将数据存储在连续的块中。&lt;/li&gt;
&lt;li&gt;程序在再一次调用中分配多个页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于系统假设数据库存储在磁盘上，DBMS 的组件负责找出如何在非易失性磁盘和易失性存储器之间来回移动数据。DBMS 的组件负责找出如何在非易失性磁盘和易失性存储器之间来回移动数据，因为系统不能直接对磁盘上的数据进行操作。&lt;/p&gt;
&lt;p&gt;数据库存储在磁盘上，系统不能直接在磁盘上操作数据，DBMS 的组件负责找出如何在非易失性磁盘和易失性存储器之间来回移动数据。&lt;/p&gt;
&lt;p&gt;我们将专注于如何隐藏磁盘的延迟，而不是专注于用寄存器和缓存进行优化，因为从磁盘获取数据的速度非常慢。如果从 L1 缓存引用中读取数据需要半秒，那么从 SSD 中读取数据需要 1.7 天，从 HDD 中读取需要 16.5 周。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/v63l8oN.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;面向磁盘的-dbms-总览&#34;&gt;面向磁盘的 DBMS 总览&lt;/h3&gt;
&lt;p&gt;数据库都在磁盘上，数据库文件中的数据被组织成页，第一页是目录页。为了对数据进行操作，DBMS 需要将数据带入内存。它通过拥有一个缓冲池来管理磁盘和内存之间的来回移动。DBMS 也有一个执行引擎，可以执行查询。执行引擎将要求缓冲池提供一个特定的页面，而缓冲池将负责把该页面带入内存，并给执行引擎一个指向内存中该页面的指针。缓冲池管理器将确保在执行引擎对该内存进行操作时，该页是存在的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/3MilQUm.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;dbms-对比-os&#34;&gt;DBMS 对比 OS&lt;/h3&gt;
&lt;p&gt;DBMS 的一个高层次设计目标是支持超过可用内存量的数据库。由于对磁盘的读/写是昂贵的，所以必须小心管理。我们不希望在从磁盘上获取东西时出现大的停顿，从而拖慢其他一切。因此，我们希望 DBMS 能够在等待从磁盘获取数据时处理其他查询。它就像虚拟内存一样，有一个大的地址空间和一个供操作系统从磁盘引入页面的地方。&lt;/p&gt;
&lt;p&gt;实现这种虚拟内存的一种方法是使用 mmap 来映射进程地址空间中的文件内容，这使得操作系统能够在磁盘和内存之间来回移动页面。
不幸的是，这意味着如果 mmap 遇到了页面故障，将阻塞进程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果你需要写东西，你永远不想在你的 DBMS 中使用 &lt;code&gt;mmap&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DBMS（几乎）总是想自己控制事情，而且可以做得更好，因为它知道更多关于被访问的数据和被处理的查询。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以正确的顺序将脏页刷入磁盘。&lt;/li&gt;
&lt;li&gt;专门的预取。&lt;/li&gt;
&lt;li&gt;更有效的缓冲区替换策略。&lt;/li&gt;
&lt;li&gt;线程/进程调度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作系统不是你的朋友。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过操作系统控制内存也是可能的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;madvise&lt;/code&gt;。通知操作系统知道你打算什么时候阅读某些页面。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mlock&lt;/code&gt;: 通知操作系统不要把内存的范围内的数据交换到磁盘上。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;msync&lt;/code&gt;: 通知操作系统将内存范围内的数据刷到磁盘上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;出于正确性和性能的考虑，我们不建议在 DBMS 中使用 mmap。即使系统会有一些看起来像操作系统可以提供的功能，但让 DBMS 自己实现这些程序会使它有更好的控制能力和性能。&lt;/p&gt;
&lt;h3 id=&#34;文件存储&#34;&gt;文件存储&lt;/h3&gt;
&lt;p&gt;在其最基本的形式中，DBMS 将数据库存储为磁盘上的文件。有些可能使用一个文件层次结构，有些则可能使用单个文件（例如，SQLite）。&lt;/p&gt;
&lt;p&gt;操作系统对这些文件的内容一无所知。只有 DBMS 知道如何解码它们的内容，因为它是以 DBMS 特有的方式编码的。&lt;/p&gt;
&lt;p&gt;DBMS 的存储管理器负责管理数据库的文件。它将这些文件表示为一个页的集合。它还跟踪哪些数据被读和写到了页面上，以及页面上有多少可用空间。以及页面中还有多少可用空间。&lt;/p&gt;
&lt;h3 id=&#34;数据库页&#34;&gt;数据库页&lt;/h3&gt;
&lt;p&gt;DBMS 将数据库组织在一个或多个文件中的固定大小的数据块，称为页。页面可以包含不同种类的数据（元组、索引、日志等）。大多数系统不会在页中混合这些类型。有些系统会要求它是自包含的，也就是说，读取每个页面所需的所有信息都在页面本身。虽然定义和数据分离可以减少体积，如果缺失了一部分定义数据，会导致数据失去意义，并且恢复难度比较大。&lt;/p&gt;
&lt;p&gt;每个页面都有一个唯一的标识符。如果数据库是一个单一的文件，那么页面标识可以只是文件的偏移量。大多数数据库管理系统有一个中介层，将页面 ID 映射到文件路径和偏移量。系统的上层会要求一个特定的页号，然后存储管理程序必须把这个页号变成一个文件和一个偏移量来找到这个页。&lt;/p&gt;
&lt;p&gt;大多数 DBMS 使用固定大小的页面来避免支持可变大小页面所需的工程开销。例如，在可变大小的页面中，删除一个页面可能会在文件中产生一个洞，而 DBMS 不能轻易用新的页面来填补。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 DBMS 中，有三种不同的 &amp;ldquo;页 &amp;ldquo;概念。
&lt;ul&gt;
&lt;li&gt;硬件页 (通常 4 KB).&lt;/li&gt;
&lt;li&gt;操作系统 (通常 4 KB).&lt;/li&gt;
&lt;li&gt;数据库页 (512B - 16 KB)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存储设备保证对硬件页的大小进行原子写入。如果硬件页是 4KB，那么当系统试图将 4KB 写入磁盘时，要么所有的 4KB 都被写入，要么都不写入。这意味着，如果我们的数据库页大于硬件页，DBMS 将不得不采取额外的措施来确保数据被安全地写出来，因为程序可能在将数据库页的一部分写到磁盘的过程中崩溃。&lt;/p&gt;
&lt;h3 id=&#34;数据库堆文件&#34;&gt;数据库堆文件&lt;/h3&gt;
&lt;p&gt;有几种方法可以找到 DBMS 想要的页面在磁盘上的位置，而堆文件组织就是其中一种方法。&lt;/p&gt;
&lt;p&gt;堆文件是一个无序的页面集合，其中的元组是以随机顺序存储的。&lt;/p&gt;
&lt;p&gt;DBMS 可以通过使用页面的链接列表或页面目录来找到磁盘上给定的页面 ID。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/eB4bj1N.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;两种方式可以表示数据库堆文件&lt;/p&gt;
&lt;h4 id=&#34;文件目录&#34;&gt;文件目录&lt;/h4&gt;
&lt;p&gt;DBMS 维护特殊页面，上面记录跟踪数据页面的位置以及每个页面上的空闲空间数量&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/AIpKCZg.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;链表&#34;&gt;链表&lt;/h4&gt;
&lt;p&gt;头页持有指向空闲页列表和数据页列表的指针。然而，如果 DBMS 正在寻找一个特定的页面，它必须对数据页列表进行顺序遍历，直到找到它要寻找的页面。链表同样支持反向遍历。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/NgjaAPh.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;页布局&#34;&gt;页布局&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每个页面都包括一个页头，记录了关于页面内容的元数据。
&lt;ul&gt;
&lt;li&gt;页面大小。&lt;/li&gt;
&lt;li&gt;校验和。&lt;/li&gt;
&lt;li&gt;DBMS 版本。&lt;/li&gt;
&lt;li&gt;事务的可见性。&lt;/li&gt;
&lt;li&gt;压缩信息&lt;/li&gt;
&lt;li&gt;一些系统要求页面是字包含的（如 oracle）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/vt7VkcX.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;存放数据的一个原始方法是跟踪 DBMS 在一个页面中存储了多少个元组，然后每次增加一个新的元组时，它就把元组附加到最后。然而，当它删除一个元组或元组有可变长度的属性时，问题就出现了。&lt;/p&gt;
&lt;h4 id=&#34;元组式页面&#34;&gt;元组式页面&lt;/h4&gt;
&lt;p&gt;先看以下按照元组方式组织的页面，当三条数据按照顺序存放在页面中&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/3ihvtT4.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;删除一条数据会发生什么？&lt;/p&gt;
&lt;p&gt;对应位置的记录被删除，留下一个空白，同步文件头中关于元组数量的记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/pnSzxC9.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;继续存入一条数据会发生什么？&lt;/p&gt;
&lt;p&gt;如果数据是定长的，那么它可以存入刚刚被删除的位置或者页面中的空白位置，如果是变长的数据，它需要向后扫描直到找到满足要求的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/KclWvZQ.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;有两种主要的方法来布置页面中的数据。&lt;/p&gt;
&lt;h4 id=&#34;插槽式页面&#34;&gt;插槽式页面&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;目前 DBMS 中使用的最常见的方法。&lt;/li&gt;
&lt;li&gt;头部跟踪已使用的槽的数量和最后使用的槽的起始位置的偏移量，以及一个槽数组，它跟踪每个元组的起始位置。&lt;/li&gt;
&lt;li&gt;要增加一个元组，槽数组将从头到尾增长，元组的数据将从尾到头增长。当槽阵列和元组数据相遇。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/5I6XPw6.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;日志式结构&#34;&gt;日志式结构&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;DBMS 不存储元组，而只存储日志记录。&lt;/li&gt;
&lt;li&gt;将数据库如何被修改（插入、更新、删除）的记录存入文件。&lt;/li&gt;
&lt;li&gt;要读取一条记录，DBMS 会逆向扫描日志文件并&amp;quot;重新创建&amp;quot;元组。&lt;/li&gt;
&lt;li&gt;写的快，读的可能慢。&lt;/li&gt;
&lt;li&gt;在仅有追加写入的存储上工作得很好，因为 DBMS 不能往回更新数据。&lt;/li&gt;
&lt;li&gt;为了避免长时间的读取，DBMS 可以有索引，允许它跳到日志中的特定位置。它还可以定期压缩日志，压缩的问题是 DBMS 最终会出现写入放大（它一次又一次地重写相同的数据）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;日志压缩&#34;&gt;日志压缩&lt;/h4&gt;
&lt;p&gt;通过删除不必要的记录，压缩将较大的日志文件凝聚成较小的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/1lGJXAs.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;元组布局&#34;&gt;元组布局&lt;/h3&gt;
&lt;p&gt;元组本质上是一个字节序列。DBMS 的工作是将这些字节解释为属性类型和值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元组标头。包含关于元组的元数据。
&lt;ul&gt;
&lt;li&gt;DBMS 的并发控制协议的可见性信息&lt;/li&gt;
&lt;li&gt;NULL 值的位图。&lt;/li&gt;
&lt;li&gt;注意，DBMS 不需要在这里存储关于数据库模式的元数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;元组数据。属性的实际数据。
&lt;ul&gt;
&lt;li&gt;属性通常按照你创建表时指定的顺序存储。&lt;/li&gt;
&lt;li&gt;大多数 DBMS 不允许一个元组超过一个页面的大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;唯一标识符。
&lt;ul&gt;
&lt;li&gt;数据库中的每个元组都被分配一个唯一的标识符。&lt;/li&gt;
&lt;li&gt;最常见的是：页面 ID +（偏移量或槽）。&lt;/li&gt;
&lt;li&gt;一个应用程序不能依赖这些 ID 来表示任何东西。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yMtXbAt.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;非规格化数据&#34;&gt;非规格化数据&lt;/h3&gt;
&lt;p&gt;如果两个表是相关的，DBMS 可以&amp;quot;预连接&amp;quot;它们，所以这些表最终会在同一个页面上。这使得读取速度加快，因为 DBMS 只需要加载一个页面，而不是两个独立的页面。然而，这使得更新更加昂贵，因为 DBMS 需要更多的空间给每个元组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/2WJMghW.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据库是以页为单位组织的。&lt;/li&gt;
&lt;li&gt;跟踪页面有不同方式。&lt;/li&gt;
&lt;li&gt;存储页面有不同方式。&lt;/li&gt;
&lt;li&gt;存储元组有不同方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据库存储第二部分&#34;&gt;数据库存储第二部分&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/anyphM7.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据表示&#34;&gt;数据表示&lt;/h3&gt;
&lt;p&gt;元组中的数据本质上只是字节数组。DBMS 要知道如何解释这些字节以得出属性的值。数据表示方案是 DBMS 如何为一个值存储字节。&lt;/p&gt;
&lt;p&gt;有五大类数据类型可以存储在元组中：整数、浮点数、定点精度数、可变长度值和日期/时间。&lt;/p&gt;
&lt;h4 id=&#34;整数&#34;&gt;整数&lt;/h4&gt;
&lt;p&gt;大多数 DBMS 使用 IEEE-754 标准规定的本地 C/C++ 类型来存储整数。这些值是固定长度的。&lt;/p&gt;
&lt;p&gt;例如。INTEGER, BIGINT, SMALLINT, TINYINT.&lt;/p&gt;
&lt;h4 id=&#34;可变精度数字&#34;&gt;可变精度数字&lt;/h4&gt;
&lt;p&gt;这些是不精确的、可变精度的数字类型，使用 IEEE-754 标准规定的 C/C++ 类型。这些值也是固定长度的。&lt;/p&gt;
&lt;p&gt;对可变精度数字的操作比任意精度数字的计算更快，因为 CPU 可以直接对它们执行指令。然而，由于有些数字不能精确表示，在进行计算时可能会出现四舍五入的错误。&lt;/p&gt;
&lt;p&gt;举例来说。FLOAT，REAL。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/3pzeQZv.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;固定点精度数&#34;&gt;固定点精度数&lt;/h4&gt;
&lt;p&gt;这些是具有任意精度和比例的数字数据类型。它们通常以精确的、可变长度的二进制表示法（几乎像一个字符串）来存储，带有额外的元数据，这些元数据会告诉系统一些事情，如数据的长度和小数点应该在哪里。&lt;/p&gt;
&lt;p&gt;当四舍五入的误差不可接受时，就会使用这些数据类型，但是 DBMS 为了获得这种准确性而付出了一定的性能代价。来获得这种准确性。&lt;/p&gt;
&lt;p&gt;例子: NUMERIC, DECIMAL.&lt;/p&gt;
&lt;h5 id=&#34;pg-中的数字表示&#34;&gt;PG 中的数字表示&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/fyKLmOu.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;mysql-中的数字表示&#34;&gt;MySQL 中的数字表示&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/FFg3nxV.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;可变长度的数据&#34;&gt;可变长度的数据&lt;/h4&gt;
&lt;p&gt;这些数据代表任意长度的数据类型。它们通常是用一个头来存储的，这个头可以追踪到追踪字符串的长度，以便于跳转到下一个值。它还可能包含一个数据的校验和。&lt;/p&gt;
&lt;p&gt;大多数 DBMS 不允许一个元组超过单页的大小。那些允许的系统将数据存储在一个特殊的 Overflow Page，并让元组包含对该页的引用。这些溢出页可以这些 Overflow Page 可以包含指向其他 Overflow Page 的指针，直到所有的数据都能被存储。&lt;/p&gt;
&lt;p&gt;有些系统会让你把这些大的数值存储在一个外部文件中，然后元组会包含一个指向该文件的指针。例如，如果数据库存储的是照片信息，DBMS 可以将照片存储在外部文件中，而不是让它们在 DBMS 中占用大量的空间。这样做的一个缺点是，DBMS 不能对这个文件的内容进行操作。因此，没有持久化或事务保护。&lt;/p&gt;
&lt;p&gt;例子: VARCHAR, VARBINARY, TEXT, BLOB.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/zDOU8Gy.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;日期和时间&#34;&gt;日期和时间&lt;/h4&gt;
&lt;p&gt;不同的系统对日期/时间的表示方法各不相同。通常情况下，它们被表示为从 unix 纪元开始的一些单位时间微秒或毫秒。&lt;/p&gt;
&lt;p&gt;例子。TIME、DATE、TIMESTAMP。&lt;/p&gt;
&lt;h4 id=&#34;系统目录&#34;&gt;系统目录&lt;/h4&gt;
&lt;p&gt;为了使 DBMS 能够解码元组的内容，它维护了一个内部目录来告诉它关于数据库的元数据。元数据将包含关于数据库有哪些表和列的信息，以及它们的类型和值的顺序。大多数 DBMS 以它们用于表的格式在自己内部存储目录。他们使用特殊的代码来访问这些目录表。DBMS 没有标准的方式来检索这些信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/weMyy99.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;工作负载&#34;&gt;工作负载&lt;/h3&gt;
&lt;p&gt;数据库系统有许多不同的工作负载。我们所说的工作负载，是指一个系统要处理的请求的一般性质。本课程将重点讨论两种类型。在线事务处理和在线分析处理。&lt;/p&gt;
&lt;h4 id=&#34;oltp在线事务处理&#34;&gt;OLTP：在线事务处理&lt;/h4&gt;
&lt;p&gt;快速操作，每次只读取/更新少量的的快速操作，每次只读/更新少量的数据。&lt;/p&gt;
&lt;h4 id=&#34;olap在线分析处理&#34;&gt;OLAP：在线分析处理&lt;/h4&gt;
&lt;p&gt;读取大量数据的复杂查询，以计算聚合结果。&lt;/p&gt;
&lt;h4 id=&#34;htap混合事务分析处理&#34;&gt;HTAP：混合事务/分析处理&lt;/h4&gt;
&lt;p&gt;在同一个数据库中同时进行 OLTP 和 OLAP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/zzz4jgR.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;存储模型&#34;&gt;存储模型&lt;/h3&gt;
&lt;p&gt;DBMS 可以用不同的方式存储元组，这些方式更适合 OLTP 或 OLAP 工作负载。&lt;/p&gt;
&lt;h4 id=&#34;n-ary-存储模型nsm&#34;&gt;N-Ary 存储模型（NSM）&lt;/h4&gt;
&lt;p&gt;在 n-ary 存储模型中，DBMS 将一个元组的所有属性连续地存储在一个单一的页，所以 NSM 也被称为 &amp;ldquo;行存储&amp;rdquo;。这种方法是 OLTP 工作负载的理想选择，在这种工作负载中，要求这种方法是 OLTP 工作负载的理想选择，在这种工作负载中，请求是大量插入的，并且事务往往只操作一个单独的实体。它是理想的，因为它只可以一次性获取一个元组的所有属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点。
&lt;ul&gt;
&lt;li&gt;快速插入、更新和删除。&lt;/li&gt;
&lt;li&gt;适合于需要单个元组的查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点。
&lt;ul&gt;
&lt;li&gt;不利于扫描表的大部分和/或属性的一个子集，这是因为它查询出来的不需要处理的数据污染了缓冲池。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/z5zRhf6.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;分解存储模型&#34;&gt;分解存储模型&lt;/h4&gt;
&lt;p&gt;在分解存储模型中，DBMS 为所有元组连续地存储一个单一的属性（列）。在一个数据块中。因此，它也被称为 &amp;ldquo;列存储&amp;rdquo;。这种模式是 OLAP 工作负载的理想选择，用来执行只读查询，在表的属性子集上进行大量扫描。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点。
&lt;ul&gt;
&lt;li&gt;减少了查询执行过程中的浪费，因为 DBMS 只读取查询所需的数据。&lt;/li&gt;
&lt;li&gt;能够更好地压缩，因为同一属性的所有值都是连续存储的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点。
&lt;ul&gt;
&lt;li&gt;由于元组的分割/缝合，点查询、插入、更新和删除的速度很慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在使用列存储时，要把元组重新组合起来，有两种常见的方法。&lt;/p&gt;
&lt;p&gt;最常用的方法是固定长度的偏移量。假设属性都是固定长度的，DBMS 可以计算每个元组的属性的偏移量。然后，当系统想要某个特定元组的属性时，它知道如何从偏移量跳到文件中的那个位置。为了适应可变长度的字段，系统可以填充字段，使它们都是相同的长度，或者使用一个字典，接受一个固定大小的整数，将整数映射到值。&lt;/p&gt;
&lt;p&gt;一个不太常见的方法是使用嵌入式元组 ID。在这里，对于列中的每个属性，DBMS 都会用它来存储一个元组 ID（例如：主键）。然后，系统还将存储一个映射，告诉它如何跳转到具有该 ID 的每个属性。请注意，这种方法有很大的存储开销，因为它需要为每个属性条目存储一个元组 ID。为每个属性条目存储一个元组 ID&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/4l9etYt.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CMU::15-445/645::Advanced SQL 笔记</title>
      <link>/notes/cmu_15_445_02_note/</link>
      <pubDate>Sun, 01 Aug 2021 09:07:42 +0800</pubDate>
      <guid>/notes/cmu_15_445_02_note/</guid>
      <description>&lt;h2 id=&#34;高级-sql&#34;&gt;高级 SQL&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/flXoQVk.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;关系语言&#34;&gt;关系语言&lt;/h3&gt;
&lt;p&gt;Edgar Codd 在 20 世纪 70 年代初发表了关于关系模型的主要论文。他最初只定义了 DBMS 如何在关系模型 DBMS 上执行查询的数学符号。&lt;/p&gt;
&lt;p&gt;用户只需要使用声明性语言（即 SQL）来指定他们想要的结果。DBMS 负责通过使用查询优化器重新组合操作确定产生该答案的最有效计划。&lt;/p&gt;
&lt;p&gt;关系代数是基于 &lt;code&gt;sets&lt;/code&gt;（无序的，没有重复的）。SQL 是基于 &lt;code&gt;bags&lt;/code&gt;（无序的，允许重复）&lt;/p&gt;
&lt;h3 id=&#34;sql-历史&#34;&gt;SQL 历史&lt;/h3&gt;
&lt;p&gt;SQL。结构化查询语言&lt;/p&gt;
&lt;p&gt;IBM 最初称其为 &lt;code&gt;SEQUEL&lt;/code&gt; (Structured English Query Language)&lt;/p&gt;
&lt;p&gt;由不同类别的命令组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据操作语言（DML）。&lt;code&gt;SELECT&lt;/code&gt;,&lt;code&gt;INSERT&lt;/code&gt;,&lt;code&gt;UPDATE&lt;/code&gt;,&lt;code&gt;DELETE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据定义语言（DDL）。模式定义。&lt;/li&gt;
&lt;li&gt;数据控制语言（DCL）。安全，访问控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前的 SQL 标准是 SQL:2016&lt;/p&gt;
&lt;p&gt;各阶段引入的特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SQL:2016 → JSON, Polymorphic tables&lt;/li&gt;
&lt;li&gt;SQL:2011 → Temporal DBs, Pipelined DML&lt;/li&gt;
&lt;li&gt;SQL:2008 → TRUNCATE, Fancy sorting&lt;/li&gt;
&lt;li&gt;SQL:2003 → XML, windows, sequences, auto-gen IDs.&lt;/li&gt;
&lt;li&gt;SQL:1999 → Regex, triggers, OO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SQL 并没有死。它每隔几年就会有新的功能被更新。SQL-92 是一个 DBMS 必须支持的最低版本，以便声称他们支持 SQL。每个供应商都在一定程度上遵循该标准，但也有许多专有的扩展。&lt;/p&gt;
&lt;h3 id=&#34;数据库例子&#34;&gt;数据库例子&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ADQaxYv.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;聚合&#34;&gt;聚合&lt;/h3&gt;
&lt;p&gt;聚合函数接收一组元组作为其输入，然后产生一个单一的标量值作为其输出。只能在 SELECT 输出列表中使用。&lt;/p&gt;
&lt;p&gt;举例：获取使用&#39;@cs&amp;rsquo;登录的学生某个信息。以下三个查询是等价的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;login&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;like&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;%@cs&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;login&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;login&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;like&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;%@cs&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;login&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;like&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;%@cs&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;count(1)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;获取用&#39;@cs&amp;rsquo;登录的学生数量和他们的平均 GPA。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;avg&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;gpa&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;),&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;login&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;like&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;%@cs&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;avg(gpa)&lt;/th&gt;
&lt;th&gt;count(sid)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;3.25&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;部分函数支持&lt;code&gt;DISTINCT&lt;/code&gt;关键字&lt;/p&gt;
&lt;p&gt;&lt;code&gt;COUNT&lt;/code&gt;, &lt;code&gt;SUM&lt;/code&gt;, &lt;code&gt;AVG&lt;/code&gt; 支持 &lt;code&gt;DISTINCT&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;distinct&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;login&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;login&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;like&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;%@cs&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;COUNT(DISTINCT login)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;聚合列之外的其他列的输出是未定义的（e.cid 在下面未定义）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;avg&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;gpa&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;),&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;cid&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;enrolled&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;AVG(s.gpa)&lt;/th&gt;
&lt;th&gt;e.cid&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;3.5&lt;/td&gt;
&lt;td&gt;???&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因此，聚合列之外的其他列必须被聚合或用于 GROUP BY 命令中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;avg&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;gpa&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;),&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;cid&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;enrolled&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;group&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;by&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;cid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;HAVING&lt;/code&gt;：过滤聚合后的输出结果。就像一个&lt;code&gt;GROUP BY&lt;/code&gt;的&lt;code&gt;WHERE&lt;/code&gt;子句&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;AVG&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;gpa&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;avg_gpa&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;cid&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;enrolled&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;cid&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;HAVING&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;avg_gpa&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;字符串操作&#34;&gt;字符串操作&lt;/h3&gt;
&lt;p&gt;SQL 标准规定，字符串区分大小写，而且只能是单引号&lt;/p&gt;
&lt;p&gt;事实上&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;SQL-92&lt;/th&gt;
&lt;th&gt;Sensitive&lt;/th&gt;
&lt;th&gt;Single Only&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Postgres&lt;/td&gt;
&lt;td&gt;Sensitive&lt;/td&gt;
&lt;td&gt;Single Only&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;Insensitive&lt;/td&gt;
&lt;td&gt;Single/Double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SQLite&lt;/td&gt;
&lt;td&gt;Sensitive&lt;/td&gt;
&lt;td&gt;Single/Double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DB2&lt;/td&gt;
&lt;td&gt;Sensitive&lt;/td&gt;
&lt;td&gt;Single Only&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Oracle&lt;/td&gt;
&lt;td&gt;Sensitive&lt;/td&gt;
&lt;td&gt;Single Only&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;有一些函数可以处理字符串，可以在查询的任何部分使用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;substring&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;abbrv_name&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;53688&lt;/span&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;upper&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;like&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;kan%&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;substring&lt;/li&gt;
&lt;li&gt;upper&lt;/li&gt;
&lt;li&gt;lower&lt;/li&gt;
&lt;li&gt;concat&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模式匹配&lt;/p&gt;
&lt;p&gt;LIKE 关键字用于谓词中的字符串匹配&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;%&amp;rdquo; 匹配任何子字符串（包括空）&lt;/li&gt;
&lt;li&gt;&amp;ldquo;_&amp;rdquo; 匹配任何一个字符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;串联&lt;/p&gt;
&lt;p&gt;两个竖条（&amp;quot;||&amp;quot;）将两个或多个字符串连接成一个单一的字符串&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SQL-92&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;login&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;LOWER&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;@cs&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;MSSQL&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;login&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;LOWER&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;@cs&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;MySQL&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;login&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;CONCAT&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;LOWER&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;),&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;@cs&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;时间日期操作&#34;&gt;时间日期操作&lt;/h3&gt;
&lt;p&gt;处理和修改日期/时间属性&lt;/p&gt;
&lt;p&gt;可以在输出和谓词中使用&lt;/p&gt;
&lt;p&gt;支持/语法有很大的不同&lt;/p&gt;
&lt;p&gt;例子:获取一年中的第几天&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pgsql&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;date&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;2019-08-23&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;date&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;2019-01-01&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;days&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;mysql&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;datediff&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;date&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;2019-08-23&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;date&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;2019-01-01&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;days&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;sqlite&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;supprt&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;输出重定向&#34;&gt;输出重定向&lt;/h3&gt;
&lt;p&gt;把查询结果存入另一张表&lt;/p&gt;
&lt;p&gt;新表:将查询的输出存储到一个新的表中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;DISTINCT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cid&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;INTO&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;CourseIds&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;enrolled&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现有的表:将查询的输出存储到数据库中已经存在的表中。该表目标表必须有与目标表相同数量和相同类型的列，但输出查询中的列名不需要匹配。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;INTO&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;CourseIds&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;DISTINCT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cid&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;enrolled&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;输出控制&#34;&gt;输出控制&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ORDER BY&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由于 SQL 的结果是无序的，你必须使用&lt;code&gt;ORDER BY&lt;/code&gt;子句来对元组进行排序。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;enrolled&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;15-721&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;grade&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;DESC&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可以使用多个&lt;code&gt;ORDER BY&lt;/code&gt;子句来更复杂的排序。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;enrolled&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;15-721&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;grade&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;DESC&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;ASC&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你也可以在&lt;code&gt;ORDER BY&lt;/code&gt;子句中使用任何任意的表达式。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;enrolled&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;15-721&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;UPPER&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;grade&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;DESC&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;ASC&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;LIMIT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，DBMS 将返回由查询产生的所有元组。你可以使用 &lt;code&gt;LIMIT&lt;/code&gt; 子句来限制结果元组的数量&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;login&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;LIKE&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;%@cs&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;LIMIT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;也可以提供一个偏移量来返回结果中的一个范围&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;login&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;LIKE&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#39;%@cs&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;LIMIT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;OFFSET&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;除非你使用带有&lt;code&gt;LIMIT&lt;/code&gt;的&lt;code&gt;ORDER BY&lt;/code&gt;子句，否则每次调用的结果中的元组可能是不同的。&lt;/p&gt;
&lt;h3 id=&#34;嵌套查询&#34;&gt;嵌套查询&lt;/h3&gt;
&lt;p&gt;在其他查询中调用查询，以在单个查询中执行更复杂的逻辑。外部查询的范围包括在内部查询中（即内部查询可以访问外部查询的属性），但不能反过来。&lt;/p&gt;
&lt;p&gt;内部查询几乎可以出现在查询的任何地方&lt;/p&gt;
&lt;p&gt;从输出结果&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;one&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从子句&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;enrolled&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从 WHERE 子句&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;student&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;IN&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;enrolled&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;嵌套查询结果表达式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ALL: 必须满足子查询中所有记录的表达式。&lt;/li&gt;
&lt;li&gt;ANY: 必须满足子查询中至少一条记录的表达式。&lt;/li&gt;
&lt;li&gt;IN: 相当于 ANY()&lt;/li&gt;
&lt;li&gt;EXISTS: 至少有一条记录被返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;窗口函数&#34;&gt;窗口函数&lt;/h3&gt;
&lt;p&gt;在一组元组中执行 &amp;ldquo;移动 &amp;ldquo;计算。像聚合操作，但它仍然返回原始元组&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Functions&lt;/code&gt; 可以是我们上面讨论的任何一个聚合函数。也可以是一个特殊的窗口函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ROW NUMBER：当前行的编号。&lt;/li&gt;
&lt;li&gt;RANK：当前行的顺序位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Grouping&lt;/code&gt; The &lt;code&gt;OVER&lt;/code&gt; clause specifies how to group together tuples when computing the window function. Use &lt;code&gt;PARTITION BY&lt;/code&gt; to specify group.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;ROW_NUMBER&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;OVER&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;PARTITION&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;enrolled&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你也可以在&lt;code&gt;OVER&lt;/code&gt;中放一个&lt;code&gt;ORDER BY&lt;/code&gt;，以确保即使数据库内部发生变化，结果的排序也是确定不变的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;ROW_NUMBER&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;OVER&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;enrolled&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cid&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;重要提示：DBMS 在窗口函数排序后计算 &lt;code&gt;RANK&lt;/code&gt;，而在排序前计算 &lt;code&gt;ROW_NUMBER&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;公共表表达式&#34;&gt;公共表表达式&lt;/h3&gt;
&lt;p&gt;公共表表达式（CTE）是窗口或嵌套查询的一种替代方法，可以用来编写更复杂的查询。我们可以把 CTE 看作是一个临时表，只用于一个查询。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WITH&lt;/code&gt; 子句将内部查询的输出与具有该名称的临时结果结合起来。生成一个名为 &amp;ldquo;cteName&amp;quot;的 CTE，它包含一个单一属性设置为 &amp;ldquo;1&amp;rdquo; 的元组。然后底部的查询只是返回 &amp;ldquo;cteName &amp;ldquo;的所有属性。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;WITH&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cteName&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cteName&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可以在 AS 之前将输出列与名称绑定。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;WITH&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cteName&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;col1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;col2&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;col1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;col2&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cteName&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个查询可以包含多个 CTE 声明。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;WITH&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cte1&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;col1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;),&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cte2&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;col2&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cte1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cte2&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在&lt;code&gt;WITH&lt;/code&gt;后面添加&lt;code&gt;RECURSIVE&lt;/code&gt;关键字允许 CTE 引用自己。&lt;/p&gt;
&lt;p&gt;例子。打印从 1 到 10 的数字序列。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;WITH&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;RECURSIVE&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cteSource&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;counter&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;UNION&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;counter&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cteSource&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;counter&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;cteSource&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>CMU::15-445/645::Relational Model 笔记</title>
      <link>/notes/cmu_15_445_01_note/</link>
      <pubDate>Sat, 31 Jul 2021 01:51:13 +0800</pubDate>
      <guid>/notes/cmu_15_445_01_note/</guid>
      <description>&lt;h2 id=&#34;关系模型和关系代数&#34;&gt;关系模型和关系代数&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/0W1wSYn.png&#34; alt=&#34;0W1wSYn&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据库&#34;&gt;数据库&lt;/h3&gt;
&lt;p&gt;数据库是一个有组织的相互关联的数据集合，它对现实世界的某些方面进行建模。数据库是很多计算机应用的核心部分。人们经常将&lt;code&gt;数据库&lt;/code&gt;与&lt;code&gt;数据库管理系统&lt;/code&gt;(比如 MyQSL，Oracle，MongoDB)相混淆，数据库管理系统是指管理数据库的软件。&lt;/p&gt;
&lt;h3 id=&#34;文本文件稻草人&#34;&gt;文本文件稻草人&lt;/h3&gt;
&lt;p&gt;数据库被存储为 DBMS 管理的逗号分隔值（CSV）文件。每个实体将被存储在它自己的文件中。应用程序每次要读取或更新记录时，都必须解析文件。每个每个实体都有自己的属性集，所以在每个文件中，不同的记录都用新的行来分隔，而记录中的每个而记录中的每个相应的属性都用逗号隔开。继续沿用数字音乐商店的例子，会有两个文件：一个是艺术家文件，另一个是专辑。一个艺术家可以有一个名字、年份和国家属性，而一张专辑有名字、艺术家和年份属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/J7czXgM.png&#34; alt=&#34;J7czXgM&#34;&gt;&lt;/p&gt;
&lt;p&gt;查询 Ice Cube 解散的年份&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/CFu6bLL.png&#34; alt=&#34;ICFu6bL&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;无格式文件的问题&#34;&gt;无格式文件的问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据完整性
&lt;ul&gt;
&lt;li&gt;我们如何确保每个专辑条目中的艺术家是相同的？&lt;/li&gt;
&lt;li&gt;如果有人用一个无效的字符串覆盖了专辑年份怎么办？&lt;/li&gt;
&lt;li&gt;我们如何存储一张专辑中有多个艺术家的情况？&lt;/li&gt;
&lt;li&gt;如果我们删除了一个有专辑的艺术家会发生什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现
&lt;ul&gt;
&lt;li&gt;你如何找到一个特定的记录？&lt;/li&gt;
&lt;li&gt;如果我们现在想创建一个使用相同数据库的新应用程序，该怎么办？&lt;/li&gt;
&lt;li&gt;如果两个线程试图同时写到同一个文件怎么办？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;持久性
&lt;ul&gt;
&lt;li&gt;如果我们的程序在更新一条记录时机器崩溃了怎么办？&lt;/li&gt;
&lt;li&gt;如果我们想在多台机器上复制数据库以获得高可用性怎么办？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据库管理系统&#34;&gt;数据库管理系统&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DBMS 是一种允许应用程序在数据库中存储和分析信息的软件&lt;/li&gt;
&lt;li&gt;通用的 DBMS 被能够定义、创建、查询、更新和管理数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;早期数据库&#34;&gt;早期数据库&lt;/h4&gt;
&lt;p&gt;数据库应用很难建立和维护，因为逻辑层和物理层之间存在着紧密的耦合。&lt;/p&gt;
&lt;p&gt;逻辑层是指数据库有哪些实体和属性，而物理层是指这些实体和属性是如何被存储的。&lt;/p&gt;
&lt;p&gt;早期，物理层是在应用程序代码中定义的，所以如果我们想改变应用程序正在使用的物理层，我们就必须改变所有的代码来匹配新的物理层。&lt;/p&gt;
&lt;p&gt;随着人工成本超过物理成本，这种做法逐渐不可接受，Codd 发布了关于数据关系模型的&lt;a href=&#34;http://dl.acm.org/citation.cfm?id=1558336&#34;&gt;论文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/N5XTGyo.png&#34; alt=&#34;N5XTGyo&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;关系模型&#34;&gt;关系模型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;关系模型三个关键点
&lt;ul&gt;
&lt;li&gt;以简单的数据结构（关系）存储数据库&lt;/li&gt;
&lt;li&gt;通过高级语言访问数据&lt;/li&gt;
&lt;li&gt;物理存储由实现决定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据模型是描述数据库中数据的概念的集合。关系模型是一个数据模型的例子&lt;/p&gt;
&lt;p&gt;模式是对一个特定的数据集合的描述，使用一个给定的数据模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/OCpfN5r.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;关系型数据库定了三个概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构。关系的定义和它们的内容。这就是关系所具有的属性和这些属性可以持有的值&lt;/li&gt;
&lt;li&gt;完整性。确保数据库的内容满足约束。一个约束的例子是年份属性的任何值都必须是一个数字&lt;/li&gt;
&lt;li&gt;操作性。如何访问和修改数据库的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关系是一个无序的集合，包含代表实体的属性关系。由于关系是无序的，DBMS 可以以任何方式存储它们，允许进行优化&lt;/p&gt;
&lt;p&gt;&lt;code&gt;元组&lt;/code&gt;是关系中的一组属性值（也被称为它的域）。最初，值必须是原子或标量，现在值也可以是列表或嵌套数据结构。每个属性都可以是一个特殊的值 &lt;code&gt;NULL&lt;/code&gt;，即属性是未定义的&lt;/p&gt;
&lt;p&gt;一个有 n 个属性的关系被称为 &lt;code&gt;n-ary&lt;/code&gt; 关系&lt;/p&gt;
&lt;h4 id=&#34;键值&#34;&gt;键值&lt;/h4&gt;
&lt;p&gt;一个关系的&lt;code&gt;主键&lt;/code&gt;唯一地标识了一个单一的元组。如果你没有定义一个主键，一些 DBMS 会自动创建一个内部主键。很多 DBMS 都支持自动生成的键，所以应用程序不必手动增加键&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/4QOAVXN.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;外键&lt;/code&gt;指定了一个关系中的属性必须映射到另一个关系中的元组&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/L1ywqjO.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据操作语言-dml&#34;&gt;数据操作语言 DML&lt;/h3&gt;
&lt;p&gt;一种从数据库中存储和检索信息的语言。在这方面有两类语言可选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过程式。查询指定 DBMS 应该使用的策略来寻找所需的结果&lt;/li&gt;
&lt;li&gt;声明式。查询只指定想要什么数据，而不是如何找到它&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关系代数&#34;&gt;关系代数&lt;/h3&gt;
&lt;p&gt;关系代数是一组基本操作，用于检索和操作关系中的元组。每个运算符接受一个或多个关系作为输入，并输出一个新的关系。为了编写查询，我们可以将这些运算符连接起来，以创建更复杂的运算&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/fUnCphL.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;选择-sigma&#34;&gt;选择 \(\sigma\)&lt;/h4&gt;
&lt;p&gt;接收一个关系，并从该关系中输出一个满足选择谓词的元组的子集。谓词的作用就像一个过滤器，我们可以使用连接词和非连接词来组合多个谓词&lt;/p&gt;
&lt;p&gt;语法: \(\sigma_{predicate}(R)\)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Bb398KD.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;投影-pi&#34;&gt;投影 \(\pi\)&lt;/h4&gt;
&lt;p&gt;接收一个关系并输出一个只包含指定属性的元组的关系。你可以在输入的关系中重新安排属性的顺序，也可以操作这些值&lt;/p&gt;
&lt;p&gt;语法: \(\pi_{A1,A2,. . . ,An}(R)\)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/N0hT53f.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;并集-cup&#34;&gt;并集 \(\cup\)&lt;/h4&gt;
&lt;p&gt;接收两个关系并输出一个关系，该关系包含至少出现在一个关系中的所有元组。这两个输入关系必须具有完全相同的属性&lt;/p&gt;
&lt;p&gt;语法: (R \(\cup\) S)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/7ZpqLxR.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;交集-cap&#34;&gt;交集 \(\cap\)&lt;/h4&gt;
&lt;p&gt;接收两个关系，并输出一个包含所有在输入关系中出现的元组的关系。这两个输入关系必须具有完全相同的属性&lt;/p&gt;
&lt;p&gt;语法: (R \(\cap\) S)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Gos9rey.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;差集--&#34;&gt;差集 -&lt;/h4&gt;
&lt;p&gt;接收两个关系并输出一个关系，该关系包含出现在第一个关系中的所有元组但不在第二个关系中。注意：两个输入关系必须有完全相同的属性&lt;/p&gt;
&lt;p&gt;语法: (R - S)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/GBXU512.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;叉积-times&#34;&gt;叉积 \(\times\)&lt;/h4&gt;
&lt;p&gt;接收两个关系，并输出一个关系，该关系包含了所有可能的元组组合，这些元组来自输入关系的所有可能组合&lt;/p&gt;
&lt;p&gt;语法: (R \(\times\) S)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/qCz8Yxw.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;连接-bowtie&#34;&gt;连接 \(\bowtie\)&lt;/h4&gt;
&lt;p&gt;接收两个关系，并输出一个关系，该关系包含两个元组的所有组合。其中对于两个关系共享的每个属性，两个元组的属性的值都是相同&lt;/p&gt;
&lt;p&gt;语法: (R \(\bowtie\) S)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/BpiLSYm.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;其他关系代数&#34;&gt;其他关系代数&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/MNmTNR5.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;观察&#34;&gt;观察&lt;/h3&gt;
&lt;p&gt;关系代数是一种过程式语言，因为它定义了如何计算一个查询的高级步骤。例如，\(\sigma_{b\_id=102}(R \bowtie S)\)是说先做 R 和 S 的连接，然后再做选择，而\((R \bowtie (\sigma_{b\_id=102}(S))\)会先对 S 做选择，然后再做连接。这两个语句实际上会产生相同的答案，但是如果在 10 亿个元组中，S 中只有 1 个 b_id=102 的元组那么的连接，然后再做选择，而\((R \bowtie (\sigma_{b\_id=102}(S))\) 将明显快于 \(\sigma_{b\_id=102}(R \bowtie S)\)。&lt;/p&gt;
&lt;p&gt;一个更好的方法是说出你想要的结果，并让 DBMS 决定它要采取的步骤来计算这个查询。SQL 正是这样做的，它是在关系模型数据库上编写查询的事实上的标准。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编程::现代操作系统</title>
      <link>/reading/modern_operating_systems/</link>
      <pubDate>Sat, 24 Jul 2021 19:12:26 +0800</pubDate>
      <guid>/reading/modern_operating_systems/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_introduction&#34;&gt;现代操作系统::引论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_process_and_thread&#34;&gt;现代操作系统::进程与线程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_memory_manage&#34;&gt;现代操作系统::内存管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_file_system&#34;&gt;现代操作系统::文件系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_input_output&#34;&gt;现代操作系统::输入/输出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_deadlock&#34;&gt;现代操作系统::死锁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_virtualization_and_the_cloud&#34;&gt;现代操作系统::虚拟化与云&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_multiple_processor_systems&#34;&gt;现代操作系统::多处理器系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_security&#34;&gt;现代操作系统::系统安全&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_operating_system_design&#34;&gt;现代操作系统::操作系统设计&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>现代操作系统::操作系统设计</title>
      <link>/notes/modern_operating_systems_operating_system_design/</link>
      <pubDate>Fri, 23 Jul 2021 02:11:01 +0800</pubDate>
      <guid>/notes/modern_operating_systems_operating_system_design/</guid>
      <description>&lt;h2 id=&#34;操作系统设计&#34;&gt;操作系统设计&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;设计问题的本质
&lt;ul&gt;
&lt;li&gt;目标
&lt;ul&gt;
&lt;li&gt;定义抽象概念
&lt;ul&gt;
&lt;li&gt;进程、文件、线程、信号量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提供基本操作
&lt;ul&gt;
&lt;li&gt;每一个抽象概念可以通过具体数据结构的形式来实例化。用户可以创建进程、文件、信号量等。基本操作则处理这些数据结构。例如，用户可以读写文件。基本操作以系统调用的形式实现。从用户的观点来看，操作系统的核心是由抽象概念与其上的基本操作所构成的，而基本操作则可通过系统调用加以利用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;确保隔离
&lt;ul&gt;
&lt;li&gt;用户之间的隔离&lt;/li&gt;
&lt;li&gt;虚拟机之间的隔离&lt;/li&gt;
&lt;li&gt;进程之间的隔离&lt;/li&gt;
&lt;li&gt;故障隔离&lt;/li&gt;
&lt;li&gt;资源共享&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;管理硬件
&lt;ul&gt;
&lt;li&gt;提供一个框架，统一管理不同型号的硬件资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;难点
&lt;ul&gt;
&lt;li&gt;已经发展成了极其复杂的程序&lt;/li&gt;
&lt;li&gt;必须处理并发和并发导致竞争条件、死锁等问题。&lt;/li&gt;
&lt;li&gt;必须处理可能有敌意的用户&lt;/li&gt;
&lt;li&gt;需要提供在不同用户之间共享资源的能力&lt;/li&gt;
&lt;li&gt;设计人员需要思考未来的操作系统设计方向&lt;/li&gt;
&lt;li&gt;需要提供想当程度的通用性&lt;/li&gt;
&lt;li&gt;可移植性&lt;/li&gt;
&lt;li&gt;需要保持向后兼容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接口设计
&lt;ul&gt;
&lt;li&gt;指导原则
&lt;ul&gt;
&lt;li&gt;简单：一个简单的接口更加易于理解并且更加易于以无差错的方式实现&lt;/li&gt;
&lt;li&gt;完备：接口必须能够做用户需要做的一切事情，也就是说，它必须是完备的&lt;/li&gt;
&lt;li&gt;效率：如果一个功能特性或者系统调用不能够有效地实现，或许就不值得包含它。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;范型
&lt;ul&gt;
&lt;li&gt;用户界面范型：不管选择什么范型，重要的是所有应用程序都要使用它。因此，系统设计者需要提供库和工具包给应用程序开发人员，使他们能够访问产生一致的外观与感觉的程序。没有工具，应用开发者做出来的东西可能完全不同。&lt;/li&gt;
&lt;li&gt;执行范型：
&lt;ul&gt;
&lt;li&gt;算法范型：启动一个程序是为了执行某个功能，而该功能是事先知道的或者是从其参数获知的。&lt;/li&gt;
&lt;li&gt;事件驱动范型：在这里程序执行某种初始化（例如通过显示某个屏幕），然后等待操作系统告诉它第一个事件。事件经常是键盘敲击或鼠标移动。这一设计对干高度交互式的程序是十分有益的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据范型：
&lt;ul&gt;
&lt;li&gt;一切皆磁带：在早期的 FORTRAN 批处理系统中，所有一切都是作为连续的磁带来建立模型。用于读入的卡片组被看作输入磁带，用于穿孔的卡片组被看作输出磁带，井且打印机给出被看作输出磁带。磁盘文件也被看作磁带&lt;/li&gt;
&lt;li&gt;一切皆文件：UNIX 用”所有一切都是文件”的模型一步发展了这一思想。使用这一范型，所有 I/O 设备都被看作文件，井且可以像普通文件一样打开和操作。&lt;/li&gt;
&lt;li&gt;一切皆对象：Windows 试图使所有一切看起来像是一个对象。一旦一个进程获得了一个指向文件、进程、信号量、 邮箱或者其他内核对象的有效句柄，它就可以在其上执行操作。这一范型甚至比 UNIX 更加一般化，井且比 FORTRAN 要一般化得多。&lt;/li&gt;
&lt;li&gt;一切皆文档：Web 背后的范型是充满了文档的超空间，每一个文档具有一个 URL。通过键人一个 URL 或者点击被 URL 所支持的条目，你就可以得到该文档。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统调用接口
&lt;ul&gt;
&lt;li&gt;操作系统应该提供恰好够用的系统调用，井且每个系统调用都应该尽可能简单&lt;/li&gt;
&lt;li&gt;在某些情况下，系统调用可能需要若干变体，但是通常比较好的实现是具有处理一般情况的一个系统调用，而由不同的库过程向程序员隐藏这一事实。&lt;/li&gt;
&lt;li&gt;添加更多的代码就是添加更多的程序错误&lt;/li&gt;
&lt;li&gt;不要隐藏能力，如果硬件具有极其高效的方法做某事，它就应该以简单的方法展露给程序员&lt;/li&gt;
&lt;li&gt;任何面向连接的机制与无连接的机制之间的权衡在于建立连接的机制（例如打开文件）要求的额外开销，&lt;/li&gt;
&lt;li&gt;与系统调用接口有关的另一个问题是接口的可见性。 POSIX 强制的系统调用列表很容易找到。Microsoft 从未将 Windows 系统调用列表公开。作为替代，Win API 和其他 API 被公开了，但是这些 API 包含大量的库调用（超过 10000 个），只有很少数是其正的系统调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现
&lt;ul&gt;
&lt;li&gt;系统结构
&lt;ul&gt;
&lt;li&gt;分层系统：对于一个新系统，选择走这一路线的设计人员应该首先非常仔细地选择各个层次，井且定义每个层次的功能。底层应该总是试图隐藏硬件最糟糕的特异性&lt;/li&gt;
&lt;li&gt;外内核：他们的观点基干端到端问题，某件事情必须由用户程序本身去完成，在一个较低的层次做同样的事情就是浪费。端到端问题可以扩展到几乎所有操作系统。它主张不要让操作系统做用户程序本身可以做的任何事情。&lt;/li&gt;
&lt;li&gt;在让操作系统做每件事情和让操作系统什么也不做之间的折衷是让操作系统做一点事情。这一设计导致微内核的出现，它让操作系统的大部分作为用户级的服务器进程而运行，在所有设计中这是最模块化和最灵活的。在灵活性上的极限是让每个设备驱动程序也作为一个用户进程而运行，从而完全保护内核和其他驱动程序，但是让设备驱动程序运行在内核会增加模块化程度。&lt;/li&gt;
&lt;li&gt;可扩展的系统：将更多的模块放到内核中，但是以一种“受保护的”方式。可扩展的系统自身井不是构造一个操作系统的方法。然而，通过以一个只是包含保护机制的 朵小系统为开端，然后每次将受保护的模块添加到内核中，直到达到期望的功能，对千手边的应用而言一个最小的系统就建立起来了 。&lt;/li&gt;
&lt;li&gt;内核线程：无论选择哪种结构模型，允许存在与任何用户进程相隔离的内核线程是很方便的。这些线程可以在后台运行，将脏页面写入磁盘，在内存和磁盘之间交换进程，如此等等。实际上，内核本身可以完全由这样的线程构成，所以当一个用户发出系统调用时，用户的线程并不是在内核模式中运行，而是阻塞井且将控制传给一个内核线程，该内核线程接管控制以完成工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;机制与策略
&lt;ul&gt;
&lt;li&gt;另一个有助于体系结构一致性的原理是机制与策略的分离，该原理同时还有助于使系统保持小型和良好的结构。通过将机制放入操作系统而将策略留给用户进程，即使存在改变策略的需要，系统本身也可以保持不变。即使策略模块必须保留在内核中，它也应该尽可能地与机制相隔离，这样策略模块中的变化就不会影响机制模块。&lt;/li&gt;
&lt;li&gt;对于线程调度，机制负责从高优先级到低优先级调度线程，策略负责制定线程优先级&lt;/li&gt;
&lt;li&gt;对于内存分页，机制负责把页面在内存和磁盘之间换入换出，策略绝地交换是局部的还是全局的，是 LRU 还是 FIFO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正交性
&lt;ul&gt;
&lt;li&gt;良好的系统设计在于单独的概念可以独立地组合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;命名
&lt;ul&gt;
&lt;li&gt;操作系统大多数较长使用的数据结构都具有某种名字或标识符，通过这些名字或标识符就可以引用这些数据结构。显而易见的例子有注册名、文件名、设备名、进程 ID 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;绑定的时机
&lt;ul&gt;
&lt;li&gt;操作系统使用多种类型的名字来引用对象。有时在名字和对象之间的映射是固定的，但是有时不是。在后一种情况下，何时将名字与对象绑定可能是很重要的。一般而言，早期绑定(early binding) 是简单的，但是不灵活，而晚期绑定(late binding) 则比较复杂，但是通常更加灵活。&lt;/li&gt;
&lt;li&gt;操作系统对大多数数据结构通常使用早期绑定，但是偶尔为了灵活性也使用晚期绑定。内存分配是一个相关的案例。在缺乏地址重定位硬件的机器上，早期的多道程序设计系统不得不在某个内存地址装载一个程序，井且对其重定位以便在此处运行。如果它曾经被交换出去，那么它就必须装回到相同的内存地址，否则就会出错。相反，页式虚拟内存是晚期绑定的一种形式。在页面被访问并且实际装入内存之前，与一个给定的虚拟地址相对应的实际物理地址是不知道的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;静态与动态结构
&lt;ul&gt;
&lt;li&gt;操作系统设计人员经常被迫在静态与动态数据结构之间进行选择。静态结构总是简单易懂，更加容易编程井且用起来更快，动态结构则更加灵活。一个显而易见的例子是进程表。早期的系统只是分配一个固定的数组，存放每个进程结构。如果进程表由 256 项组成，那么在任意时刻只能存在 256 个进程。试图创建第 257 个进程将会失败，因为缺乏表空间。类似的考虑对于打开的文件表以及许多其他内核表格也是有效的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自顶向下与自底向上的实现
&lt;ul&gt;
&lt;li&gt;虽然最好是自顶向下地设计系统，但是在理论上系统可以自顶向下或者自底向上地实现。在自顶向下的实现中，实现者以系统调用处理程序为开端，并且探究需要什么机制和数据结构来支持它们。接着写这些过程等，直到触及硬件。&lt;/li&gt;
&lt;li&gt;这种方法的问题是，由于只有顶层过程可用，任何事情都难于测试。出于这样的原因，许多开发入员发现实际上自底向上地构建系统更加可行。这一方法需要首先编写隐藏底层硬件的代码。中断处理程序和时钟驱动程序也是早期就需要的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步通信与异步通信
&lt;ul&gt;
&lt;li&gt;对干系统设计者，在正确编程模型的决定上是一个艰难但是很重要的问题。这场论战没有冠军。像 apache 这样的 Web 服务器坚决拥护异步通信，但是 lighnpd 等其他服务器则基干事件驱动模式。两者都非常受欢迎。在我们看来，事件相比于线程更加容易理解和调试。只要没有多核并发的需要，事件很可能是一个好的选择。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实用技术
&lt;ul&gt;
&lt;li&gt;隐藏硬件：许多硬件是十分麻烦的，所以只好尽早将其隐藏起来&lt;/li&gt;
&lt;li&gt;引用：通过一个索引来找到另一个实体&lt;/li&gt;
&lt;li&gt;可重用性：在略微不同的上下文中重用相同的代码通常是可行的。&lt;/li&gt;
&lt;li&gt;重入：重入指的是代码同时被执行两次或多次的能力。&lt;/li&gt;
&lt;li&gt;蛮力法：在一些代码上不值得优化或优化代价很大，就不必优化&lt;/li&gt;
&lt;li&gt;首先检查错误：系统调用可能由千各种各样的原因而执行失败：要打开的文件属于他人、因为进程表满而创建进程失败、或者因为目标进程不存在而使信号不能被发送。操作系统在执行调用之前必须无微不至地检查每一个可能的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能
&lt;ul&gt;
&lt;li&gt;操作系统为什么运行缓慢
&lt;ul&gt;
&lt;li&gt;硬件检查、初始化、功能多&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;什么应该优化
&lt;ul&gt;
&lt;li&gt;唯一的优化应该是那些显而易见要成为不可避免的问题的事情&lt;/li&gt;
&lt;li&gt;性能一旦达到一个合理的水平，榨出最后一点百分比的努力和复杂性或许并不值得&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空间-时间的权衡
&lt;ul&gt;
&lt;li&gt;改进性能的一种一般性的方法是权衡时间与空间。在一个使用很少内存但是速度比较慢的莽法与一个使用很多内存但是速度更快的算法之间进行选择，这在计算机科学中是经常发生的事情。在做出重要的优化时，值得寻找通过使用更多内存加快了速度的算法，或者反过来通过做更多的计算节省了宝贵的内存的算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缓存
&lt;ul&gt;
&lt;li&gt;用于改进性能的一项众所周知的技术是缓存。在任何相同的结果可能需要被获取多次的情况下，缓存都是适用的。一般的方法是首先做完整的工作，然后将结果保存在缓存中。对于后来的获取结果的工作，首先要检查缓存。如果结果在缓存中，就使用它。否则、再做完整的工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线索
&lt;ul&gt;
&lt;li&gt;缓存项总是正确的。缓存搜索可能失败，但是如果找到了一项，那么这一项保证是正确的井且无需再费周折就可以使用。在某些系统中，包含线索(hint)的表是十分便利的。这些线索是关于答案的提示，但是它们并不保证是正确的。调用者必须自行对结果进行验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用局部性
&lt;ul&gt;
&lt;li&gt;进程和程序的行为井不是随机的，它们在时间上和空间上展现出相当程度的局部性，并且可以以各种方式利用该信息来改进性能。空间局部性的一个常见例子是：进程并不是在其地址空间内部随机地到处跳转的。在一个给定的时间间隔内．它们倾向于使用数目比较少的页面。进程正在有效地使用的页面可以被标记为它的工作集，井且操作系统能够确保当进程被允许运行时，它的工作集在内存中，这样就减少了缺页的次数。&lt;/li&gt;
&lt;li&gt;局部性起作用的另一个领域是多处理器系统中的线程调度，在多处理器上一种调度线程的方法是试图在最后一次用过的 CPU 上运行每个线程，期望它的某些内存块依然还在内存的缓存中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优化常见的情况
&lt;ul&gt;
&lt;li&gt;区分最常见的情况和最坏可能的情况井且分别处理它们，这通常是一个好主意。针对这两者的代码常常是相当不同的。重要的是要使常见的情况速度快。对于最坏的情况，如果它很少发生，使其正确就足够了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;项目管理
&lt;ul&gt;
&lt;li&gt;人月神话：
&lt;ul&gt;
&lt;li&gt;工作不可能完全并行化&lt;/li&gt;
&lt;li&gt;为了完全利用数目众多的程序员，工作必须划分成数目众多的模块，这样每个人才能有事情做。由于每个模块可能潜在地与每个其他模块相互作用，需要将模块－模块相互作用的数目看成随着模块数目的平方而培长，&lt;/li&gt;
&lt;li&gt;调试工作是高度序列化的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;团队结构
&lt;ul&gt;
&lt;li&gt;任何大型项目都需要组织成层次结构。底层是许多小的团队，每个团队由首席程序员领导。在下一层，必须由一名经理人对一组团队进行协调。经验表明，你所管理的每一个人将花费你 10% 的时间，所以每组 10 个团队需要一个全职经理。这些经理也必须被管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;经验的作用
&lt;ul&gt;
&lt;li&gt;拥有丰富经验的设计人员对于一个操作系统项目来说至关重要。Brooks 指出，大多数错误不是在代码中，而是在设计中。程序员正确地做了吩咐他们要做的事情，而吩咐他们要做的事情是错误的。再多测试软件都无法弥补糟糕的设计说明书。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;没有银弹
&lt;ul&gt;
&lt;li&gt;或许在下一个十年将会看到一颗银弹，或许我们将只好满足于逐步的、渐进的改进。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统设计的趋势
&lt;ul&gt;
&lt;li&gt;虚拟化与云&lt;/li&gt;
&lt;li&gt;众核芯片&lt;/li&gt;
&lt;li&gt;大型地址空间操作系统&lt;/li&gt;
&lt;li&gt;无缝的数据访问&lt;/li&gt;
&lt;li&gt;电池供电的计算机&lt;/li&gt;
&lt;li&gt;嵌入式系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>现代操作系统::安全</title>
      <link>/notes/modern_operating_systems_security/</link>
      <pubDate>Thu, 22 Jul 2021 02:11:01 +0800</pubDate>
      <guid>/notes/modern_operating_systems_security/</guid>
      <description>&lt;h2 id=&#34;安全&#34;&gt;安全&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;环境安全
&lt;ul&gt;
&lt;li&gt;威胁
&lt;ul&gt;
&lt;li&gt;很多安全方面的文章将信息系统的安全分解为三个部分：机密性，完整性和可用性。
&lt;ul&gt;
&lt;li&gt;机密性：指的是将机密的数据置于保密状态。更确切地说，如果数据所有者决定这些数据仅用于特定的人，那么系统就应该保证数据绝对不会发布给未经授权的人。&lt;/li&gt;
&lt;li&gt;完整性：指未经授权的用户没有得到许可就擅自改动数据&lt;/li&gt;
&lt;li&gt;可用性：没哟人可以扰乱系统使之瘫痪&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;后来，人们认为三个基本属性不能满足所有场景，因此又增添了一些额外属性，例如真实性、可审 计性、不可否认性、隐私性以及一些其他诸如此类的属性&lt;/li&gt;
&lt;li&gt;安全工具对于攻击和防守都是有用的，具有双重用途这一属性&lt;/li&gt;
&lt;li&gt;有时候攻击的影响会超越计算计机系统本身，对现实世界也会有影响。&lt;/li&gt;
&lt;li&gt;网络战，大型组织之间发动的攻击行为&lt;/li&gt;
&lt;li&gt;安全问题的另一个与保密性相关的重要方面是隐私 (privacy). 即保证私人的信息不披滥用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;入侵者
&lt;ul&gt;
&lt;li&gt;从安全性的角度来说，那些喜欢闯入与自已毫不相干区域的人叫作攻击者(anacker)、入侵者(intruder) 或敌人(adversary)&lt;/li&gt;
&lt;li&gt;攻击者的范围从技术不是很精湛的黑客爱好者（也称为脚本爱好者），到极其精通技术的黑客。他们可能专门为了罪犯、政府（如警察、军队或者情技部门）或者安全公司工作，或者只是在业余时间开展“黑客”行为的业余爱好者。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统安全
&lt;ul&gt;
&lt;li&gt;攻击分为被动攻击与主动攻击。被动攻击试图窃取信息，而主动攻击会使计算机程序行为异常。&lt;/li&gt;
&lt;li&gt;我们也将加密和程序加固区分开来。加密是将一个消息或者文件进行转码，除非获得密的密钥，否则很难恢复出原信息。程序加固是指在程序中加入保护机制从而使得攻击者很难破坏程序。操作系统在很多地方使用加密：在网络上安全传输据，在硬盘上安全存储文件，将密码存储在密码文件中等。&lt;/li&gt;
&lt;li&gt;可信系统
&lt;ul&gt;
&lt;li&gt;为什么不去做一个安全的操作系统
&lt;ul&gt;
&lt;li&gt;现代系统虽然不安全但是用户不愿抛弃它们&lt;/li&gt;
&lt;li&gt;现在已知的建立安全系统仅有的办法是保持系统的简单性。特性是安全的大敌。
&lt;ul&gt;
&lt;li&gt;邮件的多媒体文件&lt;/li&gt;
&lt;li&gt;HTML 中的可执行脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可信计算基
&lt;ul&gt;
&lt;li&gt;在安全领域中，人们通常讨论可信系统而不是安全系统．这些系统在形式上申明了安全要求并满足了这些安全要求。每一个可信系统的核心是最小的可信计算基,其中包含了实施所有安全规则所必需的硬件和软件。如果这些可信计算基根据系统规约工作，那么，无论发生了什么错误，系统安全性都不会受到威胁。&lt;/li&gt;
&lt;li&gt;典型的 TCB 包括了大多数的硬件（除了不影响安全性的 I/O 设备）、操作系统核心中的一部分、大多数或所有掌握超级用户权限的用户程序（如 UNIX 中的 SETUID 根程序）等。必须包含在 TCB 中的操作系统功能有：进程创建、进程切换、内存面管理以及部分的文件和 I/O 管理。在安全设计中、为了减少空间以及纠正错误，TCB 通常完全独立于操作系统的其他部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保护机制
&lt;ul&gt;
&lt;li&gt;保护域
&lt;ul&gt;
&lt;li&gt;域(domain)是（对象，权限）对的集合。每一对组合指定一个对象和一些可在其上运行的操作子集。这里权限 (right) 是指对某个操作的执行许可。通常域相当于单个用户，告诉用户可以做什么不可以做什么，当然有时域的范围比用户要更广。&lt;/li&gt;
&lt;li&gt;任何时间，每个进程会在某个保护域中运行。换句话说，进程可以访问某些对象的集合，每个对象都有一个权限集。进程运行时也可以在不同的域之间切换。&lt;/li&gt;
&lt;li&gt;在 UNIX 系统中，使用相同(UID, GID)组合的两个进程访问的是完全一致的对象集合。使用不同(UID, GID)值的进程访问的是不同的文件集合，虽然这些文件有大量的重叠。&lt;/li&gt;
&lt;li&gt;而且，每个 UNIX 的进程有两个部分：用户部分和核心部分。当执行系统调用时，进程从用户部分切换到核心部分。核心部分可以访问与用户部分不同的对象集。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;访问控制列表
&lt;ul&gt;
&lt;li&gt;每一个文件关联一个列表，列表里包含了所有可访问对象的域以及这些域如何访问这些对象的方法。这一列表叫作访问控制列表&lt;/li&gt;
&lt;li&gt;每个文件对他特定用户和特定组拥有不同的权限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;权能字
&lt;ul&gt;
&lt;li&gt;每一个权能字赋予所有者针对特定对象的权限。一个权能字通常包含了文件（或者更一般的情况下是对象）的标识符和用于不同权限的位图。在类似 UNIX 的系统中，文件标识符可能是 i 节点号。权能字列表本身也是对象，也可以从其他权能字列表处指定，这样就有助于共享子域。ACL 和权能字具有一些彼此互补的特性。在部分操作系统中应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全系统的形式化模型
&lt;ul&gt;
&lt;li&gt;Harrison 等人 (1976) 在保护矩阵上确定了 6 种最基本的操作，这些操作可用作任何安全系统模型的基准。这些最基本的操作是 create object、delete object、create domain、delete domain、insert right 和 remove right。合并称为保护命令&lt;/li&gt;
&lt;li&gt;多级安全
&lt;ul&gt;
&lt;li&gt;大多数操作系统允许个人用户来决定谁可以读写他们的文件和其他对象。这一策略称为可自由支配的访问控制&lt;/li&gt;
&lt;li&gt;部分场景需要强制性的访问控制来确保所阐明的安全策峈被系统强制执行，而不是可自由支配的访问控制。这些强制性的访问控制管理整个信息流，确保不会泄漏那些不应该泄漏的信息。&lt;/li&gt;
&lt;li&gt;Bell-LaPadula 模型
&lt;ul&gt;
&lt;li&gt;简易安全规则：在密级 k 上面运行的进程只能读取同一密级或更低密级的对象。例如，将军可以读取中尉的文档，但中尉却不可以读取将军的文档。&lt;/li&gt;
&lt;li&gt;*规则： 在密级 k 上面运行的进程只能写同一密级或更高密级的对象。例如，中尉只能在将军的信箱添加信息告知自己所知的全部，但是将军不能在中尉的信箱里添加信息告知自己所知的全部，因为将军拥有绝密的文档，这些文档不能泄露给中尉。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Biba 模型：
&lt;ul&gt;
&lt;li&gt;简单完整性规则 ：在安全等级 k 上运行的进程只能写同一等级或更低等级的对象（没有往上写）。&lt;/li&gt;
&lt;li&gt;完整性＊规则：在安全等级 k 上运行的进程只能读同一等级或更高等级的对象（不能向下读）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;隐蔽信道
&lt;ul&gt;
&lt;li&gt;系统通过精心设计的方式来通信，而不被察觉&lt;/li&gt;
&lt;li&gt;隐写术：将信息编码到其他的文件中，用于隐蔽地泄漏信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;密码学原理
&lt;ul&gt;
&lt;li&gt;加密的目的是将明文一也就是原始信息或文件，通过某种手段变为密文，通过这种手段，只有经过授权的人才知道如何将密文恢复为明文。对无关的人来说，密文是一段无法理解的编码&lt;/li&gt;
&lt;li&gt;在算法中使用的加密参数叫作密钥 (key) 。如果 P 代表明文，从代表加密密钥，C 代表密文，E 代表加密算法法（即，函数），那么 \(C=E(P,K_E)\) 。这就是加密的定义&lt;/li&gt;
&lt;li&gt;私钥加密技术
&lt;ul&gt;
&lt;li&gt;对于给定了加密密钥就能够较为容易地找到解密密钥，反之亦然。这样的系统采用了私钥加密技术或对称密钥加密技术&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;公钥加密技术
&lt;ul&gt;
&lt;li&gt;这一体系的特点是加密密钥和解密密钥是不同的，并且当给出了一个筛选过的加密密钥后不可能推出对应的解密密钥。在这种特性下，加密密钥可被公开而只有解密密钥处于秘密状态。&lt;/li&gt;
&lt;li&gt;一种叫作 RSA 的公钥机制表明：对计算机来说，大数乘法比对大数进行因式分解要容易得多，特别是在使用取换算法进行运算且每个数字都有上百位时 。这种机制广泛应用干密码领域。其他广泛使用的还有离散对数 。公钥机制的主要问题在于运算速度要比对称密钥机制慢数千倍。&lt;/li&gt;
&lt;li&gt;当我们使用公钥密码体系时，每个人都拥有一对密钥（公钥和私钥）井把其中的公钥公开．公钥是加密密钥，私钥是解密密钥。通常密钥的运算是自动进行的，有时候用户可以自选密码作为算法的种子．在发送机密信息时，用接收方的公钥将明文加密。由于只有接收方拥有私钥，所以也只有接收方可以解密信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单向函数，我们将看到有些函数 f, 其特性是给定 f 和参数 x, 很容易计算出 y =f(x). 但是给定 f(x), 要找到相应的 x 却不可行。这种函数采用了十分复杂的方法把数字打乱&lt;/li&gt;
&lt;li&gt;数字签名
&lt;ul&gt;
&lt;li&gt;MD5，SHA-1，SHA-256，SHA-512&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可信平台模块
&lt;ul&gt;
&lt;li&gt;如何在不安全的系统中安全地保存密钥呢？该方法需要用到一种叫作可信平台模块 (Trusted Platform Modules,TPM) 的芯片。TPM 是一种加密处理器 (cryptoprocessor),使用内部的非易失性存储介质来保存密钥。该芯片用硬件实现数据的加密／解密操作，其效果与在内存中对明文块进行加密或对密文块进行解密的效果相同，TPM 同时还可以验证数字签名。由于其所有的操作都是通过硬件实现，因此速度比用软件实现快许多，也更可能被广泛地应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;认证
&lt;ul&gt;
&lt;li&gt;密码登陆认证：弱密码容易被猜到&lt;/li&gt;
&lt;li&gt;UNIX 密码，加盐：把密码作为输入，通过一个单项散列函数计算出结果作为密码&lt;/li&gt;
&lt;li&gt;一次性密码：提供一个密码列表，每一次登陆都需要使用新的密码&lt;/li&gt;
&lt;li&gt;挑战-响应认证：用户事先选择密钥 k, 并手工放置到服务器中。密钥的备份也被安全地存放在用户的计算机里。在登录时，服务器把随机产生的数 r 发送到用户端，由用户端计算出 f(r,k)的值。其中， f 是一个公开已知的函数。然后，服务器也做同样的运算看结果是否一致。&lt;/li&gt;
&lt;li&gt;使用物理识别的认证：验证一些用户所拥有的实际物体而不是用户所知道的信息，智能卡，物理密钥&lt;/li&gt;
&lt;li&gt;使用生物识别的验证方式：脸部识别，虹膜识别，指纹识别，声音识别&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件漏洞
&lt;ul&gt;
&lt;li&gt;缓冲区溢出攻击&lt;/li&gt;
&lt;li&gt;格式化字符串攻击&lt;/li&gt;
&lt;li&gt;悬垂指针&lt;/li&gt;
&lt;li&gt;空指针引用攻击&lt;/li&gt;
&lt;li&gt;整数溢出攻击&lt;/li&gt;
&lt;li&gt;命令注入攻击&lt;/li&gt;
&lt;li&gt;检查时间/使用时间攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内部攻击
&lt;ul&gt;
&lt;li&gt;逻辑炸弹&lt;/li&gt;
&lt;li&gt;后门陷阱&lt;/li&gt;
&lt;li&gt;登录欺诈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;恶意软件
&lt;ul&gt;
&lt;li&gt;特洛伊木马&lt;/li&gt;
&lt;li&gt;病毒
&lt;ul&gt;
&lt;li&gt;共事者病毒&lt;/li&gt;
&lt;li&gt;可执行程序病毒&lt;/li&gt;
&lt;li&gt;内存驻留病毒&lt;/li&gt;
&lt;li&gt;引导扇区病毒&lt;/li&gt;
&lt;li&gt;设备驱动病毒&lt;/li&gt;
&lt;li&gt;宏病毒&lt;/li&gt;
&lt;li&gt;源代码病毒&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;蠕虫&lt;/li&gt;
&lt;li&gt;间谍软件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;防御
&lt;ul&gt;
&lt;li&gt;防火墙&lt;/li&gt;
&lt;li&gt;反病毒技术&lt;/li&gt;
&lt;li&gt;代码签名&lt;/li&gt;
&lt;li&gt;囚禁&lt;/li&gt;
&lt;li&gt;基于模型的入侵检测&lt;/li&gt;
&lt;li&gt;封装移动代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关于安全的研究
&lt;ul&gt;
&lt;li&gt;二进制程序的保护&lt;/li&gt;
&lt;li&gt;密码学&lt;/li&gt;
&lt;li&gt;权限和访问控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>现代操作系统::多处理器系统</title>
      <link>/notes/modern_operating_systems_multiple_processor_systems/</link>
      <pubDate>Wed, 21 Jul 2021 02:11:01 +0800</pubDate>
      <guid>/notes/modern_operating_systems_multiple_processor_systems/</guid>
      <description>&lt;h2 id=&#34;多处理器系统&#34;&gt;多处理器系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;多处理机
&lt;ul&gt;
&lt;li&gt;共享存储器多处理机是这样一种计算机系统，其两个或更多的 CPU 全部共享访问一个公用的 RAM。&lt;/li&gt;
&lt;li&gt;CPU 可对存储器的某个字写入某个值，然后读回该字，并得到一个不同的值。在进行恰当组织时，这种性质构成了处理器间通信的基础:一个 CPU 向存储器写人某些数据而另一个读取这些数据。&lt;/li&gt;
&lt;li&gt;多处理器硬件
&lt;ul&gt;
&lt;li&gt;所有的多处理机都具有每个 CPUi 可访问全部存储器的性质&lt;/li&gt;
&lt;li&gt;UMA 多处理器读出每个存储器字的速度是一样快的，NUMA 没有这种特性&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://imgur.com/fotq9F5.png&#34;&gt;基于总线的 UMA 多处理器结构&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;两个或更多的 CPU 以及一个或多个存储器模块都使用同一个总线进行通信&lt;/li&gt;
&lt;li&gt;当一个 CPU 需要读一个存储器字 (memory word) 时，它首先检查总线忙否。 如果总线空闲，该 CPU 把所需字的地址放到总线上，发出若干控制信号，然后等待存储器把所需的字放到总线上。当 CPU 核数上升时，效率下降严重。&lt;/li&gt;
&lt;li&gt;解决方案是为每个 CPU 添加一个高速缓存
&lt;ul&gt;
&lt;li&gt;高速缓存可以位于 CPU 芯片的内部、 CPU 附近、在处理器板上或所有这三种方式的组合&lt;/li&gt;
&lt;li&gt;高速缓存 不以单个字为基础，而是以 32 字节或 64 字节块为基础&lt;/li&gt;
&lt;li&gt;高速缓存一致性协议
&lt;ul&gt;
&lt;li&gt;CPU 试图在一个或多个远程高速缓存中写入一个字，总线硬件检测到写，并把一个信号放到总线上通知所有其他的高速缓存。如果其他高速缓存有个“干净&amp;quot;的副本，也就是同存储器内容完全一样的副本，那么它们可以丢弃该副本井让写者在修改之前从存储器取出高速缓存块。如果某些其他高速缓存有&amp;quot;脏&amp;quot;(被修改过)副本，它必须在处理写之前把数据写回存储器或者把它通过总线直接传送到写者上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://i.imgur.com/hzKkxlq.png&#34;&gt;基于交叉开关的 UMA 多处理机&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;连接 n 个 CPU 到 K 个存储器的最简单的电路是交叉开关&lt;/li&gt;
&lt;li&gt;水平线(进线)和垂直线(出线)的每个相交位咒上是一个交叉点 (crosspoint)。交叉点是一个小 的电子开关，具体取决千水平线和垂直线是否偕要连接。&lt;/li&gt;
&lt;li&gt;非阻塞网络&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://i.imgur.com/pKoIru0.png&#34;&gt;使用多级交换网络的 UMA 多处理机&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;有一种完全不同的、基于简单 2 x 2 开关的多处理机设计。 这个开关有两个输入和两个输出。到达任意一个输入线的消息可以被交换至任意一个输出线上。就我们的目标而言，消息可由四个部分组成。Module (模块)域指明使用哪个存储器。Address (地址)域指定在模块中的地址。Opcode (操作码)给定了操作，如 READ 或 WRITE。最后，在可选的 Value (值)域中可包含一个操作数，比如一个要被 WRITE 写入的 32 位字。该开关检查 Module 域并利用它确定消息是应该送给 X 还是发送给 Y。&lt;/li&gt;
&lt;li&gt;这个 2 x 2 开关可有多种使用方式，用以构建大型的多级交换网络。 有一种是简单经济的 omega 网络，&lt;/li&gt;
&lt;li&gt;Omega 网络的接线模式常被称作全混洗(perfect shuffle)。&lt;/li&gt;
&lt;li&gt;接着看看 Omega 网络是如何工作的，假设 CPU 011 打算从存储器模块 110 读取一个字。CPU 发送 READ 消息给开关 1D, 它在 Module 域包含 110。ID 开关取 110 的首位(最左位)并用它进行路由处理。0 路由到上端输出，而 1 的路由到下端，由于该位为 1, 所以消息通过低端输出被路由到 2D。&lt;/li&gt;
&lt;li&gt;所有的第二级开关，包括 2D,取用第二个比特位进行路由。这.位还是 1，所以消息通过低端输出转发到 3D。在这里对第三位进行测试，结果发现是 0。于是，消息送往上端输出，并达到所期望的存储器 110。&lt;/li&gt;
&lt;li&gt;在消息通过交换网络之后，模块号的左端的位就不再需要了。它们可以有很好的用途，可以用来记录入线编号，这样，应答消息可以找到返回路径。对于路径 a，入线编号分别是 0 (向上输入到 1D)、1(低输入到 2D)，1(低输入到 3D)、使用 011 作为应答路由，只要从右向左读出每位即可。&lt;/li&gt;
&lt;li&gt;阻塞网络&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://i.imgur.com/rGiHg3S.png&#34;&gt;NUMA 多处理机&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;所有 NUMA 机器都具有以下三种关键特性，它们是 NUMA 与其他多处理机的主要区别:
&lt;ul&gt;
&lt;li&gt;具有对所有 CPU 都可见的单个地址空间。&lt;/li&gt;
&lt;li&gt;通过 LOAD 和 STORE 指令访问远程存储器。&lt;/li&gt;
&lt;li&gt;访问远程存储器慢于访问本地存储器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在对远程存储器的访问时间不被隐藏时(因为没有高速缓存)，系统被称为 NC-NUMA (No Cache NUMA,无高速缓存 NUMA)。在有一致性高速缓存时，系统被称为 CC-NUMA (Cache Coherent NUMA,高速缓存一致 NUMA)。&lt;/li&gt;
&lt;li&gt;目前构造大型 CC-NUMA 多处理机最常见的方法是基于目录的多处理机(directory-based multiprocessor)。其基本思想是，维护个数据库来记录高速缓存行的位置及其状态。当一个高速缓存行被引用时，就查询数据库找出高速缓存行的位置以及它是“干净”的还是“脏”的。由于每条访问存储器的指令都必须查询这个数据库，所以它必须配有极高速的专用硬件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多核芯片
&lt;ul&gt;
&lt;li&gt;CPU 拥有多于一个内核&lt;/li&gt;
&lt;li&gt;CPU 可能共享高速缓存或者不共享，但是它们都共享内存&lt;/li&gt;
&lt;li&gt;特殊的硬件电路可以确保在一个字同时出现在两个或者多个的高速缓存中的情况下，当其中某个 CPU 修改了该字，所有其他高速缓存中的该字都会被自动地并且原子性地删除来确保一致性。这个过程称为窥探&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;众核芯片
&lt;ul&gt;
&lt;li&gt;众核芯片是指包括几十、几百甚至成千上万个核心的多核处理器&lt;/li&gt;
&lt;li&gt;保持缓存一致性的机制会变得非常复杂和昂贵，一致性壁垒&lt;/li&gt;
&lt;li&gt;一些工程师认为，唯一已证明可适用于众核的编程模型是采用消息传递和分布式内存实现的。&lt;/li&gt;
&lt;li&gt;成千上万的核心数现在已不再那么少见了，图形处理单元(GPU)作为当今最为常见的众核。&lt;/li&gt;
&lt;li&gt;于几乎任何一台非嵌入式并且有显示器的计算机系统中。GPU 是一个拥有专用内存和成千上万个微小核的处理器则。因而它们十分擅长进行像图形程序渲染多边形这样的大量并行的小规模计算，而不太擅长串行任务，同时也很难对它们编程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异构多核
&lt;ul&gt;
&lt;li&gt;一些芯片会把一个 GPU 和一些通用处理器核封装在一起，许多片上系统在通用处理器核之外还包括一个或多个特殊用途的处理器。在一块芯片上封装了不同类型的处理器的系统袚统称为异构多核处理器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在多核上编程
&lt;ul&gt;
&lt;li&gt;当前的编程语言井不适合编写高度并行的程序，好的编译器和调试工具也很少见，程序员很少有井行编程的经验&lt;/li&gt;
&lt;li&gt;同步、消除资源竞争条件和避免死锁等问题就像噩梦一般&lt;/li&gt;
&lt;li&gt;应用场景&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多处理机操作系统类型
&lt;ul&gt;
&lt;li&gt;每个 CPU 有自己的操作系统
&lt;ul&gt;
&lt;li&gt;允许所有的 CPU 共享操作系统的代码，而且只需要提供数据的私有副本&lt;/li&gt;
&lt;li&gt;四个潜在的问题
&lt;ul&gt;
&lt;li&gt;首先，在一个进程进行系统调用时，该系统调用是在本机的 CPU 上被捕获并处理的，并使用操作系统表中的数据结构。&lt;/li&gt;
&lt;li&gt;其次，因为每个操作系统都有自己的表，那么它也有自己的进程集合，通过自身调度这些进程。&lt;/li&gt;
&lt;li&gt;第三，没有共享物理页面。会出现如下的情形:在 CPU2 不断地进行页面调度时 CPU1 却有多余的页面。由于内存分配是固定的，所以 CPU 2 无法向 CPU 1 借用页面。&lt;/li&gt;
&lt;li&gt;第四，也是最坏的情形，如果操作系统维护近期使用过的磁盘块的缓冲区高速缓存，每个操作系统都独自进行这种维护工作，因此，可能出现某一修改过的磁盘块同时存在于多个缓冲区高速缓存的情况，这将会导致不一致性的结果。避免这一问题的唯一途径是，取消缓冲区高速缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主从多机处理机
&lt;ul&gt;
&lt;li&gt;在这种模型中，操作系统的一个副本及其数据表都在 CPU 1 上，而不是在其他所有 CPU 上。为了在该 CPU 1 上进行处理，所有的系统调用都重定向到 CPU 1 上。如果有剩余的 CPU 时间，还可以在 CPU 1 上运行用户进程。这种模型称为主从模型( master-slave), 因为 CPU 1 是主 CPU，而其他的都是从属 CPU。&lt;/li&gt;
&lt;li&gt;主从模型解决了在第一种模型中的多数问题。有单一的数据结构(如一个链表或者一组优先级链表)用来记录就绪进程。当某个 CPU 空闲下来时，它向 CPU 1 上的操作系统请求一个进程运行，并被分配一个进程。这样，就不会出现一个 CPU 空闲而另一个过载的情形。类似地，可在所有的进程中动态地分配页面，而且只有一个缓冲区高速缓存，所以决不会出现不一致的情形。&lt;/li&gt;
&lt;li&gt;这个模型的问题是，如果有很多的 CPU, 主 CPU 会变成一个瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对称对处理机
&lt;ul&gt;
&lt;li&gt;消除了上述的不对称性。在存储器中有操作系统的一个副本，但任何 CPU 都可以运行它。在有系统调用时，进行系统调用的 CPU 陷入内核并处理系统调用&lt;/li&gt;
&lt;li&gt;任何 CPU 都可以运行操作系统，但在任一时刻只有一个 CPU 可运行操作系统&lt;/li&gt;
&lt;li&gt;可以把操作系统分割成互不影响的临界区。每个临界区由其互斥信号量保护，所以一次只有一个 CPU 可执行它。采用这种方式，可以实现更多的井行操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多处理机同步
&lt;ul&gt;
&lt;li&gt;如果一个进程在单处理机(仅含一个 CPU)中需要访问一些内核临界表的系统调用，那么内核代码在接触该表之前可以先禁止中断。然后它继续工作，在相关工作完成之前，不会有任何其他的进程溜进来访问该表。&lt;/li&gt;
&lt;li&gt;在多处理机中，禁止中断的操作只影响到完成禁止中断操作的这个 CPU，其他的 CPU 继续运行并且可以访问临界表。因此，必须采用一种合适的互斥信号量协议，而且所有的 CPU 都遵守该协议以保证互斥工作的进行。&lt;/li&gt;
&lt;li&gt;任何实用的互斥信号量协议的核心都是一条特殊指令， 该指令允许检测一个存储器字并以一种不可见的操作设置。指令 TSL (Test and Set Lock 做的是，读出一个存储器字并把它存储在一个寄存器中。同时，它对该存储器字写入一个 1 (或某些非零值)。当然，这需要两个总线周期来完成存储器的读写。在单处理机中，只要该指令不被中途中断，TSL 指令就始终照常工作。&lt;/li&gt;
&lt;li&gt;为了阻止多个 CPU 同时访问同一个存储器字，SL 指令必须首先锁住总线，阻止其他的 CPU 访问它，然后进行存储器的读写访问，再解锁总线。&lt;/li&gt;
&lt;li&gt;如果正确地实现和使用 TSL，它能够保证互斥机制正常工作。但是这种互斥方法使用了自旋锁(spin lock), 因为请求的 CPU 只是在原地尽可能快地对锁进行循环测试。这样做不仅完全浪费了提出请求的各个 CPU 的时间，而且还给总线或存储器增加了大量的负载，严重地降低了所有其他 CPU 从事正常工作的速度。&lt;/li&gt;
&lt;li&gt;在获取锁之前先观察锁是否空闲，可以减少竞争，避免高速缓存颠簸。&lt;/li&gt;
&lt;li&gt;另一个减少总线流量的方式是使用著名的以太网二进制指数回退算法&lt;/li&gt;
&lt;li&gt;一个更好的想法是，让每个打算获得互斥信号量的 CPU 都拥有各自用于测试的私有锁变且&lt;/li&gt;
&lt;li&gt;自旋与同步
&lt;ul&gt;
&lt;li&gt;假设一些 CPU 是空闲的，需要访问共享的就绪链表(ready list) 以便选择一个进程运行。如果就绪链表被锁住了，CPU 必须保持等待直到能够访问该就绪链表。&lt;/li&gt;
&lt;li&gt;然而，在另外一些情形中，却存在着别的选择。例如，如果在一个 CPU 中的某些线程需要访问文件系统缓冲区高速缓存，而该文件系统缓冲区高速缓存正好锁住了，那么 CPU 可以决定切换至另外一个线程而不是等待。&lt;/li&gt;
&lt;li&gt;假设自旋和进行线程切换都是可行的选择，则可进行如下的权衡。自旋直接浪费了 CPU 周期。重复地测试锁并不是高效的工作。不过，切换也浪费了 CPU 周期，因为必须保存当前线程的状态，必须获得保护就绪链表的锁，还必须选择一个线程，必须装入其状态，并且使其开始运行。花费在这两个线程间来回切换和所有高速缓存未命中的周期时间都浪费了。&lt;/li&gt;
&lt;li&gt;有一种设计是总是进行自旋。 第二种设计 方案则总是进行切换。 而第三种设计方案是每当遇到一个锁住的互斥信号量时，就单独做出决定。在必须做出决定的时刻，并不知道自旋和切换哪种方案更好，但是对于任何给定的系统，有可能对其所有的有关活动进行跟踪，并且随后进行离线分析。然后就可以确定哪个决定最好及在最好情形下所浪费的时间。&lt;/li&gt;
&lt;li&gt;得出来了这样一个模型: 一个未能获得互斥信号量的线程自旋一段时间。 如果时间超过某个阈值，则进行切换。在某些情形下，该阈值是一个定值，典型值是切换至另一个线程再切换回来的开销。在另一些情形下，该阈值是动态变化的，它取决于所观察到的等待互斥信号量的历史信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多处理机调度
&lt;ul&gt;
&lt;li&gt;线程是内核线程还是用户线程至关重要。如果线程是由用户空间库维护的，而对内核不可见，那么调度一如既往的基于单个进程。如果内核并不知道线程的存在，它就不能调度线程。&lt;/li&gt;
&lt;li&gt;对内核线程来说，情况有所不同。在这种情况下所有线程均是内核可见的，内核可以选择一个进程的任一线程。&lt;/li&gt;
&lt;li&gt;在单处理机中，调度是一维的。唯一必须(不断重复地)回答的问题是:“接下来运行的线程应该是哪一个?”而在多处理机中，调度是二维的。调度程序必须决定哪一个进程运行以及在哪一个 CPU 上运行。这个在多处理机中增加的维数大大增加了调度的复杂性。&lt;/li&gt;
&lt;li&gt;另一个造成复杂性的因素是，在有些系统中所有的线程是不相关的，它们属于不同的进程，彼此无关。而在另外一些系统中它们是成组的，同属于同一个应用并且协同工作。前一种情形的例子是服务器系统，其中独立的用户运行相互独立的进程。这些不同进程的线程之间没有关系，后一种情形通常出现在程序开发环境中。&lt;/li&gt;
&lt;li&gt;分时
&lt;ul&gt;
&lt;li&gt;让我们首先讨论调度独立线程的情况。处理独立线程的最简单算法是，为就绪线程维护一个系统级的数据结构，它可能只是一个链表，但更多的情况下可能是对应不同优先级一个链表集合。&lt;/li&gt;
&lt;li&gt;由所有 CPU 使用的单个调度数据结构分时共享这些 CPU，正如它们在一个单处理机系统中那样。它还支持自动负载平衡，因为决不会出现一个 CPU 空闲而其他 CPU 过载的情况。不过这一方法有两个缺点，一个是随着 CPU 数量增加所引起的对调度数据结构的潜在竞争，二是当线程由于 I/O 阻塞时所引起上下文切换的开销(overhead)。&lt;/li&gt;
&lt;li&gt;为了避免这种异常情况，一些系统采用智能调度(smartscheduling)的方法，其中，获得了自旋锁的线程设置一个进程范围内的标志以表示它目前拥有了一个自旋锁。 当它释放该自旋锁时，就清除这个标志。这样调度程序就不会停止持有自旋锁的线程，相反，调度程序会给予稍微多一些的时间让该线程完成临界区内的工作并释放自旋锁。&lt;/li&gt;
&lt;li&gt;有些多处理机考虑了这一因素，并使用了所谓亲和调度。其基本思想是，尽量使一个线程在它前一次运行过的同一个 CPU 上运行。创建这种亲和力(affinity)的一种途径是采用一种两级调度算法(two-level scheduling algorithm)。&lt;/li&gt;
&lt;li&gt;在一个线程创建时，两级调度算法有三个优点。
&lt;ul&gt;
&lt;li&gt;它把负载大致平均地分配在可用的 CPU 上;&lt;/li&gt;
&lt;li&gt;它尽可能发挥了高速缓存亲和力的优势&lt;/li&gt;
&lt;li&gt;通过为每个 CPU 提供一个私有的就绪线程链表，使得对就绪线程链表的竞争减到了最小，因为试图使用另一个 CPU 的就绪线程链表的机会相对较小。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空间共享
&lt;ul&gt;
&lt;li&gt;在多个 CPU 上同时调度多个线程称为空间共享(space sharing)。&lt;/li&gt;
&lt;li&gt;最简单的空间共享算法是这样工作的。假设一组相关的线程是一次性创建的。在其创建的时刻，调度程序检查是否有同线程数量一样多的空闲 CPU 存在。如果有，每个线程获得各自专用的 CPU(非多道程序处理)并且都开始运行。如果没有足够的 CPU,就没有线程开始运行，直到有足够的 CPU 时为止。&lt;/li&gt;
&lt;li&gt;在单处理机系统中，最短作业优先是批处理调度中知名的算法。在多处理机系统中类似的算法是，选择需要最少的 CPU 周期数的线程，也就是其 CPU 周期数*运行时间最小的线程为候选线程。然而，在实际中，这一信息很难得到，因此该算法难以实现。事实上，研究表明，要胜过先来先服务算法是非常困难的。&lt;/li&gt;
&lt;li&gt;在这个简单的分区模型中，一个线程请求一定数量的 CPU，然后或者全部得到它们或者一直等到有足够数量的 CPU 可用为止。&lt;/li&gt;
&lt;li&gt;另一种处理方式是主动地管理线程的并行度。管理并行度的一种途径是使用一个中心服务器，用它跟踪哪些线程正在运行，哪些线程希望运行以及所需 CPU 的最小和最大数量。 每个应用程序周期性地询问中心服务器有多少个 CPU 可用。然后它调整线程的数量以符合可用的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;群调度
&lt;ul&gt;
&lt;li&gt;空间共享的一个明显优点是消除了多道程序设计，从而消除了上下文切换的开销。但是，一个同样明显的缺点是当 CPU 被阻塞或根本无事可做时时间被浪费了，只有等到其再次就绪。于是，人们寻找既可以调度时间又可以调度空间的算法，特别是对于要创建多个线程而这些线程通常需要彼此通信的线程。&lt;/li&gt;
&lt;li&gt;这一问题的解决方案是群调度(gang scheduling), 它是协同调度的发展产物。群调度由三个部分组成:
&lt;ul&gt;
&lt;li&gt;把一组相关线程作为一个单位，即一个群(gang)， 一起调度。&lt;/li&gt;
&lt;li&gt;一个群中的所有成员在不同的分时 CPU 上同时运行。&lt;/li&gt;
&lt;li&gt;群中的所有成员共同开始和结束其时间片。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使群调度正确工作的关键是，同步调度所有的 CPU。这意味着把时间划分为离散的时间片。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多计算机&#34;&gt;多计算机&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;多计算机是紧耦合 CPU,不共享存储器。每台计算机有自己的存储器。众所周知，这些系统有各种其他的名称，如机群计算机以及工作站机群。云计环服务都是建立在多计算机上，因为它们需要大的计算能力。&lt;/li&gt;
&lt;li&gt;多计算机硬件
&lt;ul&gt;
&lt;li&gt;一个多计算机系统的基本节点包括一个 CPU、存储器、一个网络接口，有时还有一个硬盘。节点可以封装在标准的 PC 机箱中，不过通常没有图像适配卡、显示器、键盘和鼠标等。有时这种配置被称为无主工作站、因为没有用户。有用户的工作站逻辑上应该对应地被叫作有主工作站&lt;/li&gt;
&lt;li&gt;互联技术
&lt;ul&gt;
&lt;li&gt;在每个节点上有一块网卡，带有一根或两根从网卡上接出的电缆(或光纤)。这些电缆或者连到其他的节点上，或者连到交换机上&lt;/li&gt;
&lt;li&gt;在多计算机中可采用两种交换机制
&lt;ul&gt;
&lt;li&gt;在存储转发包交换,由源节点的网络接口卡注入第一个交换机的包组成。比特串一次进来一位，当整个包到达一个输入缓冲区时，它被复制到沿着其路径通向下一个交换机的队列当中。当数据包到达目标节点所连接的交换机时，该数据包被复制到目标节点的网络接口卡，并最终到达其 RAM.&lt;/li&gt;
&lt;li&gt;另一种交换机制是电路交换,它包括由第一个交换机建立的，通过所有交换机而到达目标交换机的一条路径。一且该路径建立起来，比特流就从源到目的地通过整个路径不断地尽快输送。在所涉及的交换机中，没有中间缓冲。电路交换需要有一个建立阶段，它需要一点时间，但是一且建立完成，速度就很快。在包发送完毕之后，该路径必须被拆除。电路交换的一种变种称为虫孔路由,它把每个包拆成子包，井允许第一个子包在整个路径还没有完全建立之前就开始流动。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络接口
&lt;ul&gt;
&lt;li&gt;接口板上可以有一个或多个 DMA 通道，甚至在板上有一个完整的 CPU (乃至多个 CPU)。通过请求在系统总线上的块传送, DMA 通道可以在接口板和主 RAM 之间以非常高的速率复制包，因而可以一次性传送若干字而不需要为每个字分别请求总线&lt;/li&gt;
&lt;li&gt;很多接口板上有一个完整的 CPU, 可能另外还有一个或多个 DMA 通道。它们被称为网络处理器, 并且其功能日趋强大。这种设计意味着主 CPU 将一些工作分给了网卡，诸如处理可靠的传送、多播、压缩/解压缩、加密/解密以及在多进程系统中处理安全事务等。但是，有两个 CPU 则意味着它们必须同步，以避免竞争条件的发生，这将增加额外的开销，井且对千操作系统来说意味着要承担更多的工作。&lt;/li&gt;
&lt;li&gt;跨层复制数据是安全的，但不一定高效&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;低层通信软件
&lt;ul&gt;
&lt;li&gt;在多计算机系统中高性能通信的敌人是对包的过度复制&lt;/li&gt;
&lt;li&gt;为了避免这种对性能的影响，不少多计算机把接口板映射到用户空间，井允许用户进程直接把包送到卡上，而不需要内核的参与&lt;/li&gt;
&lt;li&gt;如果在节点上有若于个进程运行而且需要访问网络以发送包，一个解决方案是，把接口板映射到所有需要它的进程中去，但是这样做就需要有一个机制用以避免竞争&lt;/li&gt;
&lt;li&gt;内核本身会经常需要访问互连网络，最简单的设计是使用两块网络接口板，一块映射到用户空间供应用程序使用，另一块映射到内核空间供操作系统使用。许多多计算机就正是这样做的.&lt;/li&gt;
&lt;li&gt;另一方面，较新的网络接口通常是多队列的，这意味若它们有多个缓冲区可以有效地支持多个用户.例如, Intel 1350 系列网卡具有 8 个发送和 8 个接收队列，可虚拟化为许多虚拟端口&lt;/li&gt;
&lt;li&gt;节点至网络接口通信
&lt;ul&gt;
&lt;li&gt;将包送到接口板上。最快的方法是使用板上的 DMA 芯片直接将它们从 RAM 复制到板上&lt;/li&gt;
&lt;li&gt;这种方式的问题是，DMA 可以使用物理地址而不是虚拟地址，井且独立干 CPU 运行，除非存大 I/0 MMU。&lt;/li&gt;
&lt;li&gt;另外，如果操作系统决定替换一个页面.而 DMA 芯片正在从该页面复制一个包，就会传送错误的数据。然而更加糟糕的是，如果操作系统在替换某一个页面的同时 DMA 芯片正在把一个包复制进该页面，结果不仅进来的包会丢失，无辜的存储器页面也会被毁坏，这可能会带来灾难性的后果。&lt;/li&gt;
&lt;li&gt;可采用一类将页面钉住和释放的系统调用，把有关页面标记成暂时不可交换的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;远程直接内存访间
&lt;ul&gt;
&lt;li&gt;降低数据的复制品都需要很大代价。为了应对这一问题，一些网络接口支持远程直接内存访问 (RMDA) 技术，允许一台机器直接访问另一台机器的内存。RMDA 不需要操作系统的参与，直接从应用的内存空间中读取或写人数据.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用户层通信软件
&lt;ul&gt;
&lt;li&gt;在多计算机中，不同 CPU 上的进程通过互相发送消息实现通信。在最简单的情况下，这种消息传送是暴露给用户进程的。换句话说，操作系统提供了一种发送和接收消息的途径，而库过程使得这些低层的调用对用户进程可用。在较复杂的情形下，通过使得远程通信看起来像过程调用的办法，将实际的消息传递对用户隐藏起来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;远程过程调用
&lt;ul&gt;
&lt;li&gt;允许程序调用位于其他 CPU 中的过程。当机器 1 的进程调用机器 2 的过程时，在机器 1 中的调用进程被挂起，在机器 2 中被调用的过程执行。可以在参数中传递从调用者到被调用者的信息，并且可在过程的处理结果中返回信息。根本不存在对程序员可见的消息传递或 I/O。 这种技术即是所谓的远程过程调用,并且已经成为大多计算机的软件的基础。习惯上，称发出调用的过程为客户机，而称被调用的过程为服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分布式共享存储器
&lt;ul&gt;
&lt;li&gt;每台机器有其自己的虚拟内存和页表。当一个 CPU 在一个它并不拥有的页面上进行 LOAD 和 STORE 时，会陷入到操作系统当中。然后操作系统对该页面进行定位，并请求当前持有该页面的 CPU 解除对该页面的映射并通过互连网络发送该页面。在该页面到达时，页面被映射进来，于是出错指令重新启动。事实上，操作系统只是从远程 RAM 中而不是从本地磁盘中满足了这个缺页异常。对用户而言，机器看起来拥有共享存储器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多计算机调度
&lt;ul&gt;
&lt;li&gt;维护就绪进程的一个中心链表，每个进程只能在其当前所在的 CPU 上运行。不过，当创建一个新进程时，存在着一个决定将其放在哪里的选择，例如，从平衡负载的考虑出发。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;负载平衡
&lt;ul&gt;
&lt;li&gt;图论确定算法：有一类被广泛研究的算法用干下面这样一个系统，该系统包含已知 CPU 和存储器需求的进程，以及给出每对进程之间平均流量的已知矩阵。如果进程的数众大于 CPU 的数量 k, 则必须把若干个进程分配给每个 CPU。其想法是以最小的网络流量完成这个分配工作。&lt;/li&gt;
&lt;li&gt;发送者发起的分布式启发算法：当进程创建时，它就运行在创建它的节点上，除非该节点过载了。过载节点的度量可能涉及太多的进程，过大的工作集，或者其他度量。如果过载了，该节点随机机选择另一个节点井询问它的负载情况。如果被探查的节点负载低于某个阈值，就将新的进程送到该节点上。如果不是，则选择另一个机器探查。探查工作并不会永远进行下去。在 N 次探查之内，如果没有找到合适的主机，算法就终止，且进程继续在原有的机器上运行。整个算法的思想是负载较重的节点试图甩掉超额的工作。应该看到在负载重的条件下，所有的机器都会持续地对其他机器进行探查，徒劳地试配找到一台愿意接收更多工作的机器。几乎没有进程能够被卸载，可是这样的尝试会带来巨大的开销 。&lt;/li&gt;
&lt;li&gt;接收者发起的分布式启发算法：在这个算法中，只要有一个进程结束，系统就检查是否有足够的工作可做。如果不是，它随机选择某台机器井要求它提供工作。如果该台机器没有可提供的工作，会接若询问第二台，然后是第三台机器。如果在 N 次探查之后，还是没有找到工作，该节点暂时停止询问，去做任何已经安排好的工作，而在下一个进程结束之后机器会再次进行询问。如果没有可做的工作，机器就开始空闲。在经过固定的时间间隔之后，它又开始探查。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分布式系统&#34;&gt;分布式系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这些系统与多计算机类似，每个节点都有自己的私有存储器，整个系统中没有共享的物理存储器。但是，分布式系统与多计算机相比，耦合度更加松散。&lt;/li&gt;
&lt;li&gt;分布式系统添加在其底层网络上的是一些通用范型(模型)，它们提供了一种统一的方法来观察整个系统。分布式系统想要做的是，将松散连接的大量机器转化为基于一种概念的一致系统。这些范型有的比较简单，而有的是很复杂的，但是其思想则总是提供某些东西用来统一整个系统。&lt;/li&gt;
&lt;li&gt;分布式系统面对不同硬件和操作系统实现某种统一性的途径是，在操作系统的顶部添加一层软件。这层软件称为中间件。这层软件提供了一些特定的数据结构和操作，从而允许散布的机器上的进程和用户用一致的方式互操作。&lt;/li&gt;
&lt;li&gt;网络硬件
&lt;ul&gt;
&lt;li&gt;以太网
&lt;ul&gt;
&lt;li&gt;经典的以太网，在 IEEE802.3 标准中有具体描述，由用来连接若干计算机的同轴电缆组成&lt;/li&gt;
&lt;li&gt;许多计算机连接到同一根电缆上，需要一个协议来防止混乱。要在以太网上发送包，计算机首先要监听电缆，看看是否有其他的计算机正在进行传输。如果没有，这台计算机便开始传送一个包，其中有一个短包头，随后是 0 到 1500 字节的有效信息载荷 (payload)。如果电缆正在使用中，计算机只是等待直到当前的传输结束，接着该台计算机开始发送。&lt;/li&gt;
&lt;li&gt;如果两台计算机同时开始发送，就会导致冲突发生，两台机器都做检测。采用二进制指数回退算法。&lt;/li&gt;
&lt;li&gt;为了避免碰撞问题，现代以太网使用交换机。每个交换机有若干个端口. 一个端口用于连接一台计算机 一个以太网或另一个交换机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因特网
&lt;ul&gt;
&lt;li&gt;Internet 包括了两类计算机，主机和路由器。主机 (host) 有 PC、笔记本计算机、掌上电脑、服务器、大型计算机以及其他那些个人或公司所有且希望与 Internet 连接的计算机。&lt;/li&gt;
&lt;li&gt;地区网络和 ISP 的路由器通过中等速度的光纤连接到主于网上。依次，每个配备路由器的公司以太网连接到地区网络的路由器上。而 ISP 的路由器则被连接到供 ISP 客户们使用的调制解调器汇集器上。按照这种方式，在 Internet 上的每台主机至少拥有通往其他主机的一条路径.而且每台经常拥有多条通往其他主机的路径。&lt;/li&gt;
&lt;li&gt;在 Internet 上的所有通信都以包的形式传送&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络服务和协议
&lt;ul&gt;
&lt;li&gt;所有的计算机网络都为其用户(主机和进程)提供一定的服务，这种服务通过某些关干合法消息交换的规则加以实现&lt;/li&gt;
&lt;li&gt;计算机网络为使用网络的主机和进程提供服务。 包括面向连接的服务和无连接服务。&lt;/li&gt;
&lt;li&gt;每种服务可以用服务质量 (quality of service) 表征。有些服务就其从来不丢失数据而言是可靠的&lt;/li&gt;
&lt;li&gt;网络协议
&lt;ul&gt;
&lt;li&gt;所有网络都有高度专门化的规则，用以说明什么消息可以发送以及如何响应这些消息&lt;/li&gt;
&lt;li&gt;所有的现代网络都使用所谓的 协议栈 (protocol stack) 把不同的协议一层一层叠加起来。每一层解决不同的问题&lt;/li&gt;
&lt;li&gt;大多数分布式系统都使用 Internet 作为基础，因此这些系统使用的关键协议是两种主要的 Internet 协议: IP 和 TCP.&lt;/li&gt;
&lt;li&gt;DNS 用来寻找 IP 地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于文档的中间件
&lt;ul&gt;
&lt;li&gt;WWW&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于文件系统的中间件
&lt;ul&gt;
&lt;li&gt;使一个分布式系统看起来像一个大型文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于对象的中间件
&lt;ul&gt;
&lt;li&gt;对象是变量的集合，这些变昼与一套称为方法的访问过程绑定在一起。进程不允许直接访间这些变量。相反，要求它们调用方法来访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于协作的中间件
&lt;ul&gt;
&lt;li&gt;Linda： 耶鲁大学研发的用干通信和同步的新系统。在 Linda 系统中，相互独立的进程之间通过一个抽象的元组空间进行通信。对整个系统而言，元组空间是全局性的，在任何机器上的进程都可以把元组插入或移出元组空间，而不用考虑它们是如何存放的以及存放在何处。对于用户而言，元组空间像一个巨大的全局共享存储器&lt;/li&gt;
&lt;li&gt;发布/订阅：它由大量通过广播网网络互联的进程组成。每个进程可以是一个信息生产者、信息消费者或两者都是。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;有关多处理机系统的研究&#34;&gt;有关多处理机系统的研究&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;重新设计一个专门针对多核硬件的操作系统&lt;/li&gt;
&lt;li&gt;分布式一致性&lt;/li&gt;
&lt;li&gt;何使大型应用可以在多核和多处理器的环境下进行扩展&lt;/li&gt;
&lt;li&gt;调试并行应用&lt;/li&gt;
&lt;li&gt;降低多处理器系统功耗的工作&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>现代操作系统::虚拟化与云</title>
      <link>/notes/modern_operating_systems_virtualization_and_the_cloud/</link>
      <pubDate>Tue, 20 Jul 2021 02:11:01 +0800</pubDate>
      <guid>/notes/modern_operating_systems_virtualization_and_the_cloud/</guid>
      <description>&lt;h2 id=&#34;虚拟化与云&#34;&gt;虚拟化与云&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;介绍
&lt;ul&gt;
&lt;li&gt;在一个虚拟化系统中，不同的服务器可以运行在不同的虚拟机上，从而以更低的开销和更好的可维护性保留多计算机系统具有的局部故障模型。而且，可以在同一硬件上运行多个不同的操作系统，并享受虚拟机隔离带来的安全性和其他好处。&lt;/li&gt;
&lt;li&gt;虚拟化技术有效的前提是绝大多数服务中断不是硬件缺陷造成的，而是由与软件设计不周、不可靠、有缺陷、配置不当造成的，特别是操作系统。&lt;/li&gt;
&lt;li&gt;物理机数址的减少节省了硬件和电力开销以及机架空间的占用。&lt;/li&gt;
&lt;li&gt;虚拟化技术还能在尝试新想法时提供帮助&lt;/li&gt;
&lt;li&gt;虚拟机的另一个优势是设置检查点和虚拟机迁移(例如跨多台胀务器进行负载均衡)比在普通操作系统上运行的迁移要容易得多&lt;/li&gt;
&lt;li&gt;在已停止支持或无法工作于当前硬件的操作系统(或操作系统版本)上运行遗留应用程序。&lt;/li&gt;
&lt;li&gt;协助软件开发。程序员不需要在多台机器上安装不同操作系统来保证软件能在不同系统上运行。&lt;/li&gt;
&lt;li&gt;虚拟化技术目前最重要最时髦的用途是云。云的核心思想很直接:将你的计箕或存储需求外包给一个管理良好的数据中心。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;历史
&lt;ul&gt;
&lt;li&gt;20 世纪 60 年代，IBM 开发了 SIMMON 和 CP-40，运行在 System/360，重新实现成 CP-67&lt;/li&gt;
&lt;li&gt;1974 年，加拿大的两位计算机科学家发表论文定义了一个计算机体系结构有效支持虚拟化所需满足的条件&lt;/li&gt;
&lt;li&gt;20 世纪 90 年代，VMware 成立，后续 Xen，KVM，VirtualBox，Hyper-V，Parallels 也相继出现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟化的必要条件
&lt;ul&gt;
&lt;li&gt;虚拟机管理程序需要实现良好的表现
&lt;ul&gt;
&lt;li&gt;安全性: 虚拟机管理程序应完全掌控虚拟资源。&lt;/li&gt;
&lt;li&gt;保真性: 程序在虚拟机上执行的行为应与在裸机上相同.&lt;/li&gt;
&lt;li&gt;高效性: 虚拟机中运行的大部分代码应不受虚拟机管理程序的干涉。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全性
&lt;ul&gt;
&lt;li&gt;解释器(例如 Bochs)中逐条考虑指令井准确执行其行为是一种安全执行指令的方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保真性
&lt;ul&gt;
&lt;li&gt;每个包含内核态和用户态的 CPU 都有一个特殊的指令集合，其中的指令在内核态和用户态执行的行为不同。这些指令包括进行 I/O 操作和修改 MMU 设置的指令，Popek 和 Goldberg 称之为敏感指令 (sensitive instruction)。&lt;/li&gt;
&lt;li&gt;还有另一个指令集合，其中的指令在用户态执行时会导致陷人，Popek 和 Goldberg 称之为特权指令&lt;/li&gt;
&lt;li&gt;他们的论文首次指出机器可虚拟化的一个必要条件是敏感指令为特权指令的子集&lt;/li&gt;
&lt;li&gt;Intel 和 AMD 在 CPU 中引入虚拟化支持 VT，使问题得以解决。VM 技术的基本思想是创建可以运行虚拟机的容器。客户操作系统在容器中启动井持续运行，直到触发异常并陷入虚拟机管理程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;半虚拟化
&lt;ul&gt;
&lt;li&gt;半虚拟化提供一层类似物理机器的软件接口，显式暴露出自身是一个虚拟化的环境.例如，它提供一组虚拟化调用 (hypercall), 允许客户机向虚拟机管理程序发送显式的请求，就像系统调用为应用程序提供服务那样。客户机使用虚拟化调用执行特权操作，如修改页表等，但由于操作是客户机和虚拟机管理程序协作完成的，因此整个系统更加简单快速。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第一类和第二类虚拟机管理程序
&lt;ul&gt;
&lt;li&gt;第一类虚拟机管理程序就像一个操作系统，因为它是唯一一个运行在最高特权级的程序。 它的工作是支持真实硬件的多个虚拟机 (virtual machine) 拷贝，类似千普通操作系统支持的进程。&lt;/li&gt;
&lt;li&gt;第二类虚拟机管理程序则不同。它是一个依赖于 Windows、 Linux 等操作系统分配和调度资源的程序，很像一个普通的进程。寄托于宿主操作系统提供大量的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高效虚拟化技术
&lt;ul&gt;
&lt;li&gt;在不支持虚拟化的平台上实现虚拟化
&lt;ul&gt;
&lt;li&gt;虚拟机上的操作系统认为自己运行在内核态(实际上不是)。我们称之为虚拟内核态。&lt;/li&gt;
&lt;li&gt;在不支持 VT 的 CPU 上，执行内核态才能执行指令会失败井导致操作系统崩溃。在支持 VT 的 CPU 上， 客户操作系统执行敏感指令时，会陷入虚拟机管理程序，虚拟机管理程序可以检查这条指令是由虚拟机中的客户操作系统执行的还是用户程序执行的。如果是前者，虚拟机管理程序将安排这条指令功能的正确执行。否则，虚拟机管理程序将换拟其实硬件面对用户态执行敏感指令时的行为。&lt;/li&gt;
&lt;li&gt;在不支持 VT 的平台上，软件工程师们利用二进制翻译和 x86 平台确实存在的硬件特性(如处理器的特权级)构建出了虚拟机系统。&lt;/li&gt;
&lt;li&gt;进制翻译器改写运行在第 1 级的客户操作系统，虚拟机管理程序运行在第 0 级&lt;/li&gt;
&lt;li&gt;直接运行客户机代码井使用完全相同的技术需要第二类虚拟机管理程序能在最底层操纵硬件，这在用户态无法实现，因此，大多数现代的第二类虚拟机管理程序有一个在第 0 级运行的内核模块，能够使用特权指令操纵硬件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟化的开销
&lt;ul&gt;
&lt;li&gt;VT 硬件使用的陷入井模拟方法会产生大量陷入，而陷入在现代硬件上开销很大，因为 CPU 高速缓存、 TLB、转移预测都会受到不利影响。&lt;/li&gt;
&lt;li&gt;使用二进制翻译后，代码既有可能变快，也有可能变慢。替换了部分需要陷入的指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟机管理程序是真正的微内核吗
&lt;ul&gt;
&lt;li&gt;第一类和第二类虚拟机管理程序都支持未修改的客户操作系统，但需要费尽于辛万苦才能取得较好 的性能&lt;/li&gt;
&lt;li&gt;半虚拟化 采取了不同的方法，要求修改客户操作系统的諒代码。半虚拟化的客户机执行虚拟化调用而不是敏感指令，这套调用接口实际上构成了应用编程接口 (Application Programming Interface, API), 虽然接口由客户操作系统而非应用程序使用。&lt;/li&gt;
&lt;li&gt;移除客户操作系统中的所有敏感指令，只让它通过虚拟化调用访问 I/O 等系统服务，就将虚拟机管理程序变成了微内核&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存虚拟化
&lt;ul&gt;
&lt;li&gt;对每台虚拟机，虚拟机管理程序都需要创建一个影子页表, 将虚拟机使用的虚拟页映射到它分配给虚拟机的实际物理页上。&lt;/li&gt;
&lt;li&gt;嵌套页表的硬件支持
&lt;ul&gt;
&lt;li&gt;使用影子页表会造成巨大的开销。&lt;/li&gt;
&lt;li&gt;芯片生产商添加了嵌套页表 (nested page table) 的硬件支持。在无需陷入的悄况下由硬件处理虚拟化引发的额外页表操作，以降低开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;回收内存
&lt;ul&gt;
&lt;li&gt;一个小的气球模块作为伪设备驱动程序加载到每个虚拟机中，与虚拟机管理程序通信。气球模块在虚拟机管理程序的请求下可以通过申请锁定页面来膨胀，也可以通过释放这些页面而紧缩。气球膨胀，客户机的实际可用物理内存减少，客户操作系统将以换出最不重要页面的方式响应这一变化，正如期望的那样。反过来，气球紧缩，客户机可用内存增加。虚拟机管理程序让操作系统来帮它作决定，通俗地讲这叫踢皮球。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;I/O 虚拟化
&lt;ul&gt;
&lt;li&gt;I/O MMU&lt;/li&gt;
&lt;li&gt;设备隔离&lt;/li&gt;
&lt;li&gt;设备域&lt;/li&gt;
&lt;li&gt;单根 I/O 虚拟化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟应用
&lt;ul&gt;
&lt;li&gt;软件开发人员可以精心构造一个虚拟机.装上需要的操作系统、编译器、运行库和应用程序代码，固定整个虚拟机使之可以随时运行。这个虚拟机镜像可以刻录到 CD-ROM 或发布到网 站上让用户安装或下载。这种方法意味着只有软件开发人员需要知道所有的依赖关系。客户得到的是能 实际运行的完整包，与他们使用的操作系统和安装的其他软件包、运行库完全无关。这类&amp;quot;盒装”的虚 拟机通常称作虚拟应用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多核 CPU 上的虚拟机
&lt;ul&gt;
&lt;li&gt;由于多核芯片上的所有核心共享相同的 RAM, 因此单一的四核芯片根据摇要可以很容易地配置成 32 节点多处理器或多计算机系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;授权问题
&lt;ul&gt;
&lt;li&gt;某些情况下，软件生产商会在授权中显式加入禁止在(未授权)虚拟机上运行软件的条款&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;云
&lt;ul&gt;
&lt;li&gt;云的特征
&lt;ul&gt;
&lt;li&gt;按需自助服务 。无需人为操作就能自动为用户提供资源。&lt;/li&gt;
&lt;li&gt;普适的网络访问 。所有资源都可以通过网络用标准化的机制访问，以支持各种异构设备。&lt;/li&gt;
&lt;li&gt;资源池。云提供商拥有的资源可以服务多个用户并动态再分配，用户通常不知道他们使用的资源 的具体位置。&lt;/li&gt;
&lt;li&gt;快速可伸缩 。能根据用户需求弹性甚至是自动地获取和释放资源。&lt;/li&gt;
&lt;li&gt;服务可计量。云提供商按服务类型计量用户使用的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;云即服务
&lt;ul&gt;
&lt;li&gt;将计算资源集中到少数儿个地方可以实现规模经济效益。将计算处理工作外包意味着不用再过于关心 IT 基础设施的管理、备份、维护、折旧、伸缩性、可靠性、性能甚至安全性。所有这些工作都梊中在一处完成，假设云提供商是称职的，则这些都能很好地完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟机迁移
&lt;ul&gt;
&lt;li&gt;使用内存预复制迁移 (pre-copy memory migration) , 能在虚拟机提供服务的同时复制内存页。大多数内存页的写入井不频繁，直接复制是安全的。但是，虚拟机仍在运行，所以页面复制之后可能会被修改。页面修改时将其标记为脏的，以确保最新版本复制到目标机器。脏页面会重新复制。当大多数页面复制完成后，只剩少量脏页面。短暂地暂停虚拟机以复制它们，然后在目标机器上恢复虚拟机执行。虽然仍有暂停，但时间很短，应用程序通常不会受到影响。若停机时间不箕太耗时，就称作无缝热迁移&lt;/li&gt;
&lt;li&gt;虚拟机与物理硬件的解耦还有其他优势，尤其是可以暂停一个虚拟机，保存快照的最直接方式是复制所有状态，包括完整的文件系统。然而，即使磁盘速度很快，复制上 TB 的磁盘内容也会花点时间。和前面的虚拟机迁移相同，我们不想暂停太久。解决方案是使用写时复制技术，数据只有在绝对必需时才进行复制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有关虚拟化和云的研究
&lt;ul&gt;
&lt;li&gt;虚拟化技术&lt;/li&gt;
&lt;li&gt;无线网络的虚拟化&lt;/li&gt;
&lt;li&gt;嵌套虚拟化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>现代操作系统::死锁</title>
      <link>/notes/modern_operating_systems_deadlock/</link>
      <pubDate>Mon, 19 Jul 2021 02:11:01 +0800</pubDate>
      <guid>/notes/modern_operating_systems_deadlock/</guid>
      <description>&lt;h2 id=&#34;死锁&#34;&gt;死锁&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;资源
&lt;ul&gt;
&lt;li&gt;需要排他性使用的对象称为资源&lt;/li&gt;
&lt;li&gt;硬件资源，打印机，蓝牙驱动器&lt;/li&gt;
&lt;li&gt;一组信息，数据库中加锁的数据&lt;/li&gt;
&lt;li&gt;可抢占资源
&lt;ul&gt;
&lt;li&gt;可以从拥有它的进程中抢占而不会产生任何副作用，存储器就是一类可抢占的资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不可抢占资源
&lt;ul&gt;
&lt;li&gt;在不引起相关的计算失败的情况下，无法把它从占有它的进程处抢占过来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;某个资源是否可抢占取决干上下文环境。在一台标准的 PC 中，内存中的页面总是可以置换到磁盘中并置换回来，故内存是可抢占的。但是在一部不支持交换和页面调度的智能机上，仅通过将内存消耗大户交换出来是不能避免死锁的。&lt;/li&gt;
&lt;li&gt;总的来说，死锁与不可抢占资源有关，有关可抢占资源的潜在死锁通常可以通过在进程之间重新分配资源而化解。&lt;/li&gt;
&lt;li&gt;若请求时资源不可用，则请求进程被迫等待。某些进程会自动阻塞，有一些会发挥错误代码并在稍后重试。&lt;/li&gt;
&lt;li&gt;资源获取
&lt;ul&gt;
&lt;li&gt;对于数据库系统中的记录这类资源，应该由用户进程来管理其使用. 一种允许用户管理资源的可能方法是为每一个资源配置一个信号量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;死锁简介
&lt;ul&gt;
&lt;li&gt;如果一个进在集合中的每个进在都在等持只能由该进在集合中的其他进程才能引发的事件，那么，该进在集合就是死锁的.&lt;/li&gt;
&lt;li&gt;资源死锁的条件，同时满足以下四个条件
&lt;ul&gt;
&lt;li&gt;互斥条件.每个资源要么已经分配给了一个进程，要么就是可用的&lt;/li&gt;
&lt;li&gt;占有和等待条件。已经得到了某个资源的进程可以再请求新的资源。&lt;/li&gt;
&lt;li&gt;不可抢占条件。已经分配给一个进程的资源不能强制性地被抢占，它只能披占有它的进程显式地释放。&lt;/li&gt;
&lt;li&gt;环路等待条件。死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;死锁建模
&lt;ul&gt;
&lt;li&gt;Holt 指出如何用有向图建立上述四个条件的模型。在有向图中有两类节点:用圆形表示的进程，用方形表示的资源。从资源节点到进程节点的有向边代表该资源已被请求、授权井被进程占用。由进程节点到资源节点的有向边表明当前进程正在请求该资源，并且该进程已被阻塞，处于等待该资源的状态。&lt;/li&gt;
&lt;li&gt;有四种处理死锁的策眳
&lt;ul&gt;
&lt;li&gt;忽略该问题。也许如果你忽略它，它也会忽略你。&lt;/li&gt;
&lt;li&gt;检测死锁井恢复。让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题。&lt;/li&gt;
&lt;li&gt;仔细对资源进行分配，动态地避免死锁。&lt;/li&gt;
&lt;li&gt;通过破坏引起死锁的四个必要条件之一，防止死锁的产生。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;鸵鸟算法
&lt;ul&gt;
&lt;li&gt;假装根本没有问题发生&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;死锁检测和死锁恢复
&lt;ul&gt;
&lt;li&gt;每种类型一个资源的死锁检测
&lt;ul&gt;
&lt;li&gt;构造一张资源分配图，从中检测有向环图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每种类型多个资源的死锁检测
&lt;ul&gt;
&lt;li&gt;现在我们提供一种基于矩阵的算法来检测从 p1 到 pn 这 n 个进程中的死锁。&lt;/li&gt;
&lt;li&gt;假设资源的类型数为 m, E1 代表资源类型 1, E2 代表资源类型 2, Ei 代表资源类型 i。E 是现有资源向量 (existing resource vector) ,&lt;/li&gt;
&lt;li&gt;现在我们需要两个数组:C 代表当前分配矩阵 (current allocation matrix), R 代表请求矩阵 (request matrix)。 C 的第 i 行代表 Pi 当前所持有的每一种类型资源的资源数。所以，Cij 代表进程 i 所持有的资源 j 的数量。同理，Rij 代表 Pi 所需要的资源 j 的数量。&lt;/li&gt;
&lt;li&gt;每个进程起初都是没有标记过的。算法开始会对进程做标记，进程被标记后就表明它们能够被执行，不会进入死锁。当算法结束时，任何没有标记的进程都是死锁进程。该算法假定了一个最坏悄形:所有的进程在退出以前都会不停地获取资源。&lt;/li&gt;
&lt;li&gt;死锁检测算法如下:
&lt;ul&gt;
&lt;li&gt;寻找一个没有标记的进程 Pi, 对于它而言 R 矩阵的第 i 行向让小于或等于 A。&lt;/li&gt;
&lt;li&gt;如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转到第 1 步。&lt;/li&gt;
&lt;li&gt;如果没有这样的进程，那么算法终止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从死锁中恢复
&lt;ul&gt;
&lt;li&gt;利用抢占恢复：在不通知原进程的情况下，将某一资源从一个进程强行取走给另一个进程使用，接着又送回，这种做法是否可行主要取决于该资源本身的特性。用这种方法恢复通常比较困难或者说不太可能。若选择挂起某个进程，则在很大程度上取决干哪一个进程拥有比较容易收回的资源。&lt;/li&gt;
&lt;li&gt;利用回滚恢复：周期性地对进程进行检查点检查，进程检查点检查查就是将进程的状态写入一个文件以备以后重启。该检查点中不仅包括存储映像，还包括了资源状态，即哪些资源分配给了该进程。一旦检测到死锁，就很容易发现需要哪些资源。为了进行恢复，要从一个较早的检查点上开始，这样拥有所需要资源的进程会回滚到一个时间点，在此时间点之前该进程获得了一些其他的资源。在该检查点后所做的所有工作都丢失。&lt;/li&gt;
&lt;li&gt;通过杀死进程恢复：最直接也是最简单的解决死锁的方法是杀死一个或若干个进程。一种方法是杀掉环中的一个进程。如果走运的话，其他进程将可以继续。如果这样做行不通的话，就需要继续杀死别的进程直到打破死锁环。另一种方法是选一个环外的进程作为牺牲品以释放该进程的资源。在使用这种方法时，选择一个要被杀死的进程要特别小心，它应该正好持有环中某些进程所需的资源.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;死锁避免
&lt;ul&gt;
&lt;li&gt;安全状态和不安全状态&lt;/li&gt;
&lt;li&gt;单个资源的银行家算法&lt;/li&gt;
&lt;li&gt;多个资源的银行家算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;死锁预防
&lt;ul&gt;
&lt;li&gt;破坏互斥条件
&lt;ul&gt;
&lt;li&gt;假脱机硬件资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;破坏占有并等待条件
&lt;ul&gt;
&lt;li&gt;规定所有进程在开始执行前请求所需的全部资源。如果所需的全部资源可用，那么就将它们分配给这个进程，千是该进程肯定能够运行结束。如果有一个或多个资沥正被使用，那么就不进行分配，进程等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;破坏不可抢占条件
&lt;ul&gt;
&lt;li&gt;一些资源可以通过虚拟化的方式来避免发生这样的情况。假脱机打印机向磁盘输出，并且只允许打印机守护进程访问真正的物理打印机，这种方式可以消除涉及打印机的死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;破坏环路等待条件
&lt;ul&gt;
&lt;li&gt;保证每一个进程在任何时刻只能占用一个资源，如果要请求另外一个资源. 它必须先释放第一个资源。&lt;/li&gt;
&lt;li&gt;进程可以在任何时刻提出资源请求，但是所有诮求必须按照资源编号的顺序(升序)提出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他问题
&lt;ul&gt;
&lt;li&gt;两段式加锁: 在第一阶段，进程试图对所有所需的记录进行加锁，一次锁一个记录。如果第一阶段加锁成功，就开始第二阶段，完成更新然后释放锁。在第一阶段并没有做实际的工作。 如果在第一阶段某个进程需要的记录已经被加锁，那么该进程释放它所有加锁的记录，然后重新开始第一阶段。&lt;/li&gt;
&lt;li&gt;通信死锁: 通信死锁不能通过对资源排序(因为没有)或者通过仔细地安排调度来避免(因为任何时刻的诮求都是不允许被延迟的)。幸运的是，另外一种技术通常可以用来中断通信死锁:超时。&lt;/li&gt;
&lt;li&gt;活锁: 在某些情况下，当进程意识到它不能获取缓冲区路由器所需要的下一个锁时，就会尝试礼貌地释放已经获得的锁，然后等待 1ms, 再尝试一次。&lt;/li&gt;
&lt;li&gt;饥饿: 动态运行的系统中，在任何时刻都可能请求资源。这就需要一些策略来决定在什么时候谁获得什么资源。虽然这个策略表面上很有道理，但依然有可能使一些进程永远得不到服务，虽然它们并不是死锁进程。饥饿可以通过先来先服务资源分配策略来避免。在这种机制下，等待最久的进程会是下一个被调度的进程。随着时间的推移，所有进程都会变成最“老”的，因而，最终能够获得资源而完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有关死锁的研究
&lt;ul&gt;
&lt;li&gt;死锁避免&lt;/li&gt;
&lt;li&gt;死锁检测&lt;/li&gt;
&lt;li&gt;分布式死锁检测&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>现代操作系统::输入/输出</title>
      <link>/notes/modern_operating_systems_input_output/</link>
      <pubDate>Sun, 18 Jul 2021 02:11:01 +0800</pubDate>
      <guid>/notes/modern_operating_systems_input_output/</guid>
      <description>&lt;h2 id=&#34;输入输出&#34;&gt;输入/输出&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;I/O 硬件原理
&lt;ul&gt;
&lt;li&gt;I/O 设备
&lt;ul&gt;
&lt;li&gt;分类
&lt;ul&gt;
&lt;li&gt;块设备，块设备把信息存储在固定大小的块中.每个块有自己的地址。通常块的大小在 512 字节至 65536 字节之间。所有传输以一个或多个完整的(连续的)块为单位。块设备的基本特征是每个块都能独立干其他块而读写。硬盘、蓝光光盘和 USB 盘是最常见的块设备。&lt;/li&gt;
&lt;li&gt;字符设备，字符设备以字符为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。打印机、鼠标、键盘以及大多数与磁盘不同的设备都可以看作字符设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设备控制器
&lt;ul&gt;
&lt;li&gt;I/O 设备一般由机械部件和电子部件两部分组成。通常可以将这两部分分开处理，以提供更加模块化和更加通用的设计。电子部件称作设备控制器 (device controller) 或适配器 (adapter)。在个人计算机上，它经常以主板上的芯片的形式出现，或者以插入 (PCI) 扩展槽中的印刷电路板的形式出现。机械部件则是设备本身。&lt;/li&gt;
&lt;li&gt;控制器与设备之间的接口通常是一个很低层次的接口。&lt;/li&gt;
&lt;li&gt;控制器的任务是把串行的位流转换为字节块，井进行必要的错误校正工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存映射 I/O
&lt;ul&gt;
&lt;li&gt;每个控制器有几个寄存器用来与 CPU 进行通信。通过写人这些寄存器，操作系统可以命令设备发送数据接收数据、开启或关闭，或者执行某些其他操作。通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。&lt;/li&gt;
&lt;li&gt;除了这些控制寄存器以外，许多设备还有一个操作系统可以读写的数据缓冲区。&lt;/li&gt;
&lt;li&gt;每个控制寄存器被分配一个 I/O 端口 (I/O port) 号，这是一个 8 位或 16 位的整数。所 有 I/O 端口形成 I/O 端口空间 (I/O port space), 井且受到保护使得普通的用户程序不能对其进行访问(只有操作系统可以访问)。CPU 通过这个 I/O 端口和控制器通信。&lt;/li&gt;
&lt;li&gt;另一种方式是将所有控制寄存器映射到内存空间中，每个控制寄存器被分配唯一的一个内存地址，井且不会有内存被分配这一地址。这样的系统称为内存映射 I/O&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;直接存储器存取
&lt;ul&gt;
&lt;li&gt;CPU 从 I/O 控制器请求数据浪费 CPU 时间，所以经常用到一种称为直接存储器存取的方案。&lt;/li&gt;
&lt;li&gt;DMA 的工作过程
&lt;ul&gt;
&lt;li&gt;CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA 控制器知道将什么数据传送到什么地方。&lt;/li&gt;
&lt;li&gt;DMA 控制器通过在总线上发出一个读请求到磁盘控制器而发起 DMA 传送&lt;/li&gt;
&lt;li&gt;磁盘控制器从其内部缓冲区读取内容后，写到内存中。&lt;/li&gt;
&lt;li&gt;当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器&lt;/li&gt;
&lt;li&gt;DMA 控制器步增要使用的内存地址，井且步减字节计数。如果字节计数仍然大于 O, 则重复第 2 步到第 4 步，直到字节计数到达 0。此时，DMA 控制器将中断 CPU 以便让 CPU 知道传送现在已经完成了。当操作系统开始工作时，用不着将磁盘块复制到内存中，因为它已经在内存中了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;总线操作模式
&lt;ul&gt;
&lt;li&gt;字模式：DMA 控制器请求传送一个字并且得到这个字。如果 CPU 也想使用总线，它必须等待。这一机制称为周期窃取(cycle stealing),因为设备控制器偶尔偷偷溜入并且从 CPU 偷走一个临时的总线周期，从而轻微地延迟 CPU。&lt;/li&gt;
&lt;li&gt;块模式：在块模式中，DMA 控制器通知设备获得总线，发起一连串的传送，然后释放总线。这一操作形式称为突发模式 (burst mode)。它比周期窃取效率更高，因为获得总线占用了时间，井且以一次总线获得的代价能够传送多个字。突发模式的缺点是，如果正在进行的是长时间突发传送，有可能将 CPU 和其他设备阻塞相当长的周期。&lt;/li&gt;
&lt;li&gt;飞跃模式：DMA 控制器通知设备控制器直接将数据传送到主存。某些 DMA 控制器使用的其他校式是让设备控制器将字发送给 DMA 控制器. DMA 控制器然后发起第 2 个总线请求将该字写到它应该去的任何地方。采用这种方案，每传送一个字需要一个额外的总线周期，但是更加灵活，因为它可以执行设备到设备的复制甚至是内存到内存的复制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重温中断
&lt;ul&gt;
&lt;li&gt;在硬件层面，中断的工作如下所述。当一个 I/O 设备完成交给它的工作时，它就产生一个中断(假设操作系统已经开放中断)，它是通过在分配给它的一条总线信号线上置起信号而产生中断的。该信号被主板上的中断控制器芯片检测到，由中断控制器芯片决定做什么。&lt;/li&gt;
&lt;li&gt;中断信号导致 CPU 停止当前正在做的工作井且开始做其他的事情。地址线上的数字被用做指向一个称为中断向量 (interrupt vector) 的表格的索引，以便读取一个新的程序计数器。这一程序计数器指向相应的中断服务过程的开始.&lt;/li&gt;
&lt;li&gt;中断服务过程开始运行后，它立刻通过将一个确定的值写到中断控制器的某个 I/O 端口来对中断做出应答。这一应答告诉中断控制器可以自由地发出另一个中断。通过让 CPU 延迟这一应答直到它准备好处理下一个中断，就可以避免与多个几乎同时发生的中断相牵涉的竞争状态。&lt;/li&gt;
&lt;li&gt;在开始服务程序前，硬件需要保存必要的信息。&lt;/li&gt;
&lt;li&gt;精确中断和不精确中断
&lt;ul&gt;
&lt;li&gt;将机器留在一个明确状态的中断称为精确中断
&lt;ul&gt;
&lt;li&gt;PC(程序计数器)保存在一个已知的地方 。&lt;/li&gt;
&lt;li&gt;PC 所指向的指令之前的所有指令已经完全执行。&lt;/li&gt;
&lt;li&gt;PC 所指向的指令之后的所有指令都没有执行。&lt;/li&gt;
&lt;li&gt;PC 所指向的指令的执行状态是已知的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不满足以上条件的中断称为不精确中断
&lt;ul&gt;
&lt;li&gt;具有不精确中断的机器通常将大量的内部状态&amp;quot;吐出”到堆栈中，从而使操作系统有可能判断出正在发生什么事情。重新启动机器所必需的代码通常极其复杂。此外，在每次中断发生时将大让的信息保存在内存中使得中断响应十分缓慢，而恢复则更加糟糕。&lt;/li&gt;
&lt;li&gt;某些超标量计算机(例如 x86 系列)具有精确中断，从而使老的软件正确工作。为与精确中断保持后向兼容付出的代价是 CPU 内部极其复杂的中断逻辑，以便确保当中断控制器发出信号想要导致一个中断时，允许直到某一点之前的所有指令完成而不允许这一点之后的指令对机器状态产生任何重要的影响。&lt;/li&gt;
&lt;li&gt;此处付出的代价不是在时间上，而是在芯片面积和设计复杂性上。如果不是因为向后兼容的目的而要求精确中断的话，这一芯片面积就可以用于更大的片上高速缓存，从而使 CPU 的速度更快。另一方面，不精确中断使得操作系统更为复杂而且运行得更加缓慢，所以断定哪一种方法更好是十分困难的.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;I/O 软件原理
&lt;ul&gt;
&lt;li&gt;I/O 软件的目标
&lt;ul&gt;
&lt;li&gt;在设计 I/O 软件时一个关键的概念是设备独立性 (device independence)。它的意思是应该能够编写出这样的程序:它可以访问任意 I/O 设备而无需事先指定设备。&lt;/li&gt;
&lt;li&gt;与设备独立性密切相关的是统一命名 (uniform naming) 这一目标。一个文件或一个设备的名字应该是一个简单的字符串或一个整数，它不应依赖于设备。&lt;/li&gt;
&lt;li&gt;I/O 软件的另一个重要问题是错误处理 (error handling)。一般来说，错误应该尽可能地在接近硬件的层面得到处理。只有在低层软件处理不了的情况下，才将错误上交高层处理。在许多情况下，错误恢复可以在低层透明地得到解决，而高层软件甚至不知道存在这一错误。&lt;/li&gt;
&lt;li&gt;同步 (synchronous 即阻塞)和异步 (asynchronous, 即中断驱动)传输。大多数物理 I/0 是异步的，CPU 启动传输后便转去做其他工作，直到中断发生。如果 I/O 操作是阻塞的，那么用户程序就更加容易编写一在 read 系统调用之后，程序将自动被挂起，直到缓冲区中的数据准备好。正是操作系统使实际上是中断驱动的操作变为在用户程序看来是阻塞式的操作。然而，某些性能极高的 应用程序需要控制 I/O 的所有细节，所以某些操作系统使异步 I/O 对这样的应用程序是可用的。&lt;/li&gt;
&lt;li&gt;缓冲 (buffering)。数据离开一个设备之后通常并不能直接存放到其最终的目的地，而是放到了某个地方对它进行检查，才能确定最后需要发送到哪里，缓冲区填满和清空的速率也影响 I/O 性能。&lt;/li&gt;
&lt;li&gt;设备独占和共享问题。打印机之类的只允许一个用户使用，某些文件被多人打开同时写入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;程序控制 I/O
&lt;ul&gt;
&lt;li&gt;考虑一个用户进程，该进程想通过串行接口在打印机 上打印 8 个字符的字符串&amp;quot;ABCDEFGH&amp;quot;。&lt;/li&gt;
&lt;li&gt;软件首先要在用户空间的一个缓冲区中组装字符串&lt;/li&gt;
&lt;li&gt;用户进程通过发出打开打印机一类的系统调用来获得打印机以便进行写操作&lt;/li&gt;
&lt;li&gt;操作系统(通常)将字符串缓冲区复制到内核空间中的一个数组(如 p)中&lt;/li&gt;
&lt;li&gt;操作系统要查看打印机当前是否可用。如果不可用，就要等待直到它可用&lt;/li&gt;
&lt;li&gt;操作系统就复制第一个字符到打印机的数据寄存器中，在这个例子中使用了内存映射 I/O&lt;/li&gt;
&lt;li&gt;这时，操作系统将等待打印机状态再次变为就绪。打印机就绪事件发生时，操作系统就打印下一个字符，直到过程完成，返回用户进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中断驱动 I/O
&lt;ul&gt;
&lt;li&gt;在不缓冲字符而是在每个字符到来时便打印的打印机上进行打印的情形。&lt;/li&gt;
&lt;li&gt;当程序把字符写入打印机的寄存器后，在打印机就绪前切换上下文去执行别的程序。&lt;/li&gt;
&lt;li&gt;当打印机就绪的时候发出一个中断，程序被调度回来继续执行直到完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 DMA 的 I/O
&lt;ul&gt;
&lt;li&gt;让 DMA 控制器而不是 CPU 完成任务，中断次数每字节一次变成没缓冲区一次。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;I/O 软件层次
&lt;ul&gt;
&lt;li&gt;中断处理程序
&lt;ul&gt;
&lt;li&gt;虽然程序控制 I/O 偶尔是有益的，但是对于大多数 I/O 而言，中断是令人不愉快的事情并且无法避免。应当将其深深隐藏在操作系统内部，一边系统的其他部分尽量不与它发生联系。隐藏它们的最好办法是将启动一个 I/O 操作的驱动程序阻塞起来，直到 I/O 操作完成并且产生一个中断。&lt;/li&gt;
&lt;li&gt;当中断发生时，中断处理程序将做它必须要做的全部工作以便对中断进行处理。&lt;/li&gt;
&lt;li&gt;中断最终的结果是使先前被阻塞的驱动程序现在能够继续运行。&lt;/li&gt;
&lt;li&gt;处理过程
&lt;ul&gt;
&lt;li&gt;保存没有被中断硬件保存的所有寄存器(包括 PSW)。&lt;/li&gt;
&lt;li&gt;为中断服务过程设置上下文，可能包括设置 TLB、 MMU 和页表。&lt;/li&gt;
&lt;li&gt;为中断服务过程设置堆栈.&lt;/li&gt;
&lt;li&gt;应答中断控制器，如果不存在集中的中断控制器，则再次开放中断。&lt;/li&gt;
&lt;li&gt;将寄存器从它们被保存的地方(可能是某个堆栈)复制到进程表中。&lt;/li&gt;
&lt;li&gt;运行中断服务过程，从发出中断的设备控制器的寄存器中提取信息.&lt;/li&gt;
&lt;li&gt;选择下一次运行哪个进程，如果中断导致某个被阻塞的高优先级进程变为就绪，则可能选择它现在就运行。&lt;/li&gt;
&lt;li&gt;为下一次要运行的进程设置 MMU 上下文，也许还蒂要设置某个 TLB。&lt;/li&gt;
&lt;li&gt;装入新进程的寄存器，包括其 PSW。&lt;/li&gt;
&lt;li&gt;开始运行新进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设备驱动程序
&lt;ul&gt;
&lt;li&gt;每一个控制器都设有某些设备寄存器用来向设备发出命令，或者设有某些设备寄存器用来读出设备的状态，或者设有这两种设备寄存器，寄存器的数量根据功能不同在不同的设备之间数量也不同。&lt;/li&gt;
&lt;li&gt;每个连接到计算机上的 I/O 设备都需要某些设备特定的代码来对其进行控制。这样的代码称为设备驱动程序 (device driver), 它一般由设备的制造商编写并随同设备一起交付。&lt;/li&gt;
&lt;li&gt;每个设备驱动程序通常处理一种类型的设备，或者至多处理一类紧密相关的设备。&lt;/li&gt;
&lt;li&gt;不过在有些时候，极其不同的设备却基于相同的底层技术。众所周知的例子可能是 USB。&lt;/li&gt;
&lt;li&gt;驱动程序必须是重入的 (reentrant), 这意味着一个正在运行的驱动程序必须预料到在第一次调用完成之前第二次被调用。&lt;/li&gt;
&lt;li&gt;在一个可热插拔的系统中，设备可以在计算机运行时添加或删除。&lt;/li&gt;
&lt;li&gt;驱动程序不允许进行系统调用，但是它们经常需要与内核的其余部分进行交互。对某些内核过程的调用通常是允许的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;与设备无关的 I/O 软件
&lt;ul&gt;
&lt;li&gt;设备驱动程序的统一接口
&lt;ul&gt;
&lt;li&gt;操作系统定义一组驱动程序必须支持的函数。&lt;/li&gt;
&lt;li&gt;设备无关的软件要负责把符号化的设备名映射到适当的驱动程序上。&lt;/li&gt;
&lt;li&gt;所有设备都具有主设备号和次设备号，并且所有驱动程序都是通过使用主设备号来选择驱动程序而得到访问。&lt;/li&gt;
&lt;li&gt;在 UNIX 和 Windows 中.设备是作为命名对象出现在文件系统中的，这意味着针对文件的常规的保护规则也适用千 I/O 设备。系统管理员可以为每一个设备设置适当的访问权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缓冲
&lt;ul&gt;
&lt;li&gt;实现方案
&lt;ul&gt;
&lt;li&gt;用户进程在用户空间中提供了一个包含 n 个字符的缓冲区，并且执行读入 n 个字符的读操作。中断服务过程负责将到来的字符放入该缓冲区中直到缓冲区填满，然后唤醒用户进程。&lt;/li&gt;
&lt;li&gt;在内核空间中创建一个缓冲区并且让中断处理程序将字符放到这个缓冲区中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结构
&lt;ul&gt;
&lt;li&gt;双缓冲，当一个缓冲区满的时候使用另一个缓冲区&lt;/li&gt;
&lt;li&gt;环形缓冲区，它由一个内存区域和两个指针组成。一个指针指向下一个空闲的字，新的数据可以放置到此处。另一个指针指向缓冲区中数据的第一个字，该字尚未被取走。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;错误报告
&lt;ul&gt;
&lt;li&gt;错误在 I/O 上下文中比在其他上下文中要常见得多。当错误发生时，操作系统必须尽最大努力对它们进行处理。许多错误是设备特定的并且必须由适当的驱动程序来处理，但是错误处理的框架是设备无关的.&lt;/li&gt;
&lt;li&gt;一种类型的 I/O 错误是编程错误，解决方案是将错误码返回给调用者。&lt;/li&gt;
&lt;li&gt;另一种类型的错误是实际的 I/O 错误，如磁盘损坏，在这些情形中，应该由驱动程序决定做什么。如果驱动程序不知道做什么，它应该将问题向上传递，返回给与设备无关的软件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分配与释放专用设备
&lt;ul&gt;
&lt;li&gt;某些设备，例如打印机，在任意给定的时刻只能由一个进程使用。这就要求操作系统对设备使用的诮求进行检查，并且根据被访求的设备是否可用来接受或者拒绝这些请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;与设备无关的块大小
&lt;ul&gt;
&lt;li&gt;应该由与设备无关的软件来隐藏这一事实井且向高层提供一个统一的块大小&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用户空间的 I/O 软件
&lt;ul&gt;
&lt;li&gt;大多数 I/O 事件都发生在内核，但还是有小部分发生在用户空间&lt;/li&gt;
&lt;li&gt;假脱机目录，脱离操作系统的 I/O 事件，将需要发送的块放到文件目录中，稍后由守护进程发送出去&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;盘
&lt;ul&gt;
&lt;li&gt;盘硬件
&lt;ul&gt;
&lt;li&gt;磁盘
&lt;ul&gt;
&lt;li&gt;磁盘被组织成柱面，每一个柱面包含若干磁道，磁道数与垂直堆叠的磁头个数相同。磁道又被分成若干扇区，软盘上大约每条磁道有 8~32 个扇区，硬盘上每条磁道上扇区的数目可以多达几百个。磁头 数大约是 1 ~ 16 个。&lt;/li&gt;
&lt;li&gt;磁盘驱动器本身包含一个微控制器，该微控制器承担了大员的工作并且允许实际的控制器发出一组高级命令。控制器经常做磁道高速缓存、坏块重映射以及更多的工作。&lt;/li&gt;
&lt;li&gt;对磁盘驱动程序有重要意义的一个设备特性是:控制器是否可以同时控制两个或多个驱动器进行寻道，这就是重叠寻道 (overlapped seek)。当控制器和软件等待一个驱动器完成寻道时，控制器可以同时启动另一个驱动器进行寻道。许多控制器也可以在一个驱动器上进行读写操作，与此同时再对另一个或多个其他驱动器进行寻道，但是软盘控制器不能在两个驱动器上同时进行读写操作。&lt;/li&gt;
&lt;li&gt;所有现代磁盘现在都支持一种称为逻辑块寻址，而不管磁盘的几何规格如何&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RAID
&lt;ul&gt;
&lt;li&gt;RAID 定义为 Redundant Array of Inexpensive Disk (廉价磁盘冗余阵列)，但是工业界将 I 重定义为 Independent (独立)而不是 Inexpensive (廉价)&lt;/li&gt;
&lt;li&gt;RAID 背后的基本思想是将一个装满了磁盘的盒子安装到计算机(通常是一个大型服务器)上，用 RAID 控制器替换磁盘控制器卡，将数据复制到整个 RAID 上，然后继续常规的操作。&lt;/li&gt;
&lt;li&gt;所有的 RAID 都具有同样的特性，那就是将数据分布在全部驱动器上，这样就可以并行操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;磁盘格式化
&lt;ul&gt;
&lt;li&gt;一个扇区由前导码，数据，ECC 组成。
&lt;ul&gt;
&lt;li&gt;前导码以一定的位模式开始，位模式使硬件得以识别扇区的开始。前导码还包含柱面与扇区号以及某些其他信息。&lt;/li&gt;
&lt;li&gt;数据部分的大小是由低级格式化程序决定的，大多数磁盘使用 512 字节的扇区。&lt;/li&gt;
&lt;li&gt;ECC 域包含冗余信息，可以用来恢复读错误&lt;/li&gt;
&lt;li&gt;低级格式化的结果是磁盘容量减少，减少的摄取决于前导码、扇区间间隙和 ECC 的大小以及保留的备用扇区的数目。通常格式化的容量比未格式化的容量低 20%。备用扇区不计人格式化的容量，所以一种给定类型的所有磁盘在出厂时具有完全相同的容址，与它们实际具有多少坏扇区无关&lt;/li&gt;
&lt;li&gt;在低级格式化完成之后，要对磁盘进行分区。在逻辑上，每个分区就像是一个独立的磁盘.分区对于实现多个操作系统共存是必要的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;磁盘臂调度算法
&lt;ul&gt;
&lt;li&gt;影响读写磁盘块时间的因素
&lt;ul&gt;
&lt;li&gt;寻道时间&lt;/li&gt;
&lt;li&gt;旋转延迟&lt;/li&gt;
&lt;li&gt;实际数据传输延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调度算法
&lt;ul&gt;
&lt;li&gt;先来先服务：磁盘驱动程序每次接收一个诘求井按照接收顺序完成请求&lt;/li&gt;
&lt;li&gt;最短寻道优先：总是处理与磁头距离最近的请求以使寻道时间最小化&lt;/li&gt;
&lt;li&gt;电梯算法：电梯保持按一个方向移动，直到在那个方向上没有请求为止，然后改变方向&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缓存
&lt;ul&gt;
&lt;li&gt;许多磁盘控制器总是读出多个扇区并对其进行高速缓存&lt;/li&gt;
&lt;li&gt;高速缓存的使用是由控制器动态地决定的。在最简单的模式下，高速缓存被分成两个区段，一个用于读，一个用于写&lt;/li&gt;
&lt;li&gt;磁盘控制器的高速缓存完全独立千操作系统的高速缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;错误处理
&lt;ul&gt;
&lt;li&gt;对于坏块存在两种一般的处理方法:在控制器中对它们进行处理或者在操作系统中对它们进行处理。在前一种方法中，磁盘在从工厂出厂之前要进行测试，井且将一个坏扇区列表写在磁盘上。对千每一个坏扇区，用一个备用扇区替换它 。
&lt;ul&gt;
&lt;li&gt;有两种方法进行这样的替换
&lt;ul&gt;
&lt;li&gt;控制器所能够做的事情是将备用扇区之一重映射为坏扇区&lt;/li&gt;
&lt;li&gt;另一种方法是将所有扇区向上移动一个扇区&lt;/li&gt;
&lt;li&gt;在这两种情况下，控制器都必须知道哪个扇区是哪个扇区。它可以通过内部的表来跟踪这一信息(每个磁道一张表)，或者通过重写前导码来给出重映射的扇区号。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二种操作系统必须首先获得一个坏扇区列表，或者是通过从磁盘中读出该列表，或者只是由它自己测试整个磁盘。一旦操作系统知道哪些扇区是坏的，它就可以建立项映射表。&lt;/li&gt;
&lt;li&gt;除了磁盘坏块还有寻道错误，大多数磁盘可以自动回复，通过把磁臂往外移动，并把当前柱面重置为 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;稳定存储器
&lt;ul&gt;
&lt;li&gt;一个磁盘子系统具有如下特性:当 一个写命令发给它时，磁盘要么正确地写数据，要么什么也不做，让现有的数据完整无缺地留下。&lt;/li&gt;
&lt;li&gt;稳定存储器使用一对完全相同的磁盘，对应的块一同工作以形成一个无差错的块。当不存在错误时， 在两个驱动器上对应的块是相同的，读取任意一个都可以得到相同的结果。
&lt;ul&gt;
&lt;li&gt;稳定写 (stable write)。稳定写首先将块写到驱动器 1 上，然后将其读回以校验写的是正确的。如果写的不正确，那么就再次做写和重读操作，一直到 n 次，直到正常为止。经过 n 次连续的失败之后，就将该块重映射到一个备用块上，并且重复写和重读操作直到成功为止，无论要尝试多少个备用块。在对驱动器 1 的写成功之后，对驱动器 2 上对应的块进行写和重读，如果需要的话就重复这样的操作，直到最后成功为止。如果不存在 CPU 崩溃，那么当稳定写完成后，块就正确地被写到两个驱动器上，井且在两个驱动器上得到校验。&lt;/li&gt;
&lt;li&gt;稳定读 (stable read)。稳定读首先从驱动器 1 上读取块。如果这一橾作产生错误的 ECC, 则再次尝试读操作，一直到 n 次。如果所有这些操作都给出错误的 ECC, 则从驱动器 2 上读取对应的数据块。给定一个成功的稳定写为数据块留下两个可靠的副本这样的事实，并且我们假设在合理的时间间隔内相同的块在两个驱动器上自发地变坏的概率可以忽略不计，那么稳定读就总是成功的 。&lt;/li&gt;
&lt;li&gt;崩溃恢复 (crash recovery)。崩溃之后，恢复程序扫描两个磁盘，比较对应的块。如果一对块都是好的井且是相同的，就什么都不做。 如果其中一个具有 ECC 错误，那么坏块就用对应的好块来覆盖. 如果一对块都是好的但是不相同，那么就将驱动器 1 上的块写到驱动器 2 上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时钟
&lt;ul&gt;
&lt;li&gt;时钟硬件
&lt;ul&gt;
&lt;li&gt;时钟由三个部件构成: 晶体振荡器、计数器和存储寄存器&lt;/li&gt;
&lt;li&gt;当把一块石英晶体适当地切割并且安装在一定的电压之下时，它就可以产生非常精确的周期性信号，典型的频率范围是几百兆赫兹，具体的频率值与所选的品体有关。&lt;/li&gt;
&lt;li&gt;在任何一台计算机里通常都可以找到至少一个这样的电路，它给计算机的各种电路提供同步信号。该信号被送到计数器，使其递减计数至 0。当计数器变为 0 时，产生一个 CPU 中断。&lt;/li&gt;
&lt;li&gt;可编程时钟通常具有几种操作模式
&lt;ul&gt;
&lt;li&gt;一次完成模式
&lt;ul&gt;
&lt;li&gt;当时钟启动时，它把存储寄存器的值复制到计数器中，然后，来自晶体的每一个脉冲使计数器减 1。当计数器变为 0 时，产生一个中断，井停止工作，直到软件再一次显式地启动它&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方波模式
&lt;ul&gt;
&lt;li&gt;当计数器变为 0 井且产生中断之后，存储寄存器的值自动复制到计数器中，并且整个过程无限期地再次重复下去。这些周期性的中断称为时钟滴答&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可编程时钟芯片通常包含多个独立的可编程时钟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时钟软件
&lt;ul&gt;
&lt;li&gt;时钟硬件所做的全部工作是根据已知的时间间隔产生中断。涉及时间的其他所有工作都必须由软件时钟驱动程序完成.
&lt;ul&gt;
&lt;li&gt;维护日时间
&lt;ul&gt;
&lt;li&gt;用 64 位寄存器存滴答数&lt;/li&gt;
&lt;li&gt;以秒为单位维护时间&lt;/li&gt;
&lt;li&gt;以秒为单位的系统引导时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;防止进程超时运行
&lt;ul&gt;
&lt;li&gt;每当启动一个进程时，调度程序就将一个计数器初始化为 1，以时钟滴答为单位的该进程时间片的取值。每次时钟中断时，时钟驱动程序将时间片计数器减 1。当计数器变为 0 时，时钟驱动程序调用调度程序以激活另一个进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对 CPU 的使用情况记账
&lt;ul&gt;
&lt;li&gt;启动一个不同于主系统定时器的辅助定时器。当进程终止时，读出这个定时器的值就可以知道该进程运行了多长时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理用户进程提出的 alarm 系统调用
&lt;ul&gt;
&lt;li&gt;进程可以请求操作系统在一定的时间间隔之后向它报警。警报通常是信号、中断、消息或者类似的东西。需要这类报警的一个应用是网络，当一个数据包在一定时间间隔之内没有被确认时，该数据包必须重发。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为系统本身的各个部分提供监视定时器
&lt;ul&gt;
&lt;li&gt;操作系统的组成部分也摇要设置定时器，这些定时器被称为监视定时器，并且经常用来检测死机之类的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;完成概要剖析、监视和统计信息收集
&lt;ul&gt;
&lt;li&gt;某些操作系统提供了一种机制，通过该机制用户程序可以让系统构造它的程序计数器的一个直方图，这样它就可以了解时间花在了什么地方。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软定时器
&lt;ul&gt;
&lt;li&gt;无论何时当内核因某种其他原因在运行时，在它返回到用户态之前，它都要检查实时时钟以了解软定时器是否到期。如果这个定时器已经到期，则执行被调度的事件。如，传送数据包或者桧查到来的数据包，而无需切换到内核态，因为系统已经在内核态。在完成工作之后，软定时器被复位以便再次闹响。要做的全部工作是将当前时钟值复制给定时器并且将超时间隔加上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用户界面:键盘、鼠标和监视器
&lt;ul&gt;
&lt;li&gt;输入软件
&lt;ul&gt;
&lt;li&gt;键盘软件
&lt;ul&gt;
&lt;li&gt;硬件所做的全部工作是给出键被按下和释放的中断，其他的事情由软件来做。&lt;/li&gt;
&lt;li&gt;例如，当 A 键被按下时，扫描码(30)被写入一个 I/O 寄存器。驱动程序应该负责确定键入的是小写字母.大写字母、 CTRL-A、ALT-A、CTRL-ALT-A 还是某些其他组合。由于驱动程序以断定哪些键已经按下但是还没有被释放(例如 SHIFR), 所以它拥有足够多的信息来做这一工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;鼠标
&lt;ul&gt;
&lt;li&gt;当鼠标在随便哪个方向移动了一个确定的最小距离，或者按钮被按下或释放时，都会有一条消息发送给计算机。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;输出软件
&lt;ul&gt;
&lt;li&gt;文本窗口
&lt;ul&gt;
&lt;li&gt;ASNI 标准，转移序列标准化，标准化移动光标等控制符的方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;X 窗口系统
&lt;ul&gt;
&lt;li&gt;几乎所有 UNIX 系统的用户界面都以 X 窗口系统 (X Window System) 为基础，&lt;/li&gt;
&lt;li&gt;当 X 在一台机器上运行时，从键盘或鼠标采集输入并且将输出写到屏幕上的软件称为 X 服务器 (X server)。它必须跟踪当前选择了哪个窗口(鼠标指针所在处).这样它就知道将新的键盘输入发送给哪个客户。它与称为 X 客户 (X client) 的运行中的程序进行通信 (可能通过网络 )。它将键盘与鼠标输入发送给 X 客户，井且从 X 客户接收显示命令。&lt;/li&gt;
&lt;li&gt;X 只是一个窗口系统，它不是一个完全的 GUI。为了获得完全的 GUI, 要在其上运行共他软件层。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;图形用户界面
&lt;ul&gt;
&lt;li&gt;GUI 软件可以在用户级代码中实现(如 UNIX 系统所做的那样)，也可以在操作系统中实现(如 Windows 的情况 ).&lt;/li&gt;
&lt;li&gt;GUI 系统的输入仍然使用键盘和鼠标，但是输出几乎总是送往特殊的硬件电路板，称为 图形适配器(graphics adapter)。图形适配器包含特殊的内存，称为视频 RAM(video RAM),它保存出现在屏幕上的图像。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;位图
&lt;ul&gt;
&lt;li&gt;GDI 过程是矢量图形学的实例.它们用于在屏幕上放置几何图形和文本。&lt;/li&gt;
&lt;li&gt;每一个网格方块的平均红、绿、蓝取值被采样井且保存为一个像素的值。这样的文件称为位图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字体
&lt;ul&gt;
&lt;li&gt;TrueType 的引入解决了字体放大缩小都可以完整显示的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;触摸屏
&lt;ul&gt;
&lt;li&gt;电阻屏，ITO 电荷移动获取位置&lt;/li&gt;
&lt;li&gt;电容屏，有两层表面，手指触摸改变两层之间的电容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;瘦客户机
&lt;ul&gt;
&lt;li&gt;大多数用户想要高性能的交互式计算，但是实在不想管理一台计算机。这一结论导致研究人员重新研究了分时系统使用的哑终端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;电源管理
&lt;ul&gt;
&lt;li&gt;硬件问题
&lt;ul&gt;
&lt;li&gt;电池一般分为两种类型: 一次性使用的和可再充电的。&lt;/li&gt;
&lt;li&gt;通过电源按键休眠唤醒计算机&lt;/li&gt;
&lt;li&gt;如何在休眠时候降低功耗&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统问题
&lt;ul&gt;
&lt;li&gt;显示器，休眠唤醒，降低亮度&lt;/li&gt;
&lt;li&gt;硬盘，在一定时间不读取时休眠，重新启动磁盘比较耗时，通过高速缓存降低延迟&lt;/li&gt;
&lt;li&gt;CPU，cpu 降低电压和频率&lt;/li&gt;
&lt;li&gt;内存，关闭高速缓存，将内容写到磁盘上然后关闭主存本身&lt;/li&gt;
&lt;li&gt;无线通信，基站缓存消息，通行设备休眠并且不错过消息&lt;/li&gt;
&lt;li&gt;热量管理，监控温度，在温度达到临界值时启动风扇&lt;/li&gt;
&lt;li&gt;电池管理，当电量快耗尽提醒用户&lt;/li&gt;
&lt;li&gt;驱动程序接口，操作系统可以发命令给驱动程序通知它们消减功耗&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用程序问题
&lt;ul&gt;
&lt;li&gt;降低视频帧率，减少像素&lt;/li&gt;
&lt;li&gt;降低语音识别器的功耗，使用比较小的词汇量和简单的声学模型&lt;/li&gt;
&lt;li&gt;裁剪传输的内容，减少传输功耗&lt;/li&gt;
&lt;li&gt;选择合适的 JPEG 算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有关输入/输出的研究
&lt;ul&gt;
&lt;li&gt;改善输入/输出的底层结构&lt;/li&gt;
&lt;li&gt;改善特定设备的表现&lt;/li&gt;
&lt;li&gt;网络，服务质量和性能&lt;/li&gt;
&lt;li&gt;减少能耗&lt;/li&gt;
&lt;li&gt;时钟&lt;/li&gt;
&lt;li&gt;中断延迟&lt;/li&gt;
&lt;li&gt;设备驱动&lt;/li&gt;
&lt;li&gt;瘦客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>现代操作系统::文件系统</title>
      <link>/notes/modern_operating_systems_file_system/</link>
      <pubDate>Sat, 17 Jul 2021 11:01:25 +0800</pubDate>
      <guid>/notes/modern_operating_systems_file_system/</guid>
      <description>&lt;h2 id=&#34;文件系统&#34;&gt;文件系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;文件
&lt;ul&gt;
&lt;li&gt;文件命名
&lt;ul&gt;
&lt;li&gt;文件是一种抽象机制，它提供了一种在磁盘上保存信息而且方便以后读取的方法。这种方法可以使用户不必了解存储信息的方法、位置和实际磁盘工作方式等有关细节。&lt;/li&gt;
&lt;li&gt;文件的具体命名规则在各个系统中是不同的，不过所有的现代操作系统都允许用 1 至 8 个字母组成的字符串作为合法的文件名。&lt;/li&gt;
&lt;li&gt;有些文件系统区分大小写字母，有些则不区分。 UNIX 属于前一类，老的文件系统 MS-DOS 则属于后一类。&lt;/li&gt;
&lt;li&gt;许多操作系统支持文件名用圆点隔开分为两部分，如文件名 prog.c。圆点后面的部分称为 文件扩展 名 (file extension)&lt;/li&gt;
&lt;li&gt;在某些系统中(如所有 UNIX 版本)，文件扩展名只是一种约定，操作系统井不强迫采用它。Windows 关注扩展名且对其赋予了含义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件结构
&lt;ul&gt;
&lt;li&gt;字节序列，一种无结构的字节序列，只对特定程序有意义，目前主流操作系统采取的方案。&lt;/li&gt;
&lt;li&gt;记录序列，文件是具有固定长度记录的序列，每个记录都有其内部结构。把文件作为记录序列的中心思想是:读操作返回一个记录，而写操作重写或追加一个记录。穿孔卡片采用的方案。&lt;/li&gt;
&lt;li&gt;树，这种结构中由一棵记录树构成，每个记录不必具有相同的长度，记录的固定位置上有一个键字段。可以根据特定字段找到记录的位置，在一些处理商业数据的服务器上采用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件类型
&lt;ul&gt;
&lt;li&gt;普通文件，含有包含用户信息的文件。
&lt;ul&gt;
&lt;li&gt;ASCII 文件，有多行正文组成，可以显示打印和用编辑器编辑。&lt;/li&gt;
&lt;li&gt;二进制文件，有特定结构，只对使用该结构的程序有意义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目录，管理文件系统结构的系统文件。&lt;/li&gt;
&lt;li&gt;字符特殊文件，与输入/输出有关，用于串行 I/O 类设备，如终端、打印机、网络等&lt;/li&gt;
&lt;li&gt;块特殊文件用于磁盘类设备&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件访问
&lt;ul&gt;
&lt;li&gt;顺序访问，从头按顺序读取文件的全部字节或记录，但不能跳过某一些内容，也不能不按顺序读取。&lt;/li&gt;
&lt;li&gt;随机访问文件，能够以任何次序读取其中字节或记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件属性
&lt;ul&gt;
&lt;li&gt;名字&lt;/li&gt;
&lt;li&gt;权限&lt;/li&gt;
&lt;li&gt;创建时间&lt;/li&gt;
&lt;li&gt;加锁标记&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件操作
&lt;ul&gt;
&lt;li&gt;create。创建不包含任何数据的文件。该调用的目的是表明文件即将建立，井设置文件的一些属性。&lt;/li&gt;
&lt;li&gt;delete。当不再需要某个文件时，必须删除该文件以释放磁盘空间。任何文件系统总有一个系统调用用来删除文件。&lt;/li&gt;
&lt;li&gt;open。在使用文件之前，必须先打开文件。open 调用的目的是:把文件属性和磁盘地址表装入内存，便于后续调用的快速访问。&lt;/li&gt;
&lt;li&gt;close。访问结束后，不再需要文件属性和磁盘地址，这时应该关闭文件以释放内部表空间。很多系统限制进程打开文件的个数，以鼓励用户关闭不再使用的文件。磁盘以块为单位写入，关闭文件时，写入该文件的最后一块，即使这个块还没有满。&lt;/li&gt;
&lt;li&gt;read。在文件中读取数据。 一般地，读取的数据来自文件的当前位置。调用者必须指明需要读取多少数据，并且提供存放这些数据的缓冲区。&lt;/li&gt;
&lt;li&gt;write。向文件写数据，写操作一般也是从文件当前位置开始。如果当前位置是文件末尾，文件长度增加。如果当前位置在文件中间，则现有数据被覆盖，并且永远丢失。&lt;/li&gt;
&lt;li&gt;append。此调用是 write 的限制形式，它只能在文件末尾添加数据。若系统只提供最小系统调用集合，则通常没有 append。很多系统对同一操作提供了多种实现方法，这些系统中有时有 append 调用.&lt;/li&gt;
&lt;li&gt;seek。对干随机访问文件，要指定从何处开始获取数据，通常的方法是用 seek 系统调用把当前位置指针指向文件中特定位置。 seek 调用结束后，就可以从该位置开始读写数据了。&lt;/li&gt;
&lt;li&gt;get attributes。进程运行常需要读取文件属性。例如， UNIX 中 make 程序通常用于管理由多个源文件组成的软件开发项目。在调用 make 时，它会检查全部源文件和目标文件的修改时间，实现最小编译，使得全部文件都为最新版本。为达到此目的，需要查找文件的某一些属性，即修改时间。&lt;/li&gt;
&lt;li&gt;set attributes。某些属性是可由用户设置的，甚至是在文件创建之后，实现该功能的是 set attributes 系统调用。保护模式信息是一个典型的例子，大多数标志也属于此类属性。&lt;/li&gt;
&lt;li&gt;rename。用户常常要改变已有文件的名字， rename 系统调用用于这一目的。严格地说， rename 系统调用不是必需的，因为先把文件复制到一个新文件中，然后删除原来的文件，就可以达到同样的目的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目录
&lt;ul&gt;
&lt;li&gt;一级目录系统
&lt;ul&gt;
&lt;li&gt;目录系统的最简单形式是在一个目录中包含所有的文件。这有时称为根目录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;层次目录系统
&lt;ul&gt;
&lt;li&gt;用户可以创建任意数量的子目录，每个目录又可以继续创建子目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;路径名
&lt;ul&gt;
&lt;li&gt;绝对路径名，路径名从根目录开始，不同路径之间用&#39;/&amp;lsquo;分割&lt;/li&gt;
&lt;li&gt;相对路径名，从当前工作目录开始，‘.&amp;rsquo; 表示当前路径，‘..&amp;lsquo;表示父目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目录操作
&lt;ul&gt;
&lt;li&gt;create。创建目录。除了目录项&amp;quot;.&amp;ldquo;和&amp;rdquo; ..&amp;ldquo;外，目录内容为空。目录项&amp;rdquo;.&amp;ldquo;和 &amp;ldquo;..&amp;ldquo;是系统自动放在目录中的(有时通过 mkdir 程序完成) 。&lt;/li&gt;
&lt;li&gt;delete。 删除目录。只有空目录可删除。只包含目录项&amp;rdquo;.&amp;ldquo;和&amp;rdquo;..&amp;ldquo;的目录被认为是空目录，这两个目录项通常不能删除。&lt;/li&gt;
&lt;li&gt;opendir。目录内容可被读取。例如，为列出目录中全部文件，程序必须先打开该目录，然后读其中全部文件的文件名。与打开和读文件相同，在读目录前，必须打开目录。&lt;/li&gt;
&lt;li&gt;closedir。读目录结束后，应关闭目录以释放内部表空间。&lt;/li&gt;
&lt;li&gt;readdir。系统调用 readdir 返回打开目录的下一个目录项。以前也采用 read 系统调用来读目录，但这方法有一个缺点:程序员必须了解和处理目录的内部结构。相反，不论采用哪一种目录结构，readdir 总是以标准格式返回一个目录项。&lt;/li&gt;
&lt;li&gt;rename。在很多方面目录和文件都相似。文件可换名，目录也可以 。&lt;/li&gt;
&lt;li&gt;link。链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。这种类型的链接增加了该文件的 i 节点 (i-node) 计数器的计数(记录含有该文件的目录项数目)，有时称为硬链接(hard link)。&lt;/li&gt;
&lt;li&gt;unlink。删除目录项。如果被解除连接的文件只出现在一个目录中(通常情况)，则将它从文件系统中删除。如果它出现在多个目录中，则只删除指定路径名的连接，依然保留其他路径名的连接。在 UNIX 中，用于删除文件的系统调用(前面已有论述)实际上就是 unlink.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;符号链接
&lt;ul&gt;
&lt;li&gt;不同于使用两个文件名指向同一个内部数据结构来代表一个文件&lt;/li&gt;
&lt;li&gt;符号链接的优点在于它能够跨越磁盘的界限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件系统的实现
&lt;ul&gt;
&lt;li&gt;文件系统布局
&lt;ul&gt;
&lt;li&gt;文件系统存放在磁盘上。多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统&lt;/li&gt;
&lt;li&gt;磁盘的 0 号扇区称为主引导记录，用来引导计算机，MBR 后面是分区表&lt;/li&gt;
&lt;li&gt;一个可能的文件系统布局包括:引导块、超级块、空闲空间管理、i 节点、根目录、文件和目录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件的实现
&lt;ul&gt;
&lt;li&gt;连续分配：最简单的分配方案是把每个文件作为一连串连续数据块存储在磁盘上，实现简单，读操作性能好，有磁盘碎片问题。&lt;/li&gt;
&lt;li&gt;链表分配：存储文件的第二种方法是为每个文件构造磁盘块链表。每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。可以充分利用磁盘块，顺序访问块，随机访问慢，需要从头开始遍历。因为指针占据了部分空间，导致发生额外的拼接和复制。&lt;/li&gt;
&lt;li&gt;使用内存中的表进行链表分配
&lt;ul&gt;
&lt;li&gt;如果取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表的两个不足。内存中存在这样一个表格叫做 FAT。仍然需要顺着链表查找给定的偏移量。缺点是需要把整张表存在内存中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;i 节点
&lt;ul&gt;
&lt;li&gt;每个文件赋予一个称为 i 节点的数据结构，其中列出了文件属性和文件块的磁盘地址。对比 FAT 的优势，只有在打开该文件时才加载该数据结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目录的实现
&lt;ul&gt;
&lt;li&gt;目录中有一个固定大小的目录项列表，每个文件对应一项，其中包含一个(固定长度)文件名、一个文件属性的结构体以及用以说明磁盘块位置的一个或多个磁盘地址(至某个最大值)。&lt;/li&gt;
&lt;li&gt;对于采用 i 节点的系统，把文件属性存放在 i 节点中而不是目录项中。&lt;/li&gt;
&lt;li&gt;采用散列表可以加速查找文件名，另一种方式是采用高速缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共享文件
&lt;ul&gt;
&lt;li&gt;当几个用户同在一个项目里工作时，他们常常需要共享文件。&lt;/li&gt;
&lt;li&gt;如果 C 的一个文件现在也出现在 B 的目录下。 B 的目录与该共享文件的联系称为一个链接 (link)。&lt;/li&gt;
&lt;li&gt;共享的实现
&lt;ul&gt;
&lt;li&gt;磁盘块不列入目录，而是列入一个与文件本身关联的小型数据结构中 。目录将指向这个小型数据结构。这是 UNIX 系统中 所采用的方法&lt;/li&gt;
&lt;li&gt;通过让系统建立一个类型为 LINK 的新文件，井把该文件放在 B 的目录下，使得 B 与 C 的一个文件存在链接。新的文件中只包含了它所链接的文件的路径名。当 B 读该链接文件时，操作系统查看到要读的文件是 LINK 类型，则找到该文件所链接的文件的名字，并且去读那个文件。与传统(硬)链接相对比起来，这一方法称为符号链接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;日志结构文件系统
&lt;ul&gt;
&lt;li&gt;将整个磁盘结构化为一个日志，每隔一段时间，或是有特殊需要时，被缓冲在内存中的所有未决的写操作都被放到一个单独的段中，作为在日志末尾的一个邻接段写入磁盘。这个单独的段可能会包括 i 节点、目录块、数据块或者都有。 每一个段的开始都是该段的摘要，说明该段中都包含哪些内容。&lt;/li&gt;
&lt;li&gt;i 节点分布在日志中，查找比较困难，需要维护额外的信息帮助查找 i 节点。&lt;/li&gt;
&lt;li&gt;总而言之，所有的写操作最初都被缓冲在内存中，然后周期性地把所有已缓冲的写作为一个单独的段，在日志的末尾处写入磁盘 .要打开一个文件，则首先需要从 i 节点图中找到文件的 i 节点 。一旦 i 节点定位之后就可以找到相应的块的地址。所有的块都放在段中，在日志的某个位置上。&lt;/li&gt;
&lt;li&gt;LFS 有一个清理线程，该清理线程周期地扫描日志进行磁盘压缩。整个磁盘抽象成一个大的环形缓冲区。LFS 处理大量零碎的读写性能比 UNIX 好一个数量级，在读写大块的性能方面也不逊色。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;日志文件系统
&lt;ul&gt;
&lt;li&gt;对于需要几个步骤完成的操作。&lt;/li&gt;
&lt;li&gt;日志文件系统则先写一个日志项，列出几个将要完成的动作。然后日志项被写人磁盘(并且为了良好地实施，可能从磁盘读回来验证它的完整性)。只有当日志项已经被写人，不同的操作才可以进行。 当所有的操作成功完成后，擦除日志项。如果系统这时崩溃.系统恢复后，文件系统可以通过检查日志来查看是不是有未完成的操作。如果有，可以煎新运行所有未完成的操作直到文件被正确地删除。直到操作完成。&lt;/li&gt;
&lt;li&gt;日志的写入需要幂等&lt;/li&gt;
&lt;li&gt;文件系统可以引入原子事务的概念。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟文件系统
&lt;ul&gt;
&lt;li&gt;尝试将多种文件系统统一成一个有序的结构。关键的思想就是抽象出所有文件系统都共有的部分，并且将这部分代码放在单独 的一层，该层调用底层的实际文件系统来具体管理数据。&lt;/li&gt;
&lt;li&gt;所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的 POSIX 系统调用，比如 open、 read、 write 和 lseek 等。因此，VFS 对用户进程有 一 个“上层“接口，它就是著名的 POSIX 接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件系统管理和优化
&lt;ul&gt;
&lt;li&gt;磁盘空间管理
&lt;ul&gt;
&lt;li&gt;存储一个有 n 个字节的文件可以有两种策略:分配 n 个字节的连续磁盘空间，或者把文件分成很多个连续(或井不一定连续)的块。&lt;/li&gt;
&lt;li&gt;几乎所有的文件系统都把文件分割成固定大小的块来存储，各块之间不一定相邻。&lt;/li&gt;
&lt;li&gt;块大小
&lt;ul&gt;
&lt;li&gt;需要从传输速度和磁盘利用率综合考虑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;记录空闲块
&lt;ul&gt;
&lt;li&gt;磁盘块链表，链表的每个块中包含尽可能多的空闲磁盘块号。&lt;/li&gt;
&lt;li&gt;位图，空闲块用 1 表示，已分配块用 0 表示(或者反之)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;磁盘配额
&lt;ul&gt;
&lt;li&gt;多用户操作系统常常提供一种强制性磁盘配额机制。其思想是系统管理员分给每个用户拥有文件和块的最大数量、操作系统确保每个用户不超过分给他们的配额。&lt;/li&gt;
&lt;li&gt;当用户打开一个文件时，系统找到文件属性和磁盘地址，井把它们送入内存中的打开文件表。其中一个属性告诉文件所有者是谁。任何有关该文件大小的增长都记到所有者的配额上，以防止一个用户垄断所有 i 节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件系统备份
&lt;ul&gt;
&lt;li&gt;增量转储，周期性地(每周一次或每月一次)做全面的转储(备份)，而每天只对从上一次全面转储起发生变化的数据做备份。&lt;/li&gt;
&lt;li&gt;物理转储，磁盘的第 0 块开始，将全部的磁盘块按序输出到磁带上，直到最后一块复制完毕。&lt;/li&gt;
&lt;li&gt;逻辑转储，从一个或几个指定的目录开始，递归地转储其自给定基准日期(例如，最近一次增量转储或全面系统转储的日期)后有所更改的全部文件和目录。所以，在逻辑转储中，转储磁带上会有一连串精心标识的目录和文件，这样就很容易满足恢复特定文件或目录的请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件系统的一致性
&lt;ul&gt;
&lt;li&gt;块的一致性检查&lt;/li&gt;
&lt;li&gt;文件的一致性检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件系统性能
&lt;ul&gt;
&lt;li&gt;高速缓存，检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果该块不在高速缓存中，首先要把它读到高速缓存，再复制到所需地方。之后，对同一个块的请求都通过高速缓存完成。&lt;/li&gt;
&lt;li&gt;块提前读，在需要用到块之前，试图提前将其写入高速缓存，从而提高命中率&lt;/li&gt;
&lt;li&gt;减少磁盘臂运动，把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;磁盘碎片整理
&lt;ul&gt;
&lt;li&gt;移动文件使它们相邻，并把所有的(至少是大部分的)空闲空间放在一个或多个大的连续的区域内。&lt;/li&gt;
&lt;li&gt;固态硬盘并不受磁盘碎片的影响。事实上，在固态硬盘上做磁盘碎片整理反倒是多此一举，不仅没有提高性能，反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有关文件系统的研究
&lt;ul&gt;
&lt;li&gt;备份&lt;/li&gt;
&lt;li&gt;高速缓存&lt;/li&gt;
&lt;li&gt;安全删除数据&lt;/li&gt;
&lt;li&gt;文件压缩&lt;/li&gt;
&lt;li&gt;Flash 文件系统&lt;/li&gt;
&lt;li&gt;性能&lt;/li&gt;
&lt;li&gt;可靠性和错误恢复&lt;/li&gt;
&lt;li&gt;用户及文件系统&lt;/li&gt;
&lt;li&gt;版本文件系统&lt;/li&gt;
&lt;li&gt;安全&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>现代操作系统::内存管理</title>
      <link>/notes/modern_operating_systems_memory_manage/</link>
      <pubDate>Fri, 16 Jul 2021 09:39:03 +0800</pubDate>
      <guid>/notes/modern_operating_systems_memory_manage/</guid>
      <description>&lt;h2 id=&#34;内存管理&#34;&gt;内存管理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;操作系统中管理分层存储器体系的部分称为存储管理器 (memory manager)。它的任务是有效地管理内存，即记录哪些内存是正在使用的，哪些内存是空闲的，在进程需要时为其分配内存，在进程使用完后释放内存。&lt;/li&gt;
&lt;li&gt;无存储器抽象
&lt;ul&gt;
&lt;li&gt;最简单的存储器抽象就是根本没有抽象。&lt;/li&gt;
&lt;li&gt;每一个程序都直接访问物理内存。在这种情况下，要想在内存中同时运行两个程序是不可能的。&lt;/li&gt;
&lt;li&gt;在不使用存储器抽象的情况下运行多个程序
&lt;ul&gt;
&lt;li&gt;操作系统只需要把当前内存中所有内容保存到磁盘文件中，然后把下一个程序读入到内存中再运行即可。只要在某一个时间内存中只有一个程序，那么就不会发生冲突。&lt;/li&gt;
&lt;li&gt;在特殊硬件的帮助下，即使没有交换功能，井发地运行多个程序也是可能的。 IBM 360 的早期模型是这样解决的:内存被划分为 2KB 的块，每个块被分配一个 4 位的保护键，保护键存储在 CPU 的特殊寄存器中。一个内存为 1MB 的机器只需要 512 个这样的 4 位寄存器，容量总共为 256 字节。PSW (Program Status Word, 程序状态字)中存有一个 4 位码。一个运行中的进程如果访问保护键与其 PSW 码不同的内存，360 的硬件会捕获到这一事件。因为只有操作系统可以修改保护键，这样就可以防止用户进程之间、用户进程和操作系统之间的互相干扰。引用了绝对物理地址会导致出错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一种存储器抽象：地址空间
&lt;ul&gt;
&lt;li&gt;使用绝对物理地址的问题
&lt;ul&gt;
&lt;li&gt;用户可以访问每个地址，容易造成破坏&lt;/li&gt;
&lt;li&gt;运行多个程序很困难&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;地址空间的概念
&lt;ul&gt;
&lt;li&gt;需要解决的问题
&lt;ul&gt;
&lt;li&gt;保护&lt;/li&gt;
&lt;li&gt;重定向&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，井且这个地址空间独立于其他进程的地址空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基址寄存器和界限寄存器
&lt;ul&gt;
&lt;li&gt;使用动态重定位，简单地把每个进程的地址空间映射到物理内存的不同部分。&lt;/li&gt;
&lt;li&gt;经典办法是给每个 CPU 配置两个特殊硬件寄存器，通常叫作基址寄存器和界限寄存器。当使用基址寄存器和界限寄存器时，程序装载到内存中连续的空闲位置且装载期间无须重定位，每次一个进程访问内存，取一条指令，读或写一个数据字，CPU 硬件会在把地址发送到内存总线前，自动把基址值加到进程发出的地址值上。同时，它检查程序提供的地址是否等于或大于界限寄存器里的值。如果访问的地址超过了界限，会产生错误并中止访问。&lt;/li&gt;
&lt;li&gt;对基址寄存器和界限寄存器会以一定的方式加以保护，使得只有操作系统可以修改它们。&lt;/li&gt;
&lt;li&gt;使用基址寄存器和界限寄存器重定位的缺点是，每次访问内存都需要进行加法和比较运算。比较运算可以做得很快，但是加法运算由于进位传递时间的问题，在没有使用特殊电路的情况下会显得很慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交换技术
&lt;ul&gt;
&lt;li&gt;内存容量优先，多进程存在内存超载的问题。&lt;/li&gt;
&lt;li&gt;交换
&lt;ul&gt;
&lt;li&gt;即把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘。空闲进程主要存储在磁盘上，所以当它们不运行时就不会占用内存。&lt;/li&gt;
&lt;li&gt;交换在内存中产生了多个空闲区 (hole, 也称为空洞)，通过把所有的进程尽可能向下移动，有可能将这些小的空闲区合成一大块。该技术称为内存紧缩 (memory compaction)。通常不进行这个操作，因为它要耗费大量的 CPU 时间。&lt;/li&gt;
&lt;li&gt;进程的数据段可以增长，系统如何分配内存。一种可用的方法是，当换入或移动进程时为它分配一些额外的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空闲内存管理
&lt;ul&gt;
&lt;li&gt;使用位图的存储管理
&lt;ul&gt;
&lt;li&gt;使用位图方法时，内存可能被划分成小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用(或者相反)&lt;/li&gt;
&lt;li&gt;分配单元的大小是一个重要的设计因素。分配单元越小，位图越大。&lt;/li&gt;
&lt;li&gt;这种方法的主要问题是，在决定把一个占 k 个分配单元的进程调人内存时，存储管理器必须搜索位图，在位图中找出有 k 个连续 0 的串。查找位图中指定长度的连续 0 串是耗时的操作(因为在位图中该串可能跨越字的边界)，这是位图的缺点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用链表的存储管理
&lt;ul&gt;
&lt;li&gt;维护一个记录已分配内存段和空闲内存段的链表。其中链表中的一个结点或者包含一个进程，或者是两个进程间的一块空闲区。&lt;/li&gt;
&lt;li&gt;分配算法
&lt;ul&gt;
&lt;li&gt;首次适配
&lt;ul&gt;
&lt;li&gt;存储管理器沿若段链表进行搜索，直到找到一个足够大的空闲区，除非空闲区大小和要分配的空间大小正好一样，否则将该空闲区分为两部分，一部分供进程使用，另一部分形成新的空闲区。首次适配算法是一种速度很快的算法，因为它尽可能少地搜索链表结点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;下次适配
&lt;ul&gt;
&lt;li&gt;它的工作方式和首次适配算法法相同，不同点是每次找到合适的空闲区时都记录当时的位置，以便在下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次适配算法那样每次都从头开始。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最佳适配
&lt;ul&gt;
&lt;li&gt;最佳适配算法搜索整个链表，找出能够容纳进程的最小的空闲区。最佳适配算法试图找出最接近实际需要的空闲区，以最好地匹配请求和可用空闲区，而不是先拆分一个以后可能会用到的大的空闲区。&lt;/li&gt;
&lt;li&gt;因为每次调用最佳适配算法时都要搜索整个链表，所以它要比首次适配算法慢。让人感到有点意外的是，它比首次适配算法或下次适配算法浪费更多的内存，因为它会产生大址无用的小空闲区。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最差适配
&lt;ul&gt;
&lt;li&gt;总是分配最大的可用空闲区，使新的空闲区比较大从而可以继续使用。仿真程序表明最差适配算法也不是一个好主意。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快速适配
&lt;ul&gt;
&lt;li&gt;它为那些常用大小的空闲区维护单独的链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟内存
&lt;ul&gt;
&lt;li&gt;每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作一页或页面(page)。每一页有连续的地址范围。这些页被映射到物理内存，但井不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。&lt;/li&gt;
&lt;li&gt;虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把 CPU 交给另一个进程使用.&lt;/li&gt;
&lt;li&gt;分页
&lt;ul&gt;
&lt;li&gt;程序产生的这些地址称为虚拟地址 (virtual address) , 它们构成了一个虚拟地址空间 (virtual address space)。在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上，读写操作使用具有同样地址的物理内存字，而在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到内存管理单元 (MemoryManagementUnit, MMU), MMU 把虚拟地址映射为物理内存地址。&lt;/li&gt;
&lt;li&gt;虚拟地址空间按照固定大小划分成被称为页面 (page) 的若干单元 。在物理内存中对应的单元称为页框(page frame)。页面和页框的大小通常是一样的，实际系统中的页面大小从 512 字节到 1GB。&lt;/li&gt;
&lt;li&gt;缺页中断或缺页错误
&lt;ul&gt;
&lt;li&gt;操作系统找到一个很少使用的页框且把它的内容写人磁盘(如果它不在磁盘上)。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令&lt;/li&gt;
&lt;li&gt;输入的 16 位虚拟地址被分为 4 位的页号和 12 位的偏移址。 4 位的页号可以表示 16 个页面， 12 位的偏移可以为一页内的全部 4096 个字节编址。可用页号作为页表得出对应于该虚拟页面的页框号。如果&amp;quot;在/不在“ 位是 0, 则将引起一个操作系统陷阱。如果该位是 1, 则将在页表中查到的页框号复制到输出寄存器的高 3 位中，再加上输人虚拟地址中的低 12 位偏移址。如此就构成了 15 位的物理地址。输出寄存器的内容随即被作为物理地址送到内存总线。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;页表
&lt;ul&gt;
&lt;li&gt;作为一种最简单的实现，虚拟地址到物理地址的映射可以概括如下:虚拟地址被分成虚拟页号(高位部分)和偏移址(低位部分)两部分&lt;/li&gt;
&lt;li&gt;虚拟页号可用作页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到页框号(如果有的话)。然后把页框号拼接到偏移址的高位端，以替换掉虚拟页号，形成送往内存的物理地址。&lt;/li&gt;
&lt;li&gt;页表项的结构是与机器密切相关的，但不同机器的页表项存储的信息都大致相同。
&lt;ul&gt;
&lt;li&gt;页框号&lt;/li&gt;
&lt;li&gt;”在/不在“位&lt;/li&gt;
&lt;li&gt;保护位，指出一个页允许什么类型的访问，读写执行&lt;/li&gt;
&lt;li&gt;修改位和访问位，
&lt;ul&gt;
&lt;li&gt;在写入一页时由硬件自动设置修改位。该位在操作系统重新分配页框时是非常有用的。如果一个页面已经被修改过(即它是&amp;quot;脏&amp;quot;的)，则必须把它写回磁盘。如果一个页面没有被修改过(即它是“干净”的)，则只简单地把它丢弃就可以了，因为它在磁盘上的副本仍然是有效的。这一位有时也被称为脏位 (dirty bit) , 因为它反映了该页面的状态。&lt;/li&gt;
&lt;li&gt;不论是读还是写，系统都会在该页面被访问时设置访问位。它的值被用来帮助操作系统在发生缺页中断时选择要被淘汰的页面。不再使用的页面要比正在使用的页面更适合淘汰。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;禁止高速缓存位，那些映射到设备寄存器而不是常规内存的页面而言，这个特性是非常重要的。假如操作系统正在紧张地循环等待某个 I/O 设备对它刚发出的命令作出响应，保证硬件是不断地从设备中读取数据而不是访问一个旧的被高速缓存的副本是非常重要的。通过这一位可以禁止高速缓存。具有独立的 I/O 空间而不使用内存映射 I/O 的机器不需要这一位。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;加速分页过程
&lt;ul&gt;
&lt;li&gt;虚拟地址到物理地址的映射必须非常快。&lt;/li&gt;
&lt;li&gt;如果虚拟地址空间很大，页表也会很大。&lt;/li&gt;
&lt;li&gt;转换检测缓冲区
&lt;ul&gt;
&lt;li&gt;大多数程序总是对少址的页面进行多次的访问，而不是相反。因此，只有很少的页表项会被反复读取，而其他的页表项很少被访问。解决方案是为计算机设置一个小型的硬件设备，将虚拟地址直接映射到物理地址，而不必再访问页表。这种设备称为转换检测缓冲区(Translation Lookaside Buffer, TLB),有时又称为相联存储器(associate memory)或快表，它通常在 MMU 中，包含少量的表项，在实际中很少会超过 256 个。每个表项记录了一个页面的相关信息，包括虚拟页号、页面的修改位、 保护码(读/写/执行权限)和该页所对应的物理页框。&lt;/li&gt;
&lt;li&gt;将一个虚拟地址放入 MMU 中进行转换时，硬件首先通过将该虚拟页号与 TLB 中所有表项同时(即并行)进行匹配，判断虚拟页面是否在其中。如果发现了一个有效的匹配并且要进行的访问操作并不违反保护位，则将页框号直接从 TLB 中取出而不必再访问页表。如果虚拟页号确实是在 TLB 中，但指令试图在一个只读页面上进行写操作，则会产生一个保护错误，就像对页表进行非法访间一样。&lt;/li&gt;
&lt;li&gt;如果 MMU 检测到没有有效的匹配项，就会进行正常的页表查询。接着从 TLB 中淘汰一个表项，然后用新找到的页表项代替它。这样，如果这一页面很快被再次访问，第二次访问 TLB 时自然将会命中而不是未命中。当一个表项被清除出 TLB 时，将修改位复制到内存中的页表项，而除了访问位，其他的值不变。当页表项中从页表中装入 TLB 中时，所有的值都来自内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件 TLB 管理
&lt;ul&gt;
&lt;li&gt;在现代很多机器上，几乎所有的页面管理都是在软件中实现的。在这些机器上，TLB 表项被操作系统显式地装载。当发生 TLB 访问失效时，不再是由 MMU 到页表中查找井取出需要的页表项，而是生成一个 TLB 失效并将问题交给操作系统解决。系统必须先找到该页面，然后从 TLB 中删除一个项，接着装载一个新的项，最后再执行先前出错的指令。当然，所有这一切都必须在有限的几条指令中完成，因为 TLB 失效比缺页中断发生得更加频繁。&lt;/li&gt;
&lt;li&gt;如果 TLB 大到(如 64 个表项)可以减少失效率时，TLB 的软件管理就会变得足够有效。这种方法的最主要的好处是获得了一个非常简单的 MMU, 这就在 CPU 芯片上为高速缓存以及其他改善性能的设计腾出了相当大的空间。&lt;/li&gt;
&lt;li&gt;软失效
&lt;ul&gt;
&lt;li&gt;一个页面访问在内存中而不在 TLB 中时，将产生软失效(softmiss)。那么此时所要做的就是更新一下 TLB, 不需要产生磁盘 I/O。典型的处理需要 10~20 个机器指令并花费几纳秒完成操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;硬失效
&lt;ul&gt;
&lt;li&gt;页面本身不在内存中(当然也不在 TLB 中)时，将产生硬失效。此刻需要一次磁盘存取以装入该页面，这个过程大 概储要几亳秒。硬失效的处理时间往往是软失效的百万倍。在页表结构中查找相应的映射被称为页表遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;几种场景
&lt;ul&gt;
&lt;li&gt;所需的页面可能就在内存中，但却未记录在该进程的页表里。比如该页面可能已由其他进程从硬盘中调人内存，这种情况下只需要把所需的页面正确映射到页表中，而不用再从硬盘调入。这是一种典型的软失效，称为次要缺页错误&lt;/li&gt;
&lt;li&gt;如果需要从硬盘重新调入页面，这就是严重缺页错误。&lt;/li&gt;
&lt;li&gt;程序可能访问了一个非法地址，根本不需要向 TLB 中新增映射。此时，操作系统一般会通过报告段错误来终止该程序, 这种缺页属于程序错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;针对大内存的页表
&lt;ul&gt;
&lt;li&gt;多级页表
&lt;ul&gt;
&lt;li&gt;引人多级页表的原因是避免把全部页表一直保存在内存中。特别是那些从不需要的页表就不应该保留。&lt;/li&gt;
&lt;li&gt;虚拟地址送入 MMU 后分为三个部分 PT1 用于顶级页表寻址，PT2 用于二级页表寻址，偏移量还是偏移量。以此扩展出多级页表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;倒排页表
&lt;ul&gt;
&lt;li&gt;实际内存中的每个页框对应一个表项，而不是每个虚拟页面对应一个表项。例如，对千 64 位虚拟地址，4KB 的页， 4GB 的 RAM, 一个倒排页表仅需要 1 048 576 个表项。表项记录了哪一个(进程，虚拟页面)对定位于该页框。&lt;/li&gt;
&lt;li&gt;从虚拟地址到物理地址的转换会变得很困难。它必须搜索整个倒排页表来查找某一个表项(n, p)。此外，该搜索必须对每一个内存访问操作都要执行一次，而不仅仅是在发生缺页中断时执行。每次内存访问操作都要查找一个 256K 的表不是一种使机器快速运行的方法 。&lt;/li&gt;
&lt;li&gt;走出这种两难局面的办法是使用 TLB。如果 TLB 能够记录所有频繁使用的页面，地址转换就可能变得像通常的页表一样快。但是，当发生 TLB 失效时，需要用软件搜索整个倒排页表。实现该搜索的一个可行的方法是建立一张散列表，用虚拟地址来散列。当前所有在内存中的具有相同散列值的虚拟页面被链接在一起。如果散列表中的槽数与机器中物理页面数一样多，那么散列表的冲突链的平均长度将会是 1 个表项的长度，这将会大大提高映射速度。一旦页框号被找到，新的(虚拟页号，物理页框号)对就会被装载到 TLB 中。&lt;/li&gt;
&lt;li&gt;倒排页表在 64 位机器中很常见，因为在 64 位机器中即使使用了大页面，页表项的数量还是很庞大的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;页面置换算法
&lt;ul&gt;
&lt;li&gt;最优页面置换算法
&lt;ul&gt;
&lt;li&gt;不可能实现&lt;/li&gt;
&lt;li&gt;在缺页中断发生时，有些页面在内存中，其中有一个页面将很快被访问，其他页面则可能要到 10、100 或 1000 条指令后才会被访问，每个页面都可以用在该页面首次被访问前所要执行的指令数作为标记。&lt;/li&gt;
&lt;li&gt;最优页面置换算法规定应该置换标记最大的页面。当缺页中断发生时，操作系统无法知道各个页面下一次 将在什么时候被访问。可以通过收集上一次的运行信息来判断，但是提升效率有限。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最近未使用页面置换算法
&lt;ul&gt;
&lt;li&gt;为使操作系统能够收集有用的统计信息，在大部分具有虚拟内存的计算机中，系统为每一页面设置了两个状态位。当页面被访问(读或写)时设置 R 位;当页面被写入(即修改)时设置 M 位。这些位包含在每个页表项中.&lt;/li&gt;
&lt;li&gt;当启动一个进程时，它的所有页面的两个位都由操作系统设置成 0, R 位被定期地(比如在每次时钟中断时)清零，以区别最近没有被访问的页面和被访问的页面。&lt;/li&gt;
&lt;li&gt;NRU (Not Recently Used, 最近未使用)算法随机地从没有被访问，没有被修改和没有被访问，已被修改的非空类中挑选一个页面淘汰。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;先进先出页面置换算法
&lt;ul&gt;
&lt;li&gt;由操作系统维护一个所有当前在内存中的页面的链表，最新进入的页面放在表尾，最早进入的页面放在表头。当发生缺页中断时，淘汰表头的页面井把新调入的页面加到表尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二次机会页面置换算法
&lt;ul&gt;
&lt;li&gt;FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改: 检查最老页面的 R 位。如果 R 位是 0, 那么这个页面既老又没有被使用，可以立刻置换掉，如果是 1 就将 R 位清 0, 井把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续搜索。&lt;/li&gt;
&lt;li&gt;第二次机会算法就是寻找一个在最近的时钟间隔内没有被访问过的页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时钟页面置换算法
&lt;ul&gt;
&lt;li&gt;尽管第二次机会算法是一个比较合理的算法，但它经常要在链表中移动页面，既降低了效率又不是很有必要。 一个更好的办法是把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面&lt;/li&gt;
&lt;li&gt;当发生缺页中断时，算法首先检查表针指向的页面，如果它的 R 位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置，如果 R 位是 1 就清除 R 位并把表针前移一个位置。重复这个过程直到找到了一个 R 位为 0 的页面为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最近最少使用页面置换算法
&lt;ul&gt;
&lt;li&gt;在缺页中断发生时，置换未使用时间最长的页面。&lt;/li&gt;
&lt;li&gt;实现 LRU, 需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是在每次访问内存时都必须要更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作，即使使用硬件实现也一样费时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用软件摸拟 LRU
&lt;ul&gt;
&lt;li&gt;一种可能的方案称为 NFU (NotFrequentlyUsed, 最不常用)算法，该算法将每个页面与一个软件计数器相关联，计数器的初值为 0。每次时钟中断时，由操作系统扫描内存中所有的页面，将每个页面的 R 位(它的值是 0 或 1) 加到它的计数器上。这个计数器大体上跟踪了各个页面被访问的频繁程度。发生缺页中断时，则置换计数器值最小的页面.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工作集页面置换算法
&lt;ul&gt;
&lt;li&gt;一个进程当前正在使用的页面的集合称为它的工作集&lt;/li&gt;
&lt;li&gt;若内存太小而无法容纳下整个工作集，那么进程的运行过程中会产生大量的缺页中断导致运行速度也会变得很缓慢&lt;/li&gt;
&lt;li&gt;若每执行几条指令程序就发生一次缺页中断，那么就称这个程序发生了颠簸&lt;/li&gt;
&lt;li&gt;不少分页系统都会设法跟踪进程的工作集，以确保在让进程运行以前，它的工作集就已在内存中了。该方法称为工作集模型, 其目的在于大大减少缺页中断率。在进程运行前预先装入其工作集页面也称为预先调页 (prepaging)。&lt;/li&gt;
&lt;li&gt;人们很早就发现大多数程序都不是均匀地访问它们的地址空间的，而访问往往是集中于一小部分页面。&lt;/li&gt;
&lt;li&gt;一种近似的解法是进程的工作集可以被称为在过去的 r 秒内实际运行时间中它所访问过的页面的集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工作集时钟页面置换算法
&lt;ul&gt;
&lt;li&gt;当缺页中断发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法是比较费时的.有一种改进的算法，它基于时钟算法，井且使用了工作集信息，称为 WSClock (工作集时钟)算法&lt;/li&gt;
&lt;li&gt;时钟算法一样，所需的数据结构是一个以页框为元素的循环表。最初，该表是空的。当装入第一个页面后，把它加到该表中。随若更多的页面的加入，它们形成一个环。每个表项包含来自基本工作集算法的上次使用时间，以及 R 位(已标明)和 M 位(未标明)。每次缺页中断时，首先检查指针指向的页面。如果 R 位被置为 1 该页面在当前时钟滴答中就被使用过，那么该页面就不适合被淘汰 。然后把该页面的 R 位设为 0, 指针指向下一个页面，井重复该算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;页面置换算法小结
&lt;ul&gt;
&lt;li&gt;最优算法 不可实现，但可用作基准&lt;/li&gt;
&lt;li&gt;NRU (最近未使用)算法&lt;/li&gt;
&lt;li&gt;FIFO (先进先出)算法&lt;/li&gt;
&lt;li&gt;第二次机会算法 比 FIFO 有较大的改善&lt;/li&gt;
&lt;li&gt;时钟算法 现实的&lt;/li&gt;
&lt;li&gt;LRU (最近最少使用)算法 很优秀，但很难实现&lt;/li&gt;
&lt;li&gt;NFU (最不经常使用)算法 LRU 的相对粗略的近似&lt;/li&gt;
&lt;li&gt;老化算法 LRU 的相对粗略的近似&lt;/li&gt;
&lt;li&gt;工作集算法 非常近似 LRU 的有效算法&lt;/li&gt;
&lt;li&gt;工作集时钟算法 好的有效算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分页系统中的设计问题
&lt;ul&gt;
&lt;li&gt;局部分配策略与全局分配策略
&lt;ul&gt;
&lt;li&gt;三个进程 A、 B、 C 构成了可运行进程的集合。假如 A 发生了缺页中断，页面置换算法在寻找最近最少使用的页面时是只考虑分配给 A 的 6 个页面呢? 还是考虑所有在内存中的页面?&lt;/li&gt;
&lt;li&gt;局部算法可以有效地为每个进程分配固定的内存片段。&lt;/li&gt;
&lt;li&gt;全局算法在可运行进程之间动态地分配页框，因此分配给各个进程的页框数是随时间变化的.&lt;/li&gt;
&lt;li&gt;全局算法在通常情况下工作得比局部算法好，当工作集的大小随进程运行时间发生变化时这种现象更加明显。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;负载控制
&lt;ul&gt;
&lt;li&gt;一旦所有进程的组合工作集超出了内存容量，就可能发生颠簸。&lt;/li&gt;
&lt;li&gt;减少竞争内存的进程数的一个好方法是将一部分进程交换到磁盘，并释放他们所占有的所有页面。&lt;/li&gt;
&lt;li&gt;决定交换出哪个进程时不光要考虑进程大小和分页率，还要考虑它的特性(如它究竟是 CPU 密集型还是 I/O 密集型)以及其他进程的特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;页面大小
&lt;ul&gt;
&lt;li&gt;要确定最佳的页面大小蒂要在几个互相矛盾的因素之间进行权衡。&lt;/li&gt;
&lt;li&gt;随便选择一个正文段、数据段或堆栈段很可能不会恰好装满整数个页面，平均的情况下，最后一个页面中有一半是空的。多余的空间就被浪费掉了，这种浪费称为内部碎片 (internal fragmentation)。在内存中有 n 个段、页面大小为 p 字节时，会有 np/2 字节被内部碎片浪费。从这方面考虑，使用小页面更好。&lt;/li&gt;
&lt;li&gt;考虑一个程序，它分成 8 个阶段顺序执行，每阶段需要 4KB 内存。如果页面大小是 32KB, 那就必须始终给程序分配 32KB 内存。如果页面大小是 16KB, 它就只需要 16KB。 如果页面大小是 4KB 或更小，那么在任何时刻它只需要 4KB 内存。总的来说，大尺寸页面比小尺寸页面浪费了更多内存 。&lt;/li&gt;
&lt;li&gt;另一方面，页面小意味着程序需要更多的页面，这又意味着需要更大的页表。&lt;/li&gt;
&lt;li&gt;内存与磁盘之间的传输一般是一次一页，传输中的大部分时间都花在了寻道和旋转延迟上，所以传输一个小页面所用的时间和传输一个大页面基本上是相同&lt;/li&gt;
&lt;li&gt;小页面能够更充分地利用 TLB 空间&lt;/li&gt;
&lt;li&gt;数学角度分析的结果 4KB 更适合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分离的指令空间和数据空间
&lt;ul&gt;
&lt;li&gt;早期计算机内存不够用的时候采取的设计，在使用这种设计的计算机中，两种地址空间都可以进行分页，而且互相独立。它们分别有自己的页表，分别完成虚拟页面到物理页框的映射。当硬件进行取指令操作时，它知道要使用指令空间和指令空间页表。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共享页面
&lt;ul&gt;
&lt;li&gt;那些只读的页面(诸如程序文本)可以共享，但是数据页面则不能共享。&lt;/li&gt;
&lt;li&gt;只有实际修改的数据页面需要复制。这种方法称为写时复制，它通过减少复制而提高了性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共享库
&lt;ul&gt;
&lt;li&gt;当一个共享库被装载和使用时，整个库并不是被一次性地读人内存。而是根据需要，以页面为单位装载的，因此没有被调用到的函数是不会披装载到内存中的.&lt;/li&gt;
&lt;li&gt;如果共享库中的一个函数因为修正一个 bug 被更新了，那么并不需要重新编译调用了这个函数的程序。旧的二进制文件依然可以正常工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存映射文件
&lt;ul&gt;
&lt;li&gt;进程可以通过发起一个系统调用，将一个文件映射到其虚拟地址空间的一部分。在多数实现中，在映射共享的页面时不会实际读入页面的内容，而是在访问页面时才会被每次一页地读入，磁盘文件则被当作后备存储。当进程退出或显式地解除文件映射时，所有被改动的页面会被写回到磁盘文件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;清除策略
&lt;ul&gt;
&lt;li&gt;通过一个分页守护进程定时把修改过的页写回到磁盘&lt;/li&gt;
&lt;li&gt;一种实现清除策略的方法就是使用一个双指针时钟。前指针由分页守护进程控制.当它指向一个脏页面时，就把该页面写回磁盘，前指针向前移动。当它指向一个干净页面时，仅仅指针向前移动. 后指针用于页面置换，就像在标准时钟算法中一样。现在，由于分页守护进程的工作，后指针命中干净页面的概率会增加。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟内存接口
&lt;ul&gt;
&lt;li&gt;对于一些高级系统而言，程序员可以对内存映射进行控制，并可以通过非常规的方法来增强程序的行为。&lt;/li&gt;
&lt;li&gt;过让一个进程把一片内存区域的名称通知另一个进程，而使得第二个进程可以把这片区域映射到它的虚拟地址空间中去。通过两个进程(或者更多)共享同一部分页面，高带宽的共享就成为可能&lt;/li&gt;
&lt;li&gt;分布式共享内存:允许网络上的多个进程共享一个页面集合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有关实现的问题
&lt;ul&gt;
&lt;li&gt;与分页有关的工作
&lt;ul&gt;
&lt;li&gt;时间点
&lt;ul&gt;
&lt;li&gt;进程创建
&lt;ul&gt;
&lt;li&gt;确定程序和数据在初始时有多大，井为它们创建一个页表。&lt;/li&gt;
&lt;li&gt;在内存中为页表分配空间并对其进行初始化。当进程被换出时，页表不需要驻留在内存中，但当进程运行时，它必须在内存中。&lt;/li&gt;
&lt;li&gt;操作系统要在磁盘交换区中分配空间，以便在一个进程换出时在磁盘上有放置此进程的空间。&lt;/li&gt;
&lt;li&gt;操作系统必须把有关页表和磁盘交换区的信息存储在进程表中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程执行
&lt;ul&gt;
&lt;li&gt;为新进程重置 MMU, 刷新 TLB, 以清除以前的进程遗留的痕迹。&lt;/li&gt;
&lt;li&gt;新进程的页表成为当前页表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺页中断
&lt;ul&gt;
&lt;li&gt;通过读硬件寄存器来确定是哪个虚拟地址造成了缺页中断&lt;/li&gt;
&lt;li&gt;计箕蒂要哪个页面，并在磁盘上对该页面进行定位。它必须找到合适的页框来存放新页面，必要时还要置换老的页面，然后把所需的页面读入页框。&lt;/li&gt;
&lt;li&gt;回退程序计数器，使程序计数器指向引起缺页中断的指令，并重新执行该指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程终止
&lt;ul&gt;
&lt;li&gt;操作系统必须释放进程的页表、页面和页面在硬盘上所占用的空间。&lt;/li&gt;
&lt;li&gt;如果某些页面是与其他进程共享的，当最后一个使用它们的进程终止的时候，才可以释放内存和磁盘上的页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺页中断处理
&lt;ul&gt;
&lt;li&gt;硬件陷入内核，在堆栈中保存程序计数器。&lt;/li&gt;
&lt;li&gt;启动一个汇编代码例程保存通用寄存器和其他易失的信息，以免被操作系统破坏。&lt;/li&gt;
&lt;li&gt;当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面&lt;/li&gt;
&lt;li&gt;一旦知道了发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致。如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且没有保护错误发生，系统则检查是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰。&lt;/li&gt;
&lt;li&gt;如果选择的页框&amp;quot;脏”了，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。无论如何，该页框被标记为忙，以免因为其他原因而被其他进程占用。&lt;/li&gt;
&lt;li&gt;一且页框“干净”后(无论是立刻还是在写回磁盘后)，操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面正在被装入时，产生缺页中断的进程仍然被挂起，井且如果有其他可运行的用户进程，则选择另一个用户进程运行。&lt;/li&gt;
&lt;li&gt;当磁盘中断发生时，表明该页已经被装人，页表已经更新可以反映它的位置，页框也被标记为正常状态。&lt;/li&gt;
&lt;li&gt;恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令。&lt;/li&gt;
&lt;li&gt;调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程.&lt;/li&gt;
&lt;li&gt;该例程恢复寄存器和其他状态信息，返回到用户空间继续执行，就好像缺页中断没有发生过 一样 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令备份
&lt;ul&gt;
&lt;li&gt;当程序访问不在内存中的页面时，引起缺页中断的指令会半途停止并引发操作系统的陷阱 。在操作系统取出所需的页面后，它需要重新启动引起陷阱的指令。&lt;/li&gt;
&lt;li&gt;通过使用一个隐藏的内部寄存器。在每条指令执行之前，把程序计数器的内容复制到该寄存器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;锁定内存中的页面
&lt;ul&gt;
&lt;li&gt;一种解决方法是锁住正在做 I/O 操作的内存中的页面以保证它不会被移出内存。锁住一个页面通常称为在内存中钉住 (pinning)页面.另一种方法是在内核缓冲区中完成所有的 I/O 操作，然后再将数据复制到用户页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;后备存储
&lt;ul&gt;
&lt;li&gt;页面被换出时会存放在磁盘上的哪个位置&lt;/li&gt;
&lt;li&gt;最简单的算法是在磁盘上设置特殊的交换分区，甚至从文件系统划分一块独立的磁盘。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;策略和机制的分离
&lt;ul&gt;
&lt;li&gt;控制系统复杂度的一种重要方法就是把策略从机制中分离出来。通过使大多数存储管理器作为用户级进程运行，就可以把该原则应用到存储管理中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分段
&lt;ul&gt;
&lt;li&gt;对许多问题来说，有两个或多个独立的地址空间可能比只有一个要好得多。&lt;/li&gt;
&lt;li&gt;一个直观并且通用的方法是在机器上提供多个互相独立的称为段(segment)的地址空间。每个段由一个从 0 到最大的线性地址序列构成。&lt;/li&gt;
&lt;li&gt;段是一个逻辑实体，程序员知道这一点并把它作为一个逻辑实体来使用。一个段可能包括一个过程、一个数组、一个堆栈、一组数值变址，但一般它不会同时包含多种不同类型的内容。&lt;/li&gt;
&lt;li&gt;分段也有助于在几个进程之间共享过程和数据。这方面一个常见的例子就是共享库.&lt;/li&gt;
&lt;li&gt;不同的段可以有不同种类的保护 。一个过程段可以被指明为只允许执行，从而禁止对它的读出和写入。&lt;/li&gt;
&lt;li&gt;分段和分页的实现本质上是不同的: 页面是定长的而段不是。&lt;/li&gt;
&lt;li&gt;在系统运行一段时间后内存被划分为许多块，一些块包含着段，一些则成了空闲区，这种现象称为棋盘形碎片或外部碎片&lt;/li&gt;
&lt;li&gt;如果一个段比较大，把它整个保存在内存中可能很不方便甚至是不可能的，因此产生了对它进行分页的想法。这样，只有那些真正需要的页面才会被调入内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有关内存管理的研究
&lt;ul&gt;
&lt;li&gt;内存管理中具有重启功能的虚拟机&lt;/li&gt;
&lt;li&gt;应用程序向系统提供决策，以指导取哪个物理页来支持虚拟页&lt;/li&gt;
&lt;li&gt;云服务器稳定性对页面处理的影响方面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>推理::嫌疑人X的献身</title>
      <link>/reading/douban_3211779/</link>
      <pubDate>Thu, 15 Jul 2021 17:15:37 +0800</pubDate>
      <guid>/reading/douban_3211779/</guid>
      <description></description>
    </item>
    
    <item>
      <title>现代操作系统::进程与线程</title>
      <link>/notes/modern_operating_systems_process_and_thread/</link>
      <pubDate>Thu, 15 Jul 2021 09:39:03 +0800</pubDate>
      <guid>/notes/modern_operating_systems_process_and_thread/</guid>
      <description>&lt;h2 id=&#34;进程与线程&#34;&gt;进程与线程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;进程
&lt;ul&gt;
&lt;li&gt;一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。&lt;/li&gt;
&lt;li&gt;进程的创建
&lt;ul&gt;
&lt;li&gt;4 种主要事件会导致进程的创建:
&lt;ul&gt;
&lt;li&gt;系统初始化&lt;/li&gt;
&lt;li&gt;正在运行的程序执行了创建进程的系统调用&lt;/li&gt;
&lt;li&gt;用户请求创建一个新进程&lt;/li&gt;
&lt;li&gt;一个批处理作业的初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;前台进程，与用户交互完成工作的进程&lt;/li&gt;
&lt;li&gt;后台进程，与特定的用户没有关系，完成专门功能的进程，守护进程&lt;/li&gt;
&lt;li&gt;在 UNIX 系统中，只有一个系统调用可以用来创建新进程:fork。这个系统调用会创建一个与调用进程相同的副本。在调用了 fork 后，这两个进程(父进程和子进程)拥有相同的内存映像、同样的环境字符串和同样的打开文件。这就是全部情形。通常 ，子进程接着执行 execve 或一个类似的系统调用，以修改其内存映像并运行一个新的程序。之所以要安排两步建立进程，是为了在 fork 之后但在 execve 之前允许该子进程处理其文件描述符，这样可以完成对标准输入文件、标准输出文件和标准错误文件的重定向。&lt;/li&gt;
&lt;li&gt;在 UNIX 中，子进程的初始地址空间是父进程的一个副本，但是这里涉及两个不同的地址空间，不可写的内存区是共享的。某些 UNIX 的实现使程序正文在两者间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，但这种情况下内存通过写时复制 (copy-on-write) 共享，这意味着一且两者之一想要修改部分内存，则这块内存首先被明确地复制，以确保修改发生在私有内存区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程的终止
&lt;ul&gt;
&lt;li&gt;通常有以下几种情况会导致进程的终止
&lt;ul&gt;
&lt;li&gt;正常退出(自愿的)。&lt;/li&gt;
&lt;li&gt;出错退出(自愿的).&lt;/li&gt;
&lt;li&gt;严重错误(非自愿)。&lt;/li&gt;
&lt;li&gt;被其他进程杀死(非自愿).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程的层次结构
&lt;ul&gt;
&lt;li&gt;某些系统中，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。&lt;/li&gt;
&lt;li&gt;在 UNIX 中，进程和它的所有子进程以及后裔共同组成一个进程组。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程的状态
&lt;ul&gt;
&lt;li&gt;运行态(该时刻进程实际占用 CPU)。&lt;/li&gt;
&lt;li&gt;就绪态(可运行，但因为其他进程正在运行而暂时停止)。&lt;/li&gt;
&lt;li&gt;阻塞态(除非某种外部事件发生，否则进程不能运行).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程的实现
&lt;ul&gt;
&lt;li&gt;操作系统维护进程表&lt;/li&gt;
&lt;li&gt;每个进程占用一个表项目，称为进程控制块，里面有程序运行的必要信息。&lt;/li&gt;
&lt;li&gt;所有的中断都从保存寄存器开始，对于当前进程而言，通常是保存在进程表项中。&lt;/li&gt;
&lt;li&gt;当一个 I/O 中断发生时，中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这些是硬件完成的所有操作，然后软件，特别是中断服务例程就接管一切剩余的工作。&lt;/li&gt;
&lt;li&gt;中断发生后操作系统最底层的工作步骤
&lt;ul&gt;
&lt;li&gt;硬件压人堆栈程序计数器等&lt;/li&gt;
&lt;li&gt;硬件从中断向量装人新的程序计数器&lt;/li&gt;
&lt;li&gt;汇编语言过程保存寄存器值&lt;/li&gt;
&lt;li&gt;汇编语言过程设置新的堆栈&lt;/li&gt;
&lt;li&gt;C 中断服务例程运行 (典型地读和缓冲输入)&lt;/li&gt;
&lt;li&gt;调度程序决定下一 个将运行的进程&lt;/li&gt;
&lt;li&gt;C 过程返回至汇编代码&lt;/li&gt;
&lt;li&gt;汇编语言过程开始运行新的当前进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个进程在执行过程中可能被中断数千次，但关键是每次中断后被中断的进程都返回到与中断发生前完全相同的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多道程序设计模型
&lt;ul&gt;
&lt;li&gt;采用多道程序设计可以提高 CPU 的利用率。&lt;/li&gt;
&lt;li&gt;假设一个进程等待 I/O 操作的时间与其停留在内存中时间的比为 p。当内存中同时有 n 个进程时、则所有 n 个进程都在等待 I/O (此时 CPU 空转)的概率是\( p^n \)。CPU 的利用率由下面的公式给出: \(CPU 利用率=1-p^n\)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程
&lt;ul&gt;
&lt;li&gt;线程的使用
&lt;ul&gt;
&lt;li&gt;人们需要多线程的主要原因是，在许多应用中同时发生若多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准井行运行的多个顺序线程，程序设计校型会变得更简单。&lt;/li&gt;
&lt;li&gt;在有了多线程概念之后，我们才加入了一种新的元素: 并行实体拥有共享同一个地址空间和所有可用数据的能力&lt;/li&gt;
&lt;li&gt;线程比进程更轻量级，所以它们比进程更容易(即更快)创建，也更容易撤销。许多系统中，创建一个线程较创建一个进程要快 1~100 倍&lt;/li&gt;
&lt;li&gt;如果存在着大量的计算和大量的 I/O 处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。&lt;/li&gt;
&lt;li&gt;在多 CPU 系统中，多线程是有益的，在这样的系统中，真正的并行有了实现的可能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;经典的线程模型
&lt;ul&gt;
&lt;li&gt;进程模型基于两种独立的概念:资源分组处理与执行。&lt;/li&gt;
&lt;li&gt;进程有存放程序正文和数据以及其他资源的地址空间。这些资源中包括打开的文件、子进程、即将发生的定时器、信号处理程序、账号信息等。把它们都放到进程中可以更容易管理。&lt;/li&gt;
&lt;li&gt;进程拥有一个执行的线程，通常简写为线程 (thread)。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。尽管线程必须在某个进程中执行.但是线程和它的进程是不同的概念，并且可以分别处理。进程用于把资源集中到一起，而线程则是在 CPU 上被调度执行的实体。&lt;/li&gt;
&lt;li&gt;在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。&lt;/li&gt;
&lt;li&gt;由于线程具有进程的某些性质，所以有时被称为轻量级进程&lt;/li&gt;
&lt;li&gt;一些 CPU 已经有直接硬件支持多线程，并允许线程切换在纳秒级完成。&lt;/li&gt;
&lt;li&gt;由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写或甚至清除另一个线程的堆栈。线程之间是没有保护的。不可能也没有必要实现保护，实现多线程的初衷就是为了贡献资源并协作。&lt;/li&gt;
&lt;li&gt;每个进程中的内容
&lt;ul&gt;
&lt;li&gt;地址空间&lt;/li&gt;
&lt;li&gt;全局变量&lt;/li&gt;
&lt;li&gt;打开文件&lt;/li&gt;
&lt;li&gt;子进程&lt;/li&gt;
&lt;li&gt;定时器&lt;/li&gt;
&lt;li&gt;信号和信号处理程序&lt;/li&gt;
&lt;li&gt;账户信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个线程中的内容
&lt;ul&gt;
&lt;li&gt;程序计数器&lt;/li&gt;
&lt;li&gt;寄存器&lt;/li&gt;
&lt;li&gt;堆栈&lt;/li&gt;
&lt;li&gt;状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程概念试图实现的是，共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作 。&lt;/li&gt;
&lt;li&gt;和传统进程一样(即只有一个线程的进程)，线程可以处于若干种状态的任何一个:运行、阻塞、就绪或终止。&lt;/li&gt;
&lt;li&gt;每个线程有其自己的堆栈,每个线程的堆栈有一帧，供各个被调用但是还没有从中返回的过程使用。在该栈帧中存放了相应过程的局部变量以及过程调用完成之后使用的返回地址。&lt;/li&gt;
&lt;li&gt;多线程的情况下，进程通常会从当前的单个线程开始。这个线程有能力通过调用一个库函数(如 thread_create)创建新的线程&lt;/li&gt;
&lt;li&gt;创建线程通常都返回一个线程标识符，该标识符就是新线程的名字。&lt;/li&gt;
&lt;li&gt;另一个常见的线程调用是 thread_yield, 它允许线程自动放弃 CPU 从而让另一个线程运行。因为不同于进程，(线程库)无法利用时钟中断强制线程让出 CPU。所以设法使线程行 为“高尚”起来，并且随着时间的推移自动交出 CPU, 以便让其他线程有机会运行，就变得非常重要。&lt;/li&gt;
&lt;li&gt;复杂性
&lt;ul&gt;
&lt;li&gt;如果子进程拥有了与父进程一样的多个线程，如果父进程在 read 系统调用(比如键盘)上被阻塞了会发生什么情况?&lt;/li&gt;
&lt;li&gt;另一类问题和线程共享许多数据结构的事实有关。如果一个线程关闭了某个文件，而另一个线程还在该文件上进行读操作时会怎样?假设有一个线程注意到几乎没有内存了，并开始分配更多的内存。在工作一半的时候，发生线程切换，新线程也注意到几乎没有内存了，并且也开始分配更多的内存。这样，内存可能会被分配两次。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;POSIX 线程
&lt;ul&gt;
&lt;li&gt;为实现可移植的线程程序，IEEE 在 IEEE 标准 1003.lc 中定义了线程的标准。它定义的线程包叫作 pthread。&lt;/li&gt;
&lt;li&gt;主要函数特性
&lt;ul&gt;
&lt;li&gt;pthread_create，创建一个新的线程，新创建的线程的线程标识符会作为函数值返回&lt;/li&gt;
&lt;li&gt;pthread_exit，终止该线程并释放它的栈。&lt;/li&gt;
&lt;li&gt;pthread_join，用来等待别的特定线程的终止。而要等待线程的线程标识符作为一个参数给出。&lt;/li&gt;
&lt;li&gt;pthread_yield，让出 CPU 时间片&lt;/li&gt;
&lt;li&gt;pthread_attr_init，建立关联一个线程的属性结构井初始化成默认值&lt;/li&gt;
&lt;li&gt;pthread_attr_destroy，删除一个线程的属性结构，释放它占用的内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在用户空间实现线程
&lt;ul&gt;
&lt;li&gt;内核无感知，从内核角度考虑，就是按正常的方式管理，即单线程进程。&lt;/li&gt;
&lt;li&gt;用户级线程包可以在不支持线程的操作系统上实现&lt;/li&gt;
&lt;li&gt;在用户空间管理线程时，每个进程需要有其专用的线程表，工作方式于进程表类似&lt;/li&gt;
&lt;li&gt;切换速度快，不需要陷入内核，不需要上下文切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。&lt;/li&gt;
&lt;li&gt;允许每个进程有自己定制的调度算法&lt;/li&gt;
&lt;li&gt;扩展性好，内核空间线程需要一些固定表格空间和堆栈空间。&lt;/li&gt;
&lt;li&gt;实现阻塞调用难度高&lt;/li&gt;
&lt;li&gt;缺页中断，导致内核中断整个进程直到 I/O 完成&lt;/li&gt;
&lt;li&gt;没有时钟中断，调度问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在内核空间实现线程
&lt;ul&gt;
&lt;li&gt;内核中有用来记录系统中所有线程的线程表&lt;/li&gt;
&lt;li&gt;内核的线程表保存了每个线程的寄存器、状态和其他信息。&lt;/li&gt;
&lt;li&gt;所有能够阻塞线程的调用都以系统调用的形式实现&lt;/li&gt;
&lt;li&gt;在内核中创建或撤销线程的代价比较大，某些系统采取“环保&amp;quot;的处理方式，回收其线程。当某个线程被撤销时，就把它标志为不可运行的，但是其内核数据结构没有受到影响。稍后，在必须创建一个新线程时，就重新启动某个旧线程，从而节省了一些开销。&lt;/li&gt;
&lt;li&gt;内核线程不需要任何新的、非阻塞系统调用&lt;/li&gt;
&lt;li&gt;信号是发给进程而不是线程的，当多个线程注册了同一个信号会发生什么?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;混合实现
&lt;ul&gt;
&lt;li&gt;人们已经研究了各种试图将用户级线程的优点和内核级线程的优点结合起来的方法。一种方法是使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。如同在没有多线程能力操作系统中某个进程中的用户级线程 一样，可以创建、撤销和调度这些用户级线程。在这种梭型中，每个内核级线程有一个可以轮流使用的用户级线程集合.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调度程序激活机制
&lt;ul&gt;
&lt;li&gt;调度程序激活工作的目标是模拟内核线程的功能，但是为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性。&lt;/li&gt;
&lt;li&gt;当使用调度程序激活机制时，内核给每个进程安排一定数量的虚拟处理器，并且让(用户空间)运行时系统将线程分配到处理器上。&lt;/li&gt;
&lt;li&gt;使该机制工作的基本思路是，当内核了解到一个线程被阻塞之后，内核通知该进程的运行时系统，并且在堆栈中以参数形式传递有问题的线程编号和所发生事件的一个描述。内核通过在一个已知的起始地址启动运行时系统，从而发出了通知，这是对 UNIX 中信号的一种粗略模拟。这个机制称为上行调用(upcall)。&lt;/li&gt;
&lt;li&gt;违反分层次系统内在结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;弹出式线程
&lt;ul&gt;
&lt;li&gt;一个消息的到达导致系统创建一个处理该消息的线程，这种线程称为弹出式线程&lt;/li&gt;
&lt;li&gt;对该新线程指定所要处理的消息。使用弹出式线程的结果是.消息到达与处理开始之间的时间非常短。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使单线程代码多线程化
&lt;ul&gt;
&lt;li&gt;一些容易犯的错误
&lt;ul&gt;
&lt;li&gt;多线程读写全局变量&lt;/li&gt;
&lt;li&gt;可重入问题&lt;/li&gt;
&lt;li&gt;信号共享问题&lt;/li&gt;
&lt;li&gt;堆栈的管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程间通信
&lt;ul&gt;
&lt;li&gt;需要解决的问题
&lt;ul&gt;
&lt;li&gt;一个进程如何把信息传递给另一个&lt;/li&gt;
&lt;li&gt;确保两个或更多的进程在关键活动中不会出现交叉&lt;/li&gt;
&lt;li&gt;保证相互关联的进程执行的顺序正确&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;竞争条件
&lt;ul&gt;
&lt;li&gt;两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;临界区
&lt;ul&gt;
&lt;li&gt;在某些时候进程可能需要访问共享内存或共享文件，或执行另外一些会导致竞争的操作。我们把对共享内存进行访问的程序片段称作临界区域 (critical region) 或 临界区。&lt;/li&gt;
&lt;li&gt;需要满足的条件
&lt;ul&gt;
&lt;li&gt;任何两个进程不能同时处于其临界区&lt;/li&gt;
&lt;li&gt;不应对 CPU 的速度和数量做任何假设&lt;/li&gt;
&lt;li&gt;临界区外运行的进程不得阻塞其他进程&lt;/li&gt;
&lt;li&gt;不得使进程无限期等待进人临界区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;忙等待的互斥
&lt;ul&gt;
&lt;li&gt;几种实现互斥的方案
&lt;ul&gt;
&lt;li&gt;屏蔽中断
&lt;ul&gt;
&lt;li&gt;每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断。屏蔽中断后，时钟中断也被屏蔽,阻止了进程切换，在多 CPU 下不适用，而且低效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;锁变量
&lt;ul&gt;
&lt;li&gt;设想有一个共享(锁)变量，其初始值为 0。当一个进程想进人其临界区时，它首先测试这把锁。&lt;/li&gt;
&lt;li&gt;读锁与写锁操作不具有原子性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;严格轮换法
&lt;ul&gt;
&lt;li&gt;整型变量 turn,初始值为 0,用于记录轮到哪个进程进入临界区，井桧查或更新共享内存。开始时，进程 0 检查 turn,发现其值为 0, 于是进入临界区。进程 1 也发现其值为 0,所以在一个等待循环中不停地测试 turn. 看其值何时变为 1。连续测试一个变量 直到某个值出现为止，称为忙等待。只有当认为当等待时间是很短的时候才使用这种方案&lt;/li&gt;
&lt;li&gt;用于忙等待的锁，称为自选锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Peterson 解法
&lt;ul&gt;
&lt;li&gt;在使用共享变及(即进入其临界区)之前，各个进程使用其进程号 0 或 1 作为参数来调用 enter_region。该调用在需要时将使进程等待，直到能安全地进入临界区。在完成对共享变量的操作之后，进程将调用 leave_region, 表示操作已完成，若其他的进程希望进入临界区，则现在就可以进入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TSL 指令
&lt;ul&gt;
&lt;li&gt;TSL RX, LOCK 称为测试并加锁。&lt;/li&gt;
&lt;li&gt;它将一个内存字 lock 读到寄存器 RX 中，然后在该内存地址上存一个非零值。读字和写字操作保证是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字。执行 TSL 指令的 CPU 将锁住内存总线，以禁止其他 CPU 在本指令结束之前访问内存。&lt;/li&gt;
&lt;li&gt;当操作结束时，进程用一条普通的 move 指令将 lock 的值重新设置为 0。&lt;/li&gt;
&lt;li&gt;锁住存储总线不同干屏蔽中断。屏蔽中断，然后在读内存字之后跟右写操作井不能阻止总线上的第二个处理器在读操作和写操作之间访问该内存字。&lt;/li&gt;
&lt;li&gt;一个可替代 TSL 的指令是 XCHG, 它原子性地交换了两个位置的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;睡眠与唤醒
&lt;ul&gt;
&lt;li&gt;Peterson 解法和 TSL 或 XCHG 解法有忙等待的缺点。&lt;/li&gt;
&lt;li&gt;低优先级进程无法离开临界区，优先级反转问题&lt;/li&gt;
&lt;li&gt;sleep 原语，wakeup 原语&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信号量
&lt;ul&gt;
&lt;li&gt;提供一个整型变让来累计唤醒次数，供以后使用。一个信号量的取值可以为 0 (表示没有保存下来的唤醒操作)或者为正值(表示有一个或多个唤醒操作)。&lt;/li&gt;
&lt;li&gt;PV 操作: P 表示尝试 , V 表示升高&lt;/li&gt;
&lt;li&gt;原子操作，是指一组相关联的操作要么都不间断地执行，要么都不执行。&lt;/li&gt;
&lt;li&gt;对一信号量执行 down 橾作，则是检查其值是否大干 0。若该值大于 0, 则将其值减 1 井继续；若该值为 0, 则进程将睡眠&lt;/li&gt;
&lt;li&gt;up 操作作对信号量的值增 1。如果一个或多个进程在该信号众上睡眠，无法完成一个先前的 down 操作， 则由系统选择其中的一个并允许该进程完成它的 down 操作。于是，对一个有进程在其上睡眠的信号量执行一次 up 操作之后，该信号量的值仍旧是 0, 但在其上睡眠的进程却少了一个。&lt;/li&gt;
&lt;li&gt;信号量的另一种用途是用于实现同步&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;互斥量
&lt;ul&gt;
&lt;li&gt;信号量的一个简化版本，称为互斥量&lt;/li&gt;
&lt;li&gt;互斥量是一个可以处于两态之一的变量:解锁和加锁。这样，只需要一个二进制位表示它，不过实际上，常常使用一个整型量， 0 表示解锁，而其他所有的值则表示加锁 。互斥量使用两个过程。当一个线程(或进程)需要访问临界区时，它调用 mutex_lock。如果该互斥量当前是解锁的(即临界区可用). 此调用成功，调用线程可以自由进入该临界区。&lt;/li&gt;
&lt;li&gt;另一方面，如果该互斥呈已经加锁，调用线程被阻塞，直到在临界区中的线程完成井调用 mutex_unlock。如果多个线程被阻塞在该互斥量上，将随机选择一个线程井允许它获得锁.&lt;/li&gt;
&lt;li&gt;当获取 mutex_lock 失败，线程调用 thread_yield 将 CPU 放弃给另一个线程。&lt;/li&gt;
&lt;li&gt;多个进程如何互斥
&lt;ul&gt;
&lt;li&gt;第一种，有些共享数据结构，如信号量，可以存放在内核中，并且只能通过系统调用来访问。&lt;/li&gt;
&lt;li&gt;第二种，多数现代操作系统 (包括 UNIX 和 Windows) 提供一种方法，让进程与其他进程共享其部分地址空间。在这种方法中，缓冲区和其他数据结构可以共享。在最坏的情形下，如果没有可共享的途径，则可以使用共享文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快速用户区互斥量 futex
&lt;ul&gt;
&lt;li&gt;futex 由一块能够被多个进程共享的内存空间（一个对齐后的整型变量）组成&lt;/li&gt;
&lt;li&gt;实现了基本的锁(很像互斥锁)，但避免了陷入内核，除非它真的不得不这样做。&lt;/li&gt;
&lt;li&gt;一个 futex 包含两个部分 : 一个内核服务和一个用户库。内核服务提供一个等待队列，它允许多个进程在一个锁上等待。&lt;/li&gt;
&lt;li&gt;没有竞争时，futex 完全在用户空间工作。&lt;/li&gt;
&lt;li&gt;如果该锁被另一个线程持有，那么线程必须等待。这种情况下，futex 库不自旋，而是使用一个系统调用把这个线程放在内核的等待队列上。&lt;/li&gt;
&lt;li&gt;当一个线程使用完该锁，它通过原子操作“增加并检验”来释放锁，并检查结果，看是否仍有进程阻塞在内核等待队列上。如果有，它会通知内核可以对等待队列里的一个或多个进程解除阻塞。如果没有锁竞争，内核则不需要参与其中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;pthread 中的互斥量
&lt;ul&gt;
&lt;li&gt;pthread 提供许多可以用来同步线程的函数。其基本机制是使用一个可以被锁定和解锁的互斥量来保护每个临界区。&lt;/li&gt;
&lt;li&gt;互斥量在允许或阻塞对临界区的访问上是很有用的，条件变量则允许线程由于一些未达到的条件而阻塞。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;管程
&lt;ul&gt;
&lt;li&gt;一个管程是一个由过程、变量及数据结构等组成的一个集合，它们组成一个特殊的模块或软件包。进程可在任何需要的时候调用管程中的过程，但它们不能在管程之外声明的过程中直接访问管程内的数据结构。&lt;/li&gt;
&lt;li&gt;管程有一个很重要的特性.即任一时刻管程中只能有一个活跃进程，这一特性使管程能有效地完成互斥。&lt;/li&gt;
&lt;li&gt;典型的处理方法是，当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。如果有，调用进程将被挂起，直到另一个进程离开管程将其唤醒。如果没有活跃进程在使用管程，则该调用进程可以进入。&lt;/li&gt;
&lt;li&gt;进入管程时的互斥由编译器负责，但通常的做法是用一个互斥量或二元信号量。&lt;/li&gt;
&lt;li&gt;java 的 synchronized 就是一种管程的实现&lt;/li&gt;
&lt;li&gt;用于处理共享内存的访问问题，对于多 CPU 和分布式系统，需要额外的手段。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消息传递
&lt;ul&gt;
&lt;li&gt;这种进程间通信的方法使用两条原语 send 和 receive, 它们像信号量而不像管程，是系统调用而不是语言成分。&lt;/li&gt;
&lt;li&gt;前一个调用向一个给定的目标发送一条消息，后一个调用从一个给定的源接收一条消息。如果没有消息可用，则接收者可能被阻塞，直到一条消息到达，或者，带着一个错误码立即返回 。&lt;/li&gt;
&lt;li&gt;设计要点
&lt;ul&gt;
&lt;li&gt;确认机制&lt;/li&gt;
&lt;li&gt;重发机制&lt;/li&gt;
&lt;li&gt;消息幂等&lt;/li&gt;
&lt;li&gt;身份认证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个著名的消息传递系统是消息传递接口(MPI)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;屏障
&lt;ul&gt;
&lt;li&gt;当一个进程到达屏障时，它就被屏障阻拦，直到所有进程都到达该屏障为止。屏障可用于一组进程同步，&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;避免锁：读-复制-更新
&lt;ul&gt;
&lt;li&gt;在某些情况下，我们可以允许写操作来更新数据结构，即便还有其他的进程正在使用它。窍门在干确保每个读操作要么读取旧的数据版本，要么读取新的数据版本，但绝不能是新旧数据的一些奇怪组合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调度
&lt;ul&gt;
&lt;li&gt;当计算机系统是多道程序设计系统时，通常就会有多个进程或线程同时竞争 CPU。只要有两个或更多的进程处于就绪状态，这种情形就会发生。如果只有一个 CPU 可用，那么就必须选择下一个要运行的进程。在操作系统中，完成选择工作的这一部分称为调度程序(scheduler), 该程序使用的算法称为调度算法(scheduling algorithm)。&lt;/li&gt;
&lt;li&gt;调度简介
&lt;ul&gt;
&lt;li&gt;几乎所有进程的(磁盘或网络) I/O 请求和计箕都是交替突发的&lt;/li&gt;
&lt;li&gt;典型的计算密集型进程具有较长时间的 CPU 集中使用和较小频度的 I/O 等待。 I/O 密集型进程具有较短时间的 CPU 集中使用和频繁的 I/O 等待。 它是 I/O 类的，因为这种进程 在 I/O 请求之间较少进行计算，并不是因为它们有特别长的 I/O 请求。在 I/O 开始后无论处理数据是多还是少，它们都花费同样的时间提出硬件请求读取磁盘块 。&lt;/li&gt;
&lt;li&gt;随着 CPU 变得越来越快，更多的进程倾向为 I/O 密集型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;何时调度
&lt;ul&gt;
&lt;li&gt;在创建一个新进程之后，需要决定是运行父进程还是运行子进程。&lt;/li&gt;
&lt;li&gt;在一个进程退出时必须做出调度决策。一个进程不再运行(因为它不再存在)，所以必须从就绪进程集中选择另外某个进程。如果没有就绪的进程，通常会运行一个系统提供的空闲进程。&lt;/li&gt;
&lt;li&gt;当一个进程阻塞在 I/O 和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。&lt;/li&gt;
&lt;li&gt;在一个 I/O 中断发生时，必须做出调度决策。&lt;/li&gt;
&lt;li&gt;非抢占式调度算法挑选一个进程，然后让该进程运行直至被阻塞，或者直到该进程自动释放 CPU.即使该进程运行了若干个小时，它也不会被强迫挂起。这样做的结果是，在时钟中断发生时不会进行调度。在处理完时钟中断后，如果没有更高优先级的进程等待到时，则被中断的进程会继续执行 。&lt;/li&gt;
&lt;li&gt;抢占式调度算法挑选一个进程，井且让该进程运行某个固定时段的最大值。如果在该时段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行。进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序。如果没有可用的时钟，那么非抢占式调度就是唯一的选择了 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调度算法分类
&lt;ul&gt;
&lt;li&gt;批处理
&lt;ul&gt;
&lt;li&gt;批处理系统在商业领域仍在广泛应用，用来处理薪水册、存货清单、账目收入、账目支出、利息计算(在银行)、索赔处理(在保险公司)和其他的周期性的作业 。&lt;/li&gt;
&lt;li&gt;减少了进程的切换从而改善了性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交互式
&lt;ul&gt;
&lt;li&gt;为了避免一个进程霸占 CPU 拒绝为其他进程服务，抢占是必需的&lt;/li&gt;
&lt;li&gt;抢占也是必要的。服务器也归于此类，因为通常它们要服务多个突发的(远程)用户。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实时
&lt;ul&gt;
&lt;li&gt;在有实时限制的系统中，抢占有时是不需要的，因为进程了解它们可能会长时间得不到运行，所以通常很快地完成各自的工作并阻塞。实时系统与交互式系统的差别是，实时系统只运行那些用来推进现有应用的程序，而交互式系统是通用的，它可以运行任意的非协作甚至是有恶意的程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调度算法的目标
&lt;ul&gt;
&lt;li&gt;公平一一给每个进程公平的 CPU 份额
&lt;ul&gt;
&lt;li&gt;策略强制执行一一保证规定的策略被执行&lt;/li&gt;
&lt;li&gt;平衡一一保持系统的所有部分都忙碌&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;批处理系统
&lt;ul&gt;
&lt;li&gt;吞吐量一一每小时最大作业数&lt;/li&gt;
&lt;li&gt;周转时间一一从提交到终止间的最小时间&lt;/li&gt;
&lt;li&gt;CPU 利用率一一保持 CPU 始终忙碌&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交互式系统
&lt;ul&gt;
&lt;li&gt;响应时间一一快速响应请求&lt;/li&gt;
&lt;li&gt;均衡性一一满足用户的期望&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实时系统
&lt;ul&gt;
&lt;li&gt;满足截止时间一避免丢失数据&lt;/li&gt;
&lt;li&gt;可预测性一一在多媒体系统中避免品质降低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;批处理系统中的调度
&lt;ul&gt;
&lt;li&gt;先来先服务&lt;/li&gt;
&lt;li&gt;最短作业优先&lt;/li&gt;
&lt;li&gt;最短剩余时间优先&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交互式系统中的调度
&lt;ul&gt;
&lt;li&gt;轮转调度
&lt;ul&gt;
&lt;li&gt;每个进程被分配一个时间段，称为时间片 (quantum), 即允许该进程在该时间段中运行。如果在时间片结束时该进程还在运行，则将剥夺 CPU 井分配给另一个进程。如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。&lt;/li&gt;
&lt;li&gt;时间片轮转调度很容易实现，调度程序所要做的就是维护一张可运行进程列表&lt;/li&gt;
&lt;li&gt;时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要一定时间进行管理事务处理的,更新各种表格和列表、消除和重新调入内存高速缓存等。时间片的长度影响 CPU 效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优先级调度
&lt;ul&gt;
&lt;li&gt;每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行。&lt;/li&gt;
&lt;li&gt;为了防止高优先级进程无休止地运行下去，调度程序可能在每个时钟滴答(即每个时钟中断)降低当前进程的优先级。&lt;/li&gt;
&lt;li&gt;另一种方法是，给每个进程赋予一个允许运行的最大时间片，当用完这个时间片时，次高优先级的进程便获得运行机会。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多级队列
&lt;ul&gt;
&lt;li&gt;设立优先级类。属于最高优先级类的进程运行一个时间片，属于次高优先级类的进程运行 2 个时间片，再次一级运行 4 个时间片，以此类推。当一个进程用完分配的时间片后，它被移到下一类。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最短进程优先
&lt;ul&gt;
&lt;li&gt;由于最短作业优先常常伴随君最短响应时间，所以如果能够把它用千交互进程，那将是非常好的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保证调度
&lt;ul&gt;
&lt;li&gt;为了实现所做的保证，系统必须跟踪各个进程自创建以来已使用了多少 CPU 时间。然后它计箕各个 进程应获得的 CPU 时间，即自创建以来的时间除以 n。由于各个进程实际获得的 CPU 时间是已知的，所以很容易计算出真正获得的 CPU 时间和应获得的 CPU 时间之比。比率为 0.5 说明一个进程只获得了应得时间的一半，而比率为 2.0 则说明它获得了应得时间的 2 倍。于是该算法随后转向比率最低的进程，直到该进程的比率超过它的最接近竞争者为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;彩票调度
&lt;ul&gt;
&lt;li&gt;进程提供各种系统资源(如 CPU 时间)的彩禀。 一旦需要做出一项调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得该资源。在应用到 CPU 调度时，系统可以掌握每秒钟 50 次的一种彩票，作为奖励每个获奖者可以得到 20ms 的 CPU 时间。&lt;/li&gt;
&lt;li&gt;彩栗调度可以用来解决用其他方法很难解决的问题。一个例子是，有一个视频服务器，在该视频服务器上若干进程正在向其客户提供视频流，每个视频流的帧速率都不相同。假设这些进程需要的帧速率分别是 1O、20 和 25 帧/秒。如果给这些进程分别分配 10、 20 和 25 张彩票，那么它们会自动地按照大致正确的比例(即 10:20:25)划分 CPU 的使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;公平分享调度
&lt;ul&gt;
&lt;li&gt;某些系统在调度处理之前考虑谁拥有进程这一因素。在这种模式中，每个用户分配到 CPU 时间的一部分，而调度程序以一种强制的方式选择进程。这样，如果两个用户都得到获得 50% CPU 时间的保证，那么无论一个用户有多少进程存在，每个用户都会得到应有的 CPU 份额。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实时系统中的调度
&lt;ul&gt;
&lt;li&gt;实时系统是一种时间起着主导作用的系统。&lt;/li&gt;
&lt;li&gt;计算机必须在一个确定的时间范围内恰当地做出反应&lt;/li&gt;
&lt;li&gt;实时系统通常可以分为硬实时 (hard real time) 和软实时 (soft real time) , 前者的含义是必须满足绝对的截止时间，后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。在这两种情形中，实时性能都是通过把程序划分为一组进程而实现的，其中每个进程的行为是可预测和提前掌握的。这些进程 一般寿命较短，并且极快地运行完成。在检测到一个外部信号时 ， 调度程序的任务就是按照满足所有截止时间的要求调度进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;策略和机制
&lt;ul&gt;
&lt;li&gt;对于一个进程有许多子进程井在其控制下运行，调度程序无法知晓哪个进程最重要，解决问题的方法是将调度机制与调度策略分离这个一贯的原则。也就是将调度算法以某种形式参数化，而参数可以由用户进程填写。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程调度
&lt;ul&gt;
&lt;li&gt;当若干进程都有多个线程时，就存在两个层次的并行:进程和线程。在这样的系统中调度处理有本质差别，这取决于所支持的是用户级线程还是内核级线程(或两者都支持)。&lt;/li&gt;
&lt;li&gt;用户级线程
&lt;ul&gt;
&lt;li&gt;内核调度进程，进程选择线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内核级别线程
&lt;ul&gt;
&lt;li&gt;内核选择一个特定的线程运行。它不用考虑该线程属千哪个进程，不过如果有必要的话，它可以这样做。对被选择的线程赋予一个时间片，而且如果超过了时间片，就会强制挂起该线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用户级线程和内核级线程之间的差别在于性能。用户级线程的线程切换需要少址的机器指令，而内核级线程垢要完整的上下文切换，修改内存映像，使高速缓存失效，这导致了若干数量级的延迟。另一方面，在使用内核级线程时，一且线程阻塞在 I/O 上就不需要像在用户级线程中那样将整个进程挂起 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;经典 IPC 问题
&lt;ul&gt;
&lt;li&gt;哲学家就餐问题&lt;/li&gt;
&lt;li&gt;读者-写者问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有关进程于线程的研究
&lt;ul&gt;
&lt;li&gt;多处理器上的线程集群&lt;/li&gt;
&lt;li&gt;进程执行过程的记录和重放&lt;/li&gt;
&lt;li&gt;调度间题&lt;/li&gt;
&lt;li&gt;移动设备上的低能耗调度、超线程级调度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>现代操作系统::引论</title>
      <link>/notes/modern_operating_systems_introduction/</link>
      <pubDate>Wed, 14 Jul 2021 09:39:03 +0800</pubDate>
      <guid>/notes/modern_operating_systems_introduction/</guid>
      <description>&lt;h2 id=&#34;引论&#34;&gt;引论&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;什么是操作系统
&lt;ul&gt;
&lt;li&gt;操作系统是一种运行在内核态的软件&lt;/li&gt;
&lt;li&gt;为应用程序提供一个资源集的清晰抽象，并管理这些硬件资源，而不仅仅是一堆硬件&lt;/li&gt;
&lt;li&gt;作为扩展机器的操作系统，创建好的抽象，并实现和管理它所创建的抽象对象。&lt;/li&gt;
&lt;li&gt;作为资源管理者的操作系统，在相互竞争的程序之间有序地控制对处理器、存储器以及其他 I/O 接口设备的分配。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统的历史
&lt;ul&gt;
&lt;li&gt;第一代 (1945 ~ 1955) : 真空管和穿孔卡片&lt;/li&gt;
&lt;li&gt;第二代 (1955 ~ 1965) : 晶体管和批处理系统&lt;/li&gt;
&lt;li&gt;第三代 (1965 ~ 1980) : 集成电路和多道程序设计&lt;/li&gt;
&lt;li&gt;第四代 (1980 ~ ) :个人计算机&lt;/li&gt;
&lt;li&gt;第五代 (1990 ~ ): 移动计算机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算机硬件简介
&lt;ul&gt;
&lt;li&gt;处理器
&lt;ul&gt;
&lt;li&gt;专门的指令集&lt;/li&gt;
&lt;li&gt;寄存器
&lt;ul&gt;
&lt;li&gt;程序计数器
&lt;ul&gt;
&lt;li&gt;保存了将要取出的下一条指令的内存地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;堆栈指针
&lt;ul&gt;
&lt;li&gt;指向内存中当前栈的顶端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;程序状态字
&lt;ul&gt;
&lt;li&gt;这个寄存器包含了条件码位、CPU 优先级、模式(用户态或内核态)，以及各种其他控制位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通用寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流水线
&lt;ul&gt;
&lt;li&gt;个 CPU 可以有单独的取指单元、解码单元和执行单元，于是当它执行指令 n 时，还可以对指令 n + 1 解码，井且读取指令 n + 2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;超标量 CPU
&lt;ul&gt;
&lt;li&gt;两个或更多的指令被同时取出、解码并装入暂存缓冲区中，直至它们执行完毕.只要有一个执行单元空闲.就检查保持缓冲区中是否还有可处理的指令，如果有，就把指令从缓冲区中移出并执行之.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;两种模式
&lt;ul&gt;
&lt;li&gt;内核态&lt;/li&gt;
&lt;li&gt;用户态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统调用
&lt;ul&gt;
&lt;li&gt;为了从操作系统中获得服务，用户程序必须使用系统调用(system call)以陷入内核井调用操作系统。TRAP 指令把用户态切换成内核态，并启用操作系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多线程和多核芯片
&lt;ul&gt;
&lt;li&gt;多线程允许 CPU 保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。&lt;/li&gt;
&lt;li&gt;多线程不提供其正的并行处理。在一个时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;存储器
&lt;ul&gt;
&lt;li&gt;寄存器，纳秒数量级时间&lt;/li&gt;
&lt;li&gt;高速缓存
&lt;ul&gt;
&lt;li&gt;个位数纳秒数量级时间&lt;/li&gt;
&lt;li&gt;高速缓存命中&lt;/li&gt;
&lt;li&gt;多级缓存&lt;/li&gt;
&lt;li&gt;不同的缓存位置的影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主存
&lt;ul&gt;
&lt;li&gt;易失性与非易失性存储介质&lt;/li&gt;
&lt;li&gt;十位数纳秒数量级时间&lt;/li&gt;
&lt;li&gt;闪存&lt;/li&gt;
&lt;li&gt;电可擦除可编程内存&lt;/li&gt;
&lt;li&gt;CMOS 存储器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;磁盘
&lt;ul&gt;
&lt;li&gt;毫秒数量级时间&lt;/li&gt;
&lt;li&gt;磁道&lt;/li&gt;
&lt;li&gt;柱面&lt;/li&gt;
&lt;li&gt;固态硬盘&lt;/li&gt;
&lt;li&gt;虚拟内存机制
&lt;ul&gt;
&lt;li&gt;MMU&lt;/li&gt;
&lt;li&gt;上下文切换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;I/O 设备
&lt;ul&gt;
&lt;li&gt;设备控制器
&lt;ul&gt;
&lt;li&gt;插在电路板上的一块芯片或一组芯片&lt;/li&gt;
&lt;li&gt;这块电路板物理地控制设备。它从操作系统接收命令&lt;/li&gt;
&lt;li&gt;控制器的任务是为操作系统提供一个简单的接口&lt;/li&gt;
&lt;li&gt;读写过程很复杂，控制器中经常安装一个小的嵌入式计算机，该嵌入式计算机运行为执行这些工作而专门编好的程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设备本身
&lt;ul&gt;
&lt;li&gt;本身有个相对简单的标准化接口&lt;/li&gt;
&lt;li&gt;SATA 串行高级技术附件(Serial Advanced Technology Attachment)&lt;/li&gt;
&lt;li&gt;由于实际的设备接口隐藏在控制器中，所以，操作系统看到的是对控制器的接口&lt;/li&gt;
&lt;li&gt;设备驱动程序
&lt;ul&gt;
&lt;li&gt;将内核与设备驱动程序重新链接，然后重启动系统。&lt;/li&gt;
&lt;li&gt;在一个操作系统文件中设置一个入口，并通知该文件需要一个设备驱动程序，然后重新启动系统。在系统启动时，操作系统去找寻所需的设备驱动程序井装载之。&lt;/li&gt;
&lt;li&gt;操作系统能够在运行时接受新的设备驱动程序并且立即将其安装好，无须重启动系统。&lt;/li&gt;
&lt;li&gt;每个设备控制器都有少址用千通信的寄存器
&lt;ul&gt;
&lt;li&gt;一个最小的磁盘控制器也会有用干指定磁盘地址、内存地址、扇区计数和方向(读或写)的寄存器。&lt;/li&gt;
&lt;li&gt;要激活控制器，设备驱动程序从操作系统获得一条命令，然后翻译成对应的值，并写进设备寄存器中。所有设备寄存器的集合构成了 I/O 端口空间，&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通信方式
&lt;ul&gt;
&lt;li&gt;在有些计算机中，设备寄存器被映射到操作系统的地址空间，不需要专门的 I/O 指令，用户程序可以被硬件阻挡在外，防止其接触这些存储器地址&lt;/li&gt;
&lt;li&gt;另一些机器中，设备寄存器被放入一个专门的 I/O 端口空间中，每个寄存器都有一个端口地址。在这些机器中，提供在内核态中可使用的专门 IN 和 OUT 指令，供设备驱动程序读写这些寄存器用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现输入输出的方式
&lt;ul&gt;
&lt;li&gt;用户程序发出一个系统调用，内核将其翻译成一个对应设备驱动程序的过程调用。然后设备驱动程序启动 I/O 并在一个连续不断的循环中检查该设备，看该设备是否完成了工作(一般有一些二进制位用来指示设备仍在忙碌中)。当 I/O 结束后，设备驱动程序把数据送到指定的地方(若有此需要)，井返回。然后操作系统将控制返回给调用者。这种方式称为忙等待(busywaiting), 其缺点是要占据 CPU, CPU 一直轮询设备直到对应的 I/O 操作完成。&lt;/li&gt;
&lt;li&gt;设备驱动程序启动设备并且让该设备在操作完成时发出一个中断。设备驱动程序在这个时刻返回。操作系统接若在需要时阻塞调用者井安排其他工作进行。当设备驱动程序检查到该设备的操作完毕时，它发出一个中断通知操作完成。&lt;/li&gt;
&lt;li&gt;为 I/O 使用一种特殊的直接存储器访问 (Direct Memory Access, DMA) 芯片，它可以控制在内存和某些控制器之间的位流，而无须持续的 CPU 干预。 CPU 对 DMA 芯片进行设置，说明需要传送的字节数、有关的设备和内存地址以及操作方向，接着启动 DMA。当 DMA 芯片完成时，它引发一个中断，其处理方式如前所述。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;总线
&lt;ul&gt;
&lt;li&gt;主板上有很多不同作用的总线&lt;/li&gt;
&lt;li&gt;PCIe 总线是 PCI 总线的继承者，PCI 总线是为了取代原来的 ISA 总线，速度快&lt;/li&gt;
&lt;li&gt;USB，将所有慢速 I/O 设备与计算机连接，是一种集中式总线&lt;/li&gt;
&lt;li&gt;SCSI，是一种高速总线，用在高速硬盘、扫描仪和其他需要较大带宽的设备上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;启动计算机
&lt;ul&gt;
&lt;li&gt;主板上有一块称为 BIOS 的程序，存储在非易失性存储介质中&lt;/li&gt;
&lt;li&gt;主板加电，BIOS 开始运行，检查设备&lt;/li&gt;
&lt;li&gt;根据 CMOS 存储的设备清单启动设备，从启动分区读入操作系统，启动它&lt;/li&gt;
&lt;li&gt;操作系统访问 BIOS，获取设备信息，加载设备驱动程序，初始化相关程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统大观园
&lt;ul&gt;
&lt;li&gt;大型机操作系统
&lt;ul&gt;
&lt;li&gt;用于大型机的操作系统主要面向多个作业的同时处理，多数这样的作业需要巨大的 I/O 能力。系统主要提供三类服务:批处理、事务处理和分时。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务器操作系统
&lt;ul&gt;
&lt;li&gt;它们在服务器上运行，服务器可以是大型的个人计算机、工作站，甚至是大型机。它们通过网络同时为若干个用户服务，并且允许用户共享硬件和软件资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多处理器操作系统
&lt;ul&gt;
&lt;li&gt;获得大量联合计算能力的常用方式是将多个 CPU 连接成单个的系统。依据连接和共享方式的不同，这些系统称为并行计算机、多计算机或多处理器。它们需要专门的操作系统，不过通常采用的操作系统是配有通信、连接和一致性等专门功能的服务器操作系统的变体。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;个人计算机操作系统
&lt;ul&gt;
&lt;li&gt;现代个人计算机操作系统都支持多道程序处理，在启动时，通常有几十个程序开始运行 。它们的功能是为单个用户提供良好的支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;掌上计算机操作系统
&lt;ul&gt;
&lt;li&gt;大多数设备基于的是多核 CPU、GPS、摄像头及其他的传感器、大量内存和精密的操作系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;嵌入式操作系统
&lt;ul&gt;
&lt;li&gt;嵌入式系统在用来控制设备的计算机中运行，这种设备不是一般意义上的计算机，井且不允许用户安装软件 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;传感器节点操作系统
&lt;ul&gt;
&lt;li&gt;每个传感器节点是一个配有 CPU、RAM、ROM 以及一个或多个环境传感器的实实在在的计算机。节点上运行一个小型但是真实的操作系统，通常这个操作系统是事件驱动的，可以响应外部事件，或者基于内部时钟进行周期性的测量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实时操作系统
&lt;ul&gt;
&lt;li&gt;这些系统的特征是将时间作为关键参数。工控系统，民航，军事用途。硬实时操作系统。&lt;/li&gt;
&lt;li&gt;多媒体，数字音频，软实时操作系统，允许一定延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;智能卡操作系统
&lt;ul&gt;
&lt;li&gt;智能卡是一种包含一块 CPU 芯片的信用卡。它有非常严格的运行能耗和存储空间的限制。其中，有些智能卡只具有单项功能，如电子支付，但是其他的智能卡则拥有多项功能.它们有专用的操作系统.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统概念
&lt;ul&gt;
&lt;li&gt;进程
&lt;ul&gt;
&lt;li&gt;进程本质上是正在执行的一个程序&lt;/li&gt;
&lt;li&gt;每个进程拥有自己的地址空间&lt;/li&gt;
&lt;li&gt;进程表&lt;/li&gt;
&lt;li&gt;进程间通信&lt;/li&gt;
&lt;li&gt;每个进程都归属于某个用户&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;地址空间
&lt;ul&gt;
&lt;li&gt;通常，每个进程有一些可以使用的地址集合，典型值从 0 开始直到某个最大值。&lt;/li&gt;
&lt;li&gt;虚拟内存，操作系统可以把部分地址空间装入主存，部分留在磁盘上，并且在需要时来回交换它们。在本质上，操作系统创建了一个地址空间的抽象，作为进程可以引用地址的集合。该地址空间与机器的物理内存解耦，可能大于也可能小干该物理空间。对地址空间和物理空间的管理组成了操作系统功能的一个重要部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件
&lt;ul&gt;
&lt;li&gt;为磁盘和其他 I/O 设备提供一个良好的抽象文件模型。&lt;/li&gt;
&lt;li&gt;目录和文件产生的层次结构，文件系统。&lt;/li&gt;
&lt;li&gt;每个进程都有一个工作目录&lt;/li&gt;
&lt;li&gt;每个打开的文件都有一个文件描述符。&lt;/li&gt;
&lt;li&gt;挂载磁盘文件系统到根文件系统上&lt;/li&gt;
&lt;li&gt;特殊文件，提供特殊文件是为了使 I/O 设备看起来像文件一般，块特殊文件，磁盘，字符特殊文件，字符流设备&lt;/li&gt;
&lt;li&gt;管道，虚文件，它可以连接两个进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;输入输出
&lt;ul&gt;
&lt;li&gt;操作系统有各种类型的输人和输出设备，包括键盘、显示器、打印机等。对这些设备的管理全然依靠操作系统。&lt;/li&gt;
&lt;li&gt;每个操作系统都有管理其 I/O 设备的 I/O 子系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保护
&lt;ul&gt;
&lt;li&gt;rwx 文件权限&lt;/li&gt;
&lt;li&gt;管理员，用户组，普通用户管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;shell
&lt;ul&gt;
&lt;li&gt;命令解释器&lt;/li&gt;
&lt;li&gt;并不是操作系统的一部分，提供了终端用户于操作系统之间的接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;个体重复系统发育
&lt;ul&gt;
&lt;li&gt;技术的变化会导致某些思想过时并迅速消失，这种情形经常发生。但是，技术的另一种变化还可能使某些思想再次复活.在技术的变化影响了某个系统不同部分之间的相对性能时，情况就是这样。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统调用
&lt;ul&gt;
&lt;li&gt;操作系统具有两种功能:为用户程序提供抽象和管理计算机资源。&lt;/li&gt;
&lt;li&gt;进行系统调用就像进行一个特殊的过程调用，但是只有系统调用可以进人内核，而过程调用则不能。&lt;/li&gt;
&lt;li&gt;read 系统调用过程
&lt;ul&gt;
&lt;li&gt;调用程序首先把参数压进堆栈&lt;/li&gt;
&lt;li&gt;对库过程的实际调用&lt;/li&gt;
&lt;li&gt;把系统调用的编号放到寄存器中&lt;/li&gt;
&lt;li&gt;执行 TRAP 指令，将用户态切换到内核态，并在内核中的一个固定地址开始执行&lt;/li&gt;
&lt;li&gt;TRAP 指令后的内核代码开始检查系统调用编号，然后分派给正确的系统调用处理器，这通常是通过一张由系统调用编号所引用的、指向系统调用处理器的指针表来完成&lt;/li&gt;
&lt;li&gt;系统调用处理器运行&lt;/li&gt;
&lt;li&gt;一且系统调用处理器完成其工作，控制可能会在跟随 TRAP 指令后面的指令中返回给用户空间库过程&lt;/li&gt;
&lt;li&gt;接着以通常的过程调用返回的方式，返回到用户程序&lt;/li&gt;
&lt;li&gt;清除堆栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常用系统调用
&lt;ul&gt;
&lt;li&gt;进程管理: fork waitpid execve exit&lt;/li&gt;
&lt;li&gt;文件管理: open close read write lseek stat&lt;/li&gt;
&lt;li&gt;目录和文件系统管理: mkdir rmdir link unlink mount umount&lt;/li&gt;
&lt;li&gt;各种系统调用: chdir chmod kill time&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统结构
&lt;ul&gt;
&lt;li&gt;单体系统
&lt;ul&gt;
&lt;li&gt;整个操作系统以过程集合的方式编写，链接成一个大型可执行二进制程序&lt;/li&gt;
&lt;li&gt;每个过程都可以自由调用其他过程&lt;/li&gt;
&lt;li&gt;容错性差&lt;/li&gt;
&lt;li&gt;系统笨拙难以理解&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;层次式系统
&lt;ul&gt;
&lt;li&gt;层次式结构的操作系统，它的上层软件都是在下一层软件的基础之上构建的&lt;/li&gt;
&lt;li&gt;该系统的各个部分最终仍然被链接成了完整的单个目标程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;微内核
&lt;ul&gt;
&lt;li&gt;为了实现高可靠性，将操作系统划分成小的、良好定义的模块，只有其中一个模块一一微内核一运行在内核态，其余的模块由于功能相对弱些，则作为普通用户进程运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;客户端一服务器模式
&lt;ul&gt;
&lt;li&gt;一般来说，客户端和服务器之间的通信是消息传递。为了获得一个服务，客户端进程构造一段消息，说明所需要的服务，井将其发给合适的服务器。该服务器完成工作，发送回应。&lt;/li&gt;
&lt;li&gt;客户端和服务器运行在不同的计算机上，它们通过局域网或广域网连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟机
&lt;ul&gt;
&lt;li&gt;虚拟机监控程序&lt;/li&gt;
&lt;li&gt;共享托管&lt;/li&gt;
&lt;li&gt;第一类虚拟机管理程序&lt;/li&gt;
&lt;li&gt;模拟器&lt;/li&gt;
&lt;li&gt;虚拟化&lt;/li&gt;
&lt;li&gt;二进制翻译&lt;/li&gt;
&lt;li&gt;Java 虚拟机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;外核
&lt;ul&gt;
&lt;li&gt;对机器进行分区&lt;/li&gt;
&lt;li&gt;为虚拟机分配资源，井检查使用这些资源的企图，以确保没有机器会使用他人的资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;依靠 C 的世界
&lt;ul&gt;
&lt;li&gt;指针&lt;/li&gt;
&lt;li&gt;头文件&lt;/li&gt;
&lt;li&gt;目标文件&lt;/li&gt;
&lt;li&gt;C 预处理器&lt;/li&gt;
&lt;li&gt;链接&lt;/li&gt;
&lt;li&gt;运行模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有关操作系统的研究
&lt;ul&gt;
&lt;li&gt;错误调试&lt;/li&gt;
&lt;li&gt;故障恢复&lt;/li&gt;
&lt;li&gt;文件和存储系统&lt;/li&gt;
&lt;li&gt;等等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>推理::金色麦田</title>
      <link>/reading/douban_33404959/</link>
      <pubDate>Sun, 11 Jul 2021 17:14:37 +0800</pubDate>
      <guid>/reading/douban_33404959/</guid>
      <description></description>
    </item>
    
    <item>
      <title>推理::恶意</title>
      <link>/reading/douban_26877752/</link>
      <pubDate>Sat, 03 Jul 2021 17:15:37 +0800</pubDate>
      <guid>/reading/douban_26877752/</guid>
      <description></description>
    </item>
    
    <item>
      <title>推理::心灵侦探城塚翡翠</title>
      <link>/reading/douban_35296788/</link>
      <pubDate>Sat, 03 Jul 2021 17:14:37 +0800</pubDate>
      <guid>/reading/douban_35296788/</guid>
      <description></description>
    </item>
    
    <item>
      <title>编程::计算机网络自顶向下方法</title>
      <link>/reading/computer_network_a_topdown_approach/</link>
      <pubDate>Thu, 24 Jun 2021 19:27:56 +0800</pubDate>
      <guid>/reading/computer_network_a_topdown_approach/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;../../notes/computer_network_a_topdown_approach_01&#34;&gt;计算机网络自顶向下方法::计算机网络和因特网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/computer_network_a_topdown_approach_02&#34;&gt;计算机网络自顶向下方法::应用层&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/computer_network_a_topdown_approach_03&#34;&gt;计算机网络自顶向下方法::运输层&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>计算机网络自顶向下方法::运输层</title>
      <link>/notes/computer_network_a_topdown_approach_03/</link>
      <pubDate>Wed, 16 Jun 2021 20:27:06 +0800</pubDate>
      <guid>/notes/computer_network_a_topdown_approach_03/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;概述和运输层服务
&lt;ul&gt;
&lt;li&gt;运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信。应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无须考虑承载这些报文的物理基础设施的细节。&lt;/li&gt;
&lt;li&gt;运输层协议是在端系统中而不是在路由器中实现的。在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为运输层报文段（segment）。在接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层 。运输层则处理接收到的报文段，使该报文段中的数据为接收应用进程使用。&lt;/li&gt;
&lt;li&gt;网络应用程序可以使用多种的运输层协议。例如，因特网有两种协议，即 TCP 和 UDP。每种协议都能为调用的应用程序提供一组不同的运输层服务。&lt;/li&gt;
&lt;li&gt;运输层和网络层的关系
&lt;ul&gt;
&lt;li&gt;在协议栈中，运输层刚好位于网络层之上。网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信&lt;/li&gt;
&lt;li&gt;计算机网络中可以安排多种运输层协议，每种协议为应用程序提供不同的服务模型。&lt;/li&gt;
&lt;li&gt;运输协议能够提供的服务常常受制于底层网络层协议的服务模型。如果网络层协议无法为主机之间发送的运输层报文段提供时延或带宽保证的话，运输层协议也就无法为进程之间发送的应用程序报文提供时延或带宽保证。&lt;/li&gt;
&lt;li&gt;即使底层网络协议不能在网络层提供相应的服务，运输层协议也能提供某些服务。例如可靠运输。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因特网运输层概述
&lt;ul&gt;
&lt;li&gt;UDP：它为调用它的应用程序提供了一种不可靠、无连接的服务&lt;/li&gt;
&lt;li&gt;TCP：它为调用它的应用程序提供了一种可靠的、面向连接的服务&lt;/li&gt;
&lt;li&gt;当设计一个网络应用程序时，该应用程序的开发人员必须指定使用这两种运输协议中的一种&lt;/li&gt;
&lt;li&gt;因特网网络层协议有一个名字叫 IP, 即网际协议。IP 为主机之间提供了逻辑通信。IP 的服务模型是尽力而为交付服务，是不可靠的&lt;/li&gt;
&lt;li&gt;我们总结一下 UDP 和 TCP 所提供的服务模型。UDP 和 TCP 最基本的责任是，将两个端系统间 IP 的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为运输层的多路复用 (transport-layer multiplexing) 与 多路分解 (demultiplexing)&lt;/li&gt;
&lt;li&gt;进程到进程的数据交付和差错检查是两种最低限度的运输层服务，也就是 UDP 所提供的服务&lt;/li&gt;
&lt;li&gt;TCP 额外供了可靠数据运输和拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多路复用和多路分解
&lt;ul&gt;
&lt;li&gt;一个进程有一个或多个套接字，它相当于从网络向进程传递数据和从进程向网络传递数据的门户。在接收主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字。由于在任一时刻，在接收主机上可能有不止一个套接字，所以每个套接字都有唯一的标识符。标识符的格式取决于它是 UDP 还是 TCP 套接字。&lt;/li&gt;
&lt;li&gt;主机为了将一个到达的运输层报文段定向到适当的套接字，每个运输层报文段中具有几个字段。在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作称为多路分解(demulti plexing)。在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为多路复用(multiplexing)&lt;/li&gt;
&lt;li&gt;运输层多路复用要求
&lt;ul&gt;
&lt;li&gt;套接字有唯一标识&lt;/li&gt;
&lt;li&gt;每个报文段有特殊字段来指示该报文段所要交付到的套接字&lt;/li&gt;
&lt;li&gt;这些特殊字段是源端口号字段和目的端口号字段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程&lt;/li&gt;
&lt;li&gt;无连接的多路复用与多路分解
&lt;ul&gt;
&lt;li&gt;一个 UDP 套接字是由一个二元组全面标识的，该二元组包含一个目的 IP 地址和一个目的端口号。因此，如果两个 UDP 报文段有不同的源 IP 地址和／或源端口号，但具有相同的目的 IP 地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;面向连接的多路复用与多路分解
&lt;ul&gt;
&lt;li&gt;TCP 套接字是由一个四元组（源 IP 地址，源端口号，目的 IP 地址，目的端口号）来标识的&lt;/li&gt;
&lt;li&gt;两个具有不同源 IP 地址或源端口号的到达 TCP 报文段将被定向到两个不同的套接字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Web 服务器与 TCP
&lt;ul&gt;
&lt;li&gt;如果客户与服务器使用持续 HTTP,则在整条连接持续期间 ，客户与服务器之间经由同一个服务器套接字交换 HTTP 报文 。然而，如果客户与服务器使用非持续 HTTP, 则对每一对请求／响应都创建一个新的 TCP 连接并在随后关闭、因此对每一对请求／响应创建一个新的套接字并在随后关闭。这种套接字的频繁创建和关闭会严重地影响一个繁忙的 Web 服务器的性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无连接运输：UDP
&lt;ul&gt;
&lt;li&gt;UDP 只是做了运输协议能够做的最少工作。除了复用／分解功能及少量的差错检测外，它几乎没有对 IP 增加别的东西。&lt;/li&gt;
&lt;li&gt;使用 UDP 时，在发送报文段之前，发送方和接收方的运输层实体之间没有握手&lt;/li&gt;
&lt;li&gt;使用 UDP 的理由
&lt;ul&gt;
&lt;li&gt;关于发送什么数据以及何时发送的应用层控制更为精细&lt;/li&gt;
&lt;li&gt;无须连接建立&lt;/li&gt;
&lt;li&gt;无连接状态&lt;/li&gt;
&lt;li&gt;分组首部开销小&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UDP 中缺乏拥塞控制能够导致 UDP 发送方和接收方之间的高丢包率，并挤垮了 TCP 会话，这是一个潜在的严重问题。很多研究人员已经提出了一些新的机制，使得 UDP 执行自适应的拥塞控制&lt;/li&gt;
&lt;li&gt;使用 UDP 的应用是可能实现可靠数据传输的。这可通过在应用程序自身中建立可靠性机制来完成。例如 Google 的 QUIC。&lt;/li&gt;
&lt;li&gt;UDP 报文段结构
&lt;ul&gt;
&lt;li&gt;源端口，发送方的端口号&lt;/li&gt;
&lt;li&gt;目的端口，接收方的端口号&lt;/li&gt;
&lt;li&gt;报文长度，即整个 UDP 报文的长度，包括头部和数据，单位为字节&lt;/li&gt;
&lt;li&gt;检验和。&lt;/li&gt;
&lt;li&gt;应用数据，也就是报文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UDP 检验和
&lt;ul&gt;
&lt;li&gt;检验和用千确定当 UDP 报文段从源到达目的地移动时，其中的比特是否发生了改变&lt;/li&gt;
&lt;li&gt;发送方的 UDP 对报文段中的所有 16 比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。 得到的结果被放在 UDP 报文段中的检验和字段，在接收方，全部的 4 个 16 比特字（包括检验和）没有引入差错 ，则显然在接收方处该和将是 1111111111111111&lt;/li&gt;
&lt;li&gt;UDP 提供差错检测是因为不能保证源和目的之间的所有链路都提供差错检测；这就是说，也许这些链路中的一条可能使用没有差错检测的协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可靠数据传输原理
&lt;ul&gt;
&lt;li&gt;构造可靠数据传输协议
&lt;ul&gt;
&lt;li&gt;经完全可靠信道的可靠数据传输: rdt1.0
&lt;ul&gt;
&lt;li&gt;首先，我们考虑最简单的情况，即底层信道是完全可靠的。我们称该协议为 rdt1.0,该协议本身是简单的。在这个简单的协议中，一个单元数据与一个分组没差别。而且，所有分组是从发送方流向接收方；有了完全可靠的信道，接收端就不需要提供任何反馈信息给发送方，因为不必担心出现差错！注意到我们也已经假定了接收方接收数据的速率能够与发送方发送数据的速率一样快。因此，接收方没有必要请求发送方慢一点！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;经具有比特差错信道的可靠数据传输：rdt2.0
&lt;ul&gt;
&lt;li&gt;底层信道更为实际的模型是分组中的比特可能受损的模型。在分组的传输、传播或缓存的过程中，这种比特差错通常会出现在网络的物理部件中，我们眼下还将继续假定所有发送的分组（虽然有些比特可能受损）将按其发送的顺序被接收。&lt;/li&gt;
&lt;li&gt;控制报文使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误并因此需要重复。在计算机网络环境中，基于这样重传机制的可靠数据传输协议称为自动重传请求(Automatic Repeat Request,ARQ)协议。
&lt;ul&gt;
&lt;li&gt;差错检测：首先，需要一种机制以使接收方检测到何时出现了比特差错&lt;/li&gt;
&lt;li&gt;接收方反馈：rdt2.0 协议将从接收方向发送方反馈是否接受的分组。&lt;/li&gt;
&lt;li&gt;重传：接收方收到有差错的分组时，发送方将重传该分组文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当发送方处于等待 ACK 或 NAK 的状态时，它不能从上层获得更多的数据，仅当接收到 ACK 并离开该状态时才能发生这样的事件，因此，发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。由于这种行为，rdt2.0 这样的协议被称为停等(stop-and-wait)协议。&lt;/li&gt;
&lt;li&gt;考虑受损 ACK 和 NAK 的 3 种可能性
&lt;ul&gt;
&lt;li&gt;增加确认机制，会陷入无尽的确认，不可行&lt;/li&gt;
&lt;li&gt;增加足够的检验和比特，使发送方不仅可以检测差错，还可恢复差错&lt;/li&gt;
&lt;li&gt;当发送方收到含糊不清的 ACK 或 NAK 分组时，只需重传当前数据分组即可。然而，这种方法在发送方到接收方的信道中引入了冗余分组 (duplicate packet)。冗余分组的根本困难在于接收方不知道它上次所发送的 ACK 或 NAK 是否被发送方正确地收到。因此它无法事先知道接收到的分组是新的还是一次重传！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解决这个新问题的一个简单方法是在数据分组中添加一新字段，让发送方对其数据分组编号，即将发送数据分组的序号放在该字段。于是，接收方只需要检查序号即可确定收到的分组是否一次重传。对于停等协议这种简单情况，1 比特序号就足够了，因为它可让接收方知道发送方是否正在重传前一个发送分组，或是一个新分组。&lt;/li&gt;
&lt;li&gt;协议 rdt2.1 使用了从接收方到发送方的肯定确认和否定确认。当接收到失序的分组时，接收方对所接收的分组发送一个肯定确认。如果收到受损的分组，则接收方将发送一个否定确认。如果不发送 NAK, 而是对上次正确接收的分组发送一个 ACK, 我们也能实现与 NAK 一样的效果。发送方接收到对同一个分组的两个 ACK，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组，rdt2.2 是在有比特差错信道上实现的一个无 NAK 的可靠数据传输协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;经具有比特差错的丢包信道的可靠数据传输：rdt3.0
&lt;ul&gt;
&lt;li&gt;协议现在必须处理另外两个关注的问题：怎样检测丢包以及发生丢包后该做些什么&lt;/li&gt;
&lt;li&gt;发送方负责检测和恢复丢包工作&lt;/li&gt;
&lt;li&gt;判断丢失：发送方传输一个数据分组，该分组或者接收方对该分组的 ACK 发生了丢失。在这两种情况下，发送方都收不到应当到来的接收方的响应。如果发送方愿意等待足够长的时间以便确定分组已丢失，则它只需重传该数据分组即可。&lt;/li&gt;
&lt;li&gt;决定等待时长：即发送方与接收方之间的一个往返时延（可能会包括在中间路由器的缓冲时延）加上接收方处理一个分组所需的时间。为了实现基于时间的重传机制，需要一个倒计数定时器,在一个给定的时间掀过期后，可中断发送方。因此，发送方需要能做到：每次发送一个分组（包括第一次分组和重传分组）时，便启动一个定时器；响应定时器中断；终止定时器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;现在我们归纳一下数据传输协议的要点。在检验和、序号、定时器、肯定和否定确认分组这些技术中，每种机制都在协议的运行中起到了必不可少的作用。至此，我们得到了一个可靠数据传输协议！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流水线可靠数据传输协议
&lt;ul&gt;
&lt;li&gt;rtd3.0 有个停等协议影响性能，存在信道利用率低的问题。&lt;/li&gt;
&lt;li&gt;这种特殊的性能问题的一个简单解决方法是：不以停等方式运行，允许发送方发送多个分组而无须等待确认，因为许多从发送方向接收方输送，的分组可以被看成是填充到一条流水线中，故这种技术被称为流水线&lt;/li&gt;
&lt;li&gt;流水线协议对可靠数据传输协议带来的影响
&lt;ul&gt;
&lt;li&gt;增加序列号范围&lt;/li&gt;
&lt;li&gt;发送方和接收方需要缓存多个分组&lt;/li&gt;
&lt;li&gt;所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是：回退 N 步 (Go-Back-N, GBN) 和选择重传 (Selective Repeat, SR) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;回退 N 步
&lt;ul&gt;
&lt;li&gt;那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为 N 的窗口，随着协议的运行，该窗口在序号空间向前滑动。因此，N 常被称为窗口长度 (window size),GBN 协议也常被称为滑动窗口协议 (sliding-window protocol)。&lt;/li&gt;
&lt;li&gt;GNB 发送方需要响应三种类型的事件
&lt;ul&gt;
&lt;li&gt;上层的调用：当上层调用发送函数时，如果队列满了就不发送。&lt;/li&gt;
&lt;li&gt;收到一个 ACK：对收到的序号 n 和 n 以前的分组全部确认&lt;/li&gt;
&lt;li&gt;超时事件：如果出现超时，发送方重传所有已发送但还未被确认过的分组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接收方如果一个需要为 n 的分组被正确按序接受，则接收方为分组 n 发送一个 ACK, 并将该分组中的数据部分交付到上层。在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送 ACK。因为接收方需要按序交付分组给上层。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选择重传
&lt;ul&gt;
&lt;li&gt;选择重传 (SR) 协议通过让发送方仅重传那些它怀疑在接收方出错（即丢失或受损）的分组而避免了不必要的重传。这种个别的、按需的重传要求接收方逐个地确认正确接收的分组。再次用窗口长度 N 来限制流水线中未完成 、未被确认的分组数。然 而，与 GBN 不同的是，发送方已经收到了对窗口中某些分组的 ACK。&lt;/li&gt;
&lt;li&gt;SR 接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直到所有丢失分组（即序号更小的分组 ）皆被收到为止，这时才可以将一批分组按序交付给上层 。&lt;/li&gt;
&lt;li&gt;发送方的事件
&lt;ul&gt;
&lt;li&gt;从上层收到数据。当从上层接收到数据后，SR 发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送；否则就像在 GBN 中一样，要么将数据缓存，要么将其返回给上层以便以后传输。&lt;/li&gt;
&lt;li&gt;超时。定时器再次被用来防止丢失分组。然而 ，现在每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个分组。可以使用单个硬件定时楛模拟多个逻辑定时器的操作。&lt;/li&gt;
&lt;li&gt;收到 ACK。如果收到 ACK, 倘若该分组序号在窗口内，则 SR 发送方将那个被确认的分组标记为已接收。如果该分组的序号等于 send_base, 则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接收方的事件
&lt;ul&gt;
&lt;li&gt;序号在[rev_base,rcv_base + N - 1]内的分组被正确接收。在此情况下，收到的分组落在接收方的窗口内，一个选择 ACK 被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号，则该分组以及以前缓存的序号连续的分组交付给上层。然后，接收窗口按向前移动分组的编号向上交付这些分组。&lt;/li&gt;
&lt;li&gt;序号在 [ rcv_base - N, rcv_base - 1] 内的分组被正确收到。在此情况下，必须产生一个 ACK, 是接收方以前已确认过的分组 。&lt;/li&gt;
&lt;li&gt;其他情况。忽略该分组 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于哪些分组已经被正确接收，哪些没有，发送方和接收方并不总是能看到相同的结果。对 SR 协议而言，这就意味着发送方和接收方的窗口并不总是一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可靠数据传输机制及其用途的总结
&lt;ul&gt;
&lt;li&gt;检验和；用于检测在一个传输分组中的比特错误&lt;/li&gt;
&lt;li&gt;定时器：用于超时/重传一个分组，可能因为该分组〈或其 ACK) 在信道中丢失了。由于当一个分组延时但未丢失〈过早超时) ，或当一个分组已被接收方收到但从接收方到发送方的 ACK 丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余副本&lt;/li&gt;
&lt;li&gt;序号：用于为从发送方流向接收方的数据分组按顺序编号。所接收分组的序号间的空隙可使接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余副本&lt;/li&gt;
&lt;li&gt;确认：接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或累积的，这取决于协议&lt;/li&gt;
&lt;li&gt;否定确认：接收方用于告诉发送方某个分组未被正确地接收。否定确认报文通常据带着未被正确接收的分组的序号&lt;/li&gt;
&lt;li&gt;窗口、流水线：发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。我们很快将会看到，窗口长度可根据接收方接收和缓存报文的能力、网络中的拥塞程度或两者情况来进行设置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>计算机网络自顶向下方法::应用层</title>
      <link>/notes/computer_network_a_topdown_approach_02/</link>
      <pubDate>Wed, 16 Jun 2021 20:26:06 +0800</pubDate>
      <guid>/notes/computer_network_a_topdown_approach_02/</guid>
      <description>&lt;h2 id=&#34;应用层协议原理&#34;&gt;应用层协议原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;应用层协议原理
&lt;ul&gt;
&lt;li&gt;研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序&lt;/li&gt;
&lt;li&gt;当研发新应用程序时，你需要编写将在多台端系统上运行的软件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络应用体系结构
&lt;ul&gt;
&lt;li&gt;从应用程序研发者的角度看，网络体系结构是固定的，并为应用程序提供了特定的服务集合&lt;/li&gt;
&lt;li&gt;应用程序体系结构 (application architecture) 由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。
&lt;ul&gt;
&lt;li&gt;客户-服务器体系结构
&lt;ul&gt;
&lt;li&gt;有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求&lt;/li&gt;
&lt;li&gt;客户-服务器体系结构，客户相互之间不直接通信&lt;/li&gt;
&lt;li&gt;服务器具有固定的、周知的地址，该地址称为 IP 地址&lt;/li&gt;
&lt;li&gt;具有客户-服务器体系结构的非常著名的应用程序包括 Web、FTP、Telnet 和电子邮件&lt;/li&gt;
&lt;li&gt;一个流行的社交网络站点如果仅有一台服务器来处理所有请求，将很快变得不堪重负。为此，配备大量主机的数据中心(data center)常被用于创建强大的虚拟服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;P2P 体系结构
&lt;ul&gt;
&lt;li&gt;对数据中心服务器有最小的依赖&lt;/li&gt;
&lt;li&gt;应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为对等方&lt;/li&gt;
&lt;li&gt;具有自扩展性，成本效率高，不需要庞大的基础设施&lt;/li&gt;
&lt;li&gt;具有 P2P 体系结构的应用包括 BitTorrent、因特网电话和视频会议(例如 Skype)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程通信
&lt;ul&gt;
&lt;li&gt;客户与服务器通信
&lt;ul&gt;
&lt;li&gt;网络应用程序由成对的进程组成，这些进程通过网络相互发送报文&lt;/li&gt;
&lt;li&gt;对每对通信进程，我们通常将这两个进程之一标识为客户(client) , 而另一个进程标识为服务器&lt;/li&gt;
&lt;li&gt;在 P2P 文件共享的某些应用中，一个进程能够既是客户又是服务器&lt;/li&gt;
&lt;li&gt;我们定义客户和服务器进程如下: 在一对进程之间的通信会话场景中，发起通信(即在该会话开始时发起与其他进程的联系)的进程被标识为客户，在会话开始时等待联系的进程是服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程与计算机网络之问的接口
&lt;ul&gt;
&lt;li&gt;进程通过一个称为套接字(socket)的软件接口向网络发送报文和从网络接收报文&lt;/li&gt;
&lt;li&gt;套接字是同一台主机内应用层与运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程寻址
&lt;ul&gt;
&lt;li&gt;为了标识该接收进程，需要定义两种信息
&lt;ul&gt;
&lt;li&gt;主机的地址&lt;/li&gt;
&lt;li&gt;目的主机中指定接受进程的标识符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在因特网中，主机由其 IP 地址 (IP adress) 标识&lt;/li&gt;
&lt;li&gt;目的地端口号 (port number) 用于指定运行在接收主机上的接收进程(更具体地说，接收套接字)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可供应用程序使用的运输服务
&lt;ul&gt;
&lt;li&gt;可靠数据传输
&lt;ul&gt;
&lt;li&gt;确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;吞吐量
&lt;ul&gt;
&lt;li&gt;运输层协议能够以某种特定的速率提供确保的可用吞吐量&lt;/li&gt;
&lt;li&gt;带宽敏感的应用具有特定的吞吐量要求，而弹性应用 (elastic application) 能够根据当时可用的带宽或多或少地利用可供使用的吞吐量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定时
&lt;ul&gt;
&lt;li&gt;运输层协议也能提供定时保证，能够以多种形式实现。这种服务将对交互式实时应用程序有吸引力。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全性
&lt;ul&gt;
&lt;li&gt;在发送和接收进程之间提供机密性，以防该数据以某种方式在这两个进程之间被观察到。运输协议还能提供除了机密性以外的其他安全性服务，包括数据完整性和端点鉴别&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因特网的提供的运输服务
&lt;ul&gt;
&lt;li&gt;TCP 服务
&lt;ul&gt;
&lt;li&gt;面向连接服务和可靠数据传输服务&lt;/li&gt;
&lt;li&gt;在应用层数据报文开始流动之前，TCP 让客户端和服务器互相交换运输层控制信息。在握手后，一个全双工 TCP 连接就在两者之间建立了。当应用程序结束报文发送时，必须拆除该连接。&lt;/li&gt;
&lt;li&gt;通信进程能够依靠 TCP, 无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠 TCP 将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。&lt;/li&gt;
&lt;li&gt;TCP 也提供拥塞控制机制，当发送方和接收方之间的网络出现拥塞时，TCP 的拥塞控制机制会抑制发送进程，TCP 拥塞控制也试图限制每个 TCP 连接，使它们达到公平共享网络带宽的目的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UDP 服务
&lt;ul&gt;
&lt;li&gt;UDP 是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP 是无连接的，因此在两个进程通信前没有握手过程。&lt;/li&gt;
&lt;li&gt;UDP 协议提供一种不可靠数据传送服务，不保证报文能到达接受进程，也不保证顺序。&lt;/li&gt;
&lt;li&gt;UDP 没有拥塞控制机制，可以以任意速率向下层注入数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运输协议不提供的服务
&lt;ul&gt;
&lt;li&gt;吞吐量和定时保证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用层协议
&lt;ul&gt;
&lt;li&gt;交换的报文类型，例如请求报文和响应报文。&lt;/li&gt;
&lt;li&gt;各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。&lt;/li&gt;
&lt;li&gt;字段的语义，即这些字段中的信息的含义。&lt;/li&gt;
&lt;li&gt;确定一个进程何时以及如何发送报文，对报文进行响应的规则。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;web-和-http&#34;&gt;Web 和 HTTP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP 概况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web 的应用层协议是超文本传输协议 (HyperText Transfer Protocol, HTTP) , 它是 Web 的核心&lt;/li&gt;
&lt;li&gt;HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的方式&lt;/li&gt;
&lt;li&gt;Web 页面 (Web page) (也叫文档)是由对象组成的。一个对象 (objeel) 只是一个文件，诸如一个 HTML 文件、一个 JPEG 图形、一个 Java 小程序或一个视频片段这样的文件，且它们可通过一个 URL 地址寻址。多数 Web 页面含有一个 HTML 基本文件 (baseHTML file) 以及几个引用对象。&lt;/li&gt;
&lt;li&gt;每个 URL 地址由两部分组成:存放对象的服务器主机名和对象的路径名&lt;/li&gt;
&lt;li&gt;Web 浏览器 (Web browser) (例如 IE 和 Firefox) 实现了 HTTP 的客户端&lt;/li&gt;
&lt;li&gt;Web 服务器 (Weh server) 实现了 HTTP 的服务器端，它用于存储 Web 对象，每个对象由 URL 寻址。&lt;/li&gt;
&lt;li&gt;HTTP 定义了 Web 客户向 Web 服务器请求 Web 页面的方式，以及服务器向客户传送 Web 页面的方式&lt;/li&gt;
&lt;li&gt;HTTP 使用 TCP 作为它的支撑运输协议&lt;/li&gt;
&lt;li&gt;因为 HTTP 服务器并不保存关于客户的任何信息，所以我们说 HTTP 是一个无状态协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非连续连接和连续连接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑一个 HTML 页面，包含了额外 10 个对象&lt;/li&gt;
&lt;li&gt;采用非连续连接会产生 11 个连接，以及额外的 10 个 RTT&lt;/li&gt;
&lt;li&gt;采用连续连接会产生 1 个连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 报文格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;请求报文&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#75af00&#34;&gt;GET&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;/somedir/page.html&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;HTTP&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.1&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;Host&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;www.someschool.edu&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;Connection&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;close&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;User-agent&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;Mozilla/5.0&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;Accept-language&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;fr&lt;/span&gt;

(data data data data data ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 请求报文的第一行叫作请求行 ( request line) , 其后继的行叫作首部行 (header line)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求行有 3 个字段:方法字段、URL 字段和 HTTP 版本字段。方法字段可以取几种不同的值，包括 GET、POST、HEAD 、PUT 和 DELETE 等，绝大部分的 HTTP 请求报文使用 GET 方法。当浏览器请求一个对象时，使用 GET 方法，在 URL 字段带有请求对象的标识。在本例中，该浏览器正在请求对象 /somedir/page.html。其版本字段是自解释的，在本例中，浏览器实现的是 HTTP/1.1 版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首部行 Host: &lt;a href=&#34;http://www.someschool.edu&#34;&gt;www.someschool.edu&lt;/a&gt; 指明了对象所在的主机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;connection: close 首部行，该浏览器告诉服务器不要麻烦地使用持续连接，它要求服务器在发送完被请求的对象后就关闭这条连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;User-agent: 首部行用来指明用户代理即向服务器发送请求的浏览器的类型。这里浏览器类型是 Mozilla/5.0, 即 Firefox 浏览器。这个首部行是有用的，因为服务器可以有效地为不同类型的用户代理实际发送相同对象的不同版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，Accept-language: 首部行表示用户想得到该对象的法语版本(如果服务器中有这样的对象的话);否则，服务器应当发送它的默认版本。Accept-language: 首部行仅是 HTTP 中可用的众多内容协商首部之一&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GET 请求也可以携带 body，但大多数服务器不会处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应报文&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;HTTP&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;OK&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;Connection&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;close&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;Tue, 18 Aug 2015 15:44:04 GMT&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;Server&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;Apache/2.2.3 (CentOS)&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;Last-Modified&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;Tue, 18 Aug 2015 15:11:03 GMT&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;Content-Length&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6821&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;Content-Type&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;text/html&lt;/span&gt;

(data data data data data ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它有三个部分:一个初始状态行 (stalus line), 6 个 首部行 (headerline) , 然后是实体体 (entity body)。 实体体部分是报文的主要部分，即它包含了所请求的对象本身 (表示为 data data data data data ···)。状态行有 3 个字段:协议版本字段、状态码和相应状态信息。在这个例子中，状态行指示服务器正在使用 HTTP/1.1 并且一切正常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器用 Connection: close 首部行告诉客户，发送完报文后将关闭该 TCP 连接 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Date: 首部行指示服务器产生并发送该响应报文的日期和时间。值得一提的是，这个时间不是指对象创建或者最后修改的时间，而是服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Server: 首部行指示该报文是由一台 Apache Web 服务器产生的、它类似于 HTTP 请求报文中的 User-agent : 首部行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Last-Modified: 首部行指示了对象创建或者最后修改的日期和时间。Last-Modified : 首部行对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非状态行常重要。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Content-Length: 首部行指示了被发送对象中的字节数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Content-Type : 首部行指示了实体体中的对象是 HTML 文本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常见 HTTP 状态码和说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200 OK: 请求成功，信息在返回的响应报文中。&lt;/li&gt;
&lt;li&gt;301 Moved Permanently: 请求的对象已经被永久转移了，新的 URL 定义在响应报的 Location: 首部行中。客户软件将自动获取新的 URL&lt;/li&gt;
&lt;li&gt;400 Bad Request : 一个通用差错代码，指示该请求不能被服务器理解。&lt;/li&gt;
&lt;li&gt;404 Not Found: 被请求的文档不在服务器上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cookie&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 使用 cookie 识别客户端&lt;/li&gt;
&lt;li&gt;cookie 技术有 4 个组件:
&lt;ul&gt;
&lt;li&gt;在 HTTP 响应报文中的一个 cookie 首部行&lt;/li&gt;
&lt;li&gt;在 HTTP 请求报文中的一个 cookie 首部行&lt;/li&gt;
&lt;li&gt;在用户端系统中保留有一个 cookie 文件，并由用户的浏览器进行管理&lt;/li&gt;
&lt;li&gt;位于 Web 站点的一个后端数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Web 缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;web 缓存器 (Web cache) 也叫代理服务器 (proxy server),它是能够代表初始 Web 服务器来满足 HTTP 请求的网络 实体。Web 缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。&lt;/li&gt;
&lt;li&gt;通过使用内容分发网络(Content Distribution Network, CDN),Web 缓存器正在因特网中发挥着越来越重要的作用。CDN 公司在因特网上安装了许多地理上分散的缓存器，因而使大量流量实现了本地化。有多个共享的 CDN (例如 Akamai 和 Limelight) 和专用的 CDN (例如谷歌和 Netflix) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;条件 GET 方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对缓存过期问题，HTTP 协议有一种机制，允许缓存器证实它的对象是最新的。这种机制就是条件 GET (conditional GET)方法。如果: 请求报文使用 GET 方法并且请求报文中包含一个 &amp;lsquo;If-Modified-Since:&amp;rsquo; 首部行，那么，这个 HTTP 请求报文就是一个条件 GET 请求报文。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;英特网中的电子邮件&#34;&gt;英特网中的电子邮件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;电子邮件系统有 3 个主要组成部分:用户代理 (user agent)、邮件服务器 (mail server) 和 简单邮件传输协议(Simple Mail Transfer Protocol, SMTP)&lt;/li&gt;
&lt;li&gt;邮件服务器形成了电子邮件体系结构的核心。每个接收方在其中的某个邮件服务器上有一个邮箱 (mailbox)。&lt;/li&gt;
&lt;li&gt;一个典型的邮件发送过程是: 从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中。&lt;/li&gt;
&lt;li&gt;如果的发送服务器不能将邮件交付给接受服务器，发送邮件服务器在一个报文队列中保持该报文并在以后尝试再次发送。通常每 30 分钟左右进行一次尝试; 如果几天后仍不能成功，服务器就删除该报文并以电子邮件的形式通知发送方&lt;/li&gt;
&lt;li&gt;SMTP
&lt;ul&gt;
&lt;li&gt;SMTP 是因特网电子邮件的核心，用于从发送方的邮件服务器发送报文到接收方的邮件服务器&lt;/li&gt;
&lt;li&gt;基本操作
&lt;ul&gt;
&lt;li&gt;假设 Alice 想给 Bob 发送一封简单的 ASCTI 报文 。&lt;/li&gt;
&lt;li&gt;Alice 调用她的邮件代理程序并提供 Bob 的邮件地址(例如 &lt;a href=&#34;mailto:bob@someschool.edu&#34;&gt;bob@someschool.edu&lt;/a&gt;),撰写报文，然后指示用户代理发送该报文。&lt;/li&gt;
&lt;li&gt;从 Alice 的用户代理把报文发给她的邮件服务器，在那里该报文被放在报文队列中 。&lt;/li&gt;
&lt;li&gt;运行在 Alice 的邮件服务器上的 SMTP 客户端发现了报文队列中的这个报文，它就创建一个到运行在 Bob 的邮件服务器上的 SMTP 服务器的 TCP 连接 。&lt;/li&gt;
&lt;li&gt;在经过一些初始 SMTP 握手后，SMTP 客户通过该 TCP 连接发送 Alice 的报文 。&lt;/li&gt;
&lt;li&gt;在 Bob 的邮件服务器上，SMTP 的服务器端接收该报文。Bob 的邮件服务器然后将该报文放入 Bob 的邮箱中 。&lt;/li&gt;
&lt;li&gt;在 Bob 方便的时候，他调用用户代理阅读该报文。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;与 HTTP 的对比
&lt;ul&gt;
&lt;li&gt;HTTP 是 pull，SMTP 是 push&lt;/li&gt;
&lt;li&gt;SMTP 要求每个报文(包括它们的体)采用 7 比特 ASCII 码格式。如果某报文包含了非 7 比特 ASCII 字符(如具有重音的法文字符)或二进制数据(如图形文件)，则该报文必须按照 7 比特 ASCII 码进行编码。HTTP 数据则不受这种限制 。&lt;/li&gt;
&lt;li&gt;HTTP 把每个对象封装到它自己的 HTTP 响应报文中，而 SMTP 则把所有报文对象放在一个报文之中 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;邮件报文格式
&lt;ul&gt;
&lt;li&gt;每个首部必须含有一个 From: 首部行和一个 To: 首部行; 一个首部也许包含一个 Subject: 首部行以及其他可选的首部行。&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-eml&#34; data-lang=&#34;eml&#34;&gt;From: alice@crepes.fr
To: bob@hamburger.edu
Subject: Searching for the meaning of life.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;在报文首部之后，紧接着一个空白行，然后是以 ACSII 格式表示的报文体&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;邮件访问协议
&lt;ul&gt;
&lt;li&gt;POP3 (Post Office Protocol—Version3)
&lt;ul&gt;
&lt;li&gt;POP3 按照三个阶段进行工作:特许(authorization)、事务处理以及更新
&lt;ul&gt;
&lt;li&gt;在第一个阶段即特许阶段，用户代理发送(以明文形式)用户名和口令以鉴别用户。&lt;/li&gt;
&lt;li&gt;在第二个阶段即事务处理阶段，用户代理取回报文; 同时在这个阶段用户代理还能进行如下操作，对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息。&lt;/li&gt;
&lt;li&gt;在第三个阶段即更新阶段，它出现在客户发出了 quit 命令之后，目的是结束该 POP3 会话; 这时，该邮件服务器删除那些被标记为删除的报文 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IMAP
&lt;ul&gt;
&lt;li&gt;IMAP 服务器把每个报文与一个文件夹联系起来; 当报文第一次到达服务器时，它与收件人的 INBOX 文件夹相关联。收件人则能够把邮件移到 一个新的、用户创建的文件夹中，阅读邮件，删除邮件等 。&lt;/li&gt;
&lt;li&gt;IMAP 协议为用户提供了创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令。&lt;/li&gt;
&lt;li&gt;IMAP 还为用户提供了在远程文件夹中查询邮件的命令，按指定条件去查询匹配的邮件。值得注意的是，与 POP3 不同， IMAP 服务器维护了 IMAP 会话的用户状态信息，例如，文件夹的名字以及哪些报文与哪些文件夹相关联。&lt;/li&gt;
&lt;li&gt;IMAP 的另一个重要特性是它具有允许用户代理获取报文某些部分的命令，这个特性非常有用。使用这种低带宽连接时，用户可能并不想取回他邮箱中的所有邮件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于 Web 的电子邮件
&lt;ul&gt;
&lt;li&gt;很多公司提供了基于 Web 的电子邮件。使用这种服务，用户代理就是普通的浏览器，用户和他远程邮箱之间的通信则通过 HTTP 进行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns英特网的目录服务&#34;&gt;DNS：英特网的目录服务&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;DNS 提供的服务
&lt;ul&gt;
&lt;li&gt;识别主机有两种方式，通过主机名或者 IP 地址。们喜欢便于记忆的主机名标识方式，而路由器则喜欢定长的、有着层次结构的 IP 地址。为了折中这些不同的偏好，我们需要一种能进行主机名到 IP 地址转换的目录服务。这就是域名系统 (DomainNameSystem, DNS) 的主要任务&lt;/li&gt;
&lt;li&gt;DNS 是:
&lt;ul&gt;
&lt;li&gt;一个由分层的 DNS 服务器(DNS server)实现的分布式数据库;&lt;/li&gt;
&lt;li&gt;个使得主机能够查询分布式数据库的应用层协议。&lt;/li&gt;
&lt;li&gt;DNS 服务器通常是运行 BIND (Berkeley Internet Name Domain) 软件的 UNIX 机器。DNS 协议运行在 UDP 之上，使用 53 号端口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS 通常是由其他应用层协议所使用的，包括 HTTP、 SMTP 和 FTP, 将用户提供的主机名解析为 IP 地址。&lt;/li&gt;
&lt;li&gt;基本过程
&lt;ul&gt;
&lt;li&gt;同一台用户主机上运行着 DNS 应用的客户端.&lt;/li&gt;
&lt;li&gt;浏览器从上述 URL 中抽取出主机名 &lt;a href=&#34;http://www.somschool.edu&#34;&gt;www.somschool.edu&lt;/a&gt;，并将这台主机名传给 DNS 应用的客户端 。&lt;/li&gt;
&lt;li&gt;DNS 客户向 DNS 服务器发送一个包含主机名的请求 。&lt;/li&gt;
&lt;li&gt;DNS 客户最终会收到一份回答报文，其中含有对应于该主机名的 IP 地址。&lt;/li&gt;
&lt;li&gt;一旦浏览器接收到来自 DNS 的该 IP 地址，它能够向位于该 IP 地址 80 端口的 HTTP 服务器进程发起一个 TCP 连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS 提供的其他服务
&lt;ul&gt;
&lt;li&gt;主机别名&lt;/li&gt;
&lt;li&gt;邮件服务器别名&lt;/li&gt;
&lt;li&gt;负载分配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS 工作原理
&lt;ul&gt;
&lt;li&gt;假设运行在用户主机上的某些应用程序(如 Web 浏览器或邮件阅读器)需要将主机名转换为 IP 地址。这些应用程序将调用 DNS 的客户端，并指明需要被转换的主机名 (在很多基于 UNIX 的机器上，应用程序为了执行这种转换需要调用函数 &lt;code&gt;gethostbyname()&lt;/code&gt;)。用户主机上的 DNS 接收到后，向网络中发送一个 DNS 查询报文。所有的 DNS 请求和回答报文使用 UDP 数据报经端口 53 发送。经过若干毫秒到若干秒的时延后，用户主机上的 DNS 接收到一个提供所希望映射的 DNS 回答报文。这个映射结果则被传递到调用 DNS 的应用程序 。&lt;/li&gt;
&lt;li&gt;集中式的问题
&lt;ul&gt;
&lt;li&gt;单点故障&lt;/li&gt;
&lt;li&gt;通信容量&lt;/li&gt;
&lt;li&gt;远距离的集中式数据库&lt;/li&gt;
&lt;li&gt;维护成本高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分布式、层次数据库
&lt;ul&gt;
&lt;li&gt;为了处理扩展性问题，DNS 使用了大量的 DNS 服务器，它们以层次方式组织，并且分布在全世界范围内&lt;/li&gt;
&lt;li&gt;DNS 服务器大概分成三种
&lt;ul&gt;
&lt;li&gt;根 DNS 服务器：有 400 多个根名字服务器遍及全世界。这些根名字服务器由 13 个不同的组织管理。根名字服务器提供 TLD 服务器的 IP 地址。&lt;/li&gt;
&lt;li&gt;顶级域 (DNS) 服务器。对于每个顶级域(如 com、org、net、edu 和 gov) 和所有国家的顶级域(如 uk、fr、ca 和 jp) 都有 TLD 服务器 (或服务器集群)。&lt;/li&gt;
&lt;li&gt;权威 DNS 服务器。在因特网上具有公共可访问主机(如 Web 服务器和邮件服务器)的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。一个组织机构的权威 DNS 服务器收藏了这些 DNS 记录。一个组织机构能够选择实现它自己的权威 DNS 服务器以保存这些记录; 另一种方法是，该组织能够支付费用，让这些记录存储在某个服务提供商的一个权威 DNS 服务器中。多数大学和大公司实现和维护它们自已基本和辅助(备份)的权威 DNS 服务器 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;查询过程
&lt;ul&gt;
&lt;li&gt;假设主机 cse.nyu.edu 想知道主机 gaia.cs.umss.edu 的 IP 地址。同时假设纽约大学 (NYU) 的 cse.nyu.edu 主机的本地 DNS 服务器为 dns.nyu.edu 并且 gaia.cs.umass.edu 的权威 DNS 服务器为 dns.umass.edu。&lt;/li&gt;
&lt;li&gt;主机 cse.nyu.edu 首先向它的本地 DNS 服务器 dns.nyu.edu 发送一个 DNS 查询报文。该查询报文含有被转换的主机名 gaia.cs.umass.edu。&lt;/li&gt;
&lt;li&gt;本地 DNS 服务器将该报文转发到根 DNS 服务器。该根 DNS 服务器注意到其 edu 前缀并向本地 DNS 服务器返回负责 edu 的 TLD 的 IP 地址列表。&lt;/li&gt;
&lt;li&gt;该本地 DNS 服务器则再次向这些 TLD 服务器之一发送查询报文。该 TLD 服务器注意到 umass.edu 前缀，并用权威 DNS 服务器的 IP 地址进行响应，该权威 DNS 服务器是负责马萨诸塞大学的 dns.umass.edu。&lt;/li&gt;
&lt;li&gt;最后，本地 DNS 服务器直接向 dns.umass.edu 重发查询报文，dns.umass.edu 用 gaia.cs.umass.edu 的 IP 地址行响应。&lt;/li&gt;
&lt;li&gt;这个过程中总共发送了 8 份 DNS 报文: 4 份查询报文和 4 份回答报文&lt;/li&gt;
&lt;li&gt;DNS 查询过程可能是递归或者迭代的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS 缓存
&lt;ul&gt;
&lt;li&gt;为了改善时延性能并减少在因特网上到处传输的 DNS 报文数量 DNS 广泛使用了缓存技术&lt;/li&gt;
&lt;li&gt;在一个请求链中，当某 DNS 服务器接收一个 DNS 回答(例如，包含某主机名到 IP 地址的映射)时，它能将映射缓存在本地存储器中。当另一台服务器对同一域名发起查询时就可以做到及时响应。该存储不是永久的，一段时间后失效。&lt;/li&gt;
&lt;li&gt;因为缓存，除了少数 DNS 查询以外，根服务器被绕过了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS 记录和报文
&lt;ul&gt;
&lt;li&gt;DNS 记录
&lt;ul&gt;
&lt;li&gt;共同实现 DNS 分布式数据库的所有 DNS 服务器存储了资源记录 (Resource Record, RR), RR 提供了主机名到 IP 地址的映射。每个 DNS 回答报文包含了一条或多条资源记录。&lt;/li&gt;
&lt;li&gt;资源记录是一个包含了下列字段的 4 元组: (Name, Value, Type, TTL)，TTL 是过期时间，Name 和 Value 的值取决于 Type&lt;/li&gt;
&lt;li&gt;如果 Type=A, 则 Name 是主机名，Value 是该主机名对应的 IP 地址。因此，一条类型为 A 的资源记录提供了标准的主机名到 IP 地址的映射。例如 (relayl. bar.foo.com, 145.37.93.126, A) 就是一条类型 A 记录。&lt;/li&gt;
&lt;li&gt;如果 Type=NS, 则 Name 是个域(如 foo. com),而 Value 是个知道如何获得该域中主机 IP 地址的权威 DNS 服务器的主机名。这个记录用于沿着查询链来路由 DNS 查询。例如 (foo.com, dns.foo.com, NS) 就是一条类型为 NS 的记录。&lt;/li&gt;
&lt;li&gt;如果 Type=CNAME, 则 Value 是别名为 Name 的主机对应的规范主机名。该记录能够向查询的主机提供一个主机名对应的规范主机名，例如 (foo.com, relay1.bai.foo.com, CNAME) 就是一条 CNAME 类型的记录 。&lt;/li&gt;
&lt;li&gt;如果 Type=MX、则 Value 是个别名为 Name 的邮件服务器的规范主机名。举例来说，(foo.com, mail.bar.foo.com, MX) 就是一条 MX 记录。 MX 记录允许邮件服器主机名具有简单的别名。 值得注意的是，通过使用 MX 记录，一个公司的邮件服务器和其他服务器(如它的 Web 服务器)可以使用相同的别名。 为了获得邮件服务器的规范主机名，DNS 客户应当请求一条 MX 记录; 而为了获得其他服务器的规范主机名，DNS 客户应当请求 CNAME 记录 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNS 报文
&lt;ul&gt;
&lt;li&gt;前 12 个字节是首部区域，其中有几个字段。第一个字段(标识符)是一个 16 比 特的数，用于标识该查询。&lt;/li&gt;
&lt;li&gt;问题区域包含着正在进行的查询信息。该区域包括: 名字字段，包含正在被查询的主机名字; 类型字段，指出有关该名字的正被询问的间题类型，例如主机地址是与一个名字相关联(类型 A)还是与某个名字的邮件服务器相关联(类型 MX) 。&lt;/li&gt;
&lt;li&gt;回答区域包含了对最初请求的名字的资源记录。 前面讲过每个资源记录中有 Type (如 A、NS、CNAME 和 MX) 字段、 Value 字段和 TTL 字段。在回答报文的回答区域中可以包含多条 RR, 因此一个主机名能够有多个 IP 地址&lt;/li&gt;
&lt;li&gt;权威区域包含了其他权威服务器的记录&lt;/li&gt;
&lt;li&gt;附加区域包含了其他有帮助的记录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在 DNS 数据库中插人记录
&lt;ul&gt;
&lt;li&gt;当你向某些注册登记机构注册域名 networkutopia.com 时，需要向该机构提供你的基本和辅助权威 DNS 服务器的名字和 IP 地址，假定该名字和 IP 地址 是 dns1.networkutopia.com 和 dns2.nehvorkutopia.com 及 212.212. 212.1 和 212.212.212.2。对这两个权威 DNS 服务器的每一个，该注册登记机构确保将一个类型 NS 和一个类型 A 的记录输入 TLD com 服务器 。特别是对于用于 networkutopia.com 的基本权威服务器，该注册登记机构将下列两条资 源记录插入该 DNS 系统中。&lt;/li&gt;
&lt;li&gt;你还必须确保用于 Web 服务器 &lt;a href=&#34;http://www.networkutopia.com&#34;&gt;www.networkutopia.com&lt;/a&gt; 的类型 A 资源记录和用于邮件服务器 mail.networkutopia.com 的类型 MX 资源记录被输入你的权威 DNS 服务器中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;p2p-文件分发&#34;&gt;P2P 文件分发&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用 P2P 体系结构，对总是打开的基础设施服务器有最小的(或者没有)依赖。成对间歇连接的主机(称为对等方)彼此直接通信。这些对等方并不为服务提供商所拥有，而是受用户控制的桌面计算机和膝上计算机。&lt;/li&gt;
&lt;li&gt;P2P 体系结构的扩展性
&lt;ul&gt;
&lt;li&gt;当一个对等方接收到某些文件数据，它能够使用自己的上载能力重新将数据分发给其他对等方。&lt;/li&gt;
&lt;li&gt;P2P 网络中最小分发时间比上数量总是小于 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BitTorrent
&lt;ul&gt;
&lt;li&gt;BitTorrent 是一种用于文件分发的流行 P2P 协议&lt;/li&gt;
&lt;li&gt;参与一个特定文件分发的所有对等方的集合被称为一个洪流(torrent)。在一个洪流中的对等方彼此下载等长度的文件块 (chunk), 典型的块长度为 256KB。当一个对等方首次加入一个洪流时，它没有块 。随着时间的流逝，它累积了越来越多的块 。当它下载块时，也为其他对等方上载了多个块 。一旦某对等方获得了整个文件，它也许(自私地)离开洪流，或(大公无私地)留在该洪流中并继续向其他对等方上载块 。同时，任何对等方可能在任何时候仅具有块的子集就离开该洪流，并在以后重新加入该洪流中 。&lt;/li&gt;
&lt;li&gt;每个洪流具有一个基础设施节点，称为追踪器 (tracker) 。 当一个对等方加入某洪流时，它向追踪器注册自己，并周期性地通知追踪器它仍在该洪流中。 以这种方式，追踪器跟踪参与在洪流中的对等方。 一个给定的洪流可能在任何时刻具有数以百计或数以千计的对等方 。&lt;/li&gt;
&lt;li&gt;当一个新的对等方 Alice 加入该洪流时， 追踪器随机地从参与对等方的集合中选择对等方的一个子集(为了具体起见，设有 50 个对等方)，并将这 50 个对等方的 IP 地址发送给 Alice。 Alice 持有对等方的这张列表，试图与该列表上的所有对等方创建并行的 TCP 连接。我们称所有这样与 Alice 成功地创建一个 TCP 连接的对等方为&amp;quot;邻近对等方”&lt;/li&gt;
&lt;li&gt;在任何给定的时间，每个对等方将具有来自该文件的块的子集，并且不同的对等方具有不同的子集。 Alice 周期性地(经 TCP 连接)询问每个邻近对等方它们所具有的块列表。如果 Alice 具有 L 个不同的邻居，她将获得 L 个块列表。 有了这个信息， Alice 将对她当前还没有的块发出请求 (仍通过 TCP 连接) 。&lt;/li&gt;
&lt;li&gt;决定请求哪些块的过程中， Alice 使用一种称为最稀缺优先 (raiest first)的技术。 这种技术的思路是，针对她没有的块在她的邻居中决定最稀缺的块(最稀缺的块就是那些在她的邻居中副本数量最少的块)，并首先请求那些最稀缺的块。 这样，最稀缺块得到更为迅速的重新分发，其目标是(大致地)均衡每个块在洪流中的副本数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分布式散列表
&lt;ul&gt;
&lt;li&gt;分布式散列表是一种简单的数据库，其数据库记录分布在一个 P2P 系统的多个对等方上。DHT 得到了广泛实现(如在 BitTorrent 中)，并成为大量研究的主题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;视频流和内容分发网络&#34;&gt;视频流和内容分发网络&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;因特网视频
&lt;ul&gt;
&lt;li&gt;网络上存在大量的视频，用户按需向服务器请求观看视频，根据用户自身的网络状况，可以请求不同版本的视频。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTTP 流和 DASH (Dynamic Adaptive Streaming over HTTP)
&lt;ul&gt;
&lt;li&gt;在 HTTP 流中，视频只是存储在 HTTP 服务器中作为一个普通的文件，每个文件有一个特定的 URL&lt;/li&gt;
&lt;li&gt;在 DASH 中，视频编码为几个不同的版本，其中每个版本具有不同的比特率 ，对应于不同的质量水平。客户动态地请求来自不同版本且长度为几秒的视频段数据块。当可用带宽量较高时，客户自然地选择来自高速率版本的块; 当可用带宽量较低时，客户自然地选择来自低速率版本的块。客户用 HTTP GET 请求报文一次选择一个不同的块&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内容分发网络
&lt;ul&gt;
&lt;li&gt;为了应对向分布于全世界的用户分发巨量视频数据的挑战，几乎所有主要的视频流公司都利用内容分发网 (Content Distribution Network, CDN)。CDN 管理分布在多个地理位置上的服务器，在它的服务器中存储视频(和其他类型的 Web 内容，包括文档、图片和音频)的副本，并且所有试图将每个用户请求定向到一个将提供最好的用户体验的 CDN 位置。CDN 可以是专用 CDN (private CDN),即它由内容提供商自己所拥有; 例如，谷歌的 CDN 分发 YouTube 视频和其他类型的内容。另一种 CDN 可以是第三方 CON (third-party CON), 它代表多个内容提供商分发内容; Akamai、Limelight 和 level-3 都运行第三方 CDN。&lt;/li&gt;
&lt;li&gt;CDN 通常采用两种不同的服务器安置原则
&lt;ul&gt;
&lt;li&gt;深入。第一个原则由 Akamai 首创，该原则是通过在遍及全球的接入 ISP 中部署服务器集群来深入到 ISP 的接入网中。其目标是靠近端用户，通过减少端用户和 CDN 集群之间(内容从这里收到)链路和路由器的数量，从而改善了用户感受的时延和吞吐量。因为这种高度分布式设计，维护和管理集群的任务成为挑战。&lt;/li&gt;
&lt;li&gt;邀请做客。第二个设计原则由 Limelight 和许多其他 CDN 公司所采用，该原则是通过在少量关键位置建造大集群来邀请到 ISP 做客。不是将集群放在接入 ISP 中，这些 CDN 通常将它们的集群放置在因特网交换点 (IXP)。与深入设计原则相比，邀请做客设计通常产生较低的维护和管理开销，可能以对端用户的较高时延和较低吞吐量为代价。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事实上，许多 CDN 没有将视频推入它们的集群，而是使用一种简单的拉策略:如果客户向一个未存储该视频的集群请求某视频，则该集群检索该视频(从某中心仓库或者从另一个集群)，向客户流式传输视频时的同时在本地存储一个副本。类似于因特网缓存，当某集群存储器变满时,它删除不经常请求的视频 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CDN 操作
&lt;ul&gt;
&lt;li&gt;用户访问位于 NetCinema 的 Web 网页。&lt;/li&gt;
&lt;li&gt;当用户点击链接 video.netcinema.com/6Y7B23V 时，该用户主机发送了一个对于 video.netcinema.com 的 DNS 请求。&lt;/li&gt;
&lt;li&gt;用户的本地 DNS 服务器 (LDNS) 将该 DNS 请求中继到一台用于 NetCinema 的权威 DNS 服务器，该服务器观察到主机名 video.netcinema.com 中的字符串 &amp;lsquo;video&amp;rsquo;。 为了将 该 DNS 请求移交给 KingCDN, NetCinema 权威 DNS 服务器并不返回一个 IP 地址，而是向 DNS 返回 一个 KingCDN 域的主机名,如 a1105.kingcdn.com。&lt;/li&gt;
&lt;li&gt;从这时起，DNS 请求进入了 KingCDN 专用 DNS 基础设施。用户的 LDNS 则发送第二个请求，此时是对 a1105.kingcdn. com 的 DNS 请求，KingCDN 的 DNS 系统最终向 LDNS 返回 KingCDN 内容服务器的 IP 地址。所以正是在这里，在 KingCDN 的 DNS 系统中，指定了 CDN 服务器、客户将能够从这台服务器接收到它的内容。&lt;/li&gt;
&lt;li&gt;LONS 向用户主机转发内容服务 CDN 节点的 IP 地址 。&lt;/li&gt;
&lt;li&gt;一旦客户收到 KingCDN 内容服务器的 IP 地址. 它与具有该 IP 地址的服务器创建了一条直接的 TCP 连接，并且发出对该视频的 HTTP GET 请求。如果使用了 DASH, 服务器将首先向客户发送具有 URL 列表的告示文件，每个 URL 对应视频的每个版本，并且客户将动态地选择来自不同版本的块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;集群选择策略
&lt;ul&gt;
&lt;li&gt;地理位置优先&lt;/li&gt;
&lt;li&gt;时延优先&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>计算机网络自顶向下方法::计算机网络和因特网</title>
      <link>/notes/computer_network_a_topdown_approach_01/</link>
      <pubDate>Tue, 15 Jun 2021 20:26:06 +0800</pubDate>
      <guid>/notes/computer_network_a_topdown_approach_01/</guid>
      <description>&lt;h2 id=&#34;计算机网络和因特网&#34;&gt;计算机网络和因特网&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;什么是因特网
&lt;ul&gt;
&lt;li&gt;具体构成描述
&lt;ul&gt;
&lt;li&gt;因特网是一个世界范围的计算机网络，即它是一个互联了遍及全世界数十亿计算设备的网络。&lt;/li&gt;
&lt;li&gt;传统 PC、Linux 工作站、服务器、智能手机、平板电脑、电视机、游戏机、家用电器、手表正在与互联网相连，这些设备称为主机或者端系统。&lt;/li&gt;
&lt;li&gt;端系统通过通信链路 (communication link) 和分组交换机 (packet switch) 连接到一起&lt;/li&gt;
&lt;li&gt;不同的链路能够以不同的速率传输数据，链路的传输速率 (transmission rate) 以比特/秒 (bills, 或 bps) 度量 。&lt;/li&gt;
&lt;li&gt;当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包用计算机网络的术语来说称为分组(packet)。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。&lt;/li&gt;
&lt;li&gt;分组交换器
&lt;ul&gt;
&lt;li&gt;从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组&lt;/li&gt;
&lt;li&gt;在当今的因特网中，两种最著名的类型是路由器(router)和链路层交换机(link-layer switch)&lt;/li&gt;
&lt;li&gt;链路层交换机通常用于接入网中，而路由器通常用于网络核心中。&lt;/li&gt;
&lt;li&gt;从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径(route 或 path)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ISP
&lt;ul&gt;
&lt;li&gt;端系统通过因特网服务提供商 (Internet Service Provider, ISP) 接入因特网&lt;/li&gt;
&lt;li&gt;每个 ISP 自身就是一个由多台分组交换机和多段通信链路组成的网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协议
&lt;ul&gt;
&lt;li&gt;端系统、分组交换机和其他因特网部件都要运行一系列协议 (protocol), 这些协议控制因特网中信息的接收和发送。&lt;/li&gt;
&lt;li&gt;TCP、IP、HTTP、SMTP&lt;/li&gt;
&lt;li&gt;协议标准由因特网工程任务组研发，IETF 的标准文档称为请求评论(Request For Comment, RFC)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务描述
&lt;ul&gt;
&lt;li&gt;为应用程序提供服务的基础设施&lt;/li&gt;
&lt;li&gt;因特网相连的端系统提供了一个套接字接口(socket interface), 该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;什么是协议
&lt;ul&gt;
&lt;li&gt;定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作。&lt;/li&gt;
&lt;li&gt;因特网中协议无处不在快，不同的协议用于完成不同的通信任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络边缘
&lt;ul&gt;
&lt;li&gt;与因特网相连的计算机和其他设备称为端系统，它们位于因特网的边缘，因特网的端系统包括了桌面计算机、服务器和移动计算机和非传统联网设备。&lt;/li&gt;
&lt;li&gt;端系统被称为主机
&lt;ul&gt;
&lt;li&gt;运行应用程序，提供服务&lt;/li&gt;
&lt;li&gt;主机有时又被进一步划分为两类 :客户(client)和服务器(server)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接入网
&lt;ul&gt;
&lt;li&gt;将端系统物理连接到其边缘路由器(edge router)的网络。边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。&lt;/li&gt;
&lt;li&gt;家庭接入: DSL、电缆、 FTTH、拨号和卫星&lt;/li&gt;
&lt;li&gt;企业(和家庭)接人: 以太网和 WiFi&lt;/li&gt;
&lt;li&gt;广域无线接入: 3/4/5G 和 LTE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物理媒介
&lt;ul&gt;
&lt;li&gt;双绞铜线&lt;/li&gt;
&lt;li&gt;同轴电缆&lt;/li&gt;
&lt;li&gt;光线&lt;/li&gt;
&lt;li&gt;陆地无线电信道&lt;/li&gt;
&lt;li&gt;卫星无线电信号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络核心
&lt;ul&gt;
&lt;li&gt;分组交换
&lt;ul&gt;
&lt;li&gt;在各种网络应用中, 端系统彼此交换报文(message), 报文能够包含协议设计者需要的任何东西,报文可以执行一种控制功能，也可以包含数据，&lt;/li&gt;
&lt;li&gt;为了从源端系统向目的端系统发送一个报文, 源将长报文划分为较小的数据块，称之为分组(packet)。&lt;/li&gt;
&lt;li&gt;在源和目的地之间，每个分组都通过通信链路和分组交换机(packet switch)传送。&lt;/li&gt;
&lt;li&gt;如果某源端系统或分组交换机经过一条链路发送一个 L 比特的分组，链路的传输速率为 R 比特/秒，则传输该分组的时间为 L/R 秒 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;存储转发传输
&lt;ul&gt;
&lt;li&gt;存储转发传输是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;排队时延和分组丢失
&lt;ul&gt;
&lt;li&gt;如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。因此，除了存储转发时延以外，分组还要承受输出缓存的排队时延。&lt;/li&gt;
&lt;li&gt;因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存巳被其他等待传输的分组完全充满了。在此情况下，将出现分组丢失(丢包)(packet loss), 到达的分组或已经排队的分组之一将被丢弃 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;转发表和路由选择协议
&lt;ul&gt;
&lt;li&gt;每台路由器具有一个转发表(forwarding table),用于将目的地址(或目的地址的一部分)映射成为输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发现适当的出链路。路由器则将分组导向该出链路 。&lt;/li&gt;
&lt;li&gt;因特网具有一些特殊的路由选择协议，(routing protocol) ,用于自动地设置这些转发表。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;电路交换
&lt;ul&gt;
&lt;li&gt;在电路交换网络中，在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源(缓存，链路传输速率)&lt;/li&gt;
&lt;li&gt;在分组交换网络中.这些资源则不是预留的;会话的报文按需使用这些资源，其后果可能是不得不等待(即排队)接入通信线路 。&lt;/li&gt;
&lt;li&gt;传统的电话网络是电路交换的例子。&lt;/li&gt;
&lt;li&gt;电路交换网络中的复用
&lt;ul&gt;
&lt;li&gt;频分复用，链路的频谱由跨越链路创建的所有连接共享，不够经济。&lt;/li&gt;
&lt;li&gt;时分复用，时间被划分为固定期间的帧，并且每个帧又被划分为固定数量的时隙。当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙，这些时隙专门由该连接单独使用，一个时隙(在每个帧内)可用于传输该连接的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分组交换于电路交换的对比
&lt;ul&gt;
&lt;li&gt;电路交换不考虑需求，而预先分配了传输链路的使用，这使得巳分配而并不需要的链路时间未被利用，另一方面，分组交换按需分配链路使用。链路传输能力将在所有需要在链路上传输分组的用户之间逐分组地被共享。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络的网络
&lt;ul&gt;
&lt;li&gt;今天的因特网是一个网络的网络，其结构复杂，由十多个第一层 ISP 和数十万个较低层 ISP 组成。ISP 覆盖的区域多种多样，有些跨越多个大洲和大洋，有些限于狭窄的地理区域。较低层的 ISP 与较高层的 ISP 相连，较高层 ISP 彼此互联。用户和内容提供商是较低层 ISP 的客户，较低层 ISP 是较高层 ISP 的客户。近年来，主要的内容提供商也已经创建自己的网络，直接在可能的地方与较低层 ISP 互联。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分组交换网中的时延、丢包和吞吐量
&lt;ul&gt;
&lt;li&gt;分组交换网中的时延概述
&lt;ul&gt;
&lt;li&gt;时延的类型
&lt;ul&gt;
&lt;li&gt;处理时延：检查分组首部，决定分组路由，检查比特级别差错，微秒或更低的数量级别。&lt;/li&gt;
&lt;li&gt;排队时延：一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量，实际的排队时延可以是毫秒到微秒量级。&lt;/li&gt;
&lt;li&gt;传输时延：将所有分组的比特推向链路(即传输，或者说发射)所需要的时间。实际的传输时延通常在毫秒到微秒量级。&lt;/li&gt;
&lt;li&gt;传播时延：从该链路的起点到路由器传播所需要的时间是传播时延，在广域网中，传播时延为毫秒级别。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;排队时延和丢包
&lt;ul&gt;
&lt;li&gt;排队时延对不同的分组可能是不同的。&lt;/li&gt;
&lt;li&gt;传输的第一个分组没有排队时延，而传输的最后一个分组将经受相对大的排队时延&lt;/li&gt;
&lt;li&gt;当表征排队时延时，人们通常使用统计量来度量，如平均排队时延排队时延的方差和排队时延超过某些特定值的概率&lt;/li&gt;
&lt;li&gt;如果分组以突发形式到达而不是周期性到达，则可能会有很大的平均排队时延 。&lt;/li&gt;
&lt;li&gt;随着流量强度接近于 1，平均排队时延迅速增加。该强度的少量增加将导致时延大比例增加 。&lt;/li&gt;
&lt;li&gt;当分组到达路由器，路由器没有地方存储这个分组，就会丢弃 (drop) 该分组，即该分组将会丢失 (lost)。丢失的分组可能基于端到端的原则重传，以确保所有的数据最终从源传送到了目的地。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;端到端时延
&lt;ul&gt;
&lt;li&gt;端到端的时延是之间每一跳的时延总和&lt;/li&gt;
&lt;li&gt;Traceout 可用来跟踪中间每一跳的时延&lt;/li&gt;
&lt;li&gt;端系统、应用程序和其他时延：协议有意的时延，VoIP 分组时延。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算机网络中的吞吐量
&lt;ul&gt;
&lt;li&gt;在任何时间瞬间的瞬时吞吐量(instantaneous throughput) 是主机接收到该文件的速率&lt;/li&gt;
&lt;li&gt;如果该文件由 F 比特组成，主机 B 接收到所有 F 比特用去 T 秒，则文件传送的平均吞吐量 (average throughput) 是 F/Tbps&lt;/li&gt;
&lt;li&gt;当没有其他干扰流最时，其吞吐量能够近似为沿着源和目的地之间路径的最小传输速率 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协议层次及其服务模型
&lt;ul&gt;
&lt;li&gt;分层的体系结构
&lt;ul&gt;
&lt;li&gt;一个协议层能够用软件、硬件或两者的结合来实现&lt;/li&gt;
&lt;li&gt;各层的所有协议被称为协议栈。因特网的协议栈由 5 个层次组成:物理层、链路层 、网络层、运输层和应用层。&lt;/li&gt;
&lt;li&gt;应用层：应用层是网络应用程序及它们的应用层协议存留的地方，包括了 HTTP，SMTP 和 FTP。应用层协议分布在多个端系统上，而一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。我们把这种位于应用层的信息分组称为报文 (message)。&lt;/li&gt;
&lt;li&gt;传输层：因特网的运输层在应用程序端点之间传送应用层报文。 在因特网中，有两种运输协议，即 TCP 和 UDP, 利用其中的任一个都能运输应用层报文 。 TCP 向它的应用程序提供了面向连接的服务。这种服务包括了应用层报文向目的地的确保传递和流量控制。 UDP 协议向它的应用程序提供无连接服务。这是一种不提供不必要服务的服务，没有可靠性，没有流量控制，也没有拥塞控制。&lt;/li&gt;
&lt;li&gt;网络层：因特网的网络层负责将称为数据报 (datagram) 的网络层分组从一台主机移动到另一台主机。&lt;/li&gt;
&lt;li&gt;链路层：因特网的网络层通过源和目的地之间的一系列路由器路由数据报。网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。在该下一个节点，链路层将数据报上传给网络层。我们把链路层分组称为帧。&lt;/li&gt;
&lt;li&gt;物理层：物理层的任务是将帧中的一个个比特从一个节点移动到下一个节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OSI 模型
&lt;ul&gt;
&lt;li&gt;应用层、表示层、会话层、运输层、网络层、数据链路层和物理层。&lt;/li&gt;
&lt;li&gt;表示层的作用是使通信的应用程序能够解释交换数据的含义。这些服务包括数据压缩和数据加密(它们是自解释的)以及数据描述(这使得应用程序不必担心在各台计算机中表示/存储的内部格式不同的问题)。&lt;/li&gt;
&lt;li&gt;会话层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;封装
&lt;ul&gt;
&lt;li&gt;在发送主机端，一个应用层报文 (application-layer message) 被传送给运输层。&lt;/li&gt;
&lt;li&gt;运输层收取到报文并附上附加信息(所谓运输层首部信息)该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段(transport­ layer segment)。运输层报文段因此封装了应用层报文。附加的信息也许包括了下列信息:允许接收端运输层向上向适当的应用程序交付报文的信息;差错检测位信息，该信息让接收方能够判断报文中的比特是否在途中已被改变。&lt;/li&gt;
&lt;li&gt;运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息,生成了网络层数据报 (network-layer datagram) 。&lt;/li&gt;
&lt;li&gt;该数据报接下来被传递给链路层，链路层增加它自己的链路层首部信息并生成链路层帧(link-layer frame) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;面对网络攻击
&lt;ul&gt;
&lt;li&gt;恶意软件，僵尸网络，自我复制，病毒，蠕虫&lt;/li&gt;
&lt;li&gt;DoS 攻击
&lt;ul&gt;
&lt;li&gt;弱点攻击。这涉及向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文。&lt;/li&gt;
&lt;li&gt;带宽洪泛。攻击者向目标主机发送大量的分组，分组数量之多使得目标的接入链路变得拥塞，使得合法的分组无法到达服务器 。&lt;/li&gt;
&lt;li&gt;连接洪泛。攻击者在目标主机中创建大量的半开或全开 TCP 连接。该主机因这些伪造的连接而陷入困境，并停止接受合法的连接 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;嗅探分组
&lt;ul&gt;
&lt;li&gt;在无线传输设备的附近放置一台被动的接收机，该接收机就能得到传输的每个分组的副本!这些分组包含了各种敏感信息，包括口令、社会保险号、商业秘密和隐秘的个人信息。记录每个流经的分组副本的被动接收机被称为分组嗅探器。&lt;/li&gt;
&lt;li&gt;嗅探器也能够部署在有线环境中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IP 哄骗
&lt;ul&gt;
&lt;li&gt;将具有虚假源地址的分组注入因特网的。生成具有任意源地址、分组内容和目的地址的分组，然后将这个人工制作的分组传输 到因特网中，因特网将忠实地将该分组转发到目的地。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算机网络和因特网的历史
&lt;ul&gt;
&lt;li&gt;分组交换的发展: 1961 ~ 1972&lt;/li&gt;
&lt;li&gt;专用网络和网络互联: 1972 ~ 1980&lt;/li&gt;
&lt;li&gt;网络的激增: 1980 ~ 1990&lt;/li&gt;
&lt;li&gt;因特网爆炸: 20 世纪 90 年代到现在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>推理::诡计博物馆</title>
      <link>/reading/douban_35016085/</link>
      <pubDate>Tue, 11 May 2021 17:14:37 +0800</pubDate>
      <guid>/reading/douban_35016085/</guid>
      <description></description>
    </item>
    
    <item>
      <title>推理::密室收藏家</title>
      <link>/reading/douban_26348596/</link>
      <pubDate>Wed, 28 Apr 2021 17:14:37 +0800</pubDate>
      <guid>/reading/douban_26348596/</guid>
      <description></description>
    </item>
    
    <item>
      <title>编程::深入理解Java虚拟机</title>
      <link>/reading/understand_the_jvm/</link>
      <pubDate>Sat, 24 Apr 2021 19:12:26 +0800</pubDate>
      <guid>/reading/understand_the_jvm/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_01/&#34;&gt;深入理解 Java 虚拟机::走进 Java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_02/&#34;&gt;深入理解 Java 虚拟机::自动内存管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_03/&#34;&gt;深入理解 Java 虚拟机::垃圾收集器与内存分配策略&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_04/&#34;&gt;深入理解 Java 虚拟机::虚拟机性能监控、故障处理工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_05/&#34;&gt;深入理解 Java 虚拟机::调优案例分析与实战&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_06/&#34;&gt;深入理解 Java 虚拟机::类文件结构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_07/&#34;&gt;深入理解 Java 虚拟机::虚拟机类加载机制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_08/&#34;&gt;深入理解 Java 虚拟机::虚拟机字节码执行引擎&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_09/&#34;&gt;深入理解 Java 虚拟机::类加载及执行子系统的案例与实战&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_10/&#34;&gt;深入理解 Java 虚拟机::前段编译与优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_11/&#34;&gt;深入理解 Java 虚拟机::后端编译与优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_12/&#34;&gt;深入理解 Java 虚拟机::Java 内存模型与线程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_13/&#34;&gt;深入理解 Java 虚拟机::线程安全和锁优化&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>深入理解计算机系统::计算机系统漫游</title>
      <link>/notes/csapp_01/</link>
      <pubDate>Thu, 15 Apr 2021 00:17:05 +0800</pubDate>
      <guid>/notes/csapp_01/</guid>
      <description>&lt;h2 id=&#34;计算机系统漫游&#34;&gt;计算机系统漫游&lt;/h2&gt;
&lt;h3 id=&#34;信息就是位--上下文&#34;&gt;信息就是位 + 上下文&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文件分为文本文件和二进制文件。&lt;/li&gt;
&lt;li&gt;8 个比特被组织成一组，称为字节。&lt;/li&gt;
&lt;li&gt;系统中所有的信息：包括磁盘文件，内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法就是我们读到这些数据对象时的上下文呢。在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;程序被其他程序翻译成不同的格式&#34;&gt;程序被其他程序翻译成不同的格式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;预处理阶段：预处理器根据以字符#开头的命令，修改原始的 C 程序。&lt;/li&gt;
&lt;li&gt;编译阶段：编译器将预处理后的文本文件翻译成包含汇编语言程序的文本文件。&lt;/li&gt;
&lt;li&gt;汇编阶段：汇编器将包含低汇编语言程序的文本文件翻译成机器语言指令，并将结果保存在目标文件中，目标文件是一个二进制文件。&lt;/li&gt;
&lt;li&gt;链接阶段：链接器以某种方式合并程序中调用的函数预编译目标中间，最终得到一个可执行文件，可以被加载到内存中，有系统执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;了解编译系统如何工作是大有益处的&#34;&gt;了解编译系统如何工作是大有益处的&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;优化程序性能&lt;/li&gt;
&lt;li&gt;理解链接时出现的错误&lt;/li&gt;
&lt;li&gt;避免安全漏洞&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;处理器读并解释储存在内存中的指令&#34;&gt;处理器读并解释储存在内存中的指令&lt;/h3&gt;
&lt;h4 id=&#34;系统的硬件组成&#34;&gt;系统的硬件组成&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;总线
&lt;ul&gt;
&lt;li&gt;贯穿整个系统的一组电子管道&lt;/li&gt;
&lt;li&gt;负责携带信息字节并负责在各个部件中传递。&lt;/li&gt;
&lt;li&gt;通常总线被设计成传递定长的字节块，称为字(word)，不同机器上字长不一致，需要具体的上下文判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;I/O 设备
&lt;ul&gt;
&lt;li&gt;I/O 设备是系统与外部世界的联系通道。&lt;/li&gt;
&lt;li&gt;每个 I/O 设备通过一个控制器或适配器与 I/O 总线相连。
&lt;ul&gt;
&lt;li&gt;控制器是 I/O 设备本身或者系统的主印刷电路板上的芯片组。&lt;/li&gt;
&lt;li&gt;适配器是一块插在主板插槽上的卡。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主存
&lt;ul&gt;
&lt;li&gt;主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序所处理的数据。&lt;/li&gt;
&lt;li&gt;从物理角度来说，主存是由一组 DRAM 芯片组成的。&lt;/li&gt;
&lt;li&gt;从逻辑上来说，存储器是一个线性的字节数据，每个字节都有其唯一的地址。&lt;/li&gt;
&lt;li&gt;组成程序的每条机器指令有不同数量的字节构成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理器
&lt;ul&gt;
&lt;li&gt;CPU，解释或者执行存储在内存中指令的引擎。&lt;/li&gt;
&lt;li&gt;程序计数器 PC，在任何时候，PC 都指向主存中的某条机器语言指令。&lt;/li&gt;
&lt;li&gt;寄存器文件，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。&lt;/li&gt;
&lt;li&gt;ALU，算数逻辑单元，负责做算术运算。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;运行程序&#34;&gt;运行程序&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;shell 等待输入。&lt;/li&gt;
&lt;li&gt;输入命令。&lt;/li&gt;
&lt;li&gt;shell 读取命令，并将字符串放到内存中。&lt;/li&gt;
&lt;li&gt;shell 执行一系列指令来加载可执行文件，并将目标文件中的代码和数据从磁盘复制到主存。&lt;/li&gt;
&lt;li&gt;处理器开始执行程序中 main 程序中的机器语言指令。&lt;/li&gt;
&lt;li&gt;程序中的数据从主存加载到寄存器文件中。&lt;/li&gt;
&lt;li&gt;从寄存器文件中复制到显示设备，最终显示到屏幕上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;高速缓存至关重要&#34;&gt;高速缓存至关重要&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;处理器处理数据的速度远远超出从主存读取数据的速度，系统设计者引入了高速缓存存储器作为但是的集结区域，存放处理器近期可能会需要的信息。&lt;/li&gt;
&lt;li&gt;高速缓存的局部性原理，程序具有访问局部区域里的数据和代码的趋势。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;存储设备形成层次结构&#34;&gt;存储设备形成层次结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/LomKAzN.png&#34; alt=&#34;一个存储器层次结构的示例&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;操作系统管理硬件&#34;&gt;操作系统管理硬件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;操作系统的两个基本功能
&lt;ul&gt;
&lt;li&gt;防止硬件被时空的应用程序滥用&lt;/li&gt;
&lt;li&gt;向应用程序提供简单一致的机制来控制复杂而又通常不大相同的低级硬件设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现以上功能。
&lt;ul&gt;
&lt;li&gt;文件是对 I/O 设备的抽象&lt;/li&gt;
&lt;li&gt;虚拟内存是对主存和磁盘 I/O 设备的抽象表示&lt;/li&gt;
&lt;li&gt;进程是对处理器、主存和 I/O 设备的抽象表示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程
&lt;ul&gt;
&lt;li&gt;进程是操作系统对一个正在运行的程序的一种抽象。&lt;/li&gt;
&lt;li&gt;并发，不同的进程的指令是交错执行的。&lt;/li&gt;
&lt;li&gt;多核处理器可以并行执行多个进程。&lt;/li&gt;
&lt;li&gt;任何一个时刻，但处理器都只能执行一个进程的代码。&lt;/li&gt;
&lt;li&gt;不同进程切换交错执行的机制称为上下文切换，上下文是操作系统保持跟踪进程运行所需的所有状态信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程
&lt;ul&gt;
&lt;li&gt;一个进程由多个称为线程的执行单元组成，每个线程运行在进程的上下文中，共享一部分代码和数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟内存
&lt;ul&gt;
&lt;li&gt;提供一种每个进程都独占整片主存的假象。称为虚拟地址空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件
&lt;ul&gt;
&lt;li&gt;文件解释字节序列。&lt;/li&gt;
&lt;li&gt;每个 I/O 设备，包括磁盘、键盘、显示器、甚至网络都可以看成是文件。&lt;/li&gt;
&lt;li&gt;系统的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;系统之间利用网络通信&#34;&gt;系统之间利用网络通信&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;现代系统通过网络和其他系统连接在一起&lt;/li&gt;
&lt;li&gt;网络可视为一个 I/O 设备&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;重要主题&#34;&gt;重要主题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Amdahl 定律：当我们对系统的某个部分加速时，其对系统的影响取决于该部分的重要性和加速程度。&lt;/li&gt;
&lt;li&gt;并发与并行
&lt;ul&gt;
&lt;li&gt;线程级并行
&lt;ul&gt;
&lt;li&gt;多任务快速切换&lt;/li&gt;
&lt;li&gt;多核处理器&lt;/li&gt;
&lt;li&gt;超线程技术&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令级并行
&lt;ul&gt;
&lt;li&gt;现代处理器可以同时执行多条指令&lt;/li&gt;
&lt;li&gt;流水线&lt;/li&gt;
&lt;li&gt;超标量操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单指令、多数据并行 SIMD
&lt;ul&gt;
&lt;li&gt;一条执行产生多个可以并行执行的操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;抽象的重要性
&lt;ul&gt;
&lt;li&gt;虚拟机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>深入理解Java虚拟机::线程安全和锁优化</title>
      <link>/notes/understand_the_jvm_13/</link>
      <pubDate>Mon, 12 Apr 2021 22:10:56 +0800</pubDate>
      <guid>/notes/understand_the_jvm_13/</guid>
      <description>&lt;h2 id=&#34;线程安全和锁优化&#34;&gt;线程安全和锁优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;线程安全
&lt;ul&gt;
&lt;li&gt;当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下 的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。&lt;/li&gt;
&lt;li&gt;代码本身封装了所有必要的正确性保障手段(如互斥同步等)，令调用者无须关心多线程下的调用问题，更无须自己实现任何措施来保证多线程环境下的正确调用&lt;/li&gt;
&lt;li&gt;Java 语言中的线程安全
&lt;ul&gt;
&lt;li&gt;不可变
&lt;ul&gt;
&lt;li&gt;不可变(Immutable)的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。&lt;/li&gt;
&lt;li&gt;最简单的一种就是把对象里面带有状态的变量都声明为 final&lt;/li&gt;
&lt;li&gt;常见不可变类型
&lt;ul&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;枚举类&lt;/li&gt;
&lt;li&gt;java.lang.Number 的部分子类&lt;/li&gt;
&lt;li&gt;Long&lt;/li&gt;
&lt;li&gt;Double&lt;/li&gt;
&lt;li&gt;BigInteger&lt;/li&gt;
&lt;li&gt;BigDecimal&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;绝对线程安全
&lt;ul&gt;
&lt;li&gt;不管运行时环境如何，调用者都不需要任何额外的同步措施&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;相对线程安全
&lt;ul&gt;
&lt;li&gt;需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程兼容
&lt;ul&gt;
&lt;li&gt;线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程对立
&lt;ul&gt;
&lt;li&gt;线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程安全的实现方法
&lt;ul&gt;
&lt;li&gt;互斥同步
&lt;ul&gt;
&lt;li&gt;同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条(或者是一些，当使用信号量的时候)线程使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;互斥是实现同步的一种手段，临界区(Critical Section)、互斥量 (Mutex)和号量(Semaphore)都是常见的互斥实现方式&lt;/li&gt;
&lt;li&gt;synchronized
&lt;ul&gt;
&lt;li&gt;synchronized 关键字经过 Javac 编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令 。&lt;/li&gt;
&lt;li&gt;这两个字节码指令都需要一个 reference 类型的参数来指明要锁定和解锁的对象&lt;/li&gt;
&lt;li&gt;被 synchronized 修饰的同步块对同一条线程来说是可重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。&lt;/li&gt;
&lt;li&gt;被 synchronized 修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁;也无法强制正在等待锁的线程中断等待或超时退出。&lt;/li&gt;
&lt;li&gt;持有锁是一个重量级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ReentrantLock
&lt;ul&gt;
&lt;li&gt;等待可中断:是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。&lt;/li&gt;
&lt;li&gt;公平锁:是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁;而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 中的锁是非公平的，ReentrantLock 在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致 ReentrantLock 的性能急剧下降，会明显影响吞吐量。&lt;/li&gt;
&lt;li&gt;锁绑定多个条件:是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象。在 synchronized 中，锁对象的 wait()跟它的 notify()或者 notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁;而 ReentrantLock 则无须这样做，多次调用 newCondition()方法即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;比较
&lt;ul&gt;
&lt;li&gt;性能接近&lt;/li&gt;
&lt;li&gt;只需要基础的同步功能时，更推荐 synchronized。&lt;/li&gt;
&lt;li&gt;Lock 应该确保在 finally 块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不 会释放持有的锁。这一点必须由程序员自己来保证，而使用 synchronized 的话则可以由 Java 虚拟机来确保即使出现异常，锁也能被自动释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非同步阻塞
&lt;ul&gt;
&lt;li&gt;基于冲突检测的乐观并发策略&lt;/li&gt;
&lt;li&gt;如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为非阻塞同步(Non-Blocking Synchronization)，使用这种措施的代码也常被称为无锁(Lock-Free) 编程。&lt;/li&gt;
&lt;li&gt;硬件指令保证原子性
&lt;ul&gt;
&lt;li&gt;测试并设置(Test-and-Set) ;&lt;/li&gt;
&lt;li&gt;获取并增加(Fetch-and-Increment) ;&lt;/li&gt;
&lt;li&gt;交换(Swap);&lt;/li&gt;
&lt;li&gt;比较并交换(Compare-and-Swap，下文称 CAS);&lt;/li&gt;
&lt;li&gt;加载链接/条件储存(Load-Linked/Store-Conditional，下文称 LL/SC)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无同步方案
&lt;ul&gt;
&lt;li&gt;可重入代码
&lt;ul&gt;
&lt;li&gt;可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。&lt;/li&gt;
&lt;li&gt;不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程本地存储(Thread Local Storage):如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;锁优化
&lt;ul&gt;
&lt;li&gt;自旋锁与自适应自旋
&lt;ul&gt;
&lt;li&gt;自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;锁消除
&lt;ul&gt;
&lt;li&gt;锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;锁粗化
&lt;ul&gt;
&lt;li&gt;如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展(粗化)到整个操作序列的外部&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;轻量级锁
&lt;ul&gt;
&lt;li&gt;在代码即将进入同步块的时候，如果此同步对象没有被锁定(锁标志位为“01”状态)，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的 Mark Word 的拷贝，然后，虚拟机将使用 CAS 操作尝试把对象的 Mark Word 更新为指向 Lock Record 的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象 Mark Word 的锁标志位(Mark Word 的最后两个比特)将转变为“ 00”，表示此对象处于轻量级锁定状态.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;偏向锁
&lt;ul&gt;
&lt;li&gt;它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不去做了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>深入理解Java虚拟机::Java 内存模型与线程</title>
      <link>/notes/understand_the_jvm_12/</link>
      <pubDate>Sun, 11 Apr 2021 22:10:56 +0800</pubDate>
      <guid>/notes/understand_the_jvm_12/</guid>
      <description>&lt;h2 id=&#34;java-内存模型与线程&#34;&gt;Java 内存模型与线程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Amdahl 定律通过系统中并行化与串行化的比重来描述多处理器系统能获得的运算加速能力，摩尔定律则用于描述处理器晶体管数量与运行效率之间的发展关系。这两个定律的更替代表了近年来硬件发展从追求处理器频率到追求多核心并行处理的发展过程。&lt;/li&gt;
&lt;li&gt;硬件的效率与一致性
&lt;ul&gt;
&lt;li&gt;缓存一致性
&lt;ul&gt;
&lt;li&gt;在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存&lt;/li&gt;
&lt;li&gt;当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致&lt;/li&gt;
&lt;li&gt;为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI(Illinois Protocol)、MOSI、 Synapse、Firefly 及 Dragon Protocol 等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存模型
&lt;ul&gt;
&lt;li&gt;在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java 内存模型
&lt;ul&gt;
&lt;li&gt;主内存与工作内存
&lt;ul&gt;
&lt;li&gt;Java 内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。&lt;/li&gt;
&lt;li&gt;变量
&lt;ul&gt;
&lt;li&gt;包括实例字段、静态字段和构成数组对象的元素&lt;/li&gt;
&lt;li&gt;不包括局部变量与方法参数，线程私有的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java 内存模型规定了所有的变量都存储在主内存(Main Memory)中&lt;/li&gt;
&lt;li&gt;每条线程还有自己的工作内存
&lt;ul&gt;
&lt;li&gt;线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存之间的交互操作
&lt;ul&gt;
&lt;li&gt;8 个原子操作
&lt;ul&gt;
&lt;li&gt;lock(锁定):作用于主内存的变量，它把一个变量标识为一条线程独占的状态。&lt;/li&gt;
&lt;li&gt;unlock(解锁):作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。&lt;/li&gt;
&lt;li&gt;read(读取):作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。&lt;/li&gt;
&lt;li&gt;load(载入):作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。&lt;/li&gt;
&lt;li&gt;use(使用):作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。&lt;/li&gt;
&lt;li&gt;assign(赋值):作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。&lt;/li&gt;
&lt;li&gt;store(存储):作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。&lt;/li&gt;
&lt;li&gt;write(写入):作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;需要满足的规则
&lt;ul&gt;
&lt;li&gt;不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。&lt;/li&gt;
&lt;li&gt;不允许一个线程丢弃它最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。&lt;/li&gt;
&lt;li&gt;不允许一个线程无原因地(没有发生过任何 assign 操作)把数据从线程的工作内存同步回主内存中。&lt;/li&gt;
&lt;li&gt;一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化(load 或 assign)的变量，换句话说就是对一个变量实施 use、store 操作之前，必须先执行 assign 和 load 操作 。&lt;/li&gt;
&lt;li&gt;一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。&lt;/li&gt;
&lt;li&gt;如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作以初始化变量的值。&lt;/li&gt;
&lt;li&gt;如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量。&lt;/li&gt;
&lt;li&gt;对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中(执行 store、write 操作)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于 volatile 型变量的特殊规则
&lt;ul&gt;
&lt;li&gt;两项特性
&lt;ul&gt;
&lt;li&gt;第一项是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的
&lt;ul&gt;
&lt;li&gt;保证原子性
&lt;ul&gt;
&lt;li&gt;运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。&lt;/li&gt;
&lt;li&gt;变量不需要与其他的状态变量共同参与不变约束。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;禁止指令重排序优化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;volatile 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。&lt;/li&gt;
&lt;li&gt;volatile 屏蔽指令重排序的语义在 JDK 5 中才被完全修复，此前的 JDK 中即使将变量声明为 volatile 也仍然不能完全避免重排序所导致的问题(主要是 volatile 变量前后的代码仍然存在重排序问题)，这一点也是在 JDK5 之前的 Java 中无法安全地使用 DCL(双锁检测)来实现单例模式的原因。
&lt;ul&gt;
&lt;li&gt;双重锁定检查是一种在许多语言中都广泛流传的单例构造模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;针对 long 和 double 型变量的特殊规则
&lt;ul&gt;
&lt;li&gt;long 和 double 的非原子性协定&lt;/li&gt;
&lt;li&gt;在实际开发中，除非该数据有明确可知的线程竞争，否则我们在编写代码时一般不需要因为这个原因刻意把用到的 long 和 double 变量专门声明为 volatile。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原子性、可见性与有序性
&lt;ul&gt;
&lt;li&gt;原子性(Atomicity)
&lt;ul&gt;
&lt;li&gt;由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write 这六个&lt;/li&gt;
&lt;li&gt;更大范围的原子性保证(经常会遇到)，Java 内存模型提供了 lock 和 unlock&lt;/li&gt;
&lt;li&gt;字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作。这两个字节码指令反映到 Java 代码中就是同步块——synchronized 关键字，因此在 synchronized 块之间的操作也具备原子性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可见性(Visibility)
&lt;ul&gt;
&lt;li&gt;可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改
&lt;ul&gt;
&lt;li&gt;Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是 volatile 变量都是如此。普通变量与 volatile 变量的区别是，volat ile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除了 volatile 之外，Java 还有两个关键字能实现可见性，它们是 synchronized 和 final
&lt;ul&gt;
&lt;li&gt;同步块的可见性是由&amp;quot;对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中&amp;quot;&lt;/li&gt;
&lt;li&gt;而 final 关键字的可见性是指:被 final 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去，那么在其他线程中就能看见 final 字段的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有序性(Ordering)
&lt;ul&gt;
&lt;li&gt;Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 关键字本 身就包含了禁止指令重排序的语义，而 synchronized 则是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;先行发生原则
&lt;ul&gt;
&lt;li&gt;先行发生是 Java 内存模型中定义的两项操作之间的偏序关系，比如说操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。&lt;/li&gt;
&lt;li&gt;程序次序规则(Program Order Rule):在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。&lt;/li&gt;
&lt;li&gt;管程锁定规则(Monitor Lock Rule):一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这 里必须强调的是“同一个锁”，而“后面”是指时间上的先后。&lt;/li&gt;
&lt;li&gt;volatile 变量规则(Volatile Variable Rule):对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。&lt;/li&gt;
&lt;li&gt;线程启动规则(Thread Start Rule):Thread 对象的 start() 方法先行发生于此线程的每一个动作。&lt;/li&gt;
&lt;li&gt;线程终止规则(Thread Termination Rule):线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。&lt;/li&gt;
&lt;li&gt;线程中断规则(Thread Interruption Rule):对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread::interrupted()方法检测到是否有中断发生。&lt;/li&gt;
&lt;li&gt;对象终结规则(Finalizer Rule):一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize()方法的开始。&lt;/li&gt;
&lt;li&gt;传递性(Transitivity):如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java 与线程
&lt;ul&gt;
&lt;li&gt;线程的实现
&lt;ul&gt;
&lt;li&gt;内核线程实现
&lt;ul&gt;
&lt;li&gt;内核线程(Kernel-Level Thread，KLT)就是直接由操作系统内核(Kernel，下称内核)支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器(Scheduler)对线程进行调度，并负责将线程的任务映射到各个处理器上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用户线程实现
&lt;ul&gt;
&lt;li&gt;完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;混合实现
&lt;ul&gt;
&lt;li&gt;这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java 线程的实现
&lt;ul&gt;
&lt;li&gt;Java 线程在 早期的 Classic 虚拟机上(JDK 1.2 以前)，是基于一种被称为“绿色线程”(Green Threads)的用户线程 实现的，但从 JDK 1.3 起，“主流”平台上的“主流”商用 Java 虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现，即采用 1:1 的线程模型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java 线程调度
&lt;ul&gt;
&lt;li&gt;协同式(Cooperative Threads-Scheduling)线程调度
&lt;ul&gt;
&lt;li&gt;线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。&lt;/li&gt;
&lt;li&gt;线程执行时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;抢占式(Preemptive Threads-Scheduling)线程调度。
&lt;ul&gt;
&lt;li&gt;如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;状态转换
&lt;ul&gt;
&lt;li&gt;新建(New):创建后尚未启动的线程处于这种状态。&lt;/li&gt;
&lt;li&gt;运行(Runnable):包括操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。&lt;/li&gt;
&lt;li&gt;无限期等待(Wait ing):处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒&lt;/li&gt;
&lt;li&gt;限期等待(Timed Waiting):处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。&lt;/li&gt;
&lt;li&gt;阻塞(Blocked):线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生;而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。&lt;/li&gt;
&lt;li&gt;结束(Terminat ed):已终止线程的线程状态，线程已经结束执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java 与协程
&lt;ul&gt;
&lt;li&gt;内核线程的局限
&lt;ul&gt;
&lt;li&gt;切换、调度成本高昂，系统能容纳的线程数量也很有限。&lt;/li&gt;
&lt;li&gt;用户线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的浪费&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协程的复苏
&lt;ul&gt;
&lt;li&gt;协程的主要优势是轻量，无论是有栈协程还是无栈协程，都要比传统内核线程要轻量得多&lt;/li&gt;
&lt;li&gt;需要在应用层面实现的内容(调用栈、调度器这些)特别多&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java 的解决方案
&lt;ul&gt;
&lt;li&gt;纤程，一种典型的有栈协程&lt;/li&gt;
&lt;li&gt;重新提供对用户线程的支持&lt;/li&gt;
&lt;li&gt;一段使用纤程并发的代码会被分为两部分——执行过程(Continuation)和调度器(Scheduler)&lt;/li&gt;
&lt;li&gt;执行过程主要用于维护执行现场，保护、恢复上下文状态&lt;/li&gt;
&lt;li&gt;而调度器则负责编排所有要执行的代码的顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>深入理解Java虚拟机::后端编译与优化</title>
      <link>/notes/understand_the_jvm_11/</link>
      <pubDate>Sat, 10 Apr 2021 22:10:56 +0800</pubDate>
      <guid>/notes/understand_the_jvm_11/</guid>
      <description>&lt;h2 id=&#34;后端编译与优化&#34;&gt;后端编译与优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Java 世界里，虽然提前编译(Ahead Of Time，AOT)早已有所应用，但相对而言，即时编译(Just In Time，JIT)才是占绝对主流的编译形式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解释器与编译器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主流的商用 Java 虚拟机，内部都同时包含解释器与编译器&lt;/li&gt;
&lt;li&gt;解释器与编译器两者各有优势
&lt;ul&gt;
&lt;li&gt;当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行&lt;/li&gt;
&lt;li&gt;当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解释器还可以作为编译器激进优化时后备的“逃生门”,当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现“罕见陷阱”(Uncommon Trap)时可以通过逆优化(Deoptimization)退回到解释状态继续执行&lt;/li&gt;
&lt;li&gt;内置即时编译器
&lt;ul&gt;
&lt;li&gt;客户端编译器&lt;/li&gt;
&lt;li&gt;服务端编辑器&lt;/li&gt;
&lt;li&gt;实验性 Graal 编译器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解释器与编译器搭配使用的方式在虚拟机中被称为“混合模式”(Mixed Mode)&lt;/li&gt;
&lt;li&gt;分层编译
&lt;ul&gt;
&lt;li&gt;第 0 层。程序纯解释执行，并且解释器不开启性能监控功能(Profiling)。&lt;/li&gt;
&lt;li&gt;第 1 层。使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能。&lt;/li&gt;
&lt;li&gt;第 2 层。仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。&lt;/li&gt;
&lt;li&gt;第 3 层。仍然使用客户端编译器执行，开启全部性能监控，除了第 2 层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。&lt;/li&gt;
&lt;li&gt;第 4 层。使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;热点代码
&lt;ul&gt;
&lt;li&gt;被多次调用的方法。&lt;/li&gt;
&lt;li&gt;被多次执行的循环体。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;编译器依然必须以整个方法作为编译对象&lt;/li&gt;
&lt;li&gt;热点探测
&lt;ul&gt;
&lt;li&gt;周期性地检查各个线程的调用栈顶，如果发现某个(或某些)方法经常出现在栈顶，那这个方法就是“热点方法”&lt;/li&gt;
&lt;li&gt;基于计数器的热点探测(Counter Based Hot Spot Code Detection)。采用这种方法的虚拟机会为每个方法(甚至是代码块)建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;回边计数器
&lt;ul&gt;
&lt;li&gt;统计一个方法中循环体代码执行的次数&lt;/li&gt;
&lt;li&gt;当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个栈上替换编译请求，并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;编译过程
&lt;ul&gt;
&lt;li&gt;在第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表&lt;/li&gt;
&lt;li&gt;在第二个阶段，一个平台相关的后端从 HIR 中产生低级中间代码表示&lt;/li&gt;
&lt;li&gt;最后的阶段是在平台相关的后端使用线性扫描算法在 LIR 上分配寄存器，并在 LIR 上做窥孔优化，然后产生机器代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;经典优化手段
&lt;ul&gt;
&lt;li&gt;无用代码消除(Dead Code Elimination)&lt;/li&gt;
&lt;li&gt;循环展开 (Loop Unrolling)&lt;/li&gt;
&lt;li&gt;循环表达式外提(Loop Expression Hoisting)&lt;/li&gt;
&lt;li&gt;消除公共子表达式(Common Subexpression Elimination)&lt;/li&gt;
&lt;li&gt;常量传播(Constant Propagation)&lt;/li&gt;
&lt;li&gt;基本块重排序(Basic Block Reordering)&lt;/li&gt;
&lt;li&gt;范围检查消除(Range Check Elimination)&lt;/li&gt;
&lt;li&gt;空值检查消除(Null Check Elimination)&lt;/li&gt;
&lt;li&gt;如守护内联(Guarded Inlining)&lt;/li&gt;
&lt;li&gt;分支频率预测 (Branch Frequency Prediction)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提前编译器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提前编译的优劣得失
&lt;ul&gt;
&lt;li&gt;现在提前编译产品和对其的研究有着两条明显的分支，一条分支是做与传统 C、C++编译器类似的，在程序运行之前把程序代码编译成机器码的静态翻译工作;另外一条分支是把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码(譬如公共库代码在被同一台机器其他 Java 进程使用)时直接把它加载进来使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;天然优势
&lt;ul&gt;
&lt;li&gt;首先，是性能分析制导优化&lt;/li&gt;
&lt;li&gt;其次，是激进预测性优化&lt;/li&gt;
&lt;li&gt;最后，是链接时优化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译器优化技术&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法内联
&lt;ul&gt;
&lt;li&gt;消除方法调用的成本&lt;/li&gt;
&lt;li&gt;为其他优化手段建立良好的基础&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;逃逸分析
&lt;ul&gt;
&lt;li&gt;分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸;甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸;从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。&lt;/li&gt;
&lt;li&gt;栈上分配
&lt;ul&gt;
&lt;li&gt;在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多。栈上分配可以支持方法逃逸，但不能支持线程逃逸。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;标量替换:若一个数据已经无法再分解成更小的数据来表示了，Java 虚拟机中的原始数据类型都不能再进一步分解了，那么这些数据就可以被称为标量 。&lt;/li&gt;
&lt;li&gt;同步消除:线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;公共子表达式消除
&lt;ul&gt;
&lt;li&gt;如果一个表达式 E 之前已经被计算过了，并且从先前的计算到现在 E 中所有变量的值都没有发生变化，那么 E 的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，只需要直接用前面计算过的表达式结果代替 E。如果这种优化仅限于程序基本块内，便可称为局部公共子表达式消除，如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数组边界检查消除
&lt;ul&gt;
&lt;li&gt;每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这必定是一种性能负担。&lt;/li&gt;
&lt;li&gt;数组访问发生在循环之中，并且使用循环变量来进行数组的访问。如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0，foo.length)之内，那么在循环中就可以把整个数组的上下界检查消除掉，这可以节省很多次的条件判断操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>深入理解Java虚拟机::前段编译与优化</title>
      <link>/notes/understand_the_jvm_10/</link>
      <pubDate>Fri, 09 Apr 2021 22:10:56 +0800</pubDate>
      <guid>/notes/understand_the_jvm_10/</guid>
      <description>&lt;h2 id=&#34;前段编译与优化&#34;&gt;前段编译与优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;前端编译器：把 *.java 文件转变成 *.class 文件&lt;/li&gt;
&lt;li&gt;即时编译器：运行期把字节码转变成本地机器码&lt;/li&gt;
&lt;li&gt;静态的提前编译器：直接把程序编译成与目标机器指令集相关的二进制代码&lt;/li&gt;
&lt;li&gt;Javac 编译器
&lt;ul&gt;
&lt;li&gt;Java 语言实现&lt;/li&gt;
&lt;li&gt;编译过程
&lt;ul&gt;
&lt;li&gt;准备过程:初始化插入式注解处理器。
&lt;ul&gt;
&lt;li&gt;提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程&lt;/li&gt;
&lt;li&gt;我们可以把插入式注解处理器看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解析与填充符号表
&lt;ul&gt;
&lt;li&gt;词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树
&lt;ul&gt;
&lt;li&gt;词法分析是将源代码的字符流转变为标记(Token)集合的过程，单个字符是程序编写时的最小元素&lt;/li&gt;
&lt;li&gt;词法分析过程由 com.sun.tools.javac.parser.Scanner 类来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;填充符号表。产生符号地址和符号信息
&lt;ul&gt;
&lt;li&gt;符号表(Symbol Table)是由一组符号地址和符号信息构成的数据结构&lt;/li&gt;
&lt;li&gt;符号表中所登记的信息在编译的不同阶段都要被用到。&lt;/li&gt;
&lt;li&gt;在 Javac 源代码中，填充符号表的过程由 com.sun.tools.javac.comp.Enter 类实现&lt;/li&gt;
&lt;li&gt;该过程的产出物是一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级节点，&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分析与字节码生成过程
&lt;ul&gt;
&lt;li&gt;标注检查。对语法的静态信息进行检查。
&lt;ul&gt;
&lt;li&gt;标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配&lt;/li&gt;
&lt;li&gt;顺便进行一个称为常量折叠的代码优化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据流及控制流分析。对程序动态运行过程进行检查。
&lt;ul&gt;
&lt;li&gt;数据流分析和控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解语法糖。将简化代码编写的语法糖还原为原有的形式。
&lt;ul&gt;
&lt;li&gt;计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响，但是却能更方便程序员使用该语言&lt;/li&gt;
&lt;li&gt;Java 中最常见的语法糖包括了前面提到过的泛型、变长参数、自动装箱拆箱，等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字节码生成。将前面各个步骤所生成的信息转化成字节码。
&lt;ul&gt;
&lt;li&gt;在 Javac 源码里面由 com.sun.tools.javac.jvm.Gen 类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树、符号表)转化成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作。&lt;/li&gt;
&lt;li&gt;完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交到 com.sun.tools.javac.jvm.ClassWriter 类手上，由这个类的 writeClass()方法输出字节码，生成最终的 Class 文件，到此，整个编译过程宣告结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;语法糖
&lt;ul&gt;
&lt;li&gt;泛型
&lt;ul&gt;
&lt;li&gt;泛型的本质是参数化类型(Parameterized Type)或者参数化多态(Parametric Polymorphism)的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口 和方法的创建中，分别构成泛型类、泛型接口和泛型方法。泛型让程序员能够针对泛化的数据类型编写相同的算法，这极大地增强了编程语言的类型系统及抽象能力。&lt;/li&gt;
&lt;li&gt;类型擦除式泛型&lt;/li&gt;
&lt;li&gt;Java 语言中的泛型只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型了，并且在相应的地方插入了强制 转型代码，因此对于运行期的 Java 语言来说，ArrayList&lt;!-- raw HTML omitted --&gt;与 ArrayList&lt;!-- raw HTML omitted --&gt;其实是同一个类型&lt;/li&gt;
&lt;li&gt;擦除式泛型的实现几乎只需要在 Javac 编译器上做出改进即可，不需要改动字节码、不需要改动 Java 虚拟机，也保证了以前没有使用泛型的库可以直接运行在 Java 5.0 之上。&lt;/li&gt;
&lt;li&gt;擦除法实现泛型直接无法支持原生类型的泛型&lt;/li&gt;
&lt;li&gt;运行期无法取到泛型类型信息，会让一些代码变得相当啰嗦，需要传 class 类型才能确定&lt;/li&gt;
&lt;li&gt;类型擦除导致无法重载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动装箱、拆箱与遍历循环
&lt;ul&gt;
&lt;li&gt;自动装箱、拆箱在编译之后被转化成了对应的包装和还原方法&lt;/li&gt;
&lt;li&gt;遍历循环则是把代码还原成了迭代器的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;条件编译
&lt;ul&gt;
&lt;li&gt;我不知道作者怎么理解条件编译的，但是他举的内容是编译优化里面的常见的死码消除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>深入理解Java虚拟机::类加载及执行子系统的案例与实战</title>
      <link>/notes/understand_the_jvm_09/</link>
      <pubDate>Thu, 08 Apr 2021 22:10:56 +0800</pubDate>
      <guid>/notes/understand_the_jvm_09/</guid>
      <description>&lt;h2 id=&#34;类加载及执行子系统的案例与实战&#34;&gt;类加载及执行子系统的案例与实战&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Tomcat:正统的类加载器架构
&lt;ul&gt;
&lt;li&gt;必要的服务器功能
&lt;ul&gt;
&lt;li&gt;部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以实现相互隔离&lt;/li&gt;
&lt;li&gt;部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以互相共享。&lt;/li&gt;
&lt;li&gt;服务器需要尽可能地保证自身的安全不受部署的 Web 应用程序影响&lt;/li&gt;
&lt;li&gt;支持 JSP 应用的 Web 服务器，十有八九都需要支持 HotSwap 功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为了满足上述需求，在部署 Web 应用时，单独的一个 ClassPath 就不能满足需求了，所以各种 Web 服务器都不约而同地提供了好几个有着不同含义的 ClassPath 路径供用户存放第三方类库，这些路径一般 会以“lib”或“classes”命名。被放置到不同路径中的类库，具备不同的访问范围和服务对象，通常每一个目录都会有一个相应的自定义类加载器去加载放置在里面的 Java 类库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OSGi:灵活的类加载器架构
&lt;ul&gt;
&lt;li&gt;OSGi 中的每个模块(称为 Bundle)与普通的 Java 类库区别并不太大，两者一般都以 JAR 格式进行封装，并且内部存储的都是 Java 的 Package 和 Class。但是一个 Bundle 可以声明它所依赖的 Package(通过 Import-Package 描述)，也可以声明它允许导出发布的 Package(通过 Export-Package 描述)。在 OSGi 里面，Bundle 之间的依赖关系从传统的上层模块依赖底层模块转变为平级模块之间的依赖，而且类库的可见性能得到非常精确的控制，一个模块里只有被 Export 过的 Package 才可能被外界访问，其他的 Package 和 Class 将会被隐藏起来。&lt;/li&gt;
&lt;li&gt;加载规则
&lt;ul&gt;
&lt;li&gt;以 java.*开头的类，委派给父类加载器加载。&lt;/li&gt;
&lt;li&gt;否则，委派列表名单内的类，委派给父类加载器加载。&lt;/li&gt;
&lt;li&gt;否则，Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载。&lt;/li&gt;
&lt;li&gt;否则，查找当前 Bundle 的 Classpath，使用自己的类加载器加载。&lt;/li&gt;
&lt;li&gt;否则，查找是否在自己的 Fragment Bundle 中，如果是则委派给 Fragment Bundle 的类加载器加载。&lt;/li&gt;
&lt;li&gt;否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。&lt;/li&gt;
&lt;li&gt;否则，类查找失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字节码生成技术与动态代理的实现
&lt;ul&gt;
&lt;li&gt;省去了编写代理类那一点编码工作量，&lt;/li&gt;
&lt;li&gt;实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Backport 工具:Java 的时光机器
&lt;ul&gt;
&lt;li&gt;ASM 框架直接对字节码进行处理，把高版本的字节码编译到更低版本的字节码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>深入理解Java虚拟机::虚拟机字节码执行引擎</title>
      <link>/notes/understand_the_jvm_08/</link>
      <pubDate>Wed, 07 Apr 2021 22:10:56 +0800</pubDate>
      <guid>/notes/understand_the_jvm_08/</guid>
      <description>&lt;h2 id=&#34;虚拟机字节码执行引擎&#34;&gt;虚拟机字节码执行引擎&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;概述
&lt;ul&gt;
&lt;li&gt;执行引擎是 Java 虚拟机核心的组成部分之一&lt;/li&gt;
&lt;li&gt;虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运行时栈帧结构
&lt;ul&gt;
&lt;li&gt;Java 虚拟机以方法作为最基本的执行单元&lt;/li&gt;
&lt;li&gt;栈帧是用于支持虚拟机进行方法调用和方法执行背后的数据结构&lt;/li&gt;
&lt;li&gt;虚拟机运行时数据区中的虚拟机栈的栈元素&lt;/li&gt;
&lt;li&gt;栈帧
&lt;ul&gt;
&lt;li&gt;局部变量表、操作数栈、动态连接和方法返回地址等信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程&lt;/li&gt;
&lt;li&gt;一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式&lt;/li&gt;
&lt;li&gt;局部变量表
&lt;ul&gt;
&lt;li&gt;局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量&lt;/li&gt;
&lt;li&gt;局部变量表的容量以变量槽为最小单位
&lt;ul&gt;
&lt;li&gt;64 位或者 32 位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个变量槽都应该能存放一个 boolean、 byte、char、short、int、float、reference 或 returnAddress 类型的数据&lt;/li&gt;
&lt;li&gt;局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。&lt;/li&gt;
&lt;li&gt;当一个方法被调用时，Java 虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递, 实例方法, 那局部变量表中第 0 位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从 1 开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。&lt;/li&gt;
&lt;li&gt;变量槽可以复用，但是会影响垃圾回收
&lt;ul&gt;
&lt;li&gt;把占用了大量内存但是已经用不到的变量设为 null 有助于 gc 的回收，因为在局部变量表中不再有引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作数栈
&lt;ul&gt;
&lt;li&gt;后入先出栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态连接
&lt;ul&gt;
&lt;li&gt;支持方法调用过程中的动态连接&lt;/li&gt;
&lt;li&gt;Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数&lt;/li&gt;
&lt;li&gt;这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。&lt;/li&gt;
&lt;li&gt;另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法返回地址
&lt;ul&gt;
&lt;li&gt;当一个方法开始执行后，只有两种方式退出这个方法
&lt;ul&gt;
&lt;li&gt;遇到任意一个方法返回的字节码指令&lt;/li&gt;
&lt;li&gt;代码中使用 athrow 字节码指令产生的异常&lt;/li&gt;
&lt;li&gt;方法退出的过程实际上等同于把当前栈帧出栈
&lt;ul&gt;
&lt;li&gt;恢复上层方法的局部变量表和操作数栈&lt;/li&gt;
&lt;li&gt;把返回值压入调用者栈帧的操作数栈中&lt;/li&gt;
&lt;li&gt;调整 PC 计数器的值以指向方法调用指令后面的一条指令等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法调用
&lt;ul&gt;
&lt;li&gt;方法调用阶段唯一的任务就是确定被调用方法的版本，暂时还未涉及方法内部的具体运行过程&lt;/li&gt;
&lt;li&gt;某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。&lt;/li&gt;
&lt;li&gt;解析
&lt;ul&gt;
&lt;li&gt;方法调用的目标方法在 Class 文件里面都是一个常量池中的符号引用&lt;/li&gt;
&lt;li&gt;方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的&lt;/li&gt;
&lt;li&gt;在 Java 虚拟机支持以下 5 条方法调用字节码指令，分别是:
&lt;ul&gt;
&lt;li&gt;invokestatic。用于调用静态方法。&lt;/li&gt;
&lt;li&gt;invokespecial。用于调用实例构造器&lt;!-- raw HTML omitted --&gt;()方法、私有方法和父类中的方法。&lt;/li&gt;
&lt;li&gt;invokevirtual。用于调用所有的虚方法。&lt;/li&gt;
&lt;li&gt;invokeinterface。用于调用接口方法，会在运行时再确定一个实现该接口的对象。&lt;/li&gt;
&lt;li&gt;invokedynamic。先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面 4 条调用指令，分派逻辑都固化在 Java 虚拟机内部，而 invokedynamic 指令的分派逻辑是由用户设定的引导方法来决定的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;final 方法无法被覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分派
&lt;ul&gt;
&lt;li&gt;静态分派
&lt;ul&gt;
&lt;li&gt;编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的&lt;/li&gt;
&lt;li&gt;静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的，这点也是为何一些资料选择把它归入“解析”而不是“分派”的原因。&lt;/li&gt;
&lt;li&gt;自动转型按照 char &amp;gt; int &amp;gt; long &amp;gt; float &amp;gt; double 的顺序转型进行匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态分配
&lt;ul&gt;
&lt;li&gt;重写&lt;/li&gt;
&lt;li&gt;invokevirtual 指令的运行时解析过程
&lt;ul&gt;
&lt;li&gt;找到操作数栈顶的第一个元素所指向的对象的实际类型，记作 C。&lt;/li&gt;
&lt;li&gt;如果在类型 C 中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束;不通过则返回 java.lang.IllegalAccessError 异常。&lt;/li&gt;
&lt;li&gt;否则，按照继承关系从下往上依次对 C 的各个父类进行第二步的搜索和验证过程。&lt;/li&gt;
&lt;li&gt;如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单分派与多分派
&lt;ul&gt;
&lt;li&gt;如今的 Java 语言是一门静态多分派、动态单分派的语言&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟机动态分派的实现
&lt;ul&gt;
&lt;li&gt;虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态类型语言支持
&lt;ul&gt;
&lt;li&gt;invokedynamic 实现动态类型语言&lt;/li&gt;
&lt;li&gt;动态类型语言
&lt;ul&gt;
&lt;li&gt;动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的&lt;/li&gt;
&lt;li&gt;静态类型语言能够在编译期确定变量类型，最显著的好处是编译器可以提供全面严谨的类型检查，这样与数据类型相关的潜在问题就能在编码时被及时发现，利于稳定性及让项目容易达到更大的规模。&lt;/li&gt;
&lt;li&gt;动态类型语言在运行期才确定类型，这可以为开发人员提供极大的灵活性，某些在静态类型语言中要花大量臃肿代码来实现的功能，由动态类型语言去做可能会很清晰简洁，清晰简洁通常也就意味着开发效率的提升。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java 与动态类型
&lt;ul&gt;
&lt;li&gt;invokedynamic 指令以及 java.lang.invoke 包提供了 JVM 底层对于动态语言的实现的支持&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;java.lang.invoke 包
&lt;ul&gt;
&lt;li&gt;方法句柄&lt;/li&gt;
&lt;li&gt;Java 语言也可以拥有类似于函数指针或者委托的方法别名这样的工具&lt;/li&gt;
&lt;li&gt;Reflection 和 MethodHandle 机制本质上都是在模拟方法调用，但是 Reflection 是在模拟 Java 代码层次的方法调用，而 MethodHandle 是在模拟字节码层次的方法调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;invokedynamic 指令
&lt;ul&gt;
&lt;li&gt;支持动态调用方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于栈的字节码解释执行引擎
&lt;ul&gt;
&lt;li&gt;解释执行
&lt;ul&gt;
&lt;li&gt;在 Java 语言中，Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于栈的指令集与基于寄存器的指令集
&lt;ul&gt;
&lt;li&gt;Javac 编译器输出的字节码指令流&lt;/li&gt;
&lt;li&gt;一种基于栈的指令集架构&lt;/li&gt;
&lt;li&gt;基于栈的指令集主要优点是可移植，因为寄存器由硬件直接提供&lt;/li&gt;
&lt;li&gt;代码相对更加紧凑&lt;/li&gt;
&lt;li&gt;编译器实现更加简单&lt;/li&gt;
&lt;li&gt;栈架构指令集的主要缺点是理论上执行速度相对来说会稍慢一些&lt;/li&gt;
&lt;li&gt;完成相同功能所需的指令数量一般会比寄存器架构来得更多，因为出栈、入栈操作本身就产生了相当大量的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>深入理解Java虚拟机::虚拟机类加载机制</title>
      <link>/notes/understand_the_jvm_07/</link>
      <pubDate>Tue, 06 Apr 2021 22:10:56 +0800</pubDate>
      <guid>/notes/understand_the_jvm_07/</guid>
      <description>&lt;h2 id=&#34;虚拟机类加载机制&#34;&gt;虚拟机类加载机制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;概述
&lt;ul&gt;
&lt;li&gt;Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作虚拟机的类加载机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类加载的时机
&lt;ul&gt;
&lt;li&gt;一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unload ing)七个阶段，其中验证、准备、解析三个部分统称为连接(Linking)&lt;/li&gt;
&lt;li&gt;加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的&lt;/li&gt;
&lt;li&gt;解析在某些情况下可以在初始化阶段之后再开始
&lt;ul&gt;
&lt;li&gt;为了支持 Java 语言的运行时绑定特性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JVM 规范严格规定了有且只有六种情况必须立即对类进行初始化
&lt;ul&gt;
&lt;li&gt;遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段
&lt;ul&gt;
&lt;li&gt;使用 new 关键字实例化对象的时候&lt;/li&gt;
&lt;li&gt;读取或设置一个类型的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)的时候。&lt;/li&gt;
&lt;li&gt;调用一个类型的静态方法的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 java.lang.reflect 包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化&lt;/li&gt;
&lt;li&gt;当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。&lt;/li&gt;
&lt;li&gt;当虚拟机启动时，用户需要指定一个要执行的主类(包含 &lt;code&gt;main()&lt;/code&gt;方法的那个类)，虚拟机会先初始化这个主类。&lt;/li&gt;
&lt;li&gt;当使用 JDK 7 新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。&lt;/li&gt;
&lt;li&gt;当一个接口中定义了 JDK 8 新加入的默认方法(被 default 关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类加载的过程
&lt;ul&gt;
&lt;li&gt;加载
&lt;ul&gt;
&lt;li&gt;在加载阶段，Java 虚拟机需要完成以下三件事情:
&lt;ul&gt;
&lt;li&gt;通过一个类的全限定名来获取定义此类的二进制字节流。
&lt;ul&gt;
&lt;li&gt;从 ZIP 压缩包中读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础&lt;/li&gt;
&lt;li&gt;从网络中获取，这种场景最典型的应用就是 Web Applet。&lt;/li&gt;
&lt;li&gt;运行时计算生成，这种场景使用得最多的就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。&lt;/li&gt;
&lt;li&gt;由其他文件生成，典型场景是 JSP 应用，由 JSP 文件生成对应的 Class 文件。&lt;/li&gt;
&lt;li&gt;从数据库中读取，这种场景相对少见些，例如有些中间件服务器(如 SAP Netweaver)可以选择把程序安装到数据库中来完成程序代码在集群间的分发。&lt;/li&gt;
&lt;li&gt;可以从加密文件中获取，这是典型的防 Class 文件被反编译的保护措施，通过加载时解密 Class 文件来保障程序运行逻辑不被窥探。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。&lt;/li&gt;
&lt;li&gt;在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非数组类型的加载既可以使用 Java 虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成&lt;/li&gt;
&lt;li&gt;数组类本身不通过类加载器创建，它是由 Java 虚拟机直接在内存中动态构造出来的
&lt;ul&gt;
&lt;li&gt;如果数组的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将被标识在加载该组件类型的类加载器的类名称空间上&lt;/li&gt;
&lt;li&gt;如果数组的组件类型不是引用类型, Java 虚拟机将会把数组 C 标记为与引导类加载器关联。&lt;/li&gt;
&lt;li&gt;数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为 public，可被所有的类和接口访问到。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;加载阶段结束后，Java 虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了&lt;/li&gt;
&lt;li&gt;类型数据妥善安置在方法区之后，会在 Java 堆内存中实例化一个 java.lang.Class 类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;验证
&lt;ul&gt;
&lt;li&gt;验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。&lt;/li&gt;
&lt;li&gt;文件格式验证
&lt;ul&gt;
&lt;li&gt;验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;元数据验证
&lt;ul&gt;
&lt;li&gt;对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java 语言规范》的要求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字节码验证
&lt;ul&gt;
&lt;li&gt;通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;符号引用验证
&lt;ul&gt;
&lt;li&gt;对类自身以外的各类信息进行匹配性校验&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;-Xverify:none 参数用来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;准备
&lt;ul&gt;
&lt;li&gt;准备阶段是正式为类中定义的变量分配内存并设置类变量初始值的阶段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解析
&lt;ul&gt;
&lt;li&gt;解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程
&lt;ul&gt;
&lt;li&gt;符号引用
&lt;ul&gt;
&lt;li&gt;符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可&lt;/li&gt;
&lt;li&gt;内存布局无关&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;直接引用
&lt;ul&gt;
&lt;li&gt;直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄&lt;/li&gt;
&lt;li&gt;内存布局直接相关&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟机实现可以对第一次解析的结果进行缓存, invokedynamic 除外，针对动态语言支持&lt;/li&gt;
&lt;li&gt;解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这 7 类符号引用进行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;初始化
&lt;ul&gt;
&lt;li&gt;类的初始化阶段是类加载过程的最后一个步骤&lt;/li&gt;
&lt;li&gt;根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源&lt;/li&gt;
&lt;li&gt;与构造函数不同，编译期生成的私有方法&lt;/li&gt;
&lt;li&gt;父类构造器优先子类构造器，父类静态块优先子类静态块&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类加载器
&lt;ul&gt;
&lt;li&gt;类与类加载器
&lt;ul&gt;
&lt;li&gt;类加载器虽然只用于实现类的加载动作，但它在 Java 程序中起到的作用却远超类加载阶段&lt;/li&gt;
&lt;li&gt;每一个类加载器，都拥有一个独立的类名称空间&lt;/li&gt;
&lt;li&gt;比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;双亲委派模式
&lt;ul&gt;
&lt;li&gt;启动类加载器，C++语言实现，是虚拟机自身的一部分&lt;/li&gt;
&lt;li&gt;其他所有的类加载器，这些类加载器都由 Java 语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。&lt;/li&gt;
&lt;li&gt;启动类加载器
&lt;ul&gt;
&lt;li&gt;负责加载存放在 &amp;lt;JAVA_HOME&amp;gt;\lib 目录，或者被 -Xbootclasspath 参数所指定的路径中存放的，而且是 Java 虚拟机能够识别的类库加载到虚拟机的内存中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;扩展类加载器
&lt;ul&gt;
&lt;li&gt;这个类加载器是在类 sun.misc.Launcher$ExtClassLoader 中以 Java 代码的形式实现的。它负责加载&amp;lt;JAVA_HOME&amp;gt;\lib\ext 目录中，或者被 java.ext.dirs 系统变量所指定的路径中所有的类库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用程序类加载器
&lt;ul&gt;
&lt;li&gt;由 sun.misc.Launcher$AppClassLoader 来实现。由于应用程序类加载器是 ClassLoader 类中的 getSystem ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径(ClassPath)上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。&lt;/li&gt;
&lt;li&gt;如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。&lt;/li&gt;
&lt;li&gt;java.lang 开头的包因为安全原因无法被加载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;破坏双亲委派模式
&lt;ul&gt;
&lt;li&gt;loadClass()加载类, 历史遗留问题&lt;/li&gt;
&lt;li&gt;JNDI 服务, 线程上下文类加载器 (Thread Context ClassLoader)。这个类加载器可以通过 java.lang.Thread 类的 setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。&lt;/li&gt;
&lt;li&gt;追求动态性，热部署，热加载
&lt;ul&gt;
&lt;li&gt;在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索:&lt;/li&gt;
&lt;li&gt;将以 java.*开头的类，委派给父类加载器加载。&lt;/li&gt;
&lt;li&gt;否则，将委派列表名单内的类，委派给父类加载器加载。&lt;/li&gt;
&lt;li&gt;否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载。&lt;/li&gt;
&lt;li&gt;否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载。&lt;/li&gt;
&lt;li&gt;否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载。&lt;/li&gt;
&lt;li&gt;否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。&lt;/li&gt;
&lt;li&gt;否则，类查找失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java 模块化系统
&lt;ul&gt;
&lt;li&gt;实现模块化的关键目标可配置的封装隔离机制&lt;/li&gt;
&lt;li&gt;模块就可以声明对其他模块的显式依赖，这样 Java 虚拟机就能够在启动时验证应用程序开发阶段设定好的依赖关系在运行期是否完备，如有缺失那就直接启动失败，从而避免了很大一部分由于类型依赖而引发的运行时异常。&lt;/li&gt;
&lt;li&gt;可配置的封装隔离机制还解决了原来类路径上跨 JAR 文件的 public 类型的可访问性问题。JDK 9 中的 public 类型不再意味着程序的所有地方的代码都可以随意访问到它们，模块提供了更精细的可访问性控制，必须明确声明其中哪一些 public 的类型可以被其他哪一些模块访问&lt;/li&gt;
&lt;li&gt;兼容性
&lt;ul&gt;
&lt;li&gt;保持向后兼容&lt;/li&gt;
&lt;li&gt;模块带有版本号，需要手动选择版本号打包&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类加载器
&lt;ul&gt;
&lt;li&gt;扩展类加载器(Extension Class Loader)被平台类加载器(Platform Class Loader)取代
&lt;ul&gt;
&lt;li&gt;&amp;lt;JAVA_HOME&amp;gt;\lib\ext 目录被舍弃&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;平台类加载器和应用程序类加载器都不再派生自 java.net.URLClassLoader&lt;/li&gt;
&lt;li&gt;当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载，&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>深入理解Java虚拟机::类文件结构</title>
      <link>/notes/understand_the_jvm_06/</link>
      <pubDate>Mon, 05 Apr 2021 22:10:56 +0800</pubDate>
      <guid>/notes/understand_the_jvm_06/</guid>
      <description>&lt;h2 id=&#34;类文件结构&#34;&gt;类文件结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;实现语言无关性的基础是虚拟机和字节码存储格式&lt;/li&gt;
&lt;li&gt;Class 类文件的结构
&lt;ul&gt;
&lt;li&gt;Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型无符号数和表
&lt;ul&gt;
&lt;li&gt;无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值&lt;/li&gt;
&lt;li&gt;表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上也可以视作是一张表，&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#111&#34;&gt;ClassFile&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;u4&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;magic&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//0xCAFEBABE
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;u2&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;minor_version&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//class file minor version
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;u2&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;major_version&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//class file major version
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;u2&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;constant_pool_count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//count of entries in next item
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;cp_info&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;constant_pool&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;constant_pool_count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;];&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//constants
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;u2&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;access_flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//class assess flags
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;u2&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;this_class&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//index of this class to const pool
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;u2&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;super_class&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//index of super class to const pool
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;u2&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;interfaces_count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//number of interfaces implemented
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;u2&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;interfaces&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;interfaces_count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;];&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//indices of interfaces
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;u2&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;fields_count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//number of fields in the class
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;field_info&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;fields&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;fields_count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;];&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//fields descriptions
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;u2&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;methods_count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//number of methods in the class
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;method_info&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;methods&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;methods_count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;];&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//methods descriptions
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;u2&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;attributes_count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//number of attributes of the class attribute_info
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;attributes&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;attributes_count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;];&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//attributes
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;魔数与 Class 文件的版本
&lt;ul&gt;
&lt;li&gt;魔数
&lt;ul&gt;
&lt;li&gt;每个 Class 文件的头 4 个字节被称为魔数(Magic Number)，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Class 文件的版本号
&lt;ul&gt;
&lt;li&gt;第 5 和第 6 个字节是次版本号(Minor Version)，第 7 和第 8 个字节是主版本号(Major Version)。&lt;/li&gt;
&lt;li&gt;高版本需要向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常量池
&lt;ul&gt;
&lt;li&gt;常量池的入口放置一项 u2 类型的数据，代表常量池容量计数值(constant_pool_count)&lt;/li&gt;
&lt;li&gt;Class 文件结构中只有常量池的容量计数是从 1 开始, 0 用于表示无常量池引用&lt;/li&gt;
&lt;li&gt;常量池中主要存放两大类常量: 字面量(Literal)和符号引用(Symbolic References)
&lt;ul&gt;
&lt;li&gt;字面量
&lt;ul&gt;
&lt;li&gt;文本字符串&lt;/li&gt;
&lt;li&gt;声明为 final 的常量值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;符号引用
&lt;ul&gt;
&lt;li&gt;被模块导出或者开放的包&lt;/li&gt;
&lt;li&gt;类和接口的全限定名&lt;/li&gt;
&lt;li&gt;字段的名称和描述符&lt;/li&gt;
&lt;li&gt;方法的名称和描述符&lt;/li&gt;
&lt;li&gt;方法句柄和方法类型&lt;/li&gt;
&lt;li&gt;动态调用点和动态常量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常量池中的每一项常量都是一个表，互相之间的结构都不相同
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html&#34;&gt;JVM 规范中关于 Class 文件格式的章节&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;访问标志
&lt;ul&gt;
&lt;li&gt;识别一些类或者接口层次的访问信息&lt;/li&gt;
&lt;li&gt;有 16 个标志位可以使用，当前只定义了其中 9 个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类索引、父类索引与接口索引集合
&lt;ul&gt;
&lt;li&gt;类索引用于确定这个类的全限定名&lt;/li&gt;
&lt;li&gt;父类索引用于确定这个类的父类的全限定名&lt;/li&gt;
&lt;li&gt;接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 关键字后的接口顺序从左到右排列在接口索引集合中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字段表集合
&lt;ul&gt;
&lt;li&gt;字段表用于描述接口或者类中声明的变量
&lt;ul&gt;
&lt;li&gt;类级变量以及实例级变量，但不包括在方法内部声明的局部变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字段表集合中不会列出从父类或者父接口中继承而来的字段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法表集合
&lt;ul&gt;
&lt;li&gt;volatile 关键字和 transient 关键字不能修饰方法&lt;/li&gt;
&lt;li&gt;Java 语言中，重载方法需要签名不同&lt;/li&gt;
&lt;li&gt;Class 文件格式中，允许方法签名相同，返回值不同的方法存在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;属性表集合
&lt;ul&gt;
&lt;li&gt;Code 属性
&lt;ul&gt;
&lt;li&gt;Java 程序方法体里面的代码经过 Javac 编译器处理之后，最终变为字节码指令存储在 Code 属性内。&lt;/li&gt;
&lt;li&gt;接口和抽象方法没有 Code 属性&lt;/li&gt;
&lt;li&gt;《Java 虚拟机规范》中明确限制了一个方法不允许超过 65535 条字节码指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Exceptions 属性
&lt;ul&gt;
&lt;li&gt;Exceptions 属性的作用是列举出方法中可能抛出的受查异常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LineNumberTable 属性
&lt;ul&gt;
&lt;li&gt;LineNumberTable 属性用于描述 Java 源码行号与字节码行号(字节码的偏移量)之间的对应关系&lt;/li&gt;
&lt;li&gt;非必需，对程序运行产生的最主要影响就是当抛出异常时，堆栈中将不会显示出错的行号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LocalVariableTable 及 LocalVariableTypeTable 属性
&lt;ul&gt;
&lt;li&gt;LocalVariableTable 属性用于描述栈帧中局部变量表的变量与 Java 源码中定义的变量之间的关系&lt;/li&gt;
&lt;li&gt;非必需，影响是当其他人引用这个方法时，所有的参数名称都将会丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SourceFile 及 SourceDebugExtension 属性
&lt;ul&gt;
&lt;li&gt;SourceFile 属性用于记录生成这个 Class 文件的源码文件名称&lt;/li&gt;
&lt;li&gt;非必需，当抛出异常时，堆栈中将不会显示出错代码所属的文件名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ConstantValue 属性
&lt;ul&gt;
&lt;li&gt;ConstantValue 属性的作用是通知虚拟机自动为静态变量赋值。只有被 static 关键字修饰的变量(类变量)才可以使用这项属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;InnerClasses 属性
&lt;ul&gt;
&lt;li&gt;InnerClasses 属性用于记录内部类与宿主类之间的关联。&lt;/li&gt;
&lt;li&gt;如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成 InnerClasses 属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Deprecated 及 Synthetic 属性
&lt;ul&gt;
&lt;li&gt;Deprecated 和 Synthetic 两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。&lt;/li&gt;
&lt;li&gt;Deprecated 属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用&lt;code&gt;@deprecated&lt;/code&gt;注解进行设置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;StackMapTable 属性
&lt;ul&gt;
&lt;li&gt;目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Signature 属性
&lt;ul&gt;
&lt;li&gt;它是一个可选的定长属性，可以出现于类、字段表和方法表结构的属性表中&lt;/li&gt;
&lt;li&gt;Signature 属性会为记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类型，是因为 Java 语言的泛型采用的是擦除法实现的伪泛型，字节码(Code 属性)中所有的泛型信息编译(类型变量、参数化类型)在编译之后都通通被擦除掉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BootstrapMethods 属性
&lt;ul&gt;
&lt;li&gt;用于保存 invokedynamic 指令引用的引导方法限定符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MethodParameters 属性
&lt;ul&gt;
&lt;li&gt;MethodParameters 的作用是记录方法的各个形参名称和信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;模块化相关属性
&lt;ul&gt;
&lt;li&gt;Module 属性是一个非常复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储了这个模块 requires、exports、opens、uses 和 provides 定义的全部内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运行时注解相关属性
&lt;ul&gt;
&lt;li&gt;RuntimeVisibleAnnotations 是一个变长属性，它记录了类、字段或方法的声明上记录运行时可见注解，当我们使用反射 API 来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字节码指令简介
&lt;ul&gt;
&lt;li&gt;Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字以及跟随其后的零至多个代表此操作所需的参数构成&lt;/li&gt;
&lt;li&gt;加载和存储指令
&lt;ul&gt;
&lt;li&gt;加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运算指令
&lt;ul&gt;
&lt;li&gt;算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶&lt;/li&gt;
&lt;li&gt;大体上运算指令可以分为两种: 对整型数据进行运算的指令与对浮点型数据进行运算的指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类型转换指令
&lt;ul&gt;
&lt;li&gt;类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对象创建与访问指令
&lt;ul&gt;
&lt;li&gt;虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令(在下一章会讲到数组和普通类的类型创建过程是不同的)。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作数栈管理指令
&lt;ul&gt;
&lt;li&gt;用于直接操作操作数栈的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控制转移指令
&lt;ul&gt;
&lt;li&gt;控制转移指令可以让 Java 虚拟机有条件或无条件地从指定位置指令的下 一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改 PC 寄存器的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法调用和返回指令
&lt;ul&gt;
&lt;li&gt;用于方法调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异常处理指令
&lt;ul&gt;
&lt;li&gt;显式抛出异常的操作都由 athrow 指令来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步指令
&lt;ul&gt;
&lt;li&gt;Java 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;公有设计，私有实现
&lt;ul&gt;
&lt;li&gt;《Java 虚拟机规范》描绘了 Java 虚拟机应有的共同程序存储格式:Class 文件格式以及字节码指令集。这些内容与硬件、操作系统和具体的 Java 虚拟机实现之间是完全独立的，虚拟机实现者可能更愿意把它们看作程序在各种 Java 平台实现之间互相安全地交互的手段。&lt;/li&gt;
&lt;li&gt;一个优秀的虚拟机实现，在满足《Java 虚拟机规范》的约束下对具体实现做出修改和优化也是完全可行的，并且《Java 虚拟机规范》中明确鼓励实现者这样去做。只要优化以后 Class 文件依然可以被正确读取，并且包含在其中的语义能得到完整保持，那实现者就可以选择以任何方式去实现这些语义，虚拟机在后台如何处理 Class 文件完全是实现者自己的事情，只要它在外部接口上看起来与规范描述的一致即可&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Class 文件结构的发展
&lt;ul&gt;
&lt;li&gt;Class 文件结构一直处于一个相对比较稳定的状态，Class 文件的主体结构、字节码指令的语义和数量几乎没有出现过变动，所有对 Class 文件格式的改进，都集中在访问标志、属性表这些设计上原本就是可扩展的数据结构中添加新内容。&lt;/li&gt;
&lt;li&gt;二十余年间，字节码的数量和语义只发生过屈指可数的几次变动，例如 JDK 1.0.2 时改动过 invokespecial 指令的语义，JDK 7 增加了 invokedynamic 指令，禁止了 ret 和 jsr 指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>深入理解Java虚拟机::调优案例分析与实战</title>
      <link>/notes/understand_the_jvm_05/</link>
      <pubDate>Sun, 04 Apr 2021 22:10:56 +0800</pubDate>
      <guid>/notes/understand_the_jvm_05/</guid>
      <description>&lt;h2 id=&#34;调优案例分析与实战&#34;&gt;调优案例分析与实战&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大内存硬件上的程序部署策略
&lt;ul&gt;
&lt;li&gt;目前单体应用在较大内存的硬件上主要的部署方式有两种:
&lt;ul&gt;
&lt;li&gt;通过一个单独的 Java 虚拟机实例来管理大量的 Java 堆内存。&lt;/li&gt;
&lt;li&gt;同时使用若干个 Java 虚拟机，建立逻辑集群来利用硬件资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;面临的问题
&lt;ul&gt;
&lt;li&gt;回收大块堆内存而导致的长时间停顿，自从 G1 收集器的出现，增量回收得到比较好的应用&lt;/li&gt;
&lt;li&gt;大内存必须有 64 位 Java 虚拟机的支持，但由于压缩指针、处理器缓存行容量(Cache Line)等因素，64 位虚拟机的性能测试结果普遍略低于相同版本的 32 位虚拟机。&lt;/li&gt;
&lt;li&gt;必须保证应用程序足够稳定，因为这种大型单体应用要是发生了堆内存溢出，几乎无法产生堆转 储快照，哪怕成功生成了快照也难以进行分析;如果确实出了问题要进行诊断，可能就必须应用 JM C 这种能够在生产环境中进行的运维工具。&lt;/li&gt;
&lt;li&gt;相同的程序在 64 位虚拟机中消耗的内存一般比 32 位虚拟机要大，这是由于指针膨胀，以及数据类 型对齐补白等因素导致的，可以开启压缩指针功能来缓解。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;集群间同步导致的内存溢出
&lt;ul&gt;
&lt;li&gt;集群同步软件的问题导致了内存泄漏&lt;/li&gt;
&lt;li&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;堆外内存导致的溢出错误
&lt;ul&gt;
&lt;li&gt;直接内存:可通过-XX:MaxDirectMemorySize 调整大小，内存不足时抛出 OutOfMemoryError 或者 OutOfMemoryError:Direct buffer memory。&lt;/li&gt;
&lt;li&gt;线程堆栈:可通过-Xss 调整大小，内存不足时抛出 StackOverflowError(如果线程请求的栈深度大 于虚拟机所允许的深度)或者 OutOfMemoryError(如果 Java 虚拟机栈容量可以动态扩展，当栈扩展时 无法申请到足够的内存)。&lt;/li&gt;
&lt;li&gt;Socket 缓存区:每个 Socket 连接都 Receive 和 Send 两个缓存区，分别占大约 37KB 和 25KB 内存，连接 多的话这块内存占用也比较可观。如果无法分配，可能会抛出 IOException:Too many open files 异常。&lt;/li&gt;
&lt;li&gt;JNI 代码:如果代码中使用了 JNI 调用本地库，那本地库使用的内存也不在堆中，而是占用 Java 虚 拟机的本地方法栈和本地内存的。&lt;/li&gt;
&lt;li&gt;虚拟机和垃圾收集器:虚拟机、垃圾收集器的工作也是要消耗一定数量的内存的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;外部命令导致系统缓慢
&lt;ul&gt;
&lt;li&gt;执行这个 Shell 脚本是通过 Java 的 Runtime.getRuntime().exc()方法来调用的。这种调用方式可以达到执行 Shell 脚本的目的，但是它在 Java 虚拟机中是非常消耗资源的操作，即使外 部命令本身能很快执行完毕，频繁调用时创建进程的开销也会非常可观。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务器虚拟机进程崩溃
&lt;ul&gt;
&lt;li&gt;由于 MIS 系统的用户多，待办事项变化很快，为了不被 OA 系统速度拖累，使用了异步的方式调用 Web 服务，但由于两边服务速度的完全不对等，时间越长就累积了越多 Web 服务没有调用完成，导致在等待的线程和 Socket 连接越来越多，最终超过虚拟机的承受能力后导致虚拟机进程崩溃。通知 OA 门户方修复无法使用的集成接口，并将异步调用改为生产者/消费者模式的消息队列实现后，系统恢复正常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不恰当数据结构导致内存占用过大
&lt;ul&gt;
&lt;li&gt;业务上需要每 10 分钟加载一个约 80M B 的数据文件到内存进行数据分析，这些数据会在内存中形成超过 100 万个 &lt;code&gt;HashMap&amp;lt;Long，Long&amp;gt;Entry&lt;/code&gt;，在这段时间里面 Minor GC 就会造成超过 500 毫秒的停顿，对于这种长度的停顿时间就接受不了了&lt;/li&gt;
&lt;li&gt;如果不修改程序，仅从 GC 调优的角度去解决这个问题，可以考虑直接将 Survivor 空间去掉(加入参数-XX:SurvivorRatio=65536、-XX:MaxTenuringThreshold=0 或者-XX:+Always-Tenure)，让新生代中存活的对象在第一次 Minor GC 后立即进入老年代，等到 Major GC 的时候再去清理它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;由 Windows 虚拟内存导致的长时间停顿
&lt;ul&gt;
&lt;li&gt;程序在最小化时它的工作内存被自动交换到磁盘的页面文件之中了，这样发生垃圾收集时就有可能因为恢复页面文件的操作导致不正常的垃圾收集停顿。&lt;/li&gt;
&lt;li&gt;在 Java 的 GUI 程序中要避免这种现象，可以加入参数“- Dsun.awt.keepWorkingSetOnMinimize=true”来解决&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;由安全点导致长时间停顿
&lt;ul&gt;
&lt;li&gt;解决问题的第一步是把这两个特别慢的线程给找出来，这个倒不困难，添加-XX: +SafepointTimeout 和-XX:SafepointTimeoutDelay=2000 两个参数，让虚拟机在等到线程进入安全点的时间超过 2000 毫秒时就认定为超时，这样就会输出导致问题的线程名称&lt;/li&gt;
&lt;li&gt;方法调用、循环跳转、异常跳转这些位置都可能会设置有安全点，但是 HotSpot 虚拟机为了避免安全点过多带来过重的负担，对循环还有一项优化措施，认为循环次数较少的话，执行时间应该也不会太长，所以使用 int 类型或范围更小的数据类型作为索引值的循环默认是不会被放置安全点的。这种循环被称为可数循环(Counted Loop )，相对应地，使用 long 或者范围更大的数据类型作为索引值的循环就被称为不可数循环 (Uncounted Loop)，将会被放置安全点。通常情况下这个优化措施是可行的，但循环执行的时间不单单是由其次数决定，如果循环体单次执行就特别慢，那即使是可数循环也可能会耗费很多的时间。&lt;/li&gt;
&lt;li&gt;清理连接的索引值就是 int 类型，所以这是一个可数循环，HotSpot 不会在循环中插入安全点。当垃圾收集发生时，如果线程刚好执行到该函数里的可数循环时，则必须等待循环全部跑完才能进入安全点，此时其他线程也必须一起等着，所以从现象上看就是长时间的停顿。找到了问题，解决起来就非常简单了，把循环索引的数据类型从 int 改为 long 即可，但如果不具备安全点和垃圾收集的知识，这 种问题是很难处理的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>深入理解Java虚拟机::虚拟机性能监控、故障处理工具</title>
      <link>/notes/understand_the_jvm_04/</link>
      <pubDate>Sat, 03 Apr 2021 22:10:56 +0800</pubDate>
      <guid>/notes/understand_the_jvm_04/</guid>
      <description>&lt;h2 id=&#34;虚拟机性能监控故障处理工具&#34;&gt;虚拟机性能监控、故障处理工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;jps
&lt;ul&gt;
&lt;li&gt;虚拟机进程状况工具&lt;/li&gt;
&lt;li&gt;可以列出正在运行的虚拟机进程，并显示虚拟机执行主类(Main Class，main()函数所在的类)名称以及这些进程的本地虚拟机唯一 ID(LVMID，Local Virtual Machine Identifier)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;jstat
&lt;ul&gt;
&lt;li&gt;虚拟机统计信息监视工具&lt;/li&gt;
&lt;li&gt;显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;jinfo
&lt;ul&gt;
&lt;li&gt;是实时查看和调整虚拟机各项参数&lt;/li&gt;
&lt;li&gt;System.getProperties()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;jmap
&lt;ul&gt;
&lt;li&gt;生成堆转储快照&lt;/li&gt;
&lt;li&gt;查询 finalize 执行队列&lt;/li&gt;
&lt;li&gt;Java 堆和方法区的详细信息&lt;/li&gt;
&lt;li&gt;如空间使用率&lt;/li&gt;
&lt;li&gt;当前用的是哪种收集器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;jhat
&lt;ul&gt;
&lt;li&gt;与 jmap 搭配使用，来分析 jmap 生成的堆转储快照&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;jstack
&lt;ul&gt;
&lt;li&gt;用于生成虚拟机当前时刻的线程快照&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>推理::绝对不在场证明</title>
      <link>/reading/douban_34998167/</link>
      <pubDate>Sat, 03 Apr 2021 17:14:37 +0800</pubDate>
      <guid>/reading/douban_34998167/</guid>
      <description></description>
    </item>
    
    <item>
      <title>深入理解Java虚拟机::垃圾收集器与内存分配策略</title>
      <link>/notes/understand_the_jvm_03/</link>
      <pubDate>Fri, 02 Apr 2021 22:10:56 +0800</pubDate>
      <guid>/notes/understand_the_jvm_03/</guid>
      <description>&lt;h2 id=&#34;垃圾收集器与内存分配策略&#34;&gt;垃圾收集器与内存分配策略&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;垃圾回收需要完成的三件事
&lt;ul&gt;
&lt;li&gt;那些内存需要回收&lt;/li&gt;
&lt;li&gt;什么时候回收&lt;/li&gt;
&lt;li&gt;如何回收&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当垃圾回收成为性能瓶颈时，对垃圾回收进行必要的监控和调整&lt;/li&gt;
&lt;li&gt;需要回收的区域
&lt;ul&gt;
&lt;li&gt;方法区&lt;/li&gt;
&lt;li&gt;内存堆&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对象已死
&lt;ul&gt;
&lt;li&gt;引用计数法
&lt;ul&gt;
&lt;li&gt;在对象中添加一个引用计数器&lt;/li&gt;
&lt;li&gt;每当有一个地方引用它时，计数器值就加一&lt;/li&gt;
&lt;li&gt;当引用失效时，计数器值就减一&lt;/li&gt;
&lt;li&gt;任何时刻计数器为零的对象就是不可能再被使用的&lt;/li&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;原理简单，判定效率也很高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作&lt;/li&gt;
&lt;li&gt;如单纯的引用计数就很难解决对象之间相互循环引用的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可达性分析
&lt;ul&gt;
&lt;li&gt;通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的&lt;/li&gt;
&lt;li&gt;GC Roots
&lt;ul&gt;
&lt;li&gt;在虚拟机栈（栈帧中的本地变量表）中引用的对象&lt;/li&gt;
&lt;li&gt;在方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用&lt;/li&gt;
&lt;li&gt;在本地方法栈中 JNI（即通常所说的 Native 方法）引用的对象&lt;/li&gt;
&lt;li&gt;Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器&lt;/li&gt;
&lt;li&gt;所有被同步锁（synchronized 关键字）持有的对象&lt;/li&gt;
&lt;li&gt;反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。&lt;/li&gt;
&lt;li&gt;其他临时性加入的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;引用
&lt;ul&gt;
&lt;li&gt;强引用是程序代码之中普遍存在的引用赋值&lt;/li&gt;
&lt;li&gt;软引用是用来描述一些还有用，但非必须的对象&lt;/li&gt;
&lt;li&gt;弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止&lt;/li&gt;
&lt;li&gt;虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;回收方法区
&lt;ul&gt;
&lt;li&gt;废弃的常量和不再使用的类型&lt;/li&gt;
&lt;li&gt;判断一个类不再被使用
&lt;ul&gt;
&lt;li&gt;该类所有的实例都已经被回收&lt;/li&gt;
&lt;li&gt;加载该类的类加载器已经被回收&lt;/li&gt;
&lt;li&gt;该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;垃圾回收算法
&lt;ul&gt;
&lt;li&gt;分代收集理论
&lt;ul&gt;
&lt;li&gt;绝大多数对象都是朝生夕灭的&lt;/li&gt;
&lt;li&gt;熬过越多次垃圾收集过程的对象就越难以消亡&lt;/li&gt;
&lt;li&gt;跨代引用相对于同代引用来说仅占极少数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;标记清除算法
&lt;ul&gt;
&lt;li&gt;首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象&lt;/li&gt;
&lt;li&gt;主要缺点
&lt;ul&gt;
&lt;li&gt;执行效率不稳定，标记和清除两个过程的执行效率都随对象数量增长而降低&lt;/li&gt;
&lt;li&gt;标记、清除之后会产生大量不连续的内存碎片&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;标记复制算法
&lt;ul&gt;
&lt;li&gt;它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块&lt;/li&gt;
&lt;li&gt;当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉&lt;/li&gt;
&lt;li&gt;空间浪费&lt;/li&gt;
&lt;li&gt;优化
&lt;ul&gt;
&lt;li&gt;新生代中的对象有 98%熬不过第一轮收集&lt;/li&gt;
&lt;li&gt;把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾搜集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间&lt;/li&gt;
&lt;li&gt;HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8∶1&lt;/li&gt;
&lt;li&gt;当 Survivor 空间不足以容纳一次 Minor GC 之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;标记整理算法
&lt;ul&gt;
&lt;li&gt;用于老年代回收&lt;/li&gt;
&lt;li&gt;标记过程仍然与标记清除算法一样&lt;/li&gt;
&lt;li&gt;整理时让所有存活的对象都向内存空间一端移动&lt;/li&gt;
&lt;li&gt;STW 的影响&lt;/li&gt;
&lt;li&gt;是否移动对象需要考虑延迟和吞吐&lt;/li&gt;
&lt;li&gt;优化
&lt;ul&gt;
&lt;li&gt;平时采用标记清除，当内存碎片化到影响对象分配的时候采用标记整理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HotSpot 的算法实现细节
&lt;ul&gt;
&lt;li&gt;根节点枚举
&lt;ul&gt;
&lt;li&gt;根节点枚举始终必须在一个能保障一致性的快照中进行&lt;/li&gt;
&lt;li&gt;枚举根节点时是必须要停顿的, STW&lt;/li&gt;
&lt;li&gt;准确式垃圾收集&lt;/li&gt;
&lt;li&gt;用 OopMap 的数据结构来直接得到哪些地方存放着对象引用的&lt;/li&gt;
&lt;li&gt;一旦类加载动作完成，HotSpot 会把对象偏移量上的数据类型计算出来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全点
&lt;ul&gt;
&lt;li&gt;只是在“特定的位置”记录了这些信息&lt;/li&gt;
&lt;li&gt;强制要求必须执行到达安全点后才能够暂停&lt;/li&gt;
&lt;li&gt;安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的&lt;/li&gt;
&lt;li&gt;抢先式中断
&lt;ul&gt;
&lt;li&gt;在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主动式中断
&lt;ul&gt;
&lt;li&gt;当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全区域
&lt;ul&gt;
&lt;li&gt;安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点&lt;/li&gt;
&lt;li&gt;当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的阶段)，如果完成了，那线程就当作没事发生过，继续执行;否则它就必须一直等待，直到收到可以离开安全区域的信号为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;记忆集与卡表
&lt;ul&gt;
&lt;li&gt;解决对象跨代引用所带来的问题&lt;/li&gt;
&lt;li&gt;记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构&lt;/li&gt;
&lt;li&gt;卡表
&lt;ul&gt;
&lt;li&gt;字节数组 CARD_TABLE 的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”(Card Page)&lt;/li&gt;
&lt;li&gt;一个卡页的内存中通常包含不止一个对象，只要卡页内有一个(或更多)对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为 1，称为这个元素变脏(Dirty)，没有则标识为 0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入 GC Roots 中一并扫描。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;写屏障
&lt;ul&gt;
&lt;li&gt;解决卡表元素如何维护的问题&lt;/li&gt;
&lt;li&gt;写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的 AOP 切面，在引用对象赋值时会产生一个环形(Around)通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内&lt;/li&gt;
&lt;li&gt;应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令&lt;/li&gt;
&lt;li&gt;伪共享问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并发的可达性问题
&lt;ul&gt;
&lt;li&gt;从 GC Roots 再继续往下遍历对象图，这一步骤的停顿时间就必定会与 Java 堆容量直接成正比例关系了&lt;/li&gt;
&lt;li&gt;三色标记
&lt;ul&gt;
&lt;li&gt;白色:表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。&lt;/li&gt;
&lt;li&gt;黑色:表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接(不经过灰色对象)指向某个白色对象。&lt;/li&gt;
&lt;li&gt;灰色:表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对象消失的问题
&lt;ul&gt;
&lt;li&gt;赋值器插入了一条或多条从黑色对象到白色对象的新引用&lt;/li&gt;
&lt;li&gt;赋值器删除了全部从灰色对象到该白色对象的直接或间接引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;增量更新
&lt;ul&gt;
&lt;li&gt;当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原始快照
&lt;ul&gt;
&lt;li&gt;当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;经典垃圾回收器
&lt;ul&gt;
&lt;li&gt;Serial 收集器
&lt;ul&gt;
&lt;li&gt;使用一个处理器或一条收集线程去完成垃圾收集工作&lt;/li&gt;
&lt;li&gt;额外内存消耗最小&lt;/li&gt;
&lt;li&gt;简单而高效&lt;/li&gt;
&lt;li&gt;Serial 收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ParNew 收集器
&lt;ul&gt;
&lt;li&gt;Serial 收集器的多线程并行版本&lt;/li&gt;
&lt;li&gt;Parallel Scavenge 收集器及 G1 收集器等都没有使用 HotSpot 中原本设计的垃圾收集器的分代框架，而选择另外独立实现,CMS 只能和 ParNew 搭配使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Parallel Scavenge 收集器
&lt;ul&gt;
&lt;li&gt;基于标记-复制算法实现的收集器&lt;/li&gt;
&lt;li&gt;达到一个可控制的吞吐量(Throughput)。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值&lt;/li&gt;
&lt;li&gt;最高效率地利用处理器资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Serial Old 收集器
&lt;ul&gt;
&lt;li&gt;Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器&lt;/li&gt;
&lt;li&gt;使用标记-整理算法&lt;/li&gt;
&lt;li&gt;供客户端模式下的 HotSpot 虚拟机使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Parallel Old 收集器
&lt;ul&gt;
&lt;li&gt;Parallel Old 是 Parallel Scavenge 收集器的老年代版本，支持多线程并发收集&lt;/li&gt;
&lt;li&gt;基于标记-整理算法实现&lt;/li&gt;
&lt;li&gt;注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器这个组合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CMS 收集器
&lt;ul&gt;
&lt;li&gt;获取最短回收停顿时间为目标的收集器&lt;/li&gt;
&lt;li&gt;标记-清除算法
&lt;ul&gt;
&lt;li&gt;初始标记(CMS initial mark)
&lt;ul&gt;
&lt;li&gt;仅仅只是标记一下 GC Roots 能直接关联到的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并发标记(CMS concurrent mark)
&lt;ul&gt;
&lt;li&gt;从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重新标记(CMS remark)
&lt;ul&gt;
&lt;li&gt;修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并发清除(CMS concurrent sweep)
&lt;ul&gt;
&lt;li&gt;清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其中初始标记、重新标记这两个步骤仍然需要“Stop The World”&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;对处理器资源非常敏感
&lt;ul&gt;
&lt;li&gt;CMS 默认启动的回收线程数是(处理器核心数量 +3)/4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CMS 收集器无法处理“浮动垃圾”
&lt;ul&gt;
&lt;li&gt;CMS 的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS 无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空间碎片&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;G1 收集器
&lt;ul&gt;
&lt;li&gt;开创了收集器面向局部收集的设计思路和基于 Region 的内存布局形式&lt;/li&gt;
&lt;li&gt;提供并发的类卸载的支持&lt;/li&gt;
&lt;li&gt;主要面向服务端应用的垃圾收集器&lt;/li&gt;
&lt;li&gt;JDK9 的默认收集器&lt;/li&gt;
&lt;li&gt;面向堆内存任何部分来组成回收集(Collection Set，一般简称 CSet)进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是 G1 收集器的 Mixed GC 模式&lt;/li&gt;
&lt;li&gt;基于 Region 的堆内存布局&lt;/li&gt;
&lt;li&gt;G1 不再坚持固定大小以及固定数量的分代区域划分，而是把连续的 Java 堆划分为多个大小相等的独立区域(Region)，每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。收集器能够对扮演不同角色的 Region 采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果&lt;/li&gt;
&lt;li&gt;Region 中还有一类特殊的 Humongous 区域，专门用来存储大对象。G1 认为只要大小超过了一个 Region 容量一半的对象即可判定为大对象&lt;/li&gt;
&lt;li&gt;对于那些超过了整个 Region 容量的超级大对象， 将会被存放在 N 个连续的 Humongous Region 之中&lt;/li&gt;
&lt;li&gt;使用 Region 划分内存空间，以及具有优先级的区域回收方式，保证了 G1 收集器在有限的时间内获取尽可能高的收集效率&lt;/li&gt;
&lt;li&gt;Region 里面存在的跨 Region 引用对象如何解决
&lt;ul&gt;
&lt;li&gt;使用记忆集避免全堆作为 GC Roots 扫描，但在 G1 收集器上记忆集的应用其实要复杂很多，它的每个 Region 都维护有自己的记忆集，这些记忆集会记录下别的 Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内&lt;/li&gt;
&lt;li&gt;根据经验，G1 至少要耗费大约相当于 Java 堆容量 10%至 20%的额外内存来维持收集器工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并发标记阶段如何保证收集线程与用户线程互不干扰地运行
&lt;ul&gt;
&lt;li&gt;原始快照算法&lt;/li&gt;
&lt;li&gt;如果内存回收的速度赶不上内存分配的速度， G1 收集器也要被迫冻结用户线程执行，导致 Full GC 而产生长时间“Stop The World”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;怎样建立起可靠的停顿预测模型
&lt;ul&gt;
&lt;li&gt;G1 收集器的停顿预测模型是以衰减均值(Decaying Average)为理论基础来实现的，在垃圾收集过程中，G1 收集器会记录每个 Region 的回收耗时、每个 Region 记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;收集过程
&lt;ul&gt;
&lt;li&gt;初始标记(Initial Marking):仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行 Minor GC 的时候同步完成的，所以 G1 收集器在这个阶段实际并没有额外的停顿。&lt;/li&gt;
&lt;li&gt;并发标记(Concurrent Marking):从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理 SATB 记录下的在并发时有引用变动的对象。&lt;/li&gt;
&lt;li&gt;最终标记(Final Marking):对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。&lt;/li&gt;
&lt;li&gt;筛选回收(Live Data Counting and Evacuation):负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;G1 收集器除了并发标记外，其余阶段也是要完全暂停用户线程的&lt;/li&gt;
&lt;li&gt;最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的内存分配速率 (Allocation Rate)，而不追求一次把整个 Java 堆全部清理干净&lt;/li&gt;
&lt;li&gt;G1 垃圾收集产生的内存占用(Footprint)和程序运行时的额外执行负载 (Overload)都要比 CMS 要高
&lt;ul&gt;
&lt;li&gt;G1 的记忆集(和其他内存消耗)可能会占整个堆容量的 20%乃至更多的内存空间&lt;/li&gt;
&lt;li&gt;G1 对写屏障的复杂操作要比 CMS 消耗更多的运算资源&lt;/li&gt;
&lt;li&gt;目前在小内存应用上 CMS 的表现大概率仍然要会优于 G1，而在大内存应用上 G1 则大多能发挥其优势，这个优劣势的 Java 堆容量平衡点通常在 6GB 至 8GB 之间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;低延迟垃圾收集器
&lt;ul&gt;
&lt;li&gt;ZGC 收集器
&lt;ul&gt;
&lt;li&gt;在尽可能对吞吐量影响不太大的前提下，把垃圾收集的停顿时间限制在十毫秒以内的低延迟&lt;/li&gt;
&lt;li&gt;ZGC 收集器是一款基于 Region 内存布局的，(暂时) 不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器&lt;/li&gt;
&lt;li&gt;ZGC 的 Region 具有动态性——动态创建和销毁，以及动态的区域容量大小
&lt;ul&gt;
&lt;li&gt;小型 Region(Small Region):容量固定为 2MB，用于放置小于 256KB 的小对象。&lt;/li&gt;
&lt;li&gt;中型 Region(Medium Region):容量固定为 32MB，用于放置大于等于 256KB 但小于 4MB 的对象。&lt;/li&gt;
&lt;li&gt;大型 Region(Large Region):容量不固定，可以动态变化，但必须为 2MB 的整数倍，用于放置 4MB 或以上的大对象&lt;/li&gt;
&lt;li&gt;ZGC 收集器有一个标志性的设计是它采用的染色指针技术
&lt;ul&gt;
&lt;li&gt;染色指针是一种直接将少量额外的信息存储在指针上的技术&lt;/li&gt;
&lt;li&gt;ZGC 用地址的高 4 位提取出来存储四个标志信息
&lt;ul&gt;
&lt;li&gt;其引用对象的三色标记状态&lt;/li&gt;
&lt;li&gt;是否进入了重分配集(即被移动过)&lt;/li&gt;
&lt;li&gt;是否只能通过 finalize()方法才能被访问到&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作&lt;/li&gt;
&lt;li&gt;ZGC 只使用了读屏障&lt;/li&gt;
&lt;li&gt;ZGC 使用了多重映射(Multi-Mapping)将多个不同的虚拟内存地址映射到同一个物理内存地址上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;收集过程
&lt;ul&gt;
&lt;li&gt;并发标记：标记阶段会更新染色指针中的 Marked0、Marked1 标志位&lt;/li&gt;
&lt;li&gt;并发预备重分配: 根据特定的查询条件统计得出本次收集过程要清理哪些 Region，将这些 Region 组成重分配集(Relocation Set)&lt;/li&gt;
&lt;li&gt;并发重分配(Concurrent Relocate):重分配是 ZGC 执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的 Region 上，并为重分配集中的每个 Region 维护一个转发表(Forward Table)，记录从旧对象到新对象的转向关系&lt;/li&gt;
&lt;li&gt;并发重映射(Concurrent Remap):重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选择合适的垃圾收集器
&lt;ul&gt;
&lt;li&gt;如果是数据分析、科学计算类的任务，目标是能尽快算出结果，那吞吐量就是主要关注点&lt;/li&gt;
&lt;li&gt;如果是 SLA 应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点&lt;/li&gt;
&lt;li&gt;如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>深入理解Java虚拟机::自动内存管理</title>
      <link>/notes/understand_the_jvm_02/</link>
      <pubDate>Thu, 01 Apr 2021 22:10:56 +0800</pubDate>
      <guid>/notes/understand_the_jvm_02/</guid>
      <description>&lt;h2 id=&#34;自动内存管理&#34;&gt;自动内存管理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;程序计数器
&lt;ul&gt;
&lt;li&gt;程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器&lt;/li&gt;
&lt;li&gt;每条线程都需要有一个独立的程序计数器，各条线程 之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存&lt;/li&gt;
&lt;li&gt;如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址&lt;/li&gt;
&lt;li&gt;如果正在执行的是本地(Native)方法，这个计数器值则应为空(Undefined)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java 虚拟机栈
&lt;ul&gt;
&lt;li&gt;线程私有的&lt;/li&gt;
&lt;li&gt;生命周期与线程相同&lt;/li&gt;
&lt;li&gt;每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息&lt;/li&gt;
&lt;li&gt;局部变量表存放了编译期可知的各种 Java 虚拟机基本数据类型、对象引用和 returnAddress 类型&lt;/li&gt;
&lt;li&gt;StackOverflowError&lt;/li&gt;
&lt;li&gt;OutOfMemoryError&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本地方法栈
&lt;ul&gt;
&lt;li&gt;虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务&lt;/li&gt;
&lt;li&gt;StackOverflowError&lt;/li&gt;
&lt;li&gt;OutOfMemoryError&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java 堆
&lt;ul&gt;
&lt;li&gt;Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建&lt;/li&gt;
&lt;li&gt;此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存
&lt;ul&gt;
&lt;li&gt;逃逸分析，栈上分配，标量替换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;垃圾收集器管理的内存区域
&lt;ul&gt;
&lt;li&gt;分代收集理论&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区 TLAB 以提升对象分配时的效率&lt;/li&gt;
&lt;li&gt;Java 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的&lt;/li&gt;
&lt;li&gt;OutOfMemoryError&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法区
&lt;ul&gt;
&lt;li&gt;线程共享&lt;/li&gt;
&lt;li&gt;存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据&lt;/li&gt;
&lt;li&gt;可以选择不实现垃圾收集&lt;/li&gt;
&lt;li&gt;内存回收目标主要是针对常量池的回收和对类型的卸载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运行时常量池
&lt;ul&gt;
&lt;li&gt;方法区的一部分&lt;/li&gt;
&lt;li&gt;存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中&lt;/li&gt;
&lt;li&gt;具备动态性&lt;/li&gt;
&lt;li&gt;OutOfMemoryError&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;直接内存
&lt;ul&gt;
&lt;li&gt;不是虚拟机运行时数据区的一部分&lt;/li&gt;
&lt;li&gt;在 JDK 1.4 中新加入了 NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区 (Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作&lt;/li&gt;
&lt;li&gt;不会受到 Java 堆大小的限制&lt;/li&gt;
&lt;li&gt;OutOfMemoryError&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对象的创建
&lt;ul&gt;
&lt;li&gt;当 Java 虚拟机遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程&lt;/li&gt;
&lt;li&gt;对象所需内存的大小在类加载完成后便可完全确定
&lt;ul&gt;
&lt;li&gt;对象分配空间的任务实际上便等同于把一块确定大小的内存块从 Java 堆中划分出来&lt;/li&gt;
&lt;li&gt;假设 Java 堆中内存是绝对规整的&amp;ndash;指针碰撞&lt;/li&gt;
&lt;li&gt;如果 Java 堆中的内存并不是规整的&amp;ndash;空闲列表&lt;/li&gt;
&lt;li&gt;选择哪种分配方式由 Java 堆是否规整决定
&lt;ul&gt;
&lt;li&gt;Java 堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理(Compact)的能力决定&lt;/li&gt;
&lt;li&gt;指针碰撞
&lt;ul&gt;
&lt;li&gt;Serial、ParNew 等带压缩 整理过程的收集器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空闲列表
&lt;ul&gt;
&lt;li&gt;使用 CMS 这种基于清除(Sweep)算法的收集器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在虚拟机中对象创建的线程安全
&lt;ul&gt;
&lt;li&gt;对分配内存空间的动作进行同步处理&lt;/li&gt;
&lt;li&gt;内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer，TLAB)，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存分配完成之后虚拟机必须将分配到的内存空间(但不包括对象头)都初始化为零值&lt;/li&gt;
&lt;li&gt;对对象进行必要的设置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;new 指令之后会接着执行&lt;!-- raw HTML omitted --&gt;()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对象的内存布局
&lt;ul&gt;
&lt;li&gt;对象头(Header)
&lt;ul&gt;
&lt;li&gt;对象自身的运行时数据
&lt;ul&gt;
&lt;li&gt;哈希码(HashCode)&lt;/li&gt;
&lt;li&gt;GC 分代年龄&lt;/li&gt;
&lt;li&gt;锁状态标志&lt;/li&gt;
&lt;li&gt;线程持有的锁&lt;/li&gt;
&lt;li&gt;偏向线程 ID&lt;/li&gt;
&lt;li&gt;偏向时间戳&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类型指针
&lt;ul&gt;
&lt;li&gt;指向它的类型元数据的指针&lt;/li&gt;
&lt;li&gt;记录数组长度的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实例数据(Instance Data)
&lt;ul&gt;
&lt;li&gt;程序代码里面所定义的各种类型的字段内容
&lt;ul&gt;
&lt;li&gt;父类继承下来的&lt;/li&gt;
&lt;li&gt;子类中定义的字段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对齐填充(Padding)
&lt;ul&gt;
&lt;li&gt;不是必然存在的&lt;/li&gt;
&lt;li&gt;HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对象的访问定位
&lt;ul&gt;
&lt;li&gt;使用句柄访问
&lt;ul&gt;
&lt;li&gt;Java 堆中将可能会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用直接指针访问
&lt;ul&gt;
&lt;li&gt;考虑如何放置访问类型数据的相关信息&lt;/li&gt;
&lt;li&gt;reference 中存储的直接就是对象地址&lt;/li&gt;
&lt;li&gt;速度更快，它节省了一次指针定位的时间开销&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>深入理解Java虚拟机::走进 Java</title>
      <link>/notes/understand_the_jvm_01/</link>
      <pubDate>Wed, 31 Mar 2021 22:10:56 +0800</pubDate>
      <guid>/notes/understand_the_jvm_01/</guid>
      <description>&lt;h2 id=&#34;走进-java&#34;&gt;走进 Java&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;发展史
&lt;ul&gt;
&lt;li&gt;1996.01.23 JDK 1.0 发布
&lt;ul&gt;
&lt;li&gt;JVM&lt;/li&gt;
&lt;li&gt;Applet&lt;/li&gt;
&lt;li&gt;AWT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1996.02.19 JDK 1.1 发布
&lt;ul&gt;
&lt;li&gt;JAR 文件格式&lt;/li&gt;
&lt;li&gt;JDBC&lt;/li&gt;
&lt;li&gt;JavaBeans&lt;/li&gt;
&lt;li&gt;RMI&lt;/li&gt;
&lt;li&gt;内部类&lt;/li&gt;
&lt;li&gt;反射&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1998.12.04 JDK 1.2 发布
&lt;ul&gt;
&lt;li&gt;J2SE&lt;/li&gt;
&lt;li&gt;J2EE&lt;/li&gt;
&lt;li&gt;J2ME&lt;/li&gt;
&lt;li&gt;EJB&lt;/li&gt;
&lt;li&gt;Java Plug-in&lt;/li&gt;
&lt;li&gt;Java IDL&lt;/li&gt;
&lt;li&gt;Swing&lt;/li&gt;
&lt;li&gt;JIT&lt;/li&gt;
&lt;li&gt;VM
&lt;ul&gt;
&lt;li&gt;Classic VM&lt;/li&gt;
&lt;li&gt;HotSpot VM&lt;/li&gt;
&lt;li&gt;Exact VM&lt;/li&gt;
&lt;li&gt;strictfp 关键字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2000.05.08 JDK 1.3 发布
&lt;ul&gt;
&lt;li&gt;JNDI&lt;/li&gt;
&lt;li&gt;Java 2D API&lt;/li&gt;
&lt;li&gt;JavaSound&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2002.02.13 JDK 1.4 发布
&lt;ul&gt;
&lt;li&gt;正则表达式&lt;/li&gt;
&lt;li&gt;异常链&lt;/li&gt;
&lt;li&gt;NIO&lt;/li&gt;
&lt;li&gt;日志类&lt;/li&gt;
&lt;li&gt;XML 解析器和 XSLT 转换器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2004.09.30 JDK 5 发布
&lt;ul&gt;
&lt;li&gt;自动装箱&lt;/li&gt;
&lt;li&gt;范型&lt;/li&gt;
&lt;li&gt;动态注解&lt;/li&gt;
&lt;li&gt;枚举&lt;/li&gt;
&lt;li&gt;可变长参数&lt;/li&gt;
&lt;li&gt;遍历循环&lt;/li&gt;
&lt;li&gt;JMM&lt;/li&gt;
&lt;li&gt;JUC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2006.12.11 JDK 6 发布
&lt;ul&gt;
&lt;li&gt;动态语言支持&lt;/li&gt;
&lt;li&gt;编译期注解处理器&lt;/li&gt;
&lt;li&gt;微型 HTTP 服务器 API&lt;/li&gt;
&lt;li&gt;锁和同步，垃圾回收，类加载改进&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2009.02.19 JDK 7 发布
&lt;ul&gt;
&lt;li&gt;支持 Mac OS&lt;/li&gt;
&lt;li&gt;G1 收集器&lt;/li&gt;
&lt;li&gt;加强对非 Java 语言的调用支持&lt;/li&gt;
&lt;li&gt;可并行的类加载架构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2014.03.18 JDK 8 发布
&lt;ul&gt;
&lt;li&gt;Lambda 支持&lt;/li&gt;
&lt;li&gt;Nashorn JavaScript 引擎&lt;/li&gt;
&lt;li&gt;新的时间日期 API&lt;/li&gt;
&lt;li&gt;彻底移除 HotSpot 的永久代&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2017.09.21 JDK 9 发布
&lt;ul&gt;
&lt;li&gt;Jigsaw 模块化&lt;/li&gt;
&lt;li&gt;JShell&lt;/li&gt;
&lt;li&gt;JLink&lt;/li&gt;
&lt;li&gt;HTTP 2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2018.03.20 JDK 10 发布
&lt;ul&gt;
&lt;li&gt;本地类型推断增强&lt;/li&gt;
&lt;li&gt;整合 JDK 代码仓库&lt;/li&gt;
&lt;li&gt;统一的垃圾回收接口&lt;/li&gt;
&lt;li&gt;应用程序类数据共享&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2018.09.25 JDK 11 发布
&lt;ul&gt;
&lt;li&gt;ZGC&lt;/li&gt;
&lt;li&gt;授权许可调整&lt;/li&gt;
&lt;li&gt;Epsilon：低开销垃圾回收器&lt;/li&gt;
&lt;li&gt;标准 HTTP Client 升级&lt;/li&gt;
&lt;li&gt;基于嵌套的访问控制&lt;/li&gt;
&lt;li&gt;简化启动单个源代码文件的方法
&lt;ul&gt;
&lt;li&gt;用于 Lambda 参数的局部变量语法&lt;/li&gt;
&lt;li&gt;低开销的 Heap Profiling&lt;/li&gt;
&lt;li&gt;支持 TLS 1.3 协议&lt;/li&gt;
&lt;li&gt;飞行记录器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2019.03.20 JDK 12 发布
&lt;ul&gt;
&lt;li&gt;Switch 表达式&lt;/li&gt;
&lt;li&gt;Shenandoah 垃圾回收器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2019.08.17 JDK 13 发布
&lt;ul&gt;
&lt;li&gt;ZGC 增强&lt;/li&gt;
&lt;li&gt;更新 Socket 实现&lt;/li&gt;
&lt;li&gt;Switch 表达式更新&lt;/li&gt;
&lt;li&gt;文本块&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2020.03.17 JDK 14 发布
&lt;ul&gt;
&lt;li&gt;instanceof 模式匹配&lt;/li&gt;
&lt;li&gt;G1 的 NUMA 可识别内存分配&lt;/li&gt;
&lt;li&gt;改进 NullPointerExceptions 提示信息&lt;/li&gt;
&lt;li&gt;Record 类型&lt;/li&gt;
&lt;li&gt;Switch 表达式&lt;/li&gt;
&lt;li&gt;删除 CMS 垃圾回收器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2020.09.15 JDK 15 发布
&lt;ul&gt;
&lt;li&gt;Edwards-Curve 数字签名算法&lt;/li&gt;
&lt;li&gt;封闭类&lt;/li&gt;
&lt;li&gt;禁用、弃用偏向锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java 虚拟机家族
&lt;ul&gt;
&lt;li&gt;Sun Classic/Exact VM&lt;/li&gt;
&lt;li&gt;HotSpot VM&lt;/li&gt;
&lt;li&gt;Mobile/Embedded VM&lt;/li&gt;
&lt;li&gt;BEA JRockit/IBM J9 VM&lt;/li&gt;
&lt;li&gt;BEA Liquid VM/Azul VM&lt;/li&gt;
&lt;li&gt;Apache Harmony/Google Android Dalvik VM&lt;/li&gt;
&lt;li&gt;Microsoft JVM 及其他&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>心理学::被讨厌的勇气</title>
      <link>/reading/douban_26369699/</link>
      <pubDate>Sun, 28 Mar 2021 17:14:37 +0800</pubDate>
      <guid>/reading/douban_26369699/</guid>
      <description>&lt;h1 id=&#34;被讨厌的勇气&#34;&gt;被讨厌的勇气&lt;/h1&gt;
&lt;h2 id=&#34;我们的不幸是谁的错&#34;&gt;我们的不幸是谁的错&lt;/h2&gt;
&lt;p&gt;如果我们一直依赖原因论，就会永远止步不前。&lt;/p&gt;
&lt;p&gt;任何经历本身并不是成功或者失败的原因。我们并非因为自身经历中的刺激——所谓的心理创伤——而痛苦，事实上我们会从经历中发现符合自己目的的因素。决定我们自身的不是过去的经历，而是我们自己赋予经历的意义。&lt;/p&gt;
&lt;p&gt;我们大家都是在为了某种“目的”而活着。这就是目的论。&lt;/p&gt;
&lt;p&gt;所谓愤怒其实只是可放可收的一种“手段”而已。&lt;/p&gt;
&lt;p&gt;答案不应该是从别人那里得到，而应该是自己亲自找出来。&lt;/p&gt;
&lt;p&gt;重要的不是被给予了什么，而是如何去利用被给予的东西。&lt;/p&gt;
&lt;p&gt;无视现实的是你。一味执著于“被给予了什么”，现实就会改变？我们不是可以更换的机械。我们需要的不是更换而是更新。&lt;/p&gt;
&lt;p&gt;比如现在你感觉不到幸福。有时还会觉得活得很痛苦，甚至想要变成别人。但是，现在的你之所以不幸正是因为你自己亲手选择了“不幸”，而不是因为生来就不幸。&lt;/p&gt;
&lt;p&gt;行为之恶的确有很多。但无论什么样的犯罪者，都没有因为纯粹想要作恶而去干坏事的，所有的犯罪者都有其犯罪的内在的“相应理由”。假设有人因为金钱纠纷而杀了人。即使如此，对其本人来说也是有“相应理由”的行为，换句话说就是“善”的行动。当然，这不是指道德意义上的善，而是指“利己”这一意义上的善。&lt;/p&gt;
&lt;p&gt;你在人生的某个阶段里选择了“不幸”。这既不是因为你生在了不幸的环境中，也不是因为你陷入了不幸的境地中，而是因为你认为“不幸”对你自身而言是一种“善”。&lt;/p&gt;
&lt;p&gt;人时常在选择着自己的生活方式，即使像现在这样促膝而谈的瞬间也在进行着选择。你把自己说成不幸的人，还说想要马上改变，甚至说想要变成别人。尽管如此还是没能改变，这是为什么呢？那是因为你在不断地下着不改变自己生活方式的决心。&lt;/p&gt;
&lt;p&gt;如果选择新的生活方式，那就既不知道新的自己会遇到什么问题，也不知道应该如何应对眼前的事情。未来难以预测，生活就会充满不安，也可能有更加痛苦、更加不幸的生活在等着自己。也就是说，即使人们有各种不满，但还是认为保持现状更加轻松、更能安心。&lt;/p&gt;
&lt;p&gt;阿德勒心理学就是勇气心理学。你之所以不幸并不是因为过去或者环境，更不是因为能力不足，你只不过是缺乏“勇气”，可以说是缺乏“获得幸福的勇气”。&lt;/p&gt;
&lt;p&gt;的确。你现在首先应该做的是什么呢？那就是要有“摈弃现在的生活方式”的决心。&lt;/p&gt;
&lt;p&gt;无论之前的人生发生过什么，都对今后的人生如何度过没有影响。”决定自己人生的是活在“此时此刻”的你自己。&lt;/p&gt;
&lt;h2 id=&#34;一切烦恼都来自人际关系&#34;&gt;一切烦恼都来自人际关系&lt;/h2&gt;
&lt;p&gt;你为什么讨厌自己呢？为什么只盯着缺点就是不肯去喜欢自己呢？那是因为你太害怕被他人讨厌、害怕在人际关系中受伤。&lt;/p&gt;
&lt;p&gt;那么，如何实现这种目的呢？答案很简单。只要变成一个只看自己的缺点、极其厌恶自我、尽量不涉入人际关系的人就可以了。如此一来，只要躲在自己的壳里就可以不与任何人发生关联，而且万一遭到别人的拒绝，还可以以此为理由来安慰自己。心里就会想：因为我有这样的缺点才会遭人拒绝，只要我没有这个缺点也会很讨人喜欢。&lt;/p&gt;
&lt;p&gt;但是，请你不要忘记，在人际关系中根本不可能不受伤。只要涉入人际关系就会或大或小地受伤，也会伤害别人。&lt;/p&gt;
&lt;p&gt;一切烦恼都是人际关系的烦恼&lt;/p&gt;
&lt;p&gt;困扰我们的自卑感不是“客观性的事实”而是“主观性的解释”？&lt;/p&gt;
&lt;p&gt;我们无法改变客观事实，但可以任意改变主观解释。并且，我们都活在主观世界中。&lt;/p&gt;
&lt;p&gt;也就是说，价值必须建立在社会意义之上。即使 1 美元纸币所承载的价值是一种常识（共通感觉），那它也不是客观意义上的价值。如果从印刷成本考虑的话，它根本不等于 1 美元。&lt;/p&gt;
&lt;p&gt;自卑感本身并不是坏事。这一点你能够理解吧？就像阿德勒说过的那样，自卑感也可以成为促成努力和进步的契机。例如，虽然对学历抱有自卑感，但若是正因为如此，才下定“我学历低所以更要付出加倍的努力”之类的决心，那反而成了好事。而另一方面，自卑情结是指把自己的自卑感当作某种借口使用的状态。具体就像“我因为学历低所以无法成功”或者“我因为长得不漂亮所以结不了婚”之类的想法。像这样在日常生活中大肆宣扬“因为有 A 所以才做不到 B”这样的理论，这已经超出了自卑感的范畴，它是一种自卑情结。&lt;/p&gt;
&lt;p&gt;简单地说就是害怕向前迈进或者是不想真正地努力。不愿意为了改变自我而牺牲目前所享受的乐趣——比如玩乐或休闲时间。也就是拿不出改变生活方式的“勇气”，即使有些不满或者不自由，也还是更愿意维持现状。&lt;/p&gt;
&lt;p&gt;如果真正地拥有自信，就不会自大。正因为有强烈的自卑感才会骄傲自大，那其实是想要故意炫耀自己很优秀。担心如果不那么做的话，就会得不到周围的认可。这完全是一种优越情结。这是一种通过把自卑感尖锐化来实现异常优越感的模式。具体就是指夸耀不幸。&lt;/p&gt;
&lt;p&gt;以自己的不幸为武器来支配对方。通过诉说自己如何不幸、如何痛苦来让周围的人——比如家人或朋友——担心或束缚支配其言行。刚开始提到的那些闭门不出者就常常沉浸在以不幸为武器的优越感中。阿德勒甚至指出：“在我们的文化中，弱势其实非常强大而且具有特权。&lt;/p&gt;
&lt;p&gt;不与任何人竞争，只要自己不断前进即可&lt;/p&gt;
&lt;p&gt;健全的自卑感不是来自与别人的比较，而是来自与“理想的自己”的比较。&lt;/p&gt;
&lt;p&gt;好吧，我们都不一样。性别、年龄、知识、经验、外貌，没有完全一样的人。我们应该积极地看待自己与别人的差异。但是，我们“虽然不同但是平等”。&lt;/p&gt;
&lt;p&gt;不是。无论是走在前面还是走在后面都没有关系，我们都走在一个并不存在纵轴的水平面上，我们不断向前迈进并不是为了与谁竞争。价值在于不断超越自我。&lt;/p&gt;
&lt;p&gt;这与竞争有关。请你记住。如果在人际关系中存在“竞争”，那人就不可能摆脱人际关系带来的烦恼，也就不可能摆脱不幸。&lt;/p&gt;
&lt;p&gt;竞争的可怕之处就在于此。即便不是败者、即便一直立于不败之地，处于竞争之中的人也会一刻不得安心、不想成为败者。而为了不成为败者就必须一直获胜、不能相信他人。之所以有很多人虽然取得了社会性的成功，但却感觉不到幸福，就是因为他们活在竞争之中。因为他们眼中的世界是敌人遍布的危险所在。&lt;/p&gt;
&lt;p&gt;把他人的幸福看作“我的失败”，所以才无法给予祝福。&lt;/p&gt;
&lt;p&gt;如果能够体会到“人人都是我的伙伴”，那么对世界的看法也会截然不同。不再把世界当成危险的所在，也不再活在不必要的猜忌之中，你眼中的世界就会成为一个安全舒适的地方。人际关系的烦恼也会大大减少。&lt;/p&gt;
&lt;p&gt;这种情况下，对方的目的是什么呢？是纯粹想要讨论政治吗？不是。对方只是想要责难挑衅你，通过权力之争来达到让不顺眼的你屈服的目的。这个时候你如果发怒的话，那就是正中其下怀，关系会急剧转入权力之争。所以，我们不能上任何挑衅的当。&lt;/p&gt;
&lt;p&gt;不是不能发怒，而是“没必要依赖发怒这一工具”。&lt;/p&gt;
&lt;p&gt;那就是无论认为自己多么正确，也不要以此为理由去责难对方。这是很多人都容易陷落进去的人际关系圈套。&lt;/p&gt;
&lt;p&gt;原本主张的对错与胜负毫无关系。如果你认为自己正确的话，那么无论对方持什么意见都应该无所谓。但是，很多人都会陷入权力之争，试图让对方屈服。正因为如此，才会认为“承认自己的错误”就等于“承认失败”。&lt;/p&gt;
&lt;p&gt;承认错误、赔礼道歉、退出权力之争，这些都不是“失败”。&lt;/p&gt;
&lt;p&gt;那么你为什么把别人看成是“敌人”而不能认为是“伙伴”呢？那是因为勇气受挫的你在逃避“人生的课题”。&lt;/p&gt;
&lt;p&gt;行为方面的目标有以下两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自立。&lt;/li&gt;
&lt;li&gt;与社会和谐共处。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而且，支撑这种行为的心理方面的目标也有以下两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“我有能力”的意识。&lt;/li&gt;
&lt;li&gt;“人人都是我的伙伴”的意识。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;阿德勒心理学不是改变他人的心理学，而是追求自我改变的心理学。不能等着别人发生变化，也不要等着状况有所改变，而是由你自己勇敢迈出第一步。&lt;/p&gt;
&lt;p&gt;当人能够感觉到“与这个人在一起可以无拘无束”的时候，才能够体会到爱。既没有自卑感也不必炫耀优越性，能够保持一种平静而自然的状态。真正的爱应该是这样的。&lt;/p&gt;
&lt;p&gt;现阶段能说的就是不能够逃避。无论多么困难的关系都不可以选择逃避，必须勇敢去面对。即使最终发展成用剪刀剪断，也要首先选择面对。最不可取的就是在“这样”的状态下止步不前。&lt;/p&gt;
&lt;p&gt;人就是这么任性而自私的生物，一旦产生这种想法，无论怎样都能发现对方的缺点。即使对方是圣人君子一样的人物，也能够轻而易举地找到对方值得讨厌的理由。正因为如此，世界才随时可能变成危险的所在，人们也就有可能把所有他人都看成“敌人”。&lt;/p&gt;
&lt;h2 id=&#34;让干涉你生活的人见鬼去&#34;&gt;让干涉你生活的人见鬼去&lt;/h2&gt;
&lt;p&gt;阿德勒心理学否定寻求他人的认可。&lt;/p&gt;
&lt;p&gt;你不是为了满足别人的期待而活着，我也不是为了满足别人的期待而活着。我们没必要去满足别人的期待。&lt;/p&gt;
&lt;p&gt;如果一味寻求别人的认可、在意别人的评价，那最终就会活在别人的人生中。&lt;/p&gt;
&lt;p&gt;基本上，一切人际关系矛盾都起因于对别人的课题妄加干涉或者自己的课题被别人妄加干涉。&lt;/p&gt;
&lt;p&gt;辨别究竟是谁的课题的方法非常简单，只需要考虑一下“某种选择所带来的结果最终要由谁来承担？”&lt;/p&gt;
&lt;p&gt;这一点需要注意。阿德勒心理学并不是推崇放任主义。放任是一种不知道也不想知道孩子在做什么的态度。而阿德勒心理学的主张不是如此，而是在了解孩子干什么的基础上对其加以守护。如果就学习而言，告诉孩子这是他自己的课题，在他想学习的时候父母要随时准备给予帮助，但绝不对孩子的课题妄加干涉。在孩子没有向你求助的时候不可以指手画脚。&lt;/p&gt;
&lt;p&gt;接受心理咨询辅导之后，被辅导者下什么样的决心、是否改变生活方式，这都是被辅导者本人的课题，辅导顾问不能干涉。&lt;/p&gt;
&lt;p&gt;可以把马带到水边，但不能强迫其喝水&lt;/p&gt;
&lt;p&gt;能够改变自己的只有自己。&lt;/p&gt;
&lt;p&gt;关于自己的人生你能够做的就只有“选择自己认为最好的道路”。另一方面，别人如何评价你的选择，那是别人的课题，你根本无法左右。&lt;/p&gt;
&lt;p&gt;这其实并非是不辜负好意，而仅仅是受回报思想的束缚。无论对方做什么，决定自己应该如何做的都应该是自己。&lt;/p&gt;
&lt;p&gt;没有学会直面困难的孩子最终会想要逃避一切困难。&lt;/p&gt;
&lt;p&gt;选择了不自由生活方式的大人看着自由活在当下的年轻人就会批判其“享乐主义”。当然，这其实是为了让自己接受不自由生活而捏造出的一种人生谎言。选择了真正自由的大人就不会说这样的话，相反还会鼓励年轻人要勇于争取自由。&lt;/p&gt;
&lt;p&gt;毫不在意别人的评价、不害怕被别人讨厌、不追求被他人认可，如果不付出以上这些代价，那就无法贯彻自己的生活方式，也就是不能获得自由。&lt;/p&gt;
&lt;p&gt;获得幸福的勇气也包括“被讨厌的勇气”。一旦拥有了这种勇气，你的人际关系也会一下子变得轻松起来。&lt;/p&gt;
&lt;p&gt;其实一切的卡都掌握在自己手中。这会是全新的发现。&lt;/p&gt;
&lt;p&gt;我改变了，发生变化的只是“我”。作为结果，对方会怎样我不知道，也无法左右，这也是课题分离。当然，随着我的变化——不是通过我的变化——对方也会发生改变。也许很多情况下对方不得不改变，但那不是目的，而且也可能不会发生。总之，把改变自己当成操纵他人的手段是一种极其错误的想法。&lt;/p&gt;
&lt;h2 id=&#34;要有被讨厌的勇气&#34;&gt;要有被讨厌的勇气&lt;/h2&gt;
&lt;p&gt;他人看作伙伴并能够从中感到“自己有位置”的状态，就叫共同体感觉。&lt;/p&gt;
&lt;p&gt;共同体感觉是幸福的人际关系的最重要的指标。&lt;/p&gt;
&lt;p&gt;把对自己的执著（self interest）变成对他人的关心（social interest）。&lt;/p&gt;
&lt;p&gt;不能进行“课题分离”、一味拘泥于认可欲求的人也是极其以自我为中心的人。&lt;/p&gt;
&lt;p&gt;请你考虑一下认可欲求的实质——他人如何关注自己、如何评价自己？又在多大程度上满足自己的欲求？受这种认可欲求束缚的人看似在看着他人，但实际上眼里却只有自己。失去了对他人的关心而只关心“我”，也就是以自我为中心。&lt;/p&gt;
&lt;p&gt;一味在意“他人怎么看”的生活方式正是只关心“我”的自我中心式的生活方式。&lt;/p&gt;
&lt;p&gt;就是直面“人生课题”。也就是不回避工作、交友、爱之类的人际关系课题，要积极主动地去面对。如果你认为自己就是世界的中心，那就丝毫不会主动融入共同体中，因为一切他人都是“为我服务的人”，根本没必要由自己采取行动。但是，无论是你还是我，我们都不是世界的中心，必须用自己的脚主动迈出一步去面对人际关系课题；不是考虑“这个人会给我什么”，而是要必须思考一下“我能给这个人什么”。这就是对共同体的参与和融入。&lt;/p&gt;
&lt;p&gt;是的。归属感不是生来就有的东西，要靠自己的手去获得。&lt;/p&gt;
&lt;p&gt;在学校之外，还有更加广阔的世界。而且，我们都是那个世界的一员。如果学校中没有自己位置的话，还可以从学校“外面”找到别的位置，可以转学，甚至可以退学。一张退学申请就可以切断联系的共同体终归也就只是那种程度的联系。如果了解了世界之大，就会明白自己在学校中所受的苦只不过是“杯中风暴”而已。只要跳出杯子，猛烈的风暴也会变成微风。&lt;/p&gt;
&lt;p&gt;活在害怕关系破裂的恐惧之中，那是为他人而活的一种不自由的生活方式。&lt;/p&gt;
&lt;p&gt;表扬这种行为含有“有能力者对没能力者所做的评价”这方面的特点。&lt;/p&gt;
&lt;p&gt;人表扬他人的目的就在于“操纵比自己能力低的对方”，其中既没有感谢也没有尊敬。&lt;/p&gt;
&lt;p&gt;阿德勒心理学反对一切“纵向关系”，提倡把所有的人际关系都看作“横向关系”。&lt;/p&gt;
&lt;p&gt;是这样的。自卑感原本就是从纵向关系中产生的一种意识。只要能够对所有人都建立起“虽不同但平等”的横向关系，那就根本不会产生自卑情结。&lt;/p&gt;
&lt;p&gt;正因为把人际关系看成纵向关系、把对方看得比自己低，所以才会去干涉。希望通过干涉行为把对方导向自己希望的方向。这是坚信自己正确而对方错误。&lt;/p&gt;
&lt;p&gt;答案很清楚。因为人会因为被表扬而形成“自己没能力”的信念。&lt;/p&gt;
&lt;p&gt;首先应该进行课题分离，然后应该在接受双方差异的同时建立平等的横向关系。“鼓励”则是这种基础之上的一种方法。&lt;/p&gt;
&lt;p&gt;最重要的是不“评价”他人，评价性的语言是基于纵向关系的语言。如果能够建立起横向关系，那自然就会说出一些更加真诚地表示感谢、尊敬或者喜悦的话。&lt;/p&gt;
&lt;p&gt;被表扬是得到他人“很好”之类的评价。而且，判定某种行为“好”还是“坏”是以他人的标准。如果希望得到表扬，那就只能迎合他人的标准、妨碍自己的自由。另一方面，“谢谢”不是一种评价，而是更加纯粹的感谢之词。人在听到感谢之词的时候，就会知道自己能够对别人有所贡献。&lt;/p&gt;
&lt;p&gt;例如，人怎样才能够获得“勇气”？阿德勒的见解是：人只有在能够感觉自己有价值的时候才可以获得勇气。&lt;/p&gt;
&lt;p&gt;非常简单！人只有在可以体会到“我对共同体有用”的时候才能够感觉到自己的价值。这就是阿德勒心理学的答案。&lt;/p&gt;
&lt;p&gt;关于共同体感觉问题，也有人向阿德勒本人提出过同样的疑问。当时，阿德勒的回答是这样的：“必须得有人开始。即使其他人不合作，那也跟你没关系。我的意见就是这样：应该由你来开始。不必去考虑他人是否合作。”我的意见也完全相同。&lt;/p&gt;
&lt;p&gt;首先与他人之间，只有一方面也可以，要建立起横向关系来。要从这里开始。&lt;/p&gt;
&lt;p&gt;的确，尊敬长者非常重要。如果是公司组织，职责差异自然也会存在。并不是说将任何人都变成朋友或者像对待朋友一样去对待每一个人，不是这样的，重要的是意识上的平等以及坚持自己应有的主张。&lt;/p&gt;
&lt;h2 id=&#34;认真的人活在当下&#34;&gt;认真的人活在当下&lt;/h2&gt;
&lt;p&gt;还是共同体感觉。具体来说就是，把对自己的执著（self interest）转换成对他人的关心（social interest），建立起共同体感觉。这需要从以下三点做起：“自我接纳”“他者信赖”和“他者贡献”。&lt;/p&gt;
&lt;p&gt;自我接纳是指假如做不到就诚实地接受这个“做不到的自己”，然后尽量朝着能够做到的方向去努力，不对自己撒谎。&lt;/p&gt;
&lt;p&gt;课题分离也是如此，要分清“能够改变的”和“不能改变的”。我们无法改变“被给予了什么”。但是，关于“如何去利用被给予的东西”，我们却可以用自己的力量去改变。这就是不去关注“无法改变的”，而是去关注“可以改变的”。这就是我所说的自我接纳。&lt;/p&gt;
&lt;p&gt;是的，我们并不缺乏能力，只是缺乏“勇气”。一切都是“勇气”的问题。&lt;/p&gt;
&lt;p&gt;在相信他人的时候不附加任何条件。即使没有足以构成信用的客观依据也依然相信，不考虑抵押之类的事情，无条件地相信。这就是信赖。&lt;/p&gt;
&lt;p&gt;你现在一味地担心“被背叛”，也只关注因此受到的伤痛。但是，如果不敢去信赖别人，那最终就会与任何人都建立不了深厚的关系。&lt;/p&gt;
&lt;p&gt;自我接纳。只要能够接受真实的自己并看清“自己能做到的”和“自己做不到的”，也就可以理解背叛是他人的课题，继而也就不难迈出迈向他者信赖的步伐了。&lt;/p&gt;
&lt;p&gt;悲伤的时候尽管悲伤就可以。因为，正是想要逃避痛苦或悲伤才不敢付诸行动，以至于与任何人都无法建立起深厚的关系&lt;/p&gt;
&lt;p&gt;也就是说，他者贡献并不是舍弃“我”而为他人效劳，它反而是为了能够体会到“我”的价值而采取的一种手段。&lt;/p&gt;
&lt;p&gt;最容易理解的他者贡献就是工作——到社会上去工作或者做家务。劳动并不是赚取金钱的手段，我们通过劳动来实现他者贡献、参与共同体、体会“我对他人有用”，进而获得自己的存在价值。&lt;/p&gt;
&lt;p&gt;我们应该思考的不是他人为我做了什么，而是我能为他人做什么，并积极地加以实践。只要拥有了这种奉献精神，眼前的现实就会带有截然不同的色彩。&lt;/p&gt;
&lt;p&gt;的确，世上并非全是好人，人际关系中也会遭遇到诸多不愉快的事情。但是，在这里绝对不可以搞错这样一个事实：任何情况下都只是攻击我的“那个人”有问题，而绝不是“大家”的错。&lt;/p&gt;
&lt;p&gt;人际关系不顺利既不是因为口吃也不是因为脸红恐惧症，真正的问题在于无法做到自我接纳、他者信赖和他者贡献，却将焦点聚集到微不足道的一个方面并企图以此来评价整个世界。这就是缺乏人生和谐的错误生活方式。&lt;/p&gt;
&lt;p&gt;在某种意义上来说，这是一种不敢正视人生课题的生活方式。“工作”并不仅仅是指在公司上班。家庭里的工作、育儿、对地域社会的贡献、兴趣等，这一切都是“工作”，公司等只不过是一小部分而已。只考虑公司的工作，那是一种缺乏人生和谐的生活方式。&lt;/p&gt;
&lt;p&gt;对人而言，最大的不幸就是不喜欢自己。对于这种现实，阿德勒准备了极其简单的回答——“我对共同体有益”或者“我对他人有用”这种想法就足以让人体会到自己的价值。&lt;/p&gt;
&lt;p&gt;你已经察觉到了吧？也就是“幸福即贡献感”。这就是幸福的定义。&lt;/p&gt;
&lt;p&gt;如果能够真正拥有贡献感，那就不再需要他人的认可。因为即使不特意去寻求他人的认可，也可以体会到“我对他人有用”。也就是说，受认可欲求束缚的人不具有共同体感觉，还不能做到自我接纳、他者信赖和他者贡献。&lt;/p&gt;
&lt;p&gt;无论是希望特别优秀还是希望特别差劲，其目的都一样——引起他人的关注、脱离“普通”状态、成为“特别的存在”。这就是他们的目的。&lt;/p&gt;
&lt;p&gt;是这样的。所有的问题行为，例如逃学或者割腕以及未成年人饮酒或吸烟等，一切都是“廉价的优越性追求”。你刚开始提到的那位闭门不出的朋友也是一样。孩子陷入问题行为的时候，父母或周围的大人们会加以训斥。被训斥这件事对孩子来说无疑是一种压力。但是，即使是以被训斥这样一种形式，孩子也还是希望得到父母的关注。无论什么形式都可以，就是想成为特别的存在；无论怎么被训斥孩子都不停止问题行为，这在某种意义上来说是理所当然的事情。&lt;/p&gt;
&lt;p&gt;自我接纳就是其中的重要一步。如果你能够拥有“甘于平凡的勇气”，那么对世界的看法也会截然不同。&lt;/p&gt;
&lt;p&gt;拒绝普通的你也许是把“普通”理解成了“无能”吧。普通并不等于无能，我们根本没必要特意炫耀自己的优越性。&lt;/p&gt;
&lt;p&gt;是的，是“现在”这一刹那的连续。我们只能活在“此时此刻”，我们的人生只存在于刹那之中。&lt;/p&gt;
&lt;p&gt;但是，如果登山的目的不是登顶而是登山本身，那就可以说是现实性的活动。最终能不能登上山顶都没有关系。&lt;/p&gt;
&lt;p&gt;我们的人生也完全一样。正因为把模糊而微弱的光打向人生整体，所以才能够看到过去和未来；不，是感觉能够看得到。但是，如果把强烈的聚光灯对准“此时此刻”，那就会既看不到过去也看不到未来。&lt;/p&gt;
&lt;p&gt;人生是连续的刹那，根本不存在过去和未来。你是想要通过关注过去或未来为自己寻找免罪符。过去发生了什么与你的“此时此刻”没有任何关系，未来会如何也不是“此时此刻”要考虑的问题。假如认真地活在“此时此刻”，那就根本不会说出那样的话。&lt;/p&gt;
&lt;p&gt;是的。人生很简单，并不是什么深刻的事情。如果认真过好了每一个刹那，就没有什么必要令其过于深刻。&lt;/p&gt;
&lt;p&gt;人生中最大的谎言就是不活在“此时此刻”。纠结过去、关注未来，把微弱而模糊的光打向人生整体，自认为看到了些什么。你之前就一直忽略“此时此刻”，只关注根本不在的过去和未来。对自己的人生和无可替代的刹那撒了一个大大的谎言。&lt;/p&gt;
&lt;p&gt;无论你过着怎样的刹那，即使有人讨厌你，只要没有迷失“他者贡献”这颗引导之星，那么你就不会迷失，而且做什么都可以。即使被讨厌自己的人讨厌着也可以自由地生活。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编程::数据密集型应用系统设计</title>
      <link>/reading/ddia/</link>
      <pubDate>Wed, 24 Mar 2021 19:27:56 +0800</pubDate>
      <guid>/reading/ddia/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;../../notes/designing_data_intensive_application_foundations_of_data_systems&#34;&gt;数据密集型应用系统设计::数据系统基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/designing_data_intensive_application_distributed_data&#34;&gt;数据密集型应用系统设计::分布式数据系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/designing_data_intensive_application_derived_data&#34;&gt;数据密集型应用系统设计::派生数据&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据密集型应用系统设计::派生数据</title>
      <link>/notes/designing_data_intensive_application_derived_data/</link>
      <pubDate>Mon, 22 Mar 2021 21:57:43 +0800</pubDate>
      <guid>/notes/designing_data_intensive_application_derived_data/</guid>
      <description>&lt;h2 id=&#34;派生数据&#34;&gt;派生数据&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;记录系统
&lt;ul&gt;
&lt;li&gt;一个记录系统也被称为真实数据系统，拥有数据的权威版本&lt;/li&gt;
&lt;li&gt;如果另一个系统与记录系统之间存在任何差异，那么以记录系统中的数据值为准&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;派生数据系统
&lt;ul&gt;
&lt;li&gt;派生数据系统中的数据则是从另一个系统中获取已有数据并以某种方式进行转换或处理的结果&lt;/li&gt;
&lt;li&gt;如果派生数据丢失，用户可以从原始数据源进行重建&lt;/li&gt;
&lt;li&gt;例如缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;批处理系统&#34;&gt;批处理系统&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在线服务
&lt;ul&gt;
&lt;li&gt;服务等待客户请求或指令的到达。当收到请求或指令时，服务试图尽可能快地处理它，并发回一个响应。&lt;/li&gt;
&lt;li&gt;响应时间通常是服务性能的主要衡量指标，而可用性同样非常重要&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;批处理系统
&lt;ul&gt;
&lt;li&gt;批处理系统接收大量的输入数据，运行一个作业来处理数据，并产生输出数据&lt;/li&gt;
&lt;li&gt;批处理作业的主要性能衡量标准通常是吞吐量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流处理系统
&lt;ul&gt;
&lt;li&gt;流处理介于在线与离线/批处理之间(所以有时称为近实时或近线处理)。与批处理系统类似，流处理系统处理输入并产生输出&lt;/li&gt;
&lt;li&gt;流式作业在事件发生后不久即可对事件进行处理，而批处理作业则使用固定的一组输入数据进行操作。这种差异使得流处理系统比批处理系统具有更低的延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 UNIX 工具进行批处理
&lt;ul&gt;
&lt;li&gt;使用 awk, sed， grep, sort , uniq 和 xargs 的组合 ，可以在几分钟内完成许多数据分析任务&lt;/li&gt;
&lt;li&gt;UNIX 设计哲学
&lt;ul&gt;
&lt;li&gt;每个程序做好一件事。如果要做新的工作，则建立一个全新的程序，而不是通过增加新“特征”使旧程序变得更加复杂。&lt;/li&gt;
&lt;li&gt;期待每个程序的输出成为另一个尚未确定的程序的输入。不要将输出与无关信息混淆在一起。避免使用严格的表格状或二进制输入格式。不要使用交互式输入&lt;/li&gt;
&lt;li&gt;尽早尝试设计和构建软件，甚至是操作系统，最好在几周内完成。需要扔掉那些笨拙的部分时不要犹豫，并立即进行重建&lt;/li&gt;
&lt;li&gt;优先使用工具来减轻编程任务，即使你不得不额外花费时间去构建工具，并且预期在使用完成后会将其中一些工具扔掉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;统一接口
&lt;ul&gt;
&lt;li&gt;如果希望某个程序的输出成为另一个程序的输入，也就意味着这些程序必须使用相同的数据格式，换句话说，需要兼容的接口，在 UNIX 中，这个接口就是文件(更准确地出，是文件描述符)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;逻辑与布线分离
&lt;ul&gt;
&lt;li&gt;UNIX 工具的另一个特点是使用标准输入(stdin)和标准输出(stdout)&lt;/li&gt;
&lt;li&gt;这允许 shell 用户以任何他们想要的方式连接输入和输出:程序并不知道也不关心输入来自哪里以及输出到哪里。&lt;/li&gt;
&lt;li&gt;将输入/输出的布线连接与程序逻辑分开，可以更容易地将小工具组合成更大的系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;透明与测试
&lt;ul&gt;
&lt;li&gt;UNIX 命令的输入文件通常被视为是不可变的。这意味着可以随意运行命令，尝试各种命令行选项，而不会损坏输入文件。&lt;/li&gt;
&lt;li&gt;可以在任何时候结束流水线，将输出管道输送到 less ，然后查看它是否具有预期的形式。这种检查能力对调试非常有用。&lt;/li&gt;
&lt;li&gt;可以将流水线某个阶段的输出写入文件，并将该文件用作下一阶段的输入。这使得用户可以重新启动后面的阶段，而无需重新运行整个流水线。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MapReduce 与分布式文件系统
&lt;ul&gt;
&lt;li&gt;MapReduce 有点像分布在数千台机器上的 UNIX 工具&lt;/li&gt;
&lt;li&gt;不修改输入，无副作用，在分布式文件系统上读写文件&lt;/li&gt;
&lt;li&gt;分布式文件系统
&lt;ul&gt;
&lt;li&gt;GFS&lt;/li&gt;
&lt;li&gt;HDFS&lt;/li&gt;
&lt;li&gt;Amazon S3&lt;/li&gt;
&lt;li&gt;Azure Blob&lt;/li&gt;
&lt;li&gt;OpenStack Swift&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HDFS 包含一个在每台机器上运行的守护进程，并会开放一个网络服务以允许其他节点访问存储在该机器上的文件&lt;/li&gt;
&lt;li&gt;容错
&lt;ul&gt;
&lt;li&gt;多个机器上的相同数据的多个副本&lt;/li&gt;
&lt;li&gt;纠错码方案&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MapReduce 作业执行
&lt;ul&gt;
&lt;li&gt;MapReduce 是一个编程框架，可以使用它编写代码来处理 HDFS 等分布式文件系统中的大型数据集&lt;/li&gt;
&lt;li&gt;处理模式
&lt;ul&gt;
&lt;li&gt;读取一组输入文件，并将其分解成记录&lt;/li&gt;
&lt;li&gt;调用 mapper 函数从每个输入记录中提取一个键值对&lt;/li&gt;
&lt;li&gt;按关键字将所有的键值对排序&lt;/li&gt;
&lt;li&gt;调用 reducer 函数遍历排序后的键值对&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Mapper
&lt;ul&gt;
&lt;li&gt;每个输入记录都会调用一次 mapper 程序，其任务是从输入记录中提取关键字和值。对于每个输入，它可以生成任意数量的健值对(包括空记录)。它不会保留从一个输入记录到下一个记录的任何状态，因此每个记录都是独立处理的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reducer
&lt;ul&gt;
&lt;li&gt;MapReduce 框架使用由 mapper 生成的键值对，收集属于同一个关键字的所有值，并使用迭代器调用 reducer 以使用该值的集合。Reducer 可以生成输出记录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MapReduce 的分布式执行
&lt;ul&gt;
&lt;li&gt;作业的输入通常是 HDFS 中的一个目录，且输入目录中的每个文件或文件块都被视为一个单独的分区，可以由一个单独的 map 任务来处理&lt;/li&gt;
&lt;li&gt;让靠近数据的机器就近执行 mapper 任务，减少网络传输的负载，提高了访问局部性&lt;/li&gt;
&lt;li&gt;map 任务的数量与 reduce 任务的数量不需要一致&lt;/li&gt;
&lt;li&gt;为了使相同值的 mapper 输出交给同一个 reduce 处理，采用了关键字哈希分区&lt;/li&gt;
&lt;li&gt;键值对必须排序。map 任务基于关键字哈希，按照 reducer 对输出进行分块。每个分区都被写入 mapper 程序所在文件磁盘上的已排序文件。&lt;/li&gt;
&lt;li&gt;当 mapper 完成文件输出后，MP 调度器通知 reducer 从 mapper 中获取输出文件。reduce 从 mapper 中获取文件后把他们合并在一起，同时保持数据的排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reduce 端的 join 与分组
&lt;ul&gt;
&lt;li&gt;在批处理的背景下讨论 join 时，我们主要是解决数据集内存在关联的所有事件&lt;/li&gt;
&lt;li&gt;join 最简单的实现是遍历所有记录，并在远程服务器中查找对应的记录。&lt;/li&gt;
&lt;li&gt;更好的方法是获取用户数据库的副本，并将其放入与用户活动事件日志相同的分布式文件系统。然后，可以将用户数据库放在 HDFS 中的一组文件中，并将用户活动记录放在另一组文件中，使用 MapReduce 将所有相关记录集中到一起，从而有效地处理它们。&lt;/li&gt;
&lt;li&gt;排序-合并 join
&lt;ul&gt;
&lt;li&gt;mapper 和排序过程确保将执行特定用户 ID join 操作的所有必要数据都放在一起，这样就只需要一次 reducer 调用。因为所有需要的数据已经预先排列好，所以 reducer 是一段相当简单的单线程代码，以高吞吐量和低内存开销来处理记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分组
&lt;ul&gt;
&lt;li&gt;在 mapper 阶段，使其生成的键值对使用所需的分组关键字。然后，分区和排序过程将相同 reducer 中所有具有相同关键字的记录集合在一起&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理数据倾斜
&lt;ul&gt;
&lt;li&gt;如果 join 输入中存在热键，则可以使用算法进行补偿。在真正开始执行 join 时，mapper 将任何与热键有关的记录发送到随机选择的若干个 reducer 中的一个，对于 join 的其他输入，与热键相关的记录需要被复制到所有处理该关键字的 reducer 中，这种技术将处理热键的工作分散到多个 reducer 上，可以更好地实现并行处理，代价是不得不将 join 的其他输入复制到多个 reducer&lt;/li&gt;
&lt;li&gt;使用热键对记录进行分组并汇总时，可以分两个阶段进行分组。第一个 MapReduce 阶段将记录随机发送到 reducer，以便每个 reducer 对热键的记录子集执行分组，并为每个键输出更紧凑的聚合值。然后第二个 MapReduce 作业将来自所有第一阶段 reducer 的值合并为每个键的单一值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Map 端的 join 操作
&lt;ul&gt;
&lt;li&gt;广播哈希 join
&lt;ul&gt;
&lt;li&gt;实现 map 端 join 的最简单方住特别适合大数据集与小数据集 join，尤其是小数据集能够全部加载到每个 mapper 的内存中&lt;/li&gt;
&lt;li&gt;当 mapper 程序执行时，它可以首先将用户数据库从分布式文件系统读取到内存的哈希表中。然后，mapper 程序扫描用户活动事件，并简单地查找哈希表中每个事件的用户 ID&lt;/li&gt;
&lt;li&gt;Map 任务依然可以有多个: 大数据集的每个文件块对应一个 mapper。每个 mapper 还负责将小数据集全部加载到内存中。&lt;/li&gt;
&lt;li&gt;也可以存在磁盘中，由于缓存和索引的原因，和内存查找差不多快。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分区哈希 join
&lt;ul&gt;
&lt;li&gt;如果以相同方式对 map 端 join 的输入进行分区，则哈希 join 方法可以独立作用于每个分区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;批处理工作流的输出
&lt;ul&gt;
&lt;li&gt;生成搜索索引&lt;/li&gt;
&lt;li&gt;批处理输出键值&lt;/li&gt;
&lt;li&gt;批处理输出的哲学
&lt;ul&gt;
&lt;li&gt;如果在代码中引入了漏洞，输出错误或者损坏，那么可以简单地回读到先前版本，然后重新运行该作业，将再次生成正确的输出; 或者更简单的办法是将旧的输出保存在不同的目录中，然后切换回原来的目录&lt;/li&gt;
&lt;li&gt;与发生错误即意味着不可挽回的损害相比 ，易于回滚的特性更有利于快速开发新功能。这种使不可逆性最小化的原则对于敏捷开发是有益的&lt;/li&gt;
&lt;li&gt;如果 map 或 reduce 任务失败， MapReduce 框架会自动重新安排作业并在同一个输入上再次运行，失败任务的输出则被 MapReduce 框架丢弃&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对比 Hadoop 与分布式数据库
&lt;ul&gt;
&lt;li&gt;存储多样性
&lt;ul&gt;
&lt;li&gt;分布式文件系统中的文件只是字节序列，可以使用任何数据模型和编码来编写&lt;/li&gt;
&lt;li&gt;来自事务处理 系统的数据以某种原始形式转储到分布式文件系统中，然后编写 MapReduce 作业进行数据清理，将其转换为关系表单，并将其导入 MPP 数据仓库以进行分析。数据建模仍然会发生，但它位于一个单独步骤中，与数据收集是分离的。由于分布式文件系统支持以任何格式编码的数据，所以这种解相是可行的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理模型多样性
&lt;ul&gt;
&lt;li&gt;并非所有类型的处理都可以合理地表达为 SQL 查询&lt;/li&gt;
&lt;li&gt;由于 Hadoop 平台的开放性，可以在上面实施更多的处理模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;针对频繁故障的设计
&lt;ul&gt;
&lt;li&gt;MapReduce 可以容忍 map 或者 reduce 任务失败，单个失败可以重试。&lt;/li&gt;
&lt;li&gt;MapReduce 容忍任意失败是为了更好的利用集群资源，允许高优先级任务抢占资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;超越 MapReduce
&lt;ul&gt;
&lt;li&gt;MapReduce 很强大，但依然有些问题&lt;/li&gt;
&lt;li&gt;对于某些类型的任务，其他工具可能要快几个数量级&lt;/li&gt;
&lt;li&gt;中间状态实体化
&lt;ul&gt;
&lt;li&gt;MapReduce 会把中间结果写入文件，这个过程称为实体化&lt;/li&gt;
&lt;li&gt;UNIX 管道不存在实体化，输出可以立即成为下一个的输入&lt;/li&gt;
&lt;li&gt;几个问题
&lt;ul&gt;
&lt;li&gt;输出不会立马被利用，任务耗时会比预计的久&lt;/li&gt;
&lt;li&gt;mapper 冗余，它们只是读取刚刚由 reducer 写入的同一个文件，并为下一个分区和排序阶段做准备。在许多情况下，mapper 代码可能是之前 reducer 的一部分:如果 reducer 的输出被分区和排序的方式与 mapper 输出相同，那么不同阶段的 reducer 可以直接链接在一起，而不需要与 mapper 阶段交错。&lt;/li&gt;
&lt;li&gt;把中间状态文件存储在分布式系统中意味着这些文件被复制都多个节点了，对于这样的临时数据来说通常是大材小用了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据流引擎
&lt;ul&gt;
&lt;li&gt;为了解决 MapReduce 的这些问题，开发了用于分布式批处理的新的执行引擎
&lt;ul&gt;
&lt;li&gt;Spark，Tez，Flink&lt;/li&gt;
&lt;li&gt;它们把整个工作流作为一个作业来处理，而不是把它分解成独立的子作业&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过若干个处理阶段明确地建模数据流，所以这些系统被称为数据流引擎。像 MapReduce 一样，它们通过反复调用用户定义的函数来在单个线程上一次处理一条记录。它们通过对输入进行分区来并行工作，并将一个功能的输出复制到网络上，成为另一个功能的输入 。&lt;/li&gt;
&lt;li&gt;流处理引擎可以以更加灵活的方式组装各种函数&lt;/li&gt;
&lt;li&gt;对比 MapReduce 模型的几个优点
&lt;ul&gt;
&lt;li&gt;排序等计算代价昂贵的任务只在实际需要的地方进行，而不是在每个 map 和 reduce 阶段之间默认发生&lt;/li&gt;
&lt;li&gt;没有不必要的 map 任务，因为 mapper 所做的工作通常可以合并到前面的 reduce 运算符中&lt;/li&gt;
&lt;li&gt;由于工作流中的所有 join 和数据依赖性都是明确声明的，因此调度器知道哪些数据在哪里是必需的，因此它可以进行本地优化&lt;/li&gt;
&lt;li&gt;将运算符之间的中间状态保存在内存中或写入本地磁盘通常就足够了&lt;/li&gt;
&lt;li&gt;运算符可以在输入准备就绪后立即开始执行，在下一个开始之前不需要等待前个阶段全部完成。&lt;/li&gt;
&lt;li&gt;现有的 Java 虚拟机进程可以被重用来运行新的运算符，从而减少启动开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;容错
&lt;ul&gt;
&lt;li&gt;将中间状态完全实体化到分布式文件系统的一个优点是持久化，这使得在 MapReduce 中实现容错变得相当容易&lt;/li&gt;
&lt;li&gt;Spark, Flink 和 Tez 避免将中间状态写入 HDFS，所以它们采用不同的方法来容忍错误: 如果机器发生故障，并且该机器上的中间状态、丢失，则利用其他可用的数据重新计算&lt;/li&gt;
&lt;li&gt;为了实现重新计算，框架必须追踪给定数据是如何计算的，使用了哪个输入分区，以及应用了哪个运算符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关于实体化的讨论
&lt;ul&gt;
&lt;li&gt;数据流对 MapReduce 的改进是，不需要自己将所有中间状态写入文件系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;图与迭代处理
&lt;ul&gt;
&lt;li&gt;在批处理环境中查看图也很有趣，其目标是在整个图上执行某种离线处理或分析。这种需求经常出现在机器学习应用程序或排名系统中&lt;/li&gt;
&lt;li&gt;Pregel 处理模型
&lt;ul&gt;
&lt;li&gt;作为对图数据的批处理优化，计算的批量同步并行模型&lt;/li&gt;
&lt;li&gt;一个顶点可以“发送消息”到另一个顶点，通常这些消息沿着图的边被发送。&lt;/li&gt;
&lt;li&gt;顶点状态和顶点之间的消息具有容错性和持久性，并且通信以固定的方式进行:每一轮迭代中，框架会将前一次迭代中的所有消息都发送出去。 Actor model 通常没有这样的时序保证。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;容错
&lt;ul&gt;
&lt;li&gt;由于 Pregel 集型保证在一次迭代中发送的所有消息都会在下一次迭代中被发送，所以先前的迭代必须全部完成，而且所有的消息必须在下一次迭代 开始之前复制到网络中。&lt;/li&gt;
&lt;li&gt;即使底层网络可能会丢弃、重复或任意延迟消息，但 Pregel 的实现可以保证在后续迭代中消息在目标顶点只会被处理一次。像 MapReduce 一样，该框架透明地从故障中恢复，以简化 Pregel 顶层算陆的编程模型。&lt;/li&gt;
&lt;li&gt;这种容错方式是通过在迭代结束时定期快照所有顶点的状态来实现的，即将其全部状态写入持久存储。如果某个节点发生故障并且其内存中状态丢失，则最简单的解决方也是将整个图计算回攘到上一个检查点，然后重新开始计算。如果算法是确定性的， 并且记录了消息，那么也可以选择性地只恢复丢失的分区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并行执行
&lt;ul&gt;
&lt;li&gt;顶点不需要知道它运行在哪台物理机器上。当它发送消息到其他顶点时，只需要将消息发送至一个顶点 ID。框架对图进行分区，即确定哪个顶点运行在哪个机器上，以及如何通过网络路由消息，以便它们都能到达正确的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高级 API 与语言
&lt;ul&gt;
&lt;li&gt;由于手工编写 MapReduc 巳作业太过耗时费力，因此 Hive、Pig、Cascading 和 Crunch 等高级语言和 API 变得非常流行。随着 Tez 的出现， 这些高级语言还能够移植到新的数据流执行引擎，而无需重写作业代码。Spark 和 Flink 也包含他们自己的高级数据流 API&lt;/li&gt;
&lt;li&gt;这些高级接口不仅使提高了系统利用率，而且提高了机器级别的作业执行效率。&lt;/li&gt;
&lt;li&gt;转向声明式查询语言
&lt;ul&gt;
&lt;li&gt;通过将声明式特征与高级 API 结合，使查询优化器在执行期间可以利用这些优化方法，批处理框架看起来就更像 MPP 数据库了,井且能够实现性能相当。同时，通过具有运行任意代码和读取任意格式数据的可扩展性，它们依然保持了灵活性的优势。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不同领域的专业化
&lt;ul&gt;
&lt;li&gt;要实现可重用的通用构建模块&lt;/li&gt;
&lt;li&gt;可重复使用统计和数值算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;流处理系统&#34;&gt;流处理系统&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;我们将把事件流视为一种数据管理机制: 一种无界的、持续增量处理的方式&lt;/li&gt;
&lt;li&gt;发送事件流
&lt;ul&gt;
&lt;li&gt;在流处理的上下文中，记录通常被称为事件&lt;/li&gt;
&lt;li&gt;本质上是一回事:一个小的、独立的、不可变的对象，该对象包含某个时间点发生的事情的细节。每个事件通常包含一个时间戳，用于指示事件发生的墙上时间
&lt;ul&gt;
&lt;li&gt;案例
&lt;ul&gt;
&lt;li&gt;服务器的每一行日志&lt;/li&gt;
&lt;li&gt;用户的下单或者浏览&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;格式
&lt;ul&gt;
&lt;li&gt;文本&lt;/li&gt;
&lt;li&gt;JSON&lt;/li&gt;
&lt;li&gt;二进制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生成一次，读取多次&lt;/li&gt;
&lt;li&gt;在流系统中，相关的时间通常被组合成主题或流&lt;/li&gt;
&lt;li&gt;传统数据库无法支持实时的消息通知&lt;/li&gt;
&lt;li&gt;消息系统
&lt;ul&gt;
&lt;li&gt;向消费者通知新事件的常见方法是使用消息系统:生产者发送包含事件的消息，然后该消息被推送给一个或多个消费者&lt;/li&gt;
&lt;li&gt;当生产者发送消息比消费者处理快
&lt;ul&gt;
&lt;li&gt;系统丢弃消息&lt;/li&gt;
&lt;li&gt;将消息存储在队列中&lt;/li&gt;
&lt;li&gt;激活背压，也称流量控制，组织生产者发送过多消息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果节点崩溃或者离线，是否会有消息丢失
&lt;ul&gt;
&lt;li&gt;持久化需要写入磁盘，需要成本，在可以接收消息丢失的系统上，在同样的硬件上可以将获得更高的吞吐量和更低的延迟&lt;/li&gt;
&lt;li&gt;是否接收消息丢失取决于应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生产者与消费者之间的直接消息传递
&lt;ul&gt;
&lt;li&gt;UDP 组播广泛应用与金融行业，例如股票市场等低延迟场景&lt;/li&gt;
&lt;li&gt;无代理的消息库，过 TCP 或 IP 多播实现发布/订阅消息传递。&lt;/li&gt;
&lt;li&gt;使用不可靠的 UDP 消息传递&lt;/li&gt;
&lt;li&gt;消费者在网络上公开服务，则生产者可以直接发出 HTTP 或 RPC 请求以将消息推送给消费者&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;有限容错，消息丢失&lt;/li&gt;
&lt;li&gt;生产者和消费者都需要保持在线&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消息代理
&lt;ul&gt;
&lt;li&gt;它作为服务器运行，生产者和消费者作为客户端连接到它。&lt;/li&gt;
&lt;li&gt;生产者将消息写入代理，消费者通过从消息代理那里读取消息来接收消息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消息代理与数据库对比
&lt;ul&gt;
&lt;li&gt;而大多数消息代理在消息成功传递给消费者时就自动删除消息。这样的消息代理不适合长期的数据存储。&lt;/li&gt;
&lt;li&gt;消息代理的工作集很小，如果消费慢了就会占用很多内存，整体吞吐降低&lt;/li&gt;
&lt;li&gt;数据库支持二级索引和各种搜索数据的方式，消息代理采用订阅匹配特定模式的主题&lt;/li&gt;
&lt;li&gt;数据库查询基于数据快照，消息代理不支持查询&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多个消费者
&lt;ul&gt;
&lt;li&gt;负载均衡式
&lt;ul&gt;
&lt;li&gt;每一条消息都只被传递给其中一个消费者，所以消费者可以共享主题中处理消息的工作。代理可以任意分配消息给消费者。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;扇出式
&lt;ul&gt;
&lt;li&gt;每条消息都被传递给所有的消费者。扇出允许几个独立的消费者各自“收听”相同的消息广播，而不会相互影响，流相当于多个读取相同输入文件的不同批处理作业&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;确认和重新传递
&lt;ul&gt;
&lt;li&gt;消费者随时可能崩溃，消费者消费完事件后需要显式告知消息代理，消息代理才会从队列中删除&lt;/li&gt;
&lt;li&gt;消息代理重试时间导致事件发生顺序改变，如果消息之间存在因果关系会导致问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分区日志
&lt;ul&gt;
&lt;li&gt;将数据库的持久存储方居与消息传递的低延迟功能相结合&lt;/li&gt;
&lt;li&gt;基于日志的消息存储
&lt;ul&gt;
&lt;li&gt;日志是磁盘上一个仅支持追加式修改记录的序列，我们可以使用相同的结构来实现消息代理:生产者通过将消息追加到日志的末尾来发消息，消费者通过依次读取日志来接收消息。如果消费者读到日志的末尾，它就开始等待新消息被追加的通知。&lt;/li&gt;
&lt;li&gt;为了突破单个磁盘所能提供的带宽吞吐的上限，可以对日志进行分区。不同的节点负责不同的分区，使每个分区成为一个单独的日志，并且可以独立于其他分区读取和写入。然后可以将主题定义为一组分区，他们都携带相同类型的消息&lt;/li&gt;
&lt;li&gt;在每个分区中，代理为每个消息分配一个单调递增的序列号或偏移量。这样的序列号是非常有意义，因为分区只能追加，所以分区内的消息是完全有序的。不同分区之间则没有顺序保证。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对比日志与传统消息系统
&lt;ul&gt;
&lt;li&gt;都支持扇出式消息传递&lt;/li&gt;
&lt;li&gt;因为同一分区内的消息将被传递到同一节点，所以消费一个主题的节点数最多等于该主题中的日志分区数&lt;/li&gt;
&lt;li&gt;如果单个消息处理缓慢，则会阻碍该分区中的后续消息的处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消费者偏移量
&lt;ul&gt;
&lt;li&gt;顺序读取一个分区可以很容易地判断哪些消息已经被处理，代理不需要跟踪每条消息的确认，只需要定期记录消费者的偏移量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;磁盘空间使用
&lt;ul&gt;
&lt;li&gt;如果持续不断地追加日志，磁盘空间最终将被耗尽。为了回收磁盘空间，日志实际上是被分割成段，并且不时地将旧段删除或归档保存。&lt;/li&gt;
&lt;li&gt;如果一个消费者的速度慢到难以跟上消息产生的速度，并且远远落后以至于消费者偏移量指向了已经被删除的片段，那么消费者将会错过一些消息。实际上，日志实现了一个有限大小的缓冲区，当缓冲区变搞时，旧的消息就被丢弃，该缓冲区也被称为循环缓冲区或环形 缓冲区。由于该缓冲区在磁盘上，因此它可以非常大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当消费者跟不上生产者时
&lt;ul&gt;
&lt;li&gt;基于日志的方法是一种缓冲形式，它具有比较大的缓冲区&lt;/li&gt;
&lt;li&gt;当消费者明显落后消息时发出警报，让操作员有时间修复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重新处理信息
&lt;ul&gt;
&lt;li&gt;可以用旧的偏移量重新开启一个消费队列，并将输出写到不同的位置，以便重新处理最后一段时间的消息，通过改变处理代码可以多次重复此操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据库与流
&lt;ul&gt;
&lt;li&gt;保持数据同步
&lt;ul&gt;
&lt;li&gt;多数据系统数据一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;变更数据捕获
&lt;ul&gt;
&lt;li&gt;捕获数据库中的更改并不断将相同的更改应用于搜索索引。如果以相同顺序应用于更改日志，那么可以预期搜索索引中的数据与数据库中的数据匹配。搜索索引和任何其他派生的数据系统只是变更流的消费者&lt;/li&gt;
&lt;li&gt;实现变更数据捕获
&lt;ul&gt;
&lt;li&gt;我们可以调用日志消费者的派生数据，变更数据捕获机制可以确保对记录系统所做的所有更改都反映在派生数据系统中，以便派生系统具有数据的准确副本，从本质上讲，变更数据捕获使得一个数据库成为主节点，井将其他变成从节点。由于基于日志的消息代理保留了消息的排序，因此它非常适合从原数据库传输更改事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原始快照
&lt;ul&gt;
&lt;li&gt;如果有了数据库所有更改的日志，就可以通过 replay 日志来重建数据库的整个状态。构建新的全文索引需要整个数据库的完整副本，仅仅应用最近更改的日志还不够，因为它会丢失最近未更新的项目。因此，如果没有完整的日志历史记录，则需要从一致的快照开始，数据库的快照必须与更改日志中的已知位置或偏移量相对应，以便在快照处理完成后，知道在哪一点开始应用更改。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;日志压缩
&lt;ul&gt;
&lt;li&gt;存储引擎定期查找具有相同 key 的日志记录，丢弃所有的重复项，井且只保留每个 key 的最新的更新。这个压缩和合并的过程是在后台运行的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对变更流的 API 支持
&lt;ul&gt;
&lt;li&gt;数据库将关系数据模型中的输出流表示为表，该表支持事务插入元组，但不支持查询。输出流包含了向该特殊表提交写事务的元组日志，并严格按照事务提交顺序排序。外部消费者可以异步使用此日志并使用它来更新派生数据系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间溯源
&lt;ul&gt;
&lt;li&gt;在变更捕获中，CDC 记录了操作发生的顺序&lt;/li&gt;
&lt;li&gt;时间溯源中，应用程序逻辑基于写入事件日志的不可变事件构成。&lt;/li&gt;
&lt;li&gt;从事件日志导出当前状态
&lt;ul&gt;
&lt;li&gt;使用事件溯源的应用程序需要记录事件的日志，井将其转换为适合向用户显示的状态 。这种转换可以使用任意的逻辑，但它应该是确定性的，以便可以再次运行它并从事件日志中派生相同的应用程序状态。&lt;/li&gt;
&lt;li&gt;用于更新记录的 CDC 事件通常包含记录的全部新版本，因此 key 的当前值完全由该 key 的最近事件确定，井且日志压缩可以丢弃相同 key 之前的事件&lt;/li&gt;
&lt;li&gt;使用事件溯源在更高的层次上对事件建模: 事件通常用来表达用户行为的意图，而不是一种对行为结果进行相应状态更新的机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;命令和事件
&lt;ul&gt;
&lt;li&gt;事件溯源的哲学是小心的区分事件和命令。当来自用户的请求第一次到达时，它最初是一个命令:此时它可能仍然会失败，例如因为违反了某些完整性条件。应用程序必须首先验证它是否可以执行该命令。如果验证成功并且命令被接受，它将变成一个持久且不可变的事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;状态，流与不可变
&lt;ul&gt;
&lt;li&gt;事务日志记录了对数据库所做的所有更改。高速追加是更改日志的唯一方位。从这个角度来看，数据库的内容保存了日志中最新记录值的缓存。日志是事实。数据库是日志子集的缓存。该缓存子集恰好是来自日志的每个记录和索引值的最新值。&lt;/li&gt;
&lt;li&gt;日志压缩则是链接日志与数据库区别的一种方式。它仅保留每条记录的最新版本，井丢弃被覆盖的版本。&lt;/li&gt;
&lt;li&gt;不变事件的优势
&lt;ul&gt;
&lt;li&gt;恢复历史数据&lt;/li&gt;
&lt;li&gt;记录历史操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;相同的事件日志中派生出多个视图
&lt;ul&gt;
&lt;li&gt;通过从不变事件日志中分离可变状态，可以从相同的事件日志派生出多个面向读取的表示方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并发控制
&lt;ul&gt;
&lt;li&gt;事件捕获和变更数据捕获的最大缺点是事件日志的消费者通常是异步的，所以用户可能会写入日志，然后从日志派生的视图中读取，却发现这些写操作还没有反映在读取视图中&lt;/li&gt;
&lt;li&gt;一种解决方案是同步执行读取视图的更新，并将事件追加到日志中。这需要一个事务来将写入操作合并到一个原子单元中，所以要么需要将事件日志和读取视图保存在同一个存储系统中，要么需要跨不同系统的分布式事务。&lt;/li&gt;
&lt;li&gt;另一方面，从事件日志导出当前状态也简化了并发控制。对于多对象事务的大部分需求源自单个用户需要在不同地方改变数据的操作。通过事件溯源，可以设计一个事件，使其成为用户操作的独立描述。用户操作只需要在一个地方进行一次写操作，即将事件追加到日志中，这很容易使其原子化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不变形的限制
&lt;ul&gt;
&lt;li&gt;隐私，彻底删除数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流处理
&lt;ul&gt;
&lt;li&gt;三种处理
&lt;ul&gt;
&lt;li&gt;可以将事件中的数据写入数据库、缓存、搜索索引或者类似的存储系统，然后被其他客户端查询&lt;/li&gt;
&lt;li&gt;可以通过某种方式将事件推送给用户&lt;/li&gt;
&lt;li&gt;可以处理一个或多个输入流以产生一个或多个输出流。数据流可能会先经过由几个这样的处理阶段组成的流水线，最终在输出端结束&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流处理的适用场景
&lt;ul&gt;
&lt;li&gt;监控目的的流应用
&lt;ul&gt;
&lt;li&gt;信用风控&lt;/li&gt;
&lt;li&gt;金融交易监控&lt;/li&gt;
&lt;li&gt;机器状态监控&lt;/li&gt;
&lt;li&gt;军事情报系统报警&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;复杂事件处理
&lt;ul&gt;
&lt;li&gt;在流中搜索特定模式的事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流分析
&lt;ul&gt;
&lt;li&gt;测量某种类型事件的速率&lt;/li&gt;
&lt;li&gt;计算一段时间内某个值的攘动平均值&lt;/li&gt;
&lt;li&gt;将当前的统计数据与以前的时间间隔进行比较&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;维护物化视图
&lt;ul&gt;
&lt;li&gt;使用数据库更改流来保持派生数据系统与源数据库之间的同步，可以将这些示例视为一种维护物化视图的例子: 对某个数据集导出一个特定的试图以便高效查询，并在底层数据更改时自动更新该导出视图。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在流上搜索
&lt;ul&gt;
&lt;li&gt;需要基于一些复杂条件来搜索单个事件, 搜索流是把查询条件先保存下来，所有文档流过查询条件，筛选出结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消息传递和 RPC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流的时间问题
&lt;ul&gt;
&lt;li&gt;流处理系统经常需要和时间打交道，尤其是在用于分析目的时，这些分析通常使用时间窗口&lt;/li&gt;
&lt;li&gt;事件延迟处理会引发流处理各种问题，需要有介入处理这种问题&lt;/li&gt;
&lt;li&gt;混淆事件时间与处理时间会导致错误的结果，重启流处理系统倒是的事件积压，出现处理高峰&lt;/li&gt;
&lt;li&gt;什么时候准备就绪
&lt;ul&gt;
&lt;li&gt;无法确定是否完全收到特定窗口内所有的事件
&lt;ul&gt;
&lt;li&gt;忽略滞后的事件，丢失大量数据时报警&lt;/li&gt;
&lt;li&gt;发布一个更新，针对滞后事件的一个更新值。可能还需要收回以前的输出&lt;/li&gt;
&lt;li&gt;用一个特殊值来触发窗口处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;你用谁的钟
&lt;ul&gt;
&lt;li&gt;为了调整不正确的设备时钟，一种是方法是记录三个时间戳
&lt;ul&gt;
&lt;li&gt;根据设备的时钟，记录事件发生的时间。&lt;/li&gt;
&lt;li&gt;根据设备的时钟，记录将事件发送到服务器的时间。&lt;/li&gt;
&lt;li&gt;根据服务器时钟，记录服务器收到事件的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;窗口类型
&lt;ul&gt;
&lt;li&gt;轮转窗口
&lt;ul&gt;
&lt;li&gt;翻滚窗口长度固定，每个事件都属于一个窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;跳跃窗口
&lt;ul&gt;
&lt;li&gt;窗口长度固定，窗口之间有重叠以提供平滑过渡&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;滑动窗口
&lt;ul&gt;
&lt;li&gt;滑动窗口包含在彼此的某个间隔内发生的所有事件, 滑动窗口可以通过保留按时间排序的事件缓冲区井且在从窗口过期时移除旧事件来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;会话窗口
&lt;ul&gt;
&lt;li&gt;与其他窗口类型不同，会话窗口没有固定的持续时间。相反，它是通过将同一用户在时间上紧密相关的所有事件分组在一起而定义的，一旦用户在一段时间内处于非活动状态，则窗口结束。会话分析是网站分析中常见的一种需求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流式 join
&lt;ul&gt;
&lt;li&gt;流和流 join
&lt;ul&gt;
&lt;li&gt;搜索事件和点击事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流和表 join
&lt;ul&gt;
&lt;li&gt;流处理提前加载表的内容，在流处理时匹配相关 ID&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;表和表 join
&lt;ul&gt;
&lt;li&gt;流视图和流视图的 join，每当视图更新刷新 join 结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;join 的时间依赖性
&lt;ul&gt;
&lt;li&gt;不同流和分区之间的事件，顺序是如何确定的&lt;/li&gt;
&lt;li&gt;通常的做法是，当数据发生变化后赋予一个新的关联 ID&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流处理的容错
&lt;ul&gt;
&lt;li&gt;批处理容错方法可以确保批处理作业的输出与没有出错时的最终结果相同&lt;/li&gt;
&lt;li&gt;微批处理和校验点
&lt;ul&gt;
&lt;li&gt;将流分解成多个小块，并像小型批处理一样处理每个块。这种方法被称为微批处理&lt;/li&gt;
&lt;li&gt;Apache Flink 中使用了该方法的一个变体，它定期生成状态滚动检查点并将其写入持久化存储。如果流操作发生崩溃，它可以从最近的检查点重新启动，并丢弃在上一个检查点和崩溃之间生成的所有输出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重新审视原子提交
&lt;ul&gt;
&lt;li&gt;在出现故障时，为了看起来实现恰好处理了一次，我们需要确保当且仅当处理成功时，所有输出和副作用才会生效.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;幕等性
&lt;ul&gt;
&lt;li&gt;容等操作是可以多次执行的操作，并且它与只执行一次操作具有相同的效果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;故障后重建状态
&lt;ul&gt;
&lt;li&gt;任何需要状态的流处理，比如基于窗口的聚合以及表和索引的 join 操作，都必须确保在故障发生后状态可以恢复&lt;/li&gt;
&lt;li&gt;一种选择是将状态保存在远程存储中井采取复制，然而为每个消息去查询远程数据库可能会很慢。另一种方也是将状态在本地保存，并定期进行复制。之后，当流处理器从故障中恢复时，新任务可以读取副本的状态、井且在不丢失数据的情况下恢复处理。&lt;/li&gt;
&lt;li&gt;在某些情况下，甚至可能不需要复制状态，而是从输入流开始重建&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据系统的未来&#34;&gt;数据系统的未来&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每一个软件，即使是所谓的“通用”数据库，也都是针对特定的使用模式而设计的, 第一个挑战就是弄清楚软件产品与他们适合运行环境之间的对应关系&lt;/li&gt;
&lt;li&gt;在复杂的应用程序中，数据通常以多种不同的方式被使用。不太可能存在适用于所有不同环境的软件，因此你不可避免地要将几个不同的软件组合在一起，以提供应用程序的功能性。&lt;/li&gt;
&lt;li&gt;数据集成
&lt;ul&gt;
&lt;li&gt;采用派生数据来组合工具
&lt;ul&gt;
&lt;li&gt;许多应用程序需要结合两种或以上不同的工具来满足所有需求。&lt;/li&gt;
&lt;li&gt;数据集成的需求通常只有在缩小井考虑整个组织框架内数据流时才会变得更加凸显&lt;/li&gt;
&lt;li&gt;为何需要数据流
&lt;ul&gt;
&lt;li&gt;通过单个系统来决定所有输入的写入顺序，那么以相同的顺序处理写操作就可以更容易地派生出数据的其他表示形式&lt;/li&gt;
&lt;li&gt;无论是使用变更数据捕获还是事件获取日志，都不如简化总体顺序的原则重要&lt;/li&gt;
&lt;li&gt;根据事件日志来更新一个派生数据系统通常会比较好实现，并且可以实现确定性和幂等性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;派生数据与分布式事务
&lt;ul&gt;
&lt;li&gt;分布式事务通过使用锁机制进行互斥来决定写操作的顺序&lt;/li&gt;
&lt;li&gt;CDC 和事件源使用日志进行排序&lt;/li&gt;
&lt;li&gt;分布式事务使用原子提交来确保更改只生效一次&lt;/li&gt;
&lt;li&gt;基于日志的系统通常基于确定性重试和幕等性&lt;/li&gt;
&lt;li&gt;事务系统通常提供线性化，保证读自己的写一致性&lt;/li&gt;
&lt;li&gt;派生数据系统通常是异步更新的，所以默认情况下它们无法提供类似级别保证。&lt;/li&gt;
&lt;li&gt;作者认为基于日志的派生数据是集成不同数据系统的最有前途的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全局的局限
&lt;ul&gt;
&lt;li&gt;完全有序的日志需要一个主节点来决定排序，随着系统变大，越来越复杂时，瓶颈就开始出现了&lt;/li&gt;
&lt;li&gt;事件吞吐量大于单台的可处理上限时，需要分区到多个节点，不同分区之间的事件顺序难以保证&lt;/li&gt;
&lt;li&gt;如果服务器在不在的数据中心，数据同步效率效率低，通常每个数据中心都有自己的主节点，两个不同数据中心的事件顺序不确定。&lt;/li&gt;
&lt;li&gt;无状态的微服务之间不共享状态，两个事件来自不同的服务时，这些事件没有清楚的顺序。&lt;/li&gt;
&lt;li&gt;网络延迟甚至离线导致的数据不一致问题。&lt;/li&gt;
&lt;li&gt;设计突破单节点吞吐量甚至在广域地理环境分布的共识算能仍然是一个有待研究的开放性问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;排序事件以捕获因果关系
&lt;ul&gt;
&lt;li&gt;逻辑时间戳可以在无协调者情况下提供的全序关系，所以当全序关系广播不可行时可以用得上，但是，它们仍然需要接收者 去处理那些乱序事件，井且需要额外的元数据&lt;/li&gt;
&lt;li&gt;如果可以记录一条事件来标记用户在做决定以前所看到系统状态，并给该事件一个唯一的标识符，那么任何后续的事件都可以通过引用该事件标识符来记录因果关系&lt;/li&gt;
&lt;li&gt;冲突解决算法，可以处理异常顺序的事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;批处理和流处理集成
&lt;ul&gt;
&lt;li&gt;数据整合的目标是确保数据在所有正确的地方以正确的形式结束&lt;/li&gt;
&lt;li&gt;批处理的数据是已知的有限大小&lt;/li&gt;
&lt;li&gt;流处理运行在无界的数据集上&lt;/li&gt;
&lt;li&gt;一种类型的处理可以通过另一种类型来模拟，尽管性能特征有所不同。&lt;/li&gt;
&lt;li&gt;保持派生状态
&lt;ul&gt;
&lt;li&gt;批处理
&lt;ul&gt;
&lt;li&gt;倡导确定性&lt;/li&gt;
&lt;li&gt;纯函数操作，输出仅依赖输入&lt;/li&gt;
&lt;li&gt;输出不可变&lt;/li&gt;
&lt;li&gt;追加式输出结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流处理
&lt;ul&gt;
&lt;li&gt;除了批处理的特征&lt;/li&gt;
&lt;li&gt;扩展了操作来支持可管理的，容错的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拥有良好定义的输入和输出的确定性函数原理上不仅有利用容错，还简化了组织中数据流的推理&lt;/li&gt;
&lt;li&gt;从数据管道的角度来看，对于从一个事物派生出另一个事物，通过功能应用程序代码推动一个系统中的状态更改以及将这种效果应用到派生系统，都是有帮助的。&lt;/li&gt;
&lt;li&gt;为应用程序演化而重新处理数据
&lt;ul&gt;
&lt;li&gt;为维护系统提供了一个良好的机制，平滑支持新功能以及多变的需求&lt;/li&gt;
&lt;li&gt;通过重新处理，可以将数据集重组为一个完全不同的模型，以便更好地满足新要求。&lt;/li&gt;
&lt;li&gt;派生视图可以逐步演变，知道所有用户迁移到新视图，如果有风险，总有一个工作系统可以回退&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lambda 架构
&lt;ul&gt;
&lt;li&gt;Lambda 体系结构的核心思想是进来的数据以不可变事件形式追加写到不断增长的数据集，类似于事件源。基于这些总事件，可以派生出读优化的视图。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;统一批处理和流处理
&lt;ul&gt;
&lt;li&gt;支持以相同的处理引擎来处理最新事件和处理历史回放事件。&lt;/li&gt;
&lt;li&gt;支持只处理一次语义&lt;/li&gt;
&lt;li&gt;支持依据事件发生时间而不是处理时间进行窗口化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分拆数据库
&lt;ul&gt;
&lt;li&gt;编排多种数据存储技术
&lt;ul&gt;
&lt;li&gt;创建一个索引
&lt;ul&gt;
&lt;li&gt;数据库必须扫描表的一致性快照，挑选出所有被索引的字段值，对它们进行排序，然后得到索引。接下来，必须处理从一致性快照创建以来所累计的写入操作，完成后，只要有事务写入表中，数据库就必须持续保持索引处于最新状态。&lt;/li&gt;
&lt;li&gt;索引是现有数据的一个视图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;元数据库
&lt;ul&gt;
&lt;li&gt;联合数据库：统一端读
&lt;ul&gt;
&lt;li&gt;可以为各种各样的底层存储引擎和处理方法提供一个统一的查询接口:一种称为联合数据库或聚合存储的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分离式数据库：统一写端
&lt;ul&gt;
&lt;li&gt;在构建跨多个存储系统的数据库时，我们同样需要确保所有数据更改都会体现在所有正确的位置上，即使中间发生了某些故障。多个存储系统可以可靠地连接在一起&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分离式如何工作
&lt;ul&gt;
&lt;li&gt;基于日志的集成的一大优势是各个组件之间的松耦合，这体现在两个方面
&lt;ul&gt;
&lt;li&gt;在系统级别，异步事件流使整个系统在应对各个组件的中断或性能下降时表现更加稳健，日志可以慢慢消费且不会丢失。&lt;/li&gt;
&lt;li&gt;在人员角度看，分离式数据系统使得不同的团队可以独立的开发、改进和维护不同的软件组件和服务。专业化使得每个团队都可以专注于做好一件事情，且与其他系统维护清晰明确的接口，事件日志提供了一个足够强大的接口，不但能捕获相当强的一致性，同时也普遍适用于几乎任何类型的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分离式与集成式系统
&lt;ul&gt;
&lt;li&gt;目前形式的数据库不会被取代
&lt;ul&gt;
&lt;li&gt;维护流处理器中的状态仍然需要数据库&lt;/li&gt;
&lt;li&gt;专门的查询引擎对于特定的工作负载仍然很重要&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运行多个不同的基础架构所带来的复杂性可能确是一个问题
&lt;ul&gt;
&lt;li&gt;不同的学习曲线&lt;/li&gt;
&lt;li&gt;不同的配置&lt;/li&gt;
&lt;li&gt;不同的操作习惯&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单个集成的软件产品有可能确实在其针对的负载上表现更好，性能更可预测&lt;/li&gt;
&lt;li&gt;分离的目标是让你可以将多个不同的数据库组合起来，以便在更广泛的工作负载范围内实现比单一软件更好的性能&lt;/li&gt;
&lt;li&gt;当没有单一的软件能满足所有需求时，分离和组合的优势才会显现出来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;围绕数据流设计应用系统
&lt;ul&gt;
&lt;li&gt;应用程序代码作为派生函数
&lt;ul&gt;
&lt;li&gt;当某个数据集从另一个数据集派生而来时，它一定会经历某种转换函数
&lt;ul&gt;
&lt;li&gt;二级索引是一种派生的数据集，它具有一个简单的转换函数：对于主表中的每一行或者一个文档，挑选那些索引到的列或者字段值，并且按照值进行排序&lt;/li&gt;
&lt;li&gt;通过各种自然语言处理函数创建全文搜索索引，然后构建用于高效查找的数据结构&lt;/li&gt;
&lt;li&gt;在机器学习系统中，可以考虑通过应用各种特征提取和统计分析功能从训练数据中导出模型。&lt;/li&gt;
&lt;li&gt;缓存通常包含那些即将显式在用户界面的聚合数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用程序代码与状态分离
&lt;ul&gt;
&lt;li&gt;作者认为系统的某部分专注于持久性数据存储，同时有另外一部分专门负责运行应用程序代码是有道理的。这两部会有交互，但是各自仍保持独立运行。&lt;/li&gt;
&lt;li&gt;数据库充当一种可以通过网络同步访问的可变共享变量。应用程序可以读取或更新变量，数据库负责持久性，提供一些井发控制和容错功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据流: 状态变化和应用程序代码之间的相互影晌
&lt;ul&gt;
&lt;li&gt;当维护报生数据时，状态更改的顺序通常很重要，如果从事件日志中派生出了多个视图，每个试图都需要按照相同的顺序来处理这些事件，以使它们互相保持一致。&lt;/li&gt;
&lt;li&gt;容错性是派生数据的关键: 丢失哪怕单个消息都会导致派生数据集永远无法与数据源同步。消息传递和派生状态更新都必须可靠。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流式处理与服务
&lt;ul&gt;
&lt;li&gt;面向服务的结构优于单体应用程序之处在于松相合所带来的组织伸缩性: 不同的团队可以在不同的服务上工作，这减少了团队之间的协调工作&lt;/li&gt;
&lt;li&gt;数据流系统与微服务理念有很多相似的特征。但是，底层的通信机制差异很大:前者是单向、异步的消息流，而不是同步的请求/响应交互&lt;/li&gt;
&lt;li&gt;最快和最可靠的网络请求就是根本没有网络请求&lt;/li&gt;
&lt;li&gt;订阅变化的流，而不是在需要时去查询状态，使我们更接近类似电子表格那样的计算模型: 当某些数据发生更改时，依赖于此的所有派生数据都可以快速更新&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;观察派生状态
&lt;ul&gt;
&lt;li&gt;写路径和读路径涵盖了数据的整个过程，从数据收集到数据使用&lt;/li&gt;
&lt;li&gt;写路径可以看作是预计算的一部分，即一旦数据进入，即刻完成，无论是否有人要求访问它。&lt;/li&gt;
&lt;li&gt;过程中的读路径则只有当明确有人要求访问时才会发生。&lt;/li&gt;
&lt;li&gt;实体化视图与缓存
&lt;ul&gt;
&lt;li&gt;全文索引：写路径构建了索引，读路径不需要扫描全部文档&lt;/li&gt;
&lt;li&gt;缓存：对常见查询进行预计算，使这部分查询可以快速响应，其他的依然依靠索引，当添加新的数据时，视图也要随之更新&lt;/li&gt;
&lt;li&gt;它们主要是调整读、写路径之间的边界。通过预先计算结果，写路径上承担了更多的工作，而读路径则可以简化加速&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有状态，可离线客户端
&lt;ul&gt;
&lt;li&gt;SPA 应用支持很多有状态的功能，移动 app 也可以在本地保存很多状态，很多交互不需要和服务器通信。&lt;/li&gt;
&lt;li&gt;我们可以将设备上的状态视为服务器上的状态缓存。屏幕上的呈现是一种客户端对象模型的实体化视图;而客户端的对象模型则是远程数据中心在本地的状态副本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;状态更改推送至客户端
&lt;ul&gt;
&lt;li&gt;更新的 HTTP 协议支持从服务端推送事件到客户端，从而缩小两者之间状态的滞后程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;端到端的事件流
&lt;ul&gt;
&lt;li&gt;状态变化可以通过端到端的写路径流动：某个设备上交互行为触发了状态变化，通过事件日志、派生数据系统和流式处理等，一直到另一台设备上用户观察到状态。这些状态变化传播的延迟可以做到很低的水平，例如端到端只需一秒。&lt;/li&gt;
&lt;li&gt;为了将写路径扩展到最终用户，我们需要从根本上重新思考构建这些系统的方式:从请求/响应交互转向发布/订阅数据流&lt;/li&gt;
&lt;li&gt;更具晌应性的用户界面和更好的离线支持&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读也是事件
&lt;ul&gt;
&lt;li&gt;当写入和读取都被表示为事件，并且被路由到相同的 stream operator 统一处理时，我们实际上是在查询流和数据库之间执行 stream-table join 操作。读事件需要发送到保存数据的数据库分区节点上&lt;/li&gt;
&lt;li&gt;以日志方式记录读事件可能还可以帮助跟踪系统级别的事件因果关系和数据源: 它可以重建用户在做出某个决定之前看到的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多数据分区处理
&lt;ul&gt;
&lt;li&gt;对于仅涉及单个分区的查询，通过流来发送查询并收集响应事件流可能显得有些大材小用 。然而 ，这种方怯却开启了 一种分布式执行复杂查询的可能性，这需要合并来自多个分区的数据，并很好地借助底层流处理系统所提供的消息路由、分区和 join 功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;端到端的正确性
&lt;ul&gt;
&lt;li&gt;数据库的端到端争论
&lt;ul&gt;
&lt;li&gt;仅仅因为应用程序使用了具有较强安全属性的数据系统，并不能意味着应用程序一定保证没有数据丢失或损坏，应用程序的 bug 或从数据库删除数据&lt;/li&gt;
&lt;li&gt;Exactly-once 执行操作
&lt;ul&gt;
&lt;li&gt;使操作满足幂等性&lt;/li&gt;
&lt;li&gt;维护额外的元数据确保节点丢失和切换中必要的 fencing 措施。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重复消除
&lt;ul&gt;
&lt;li&gt;许多模式都需要重复消除&lt;/li&gt;
&lt;li&gt;TCP 采用序列号检测包丢失或重复，井最终确保数据包以正确的顺序接受，丢失的数据包都会被重新发送，并且在将数据交给应用程序之前，TCP 堆栈将负责删除重复的数据包。&lt;/li&gt;
&lt;li&gt;网络不佳的情况下，客户端和服务端之间的事件可能会丢失，客户端上再次操作会导致事件重复提交&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;标识操作符
&lt;ul&gt;
&lt;li&gt;可以为每个事件生成一个唯一的标识符号，确保在服务端每个事件只被执行一次&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;端到端的争论
&lt;ul&gt;
&lt;li&gt;底层的可靠性功能本身不足以确保端到端的正确性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在数据系统中采用端到端的思路
&lt;ul&gt;
&lt;li&gt;即使应用程序所使用的数据系统提供了比较强的安全属性，也并不意味着应用程序就一定没有数据丢失或损坏，应用程序本身也需要采取端到端的措施，例如重复消除。&lt;/li&gt;
&lt;li&gt;事务处理的代价很高，特别是在楼及异构存储技术时&lt;/li&gt;
&lt;li&gt;大多数的应用程序级别的容错机制无法正常工作导致了数据丢失或者损坏&lt;/li&gt;
&lt;li&gt;探索更好的容错抽象是很有必要的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;强制约束
&lt;ul&gt;
&lt;li&gt;唯一性约束需要达成共识
&lt;ul&gt;
&lt;li&gt;基于主节点做出所有的决策，就能够达成共识&lt;/li&gt;
&lt;li&gt;无法支持异步的多主节点复制，发生写冲突，无法保证值的唯一性&lt;/li&gt;
&lt;li&gt;单点失败，扩展性问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于日志的消息传递唯一性
&lt;ul&gt;
&lt;li&gt;日志机制可以确保所有消费者以相同的顺序查看消息，这种保证在形式上被称为全序关系广播，它等价于共识问题&lt;/li&gt;
&lt;li&gt;在基于日志的消息传递的分离式数据库系统中，我们可以采用非常类似的方法来保证唯一性约束&lt;/li&gt;
&lt;li&gt;任何可能冲突的写人都被路由到特定的分区并按顺序处理, 在每个分区内事件有唯一顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多分区请求处理
&lt;ul&gt;
&lt;li&gt;通过将多分区事务划分为两个不同分区的处理阶段，并使用端到端的请求 ID，实现了同样的正确性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实效性与完整性
&lt;ul&gt;
&lt;li&gt;实效性
&lt;ul&gt;
&lt;li&gt;时效性意味着确保用户观察到系统的最新状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;完整性
&lt;ul&gt;
&lt;li&gt;完整性意味着避免数据损坏，即没有数据丢失，也没有互相矛盾或错误的数据。尤其是，如果将某些派生数据集作为基础数据的视图来进行维护，派生必须做到正确, 如果完整性受到破坏, 这种不一致将是永久性的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据流系统的正确性
&lt;ul&gt;
&lt;li&gt;可靠的流处理系统可以在不需要分布式事务和原子提交协议的情况下保持完整性
&lt;ul&gt;
&lt;li&gt;将写入操作的内容表示为单条消息，可以轻松地采用原子方式编写，这种方法非常适合事件源&lt;/li&gt;
&lt;li&gt;使用确定性派生函数从该条消息报生所有其他状态的更新操作&lt;/li&gt;
&lt;li&gt;通过所有这些级别的处理来传递客户端生成的请求 ID，实现端到端重复消除和容等性。&lt;/li&gt;
&lt;li&gt;消息不可变，并支持多次重新处理派生数据，从而使错误恢复变得更容易&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;宽松的约束
&lt;ul&gt;
&lt;li&gt;传统的需要达成唯一性约束需要通过单节点汇聚所有分区事件实现&lt;/li&gt;
&lt;li&gt;很多应用程序采取了弱一致性
&lt;ul&gt;
&lt;li&gt;如果万一两个人同时注册了相同的用户名或预订了同一个座位，则可以向其中一个发送道歉消息，并要求他们选择另一个，这种纠正错误的措施被称为补偿性事务&lt;/li&gt;
&lt;li&gt;如果客户订购的商品超出当前库存，则可以追加补充库存，但需要为延误发货向客户道歉，并为他们提供折扣&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;很多场景中，实际上可以接受违反约束，通过后续的事务补偿来恢复最终的完整性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无需协调的数据系统
&lt;ul&gt;
&lt;li&gt;两种观察
&lt;ul&gt;
&lt;li&gt;数据流系统可以保证派生数据的完整性，无需原子提交，线性化或跨分区的同步协调。&lt;/li&gt;
&lt;li&gt;唯一性约束要求时效性和协调性，但是只要整体上保证完整性，即使发生暂时约束破坏，可以事后进行修复，因此许多应用实际上采用宽松式的约束并没有问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据流系统可以为应用提供数据管理服务而不需要协调，同时仍然提供强大的完整性保证。这种避免协调的数据系统具有很大的吸引力:与需要执行同步协调的系统相比，可以实现更好的性能和容错能力&lt;/li&gt;
&lt;li&gt;跨数据中心多主节点异步复制系统，任何一个节点都可以独立运行，实效性弱，完整性强&lt;/li&gt;
&lt;li&gt;同步协调只在有必要的时候使用&lt;/li&gt;
&lt;li&gt;另一种理解协调和约束的方毡是:它们减少了由于不一致而引发的道歉数量，但是也可能降低系统的性能与可用性，并由此可能增加由于业务中断而引发的道歉数量 。你不能将道歉减少到零，但是你可以根据自己的需求找到最佳的折中方案:选择一个合适点使得既不能有太多不一致，也不能出现太多可用性问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信任，但要确认
&lt;ul&gt;
&lt;li&gt;总会有一些违反假设的事情发生，硬件和软件，我们不能假设依赖的基础设施不会出错&lt;/li&gt;
&lt;li&gt;软件缺陷时的完整性
&lt;ul&gt;
&lt;li&gt;软件存在的 bug，无法通过校验和来捕获，一旦发现会造成数据的破坏，需要在设计，测试，代码检查方面经过大量的努力。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不要盲目信任承诺
&lt;ul&gt;
&lt;li&gt;硬件和软件并不能总是处于理想状态，数据损坏迟似乎只是迟早的事情而无也避免。因此，我们至少需要有办桂来查明数据是否已经损坏，以便之后修复这些数据，并试图找出错误的根掘。检查数据的完整性也被称为审计 。&lt;/li&gt;
&lt;li&gt;成熟的系统同样会考虑不太可能的事情出错的可能性，并且主动管理这种风险。&lt;/li&gt;
&lt;li&gt;如果想确保你的数据仍然在那，只能不断地去读取和检查。大多数情况下，情况一切正常，但万一发现异常，则越早发现问题越好。基于此，今早尝试从备份来恢复数据，否则当你丢失数据 ，你会发现连备份也已经破坏，那时将为时已晚。千万不要盲目地相信系统总是正常工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;验证的文化
&lt;ul&gt;
&lt;li&gt;许多人认为正确性的保证是绝对的，而没有为少见但可能的数据损坏而有所准备，作者希望将来会有更多的自我验证或自我审计系统，不断的检查自身的完整性，而不是依赖盲目的信任。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可审计性的设计
&lt;ul&gt;
&lt;li&gt;基于事件的系统可以提供更好的可审计性。在事件源方法中，用户对系统中的输入都被表示为一个单一的不可变事件，并且任何结果状态的更新都是依据该事件派生而来。派生可以很确定性的执行并且是可重复的，所以通过相同版本的派生代码来处理相同的事件日志将产生相同的状态更新。&lt;/li&gt;
&lt;li&gt;清楚地控制数据流可以使数据的来源管理更加清晰，从而使完整性检查更加可行&lt;/li&gt;
&lt;li&gt;对于事件日志，我们可以使用哈希校验来检查存储层是否发生数据破坏&lt;/li&gt;
&lt;li&gt;对于派生状态，我们可以重新运行对相同的事件日志执行的批处理和流处理，以检查是否得到相同的结果，甚至是并行运行一个冗余派生系统。&lt;/li&gt;
&lt;li&gt;确定的和定义清晰数据流也有助于系统调试和跟踪系统的操作，从而确定为什么发生了某些事情。如果中间发生了意外事件，可以提供诊断能力来重现导致意外事件的相同环境，这种精准复现历史时刻的调试能力将非常有价值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;端到端论点的再讨论
&lt;ul&gt;
&lt;li&gt;检查数据系统的完整性最好以端到端的方式进行:在完整性检查中所包含的系统部件越多，则过程中某些阶段发生无告警的数据破坏的概率就越少。如果我们可以检查整个派生系统流水线是端到端正确的，那么路径中的任何磁盘、网络、服务和算法已经全部囊括在内了。&lt;/li&gt;
&lt;li&gt;持续的端到端完整性检查可以提高你对系统正确性的信心，从而使你的发展速度更快&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;审计数据系统的工具
&lt;ul&gt;
&lt;li&gt;目前，将可审计性列为高优先级别关注的数据系统井不多。有些应用程序实现了内部的审计机制，例如将所有更改记录到单独的审计表中，但是保证审计日志的完整性和数据库状态仍然有些困难&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;做正确的事
&lt;ul&gt;
&lt;li&gt;每个系统的都有其构建目的，我们所采取的每一个行动都会产生有意或无意的后果。目的可能像赚钱一样简单，但对世界带来的影响可能远远超出我们的初衷。建立这些系统的工程师有责任仔细考虑这些后果，井有意识地决定我们想要生活在什么样的世界。&lt;/li&gt;
&lt;li&gt;许多数据集都是关于人的: 他们的行为、他们的兴趣和他们的身份。我们必须以人性和尊重来对待这些数据。用户也是人，人的尊严是最重要的。&lt;/li&gt;
&lt;li&gt;作者认为软件工程师如果只专注于技术而忽视其后果是不够的，道德责任也是我们要担起的责任。评判道德总是困难的，但它太重要了以至无论如何不能被忽视。&lt;/li&gt;
&lt;li&gt;预测性分析
&lt;ul&gt;
&lt;li&gt;通过大数据算法预测一个人的犯罪倾向，自动化的系统则有可能系统地、任意地排除某个人参与社会活动，而且是在这个人没有任何犯罪证据的情况下，井且对他/她来说几乎没有上诉的机会。&lt;/li&gt;
&lt;li&gt;偏见和歧视
&lt;ul&gt;
&lt;li&gt;算法做出的决定不一定比人类做得更好或更糟&lt;/li&gt;
&lt;li&gt;如果在算法的输入中存在系统性偏见，那么系统很可能吸收并在最终输出中放大这种偏见&lt;/li&gt;
&lt;li&gt;预测分析系统只是基于过去而推断，如果过去是有偏见的，它们就会把这种偏见编码下来。如果我们希望未来比过去更好，那么就需要道德想象力，而这只有人类才具备。数据和模型只应该是我们的工具，而不是我们的主人。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;责任与问责
&lt;ul&gt;
&lt;li&gt;基于机器学习的评分算法通常使用更广泛的输入范围，而且更加不透明，更难理解某个特定决策是如何发生的，以及是否有人受到不公正的对待&lt;/li&gt;
&lt;li&gt;盲目地相信数据至高无上不仅是误解的，而且是非常危险的 。随着数据驱动的决策变得越来越普遍，我们需要弄清楚如何使算陆更负责任和透明，如何避免强化现有的偏见，以及如何在错误不可避免时加以修复。&lt;/li&gt;
&lt;li&gt;我们还需要弄清楚如何防止数据被滥用，井努力发挥数据的正面作用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;反馈环路
&lt;ul&gt;
&lt;li&gt;当预测分析影响人们的生活时，特别是由于自我强化反馈环路而出现一些有害问题。由于不合适的假设，产生了这样一个隐藏在数学严谨性和数据的伪装背后的下降旋涡。&lt;/li&gt;
&lt;li&gt;我们不是总能预测什么时候发生这样的反馈环路。然而，通过思考整个系统可以预测许多后果，这是一种被称为系统思维 的方法。我们可以尝试理解一个数据分析系统是如何响应不同的行为、结构和特征。系统是否强化和扩大了人们之间存在的差异?还是试图打击不公平性? 即使有最好的意图，我们也必须小心意外的后果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据隐私与追踪
&lt;ul&gt;
&lt;li&gt;跟踪行为数据对于许多面向用户的在线服务变得越来越重要, 这些功能需要一定量的用户行为跟踪，井且用户也可以从中受益。但是，根据公司的商业模式，追踪往往不止于此。如果服务是通过广告获得资助的，那么广告主就是实际的客户，而用户的利益则是次要的。跟踪数据会更加详细，分析变得更加深入，数据也会被保留很长时间，以便为营销目去建立每个人的详细资 料。现在，公司和被收集数据的用户之间的关系开始变得和以往大不一样了。用户得到免费的服务，并尽可能地被引诱参与到服务中。对用户的追踪不再是服务与个人，而是服务于资助广告客户的需求。我认为这种关系可以用一个更阴暗的词来描述 : 监视。&lt;/li&gt;
&lt;li&gt;监视
&lt;ul&gt;
&lt;li&gt;当监控被用来确定生活中重要的事情，例如保险或就业等方面的东西时，它就开始变得不那么亲切了。此外，数据分析可以揭示出令人惊讶的侵入性的事情&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;赞成与选择的自由
&lt;ul&gt;
&lt;li&gt;用户几乎不知道什么样的个人数据会进入到数据库，或者数据是如何保留和处理的，大多数隐私政策的条款也极尽所能地搞得含混不清。不清楚他们的数据会发生什么，用户就不能给予任何有意义的认同。通常，来自用户的数据还被用到了不是该服务的用户身上，并且该用户根本就没有同意数据收集的任何条款。&lt;/li&gt;
&lt;li&gt;数据是通过单向过程从用户提取而来，而不是通过真正的互惠关系，也不是公平的价值交换。没有对话，用户无战选择提供多少数据以及他们会收到什么样的服务 :服务与用户之间的关系是非常不对称的 :这些条款是由服务提供商所设置，而不是由用户&lt;/li&gt;
&lt;li&gt;由于担心服务跟踪用户而决定拒绝使用，这只对极少数拥有足够的时间和知识来充分了解隐私政策的人群可以称得上是一种选择，并且他们可以不需要担心由此可能会失去某些机会而被迫参与这些服务。然而，对于处境较差的人来说，选择自由没有意义:对他们来说，被监视变得不可避免。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据隐私和使用
&lt;ul&gt;
&lt;li&gt;拥有隐私并不意味着一切事情都要保密:它意味着你可以自由选择向谁展示，并展示哪些东西，要公开什么，以及要保密什么。隐私权是一个决定权:每个人都能够决定在各种情况下如何在保密和透明之间取舍。这事关个人的自由和自主。&lt;/li&gt;
&lt;li&gt;这些公司最终选择对大部分数据继续保持私密，因为泄露数据会引起可怕的后果，井且会损害它们的商业模式。关于用户的隐私信息通常是间接地被泄露，例如借助数据分析，将广告投放给特定人群&lt;/li&gt;
&lt;li&gt;互联网服务使得在没有用户同意的情况下积累大量敏感信息更加容易，并且在用户不知情相关后果的前提下大规模地使用它。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据作为资产和权力
&lt;ul&gt;
&lt;li&gt;数据中介公司的存在也印证了个人数据是宝贵资产的说法，这个数据中间商是一个秘密行业，从事采购、汇总、分析、推 断和兜售侵入性个人数据，主要是为了营销目的。很多初创公司主要靠它们的用户量来估价。&lt;/li&gt;
&lt;li&gt;收集数据时，一定要综合考量&lt;/li&gt;
&lt;li&gt;此外，审视他人但避免自我审查是最重要的权力形式之一。尽管今天的科技公司并没有公开地寻求某些权力，但是它们所积累的数据和知识给了它们很大的控制权力，而且很多是在私下进行，不在公众监督之内。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;记住工业革命
&lt;ul&gt;
&lt;li&gt;数据是信息时代的关键性特征。互联网，数据存储，处理器和软件驱动的自动化正在对全球经济和人类社会产生重大影响。由此不由得联想到工业革命, 但工业革命也带来了注入环境污染，工人处境恶劣等一系列问题。&lt;/li&gt;
&lt;li&gt;正如工业革命存在需要被管理的黑暗面一样，向信息时代的过搜也有需要面对和解决的重大问题。作者相信收集和使用数据就是其中一个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;立法与自律
&lt;ul&gt;
&lt;li&gt;数据保护法可能有助于维护个人的权利&lt;/li&gt;
&lt;li&gt;从根本上说，我认为需要对针对个人数据的技术领域有观念上转变。我们应该停止过度以用户为衡量指标，牢记用户值得尊重。我们应该主动调整数据收集和处理流程，建立和维持与那些依赖我们软件的人们之间的信任关系。我们应该主动向用户介绍他们的数据如何使用，而不是让他们蒙在鼓里全然不知&lt;/li&gt;
&lt;li&gt;我们应该允许每个人维护自己的隐私，即控制自己的数据而不是通过监视来窃取他们的控制权&lt;/li&gt;
&lt;li&gt;我们不应该永远保留数据，一且不再需要，就尽快清除它们&lt;/li&gt;
&lt;li&gt;一个很有前途的方陆是通过加密协议来实施访问控制，而不仅仅是通过策略&lt;/li&gt;
&lt;li&gt;总的来说，观念与态度的变化都是必要的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>数据密集型应用系统设计::分布式数据系统</title>
      <link>/notes/designing_data_intensive_application_distributed_data/</link>
      <pubDate>Sun, 21 Mar 2021 21:57:43 +0800</pubDate>
      <guid>/notes/designing_data_intensive_application_distributed_data/</guid>
      <description>&lt;h2 id=&#34;分布式数据系统&#34;&gt;分布式数据系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;扩展性&lt;/li&gt;
&lt;li&gt;容错与高性能&lt;/li&gt;
&lt;li&gt;延迟考虑&lt;/li&gt;
&lt;li&gt;系统扩展能力
&lt;ul&gt;
&lt;li&gt;共享内存架构
&lt;ul&gt;
&lt;li&gt;成本增长过快&lt;/li&gt;
&lt;li&gt;无异地容错能力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共享磁盘架构
&lt;ul&gt;
&lt;li&gt;适用于数仓&lt;/li&gt;
&lt;li&gt;资源竞争和锁开销限制扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无共享结构
&lt;ul&gt;
&lt;li&gt;水平扩展&lt;/li&gt;
&lt;li&gt;扩展更加简单&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;复制与分区
&lt;ul&gt;
&lt;li&gt;复制
&lt;ul&gt;
&lt;li&gt;在多个节点保存相同的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分区
&lt;ul&gt;
&lt;li&gt;将一个大块头的数据库拆分成多个较小的子集&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据复制&#34;&gt;数据复制&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;目的
&lt;ul&gt;
&lt;li&gt;使数据在地理位置上更接近用户，从而降低访问延迟&lt;/li&gt;
&lt;li&gt;当部分组件出现位障，系统依然可以继续工作，从而提高可用性&lt;/li&gt;
&lt;li&gt;扩展至多台机器以同时提供数据访问服务，从而提高读吞吐量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三种复制方案
&lt;ul&gt;
&lt;li&gt;主从复制
&lt;ul&gt;
&lt;li&gt;工作原理
&lt;ul&gt;
&lt;li&gt;指定某一个副本为主副本(或称为主节点)。当客户写数据库时，必须将写请求首先发送给主副本，主副本首先将新数据写入本地存储&lt;/li&gt;
&lt;li&gt;其他副本全部称为从副本或称为从节点。主副本把新数据写入本地存储后，然后将数据更改作为复制的日志或更改流发送给所有从副本。每个从副本获得更改日志之后将其应用到本地，且严格保持与主副本相同的写入顺序。&lt;/li&gt;
&lt;li&gt;客户端从数据库中读数据时，可以在主副本或者从副本上执行查询。再次强调，只有主副本才可以接受写请求,从客户端的角度来看，从副本都是只读的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步复制与异步复制
&lt;ul&gt;
&lt;li&gt;同步复制数据强一致性，但是会阻塞后续的写操作&lt;/li&gt;
&lt;li&gt;异步响应速度快&lt;/li&gt;
&lt;li&gt;实践中把一个副节点设置为同步复制，其他副节点设置为异步复制，当主节点不可用时，提升另一个副节点到主节点&lt;/li&gt;
&lt;li&gt;全异步复制吞吐高，存在数据丢失问题，复制滞后问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配置新的从节点
&lt;ul&gt;
&lt;li&gt;在某个时间点对主节点的数据副本产生一个一致性快照，这样避免长时间锁定整个数据库&lt;/li&gt;
&lt;li&gt;将此快照拷贝到新的从节点&lt;/li&gt;
&lt;li&gt;从节点连接到主节点并请求快照点之后所发生的数据更改日志&lt;/li&gt;
&lt;li&gt;获得日志之后，从节点来应用这些快照点之后所有数据变更，这个过程称之为追赶。接下来，它可以继续处理主节点上新的数据变化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理节点失效
&lt;ul&gt;
&lt;li&gt;从节点失效
&lt;ul&gt;
&lt;li&gt;从节点根据复制日志，知道故障之前最后一笔事务，然后连接到主节点，请求那笔事务后面所有的数据变更。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主节点失效
&lt;ul&gt;
&lt;li&gt;确认主节点失效，心跳检测&lt;/li&gt;
&lt;li&gt;选举出新的主节点，共识算法&lt;/li&gt;
&lt;li&gt;重新配置系统使得新节点生效，原主节点重新上线后要降级成从节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;变数
&lt;ul&gt;
&lt;li&gt;使用异步复制丢失数据，主从切换过程中丢失数据&lt;/li&gt;
&lt;li&gt;其他依赖数据库的内容在一起使用&lt;/li&gt;
&lt;li&gt;集群脑裂&lt;/li&gt;
&lt;li&gt;不合适的超时检测&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;复制日志的实现
&lt;ul&gt;
&lt;li&gt;基于语句的复制
&lt;ul&gt;
&lt;li&gt;主节点记录所执行的每个写请求(操作语句)并将该操作语句作为日志发送给从节点&lt;/li&gt;
&lt;li&gt;问题
&lt;ul&gt;
&lt;li&gt;调用 date()，rand()等函数会在从节点产生不一样的值&lt;/li&gt;
&lt;li&gt;并发事务限制&lt;/li&gt;
&lt;li&gt;有副作用的语句会在不同的节点产生不同的副作用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于 WAL 传输
&lt;ul&gt;
&lt;li&gt;从节点收到日志进行处理，建立与主节点内容完全相同的数据副本&lt;/li&gt;
&lt;li&gt;问题
&lt;ul&gt;
&lt;li&gt;复制方案和存储引擎紧密耦合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于行的逻辑日志复制
&lt;ul&gt;
&lt;li&gt;关系数据库的逻辑日志通常是指一系列记录来描述数据表行级别的写请求
&lt;ul&gt;
&lt;li&gt;对于行插入，日志包含所有相关列的新值。&lt;/li&gt;
&lt;li&gt;对于行删除，日志里有足够的信息来唯一标识已删除的行，通常是靠主键，但如果表上没有定义主键，就需要记录所有列的旧值。&lt;/li&gt;
&lt;li&gt;对于行更新，日志包含足够的信息来唯一标识更新的行，以及所有列的新值(或至少包含所有已更新列的新值)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优势
&lt;ul&gt;
&lt;li&gt;与存储引擎结耦，更容易向后兼容&lt;/li&gt;
&lt;li&gt;容易解析，可以发送到外部数据源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于触发器的复制
&lt;ul&gt;
&lt;li&gt;触发器支持注册自己的应用层代码，使得当数据库系统发生数据更改(写事务)时自动执行上述自定义代码。通过触发器技术，可以将数据更改记录到一个单独的表中，然后外部处理逻辑访问该表，实施必要的自定义应用层逻辑，例如将数据更改复制到另一个系统。&lt;/li&gt;
&lt;li&gt;问题
&lt;ul&gt;
&lt;li&gt;开销大&lt;/li&gt;
&lt;li&gt;容易出错，有很多限制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;复制滞后问题
&lt;ul&gt;
&lt;li&gt;主从复制要求所有写请求经过主节点，而任何副节点只能接收只读查询。&lt;/li&gt;
&lt;li&gt;当从节点变多时，可以提高读请求的服务吞吐量，但是写请求吞吐变低&lt;/li&gt;
&lt;li&gt;副节点落后与主节点，读到过期数据，一段时间后达成最终一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解决复制滞后的问题
&lt;ul&gt;
&lt;li&gt;写后读一致性
&lt;ul&gt;
&lt;li&gt;如果用户访问可能会被修改的内容，从主节点读取;否则，在从节点读取&lt;/li&gt;
&lt;li&gt;客户端还可以记住最近更新时的时间戳 ，并附带在读请求中，据此信息，系统可以确保对该用户提供读服务时都应该至少包含了该时间戳的更新 。如果不够新，要么交由另一个副本来处理，要么等待直到副本接收到了最近的更新。
&lt;ul&gt;
&lt;li&gt;时间戳可以是逻辑时间戳或实际系统时钟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果副本分布在多数据中心，情况会更复杂些。必须先把请求路由到主节点所在的数据中心&lt;/li&gt;
&lt;li&gt;跟踪最近更新的时间，如果更新后一分钟之内，则总是在主节点读取;并监控从节点的复制滞后程度，避免从那些滞后时 间超过一分钟的从节点读取&lt;/li&gt;
&lt;li&gt;需要考虑的问题
&lt;ul&gt;
&lt;li&gt;记住用户上次更新时间戳的方法实现起来会比较困难，因为在一台设备上运行的代码完全无法知道在其他设备上发生了什么。此时，元数据必须做到全局共享&lt;/li&gt;
&lt;li&gt;如果副本分布在多数据中心, 无法保证来自不同设备的连接经过路由之后都到达同一个数据中心，需要想办法确保将来自不同设备的请求路由到同一个数据中心&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单调读
&lt;ul&gt;
&lt;li&gt;一个比强一致性弱，但比最终一致性强的保证。当读取数据时，单调读保证，如果某个用户依次进行多次读取，则他绝 不会看到回滚现象，即在读取较新值之后又发生读旧值的情况&lt;/li&gt;
&lt;li&gt;一种实现方法是每个用户总是从同一副本执行读取&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;前缀一致读
&lt;ul&gt;
&lt;li&gt;保证是说，对于一系列按照某个顺序发生的写请求，那么读取这些内容时也会按照当时写入的顺序&lt;/li&gt;
&lt;li&gt;一个解决方案是确保任何具有因果顺序关系的写入都交给一个分区来完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多主节点复制
&lt;ul&gt;
&lt;li&gt;单节点单点失败问题&lt;/li&gt;
&lt;li&gt;适用场景
&lt;ul&gt;
&lt;li&gt;多数据中心
&lt;ul&gt;
&lt;li&gt;在每个数据中心都配置主节点&lt;/li&gt;
&lt;li&gt;每个数据中心内，采用常规的主从复制方案&lt;/li&gt;
&lt;li&gt;数据中心之间，由各个数据中心的主节点来负责同其他数据中心的主节点进行数据的交换、更新&lt;/li&gt;
&lt;li&gt;与单节点的主从复制方案的区别
&lt;ul&gt;
&lt;li&gt;就近访问，降低写入延迟，异步同步到其他数据中心&lt;/li&gt;
&lt;li&gt;容忍数据中心失效，每个数据中心的主节点独立运行，失效主节点恢复后可以重新从其他主节点获取最新数据&lt;/li&gt;
&lt;li&gt;容忍网络问题，主从模式写入是同步操作，需要更可靠的网络性能，多主节点是异步复制，可以更好容忍不可靠的网络&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;离线客户端操作
&lt;ul&gt;
&lt;li&gt;应用在离线后还需要继续工作的
&lt;ul&gt;
&lt;li&gt;日历，笔记&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协作编辑
&lt;ul&gt;
&lt;li&gt;当一个用户编辑文档时，所做的更改会立即应用到本地副本，然后异步复制到服务器以及编辑同一文档的其他用户。&lt;/li&gt;
&lt;li&gt;如果要确保不会发生编辑冲突，则应用程序必须先将文档锁定，然后才能对其进行编辑。如果另一个用户想要编辑同一个文档，首先必须等到第一个用户提交修改并释放锁。这种协作模式相当于主从复制模型下在主节点上执行事务操作。&lt;/li&gt;
&lt;li&gt;为了加快协作编辑的效率，可编辑的粒度需要非常小。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理写冲突
&lt;ul&gt;
&lt;li&gt;在不同的数据中心修改统一记录，在数据中心内部完成写入，在跨数据中心同步的时候出现写冲突&lt;/li&gt;
&lt;li&gt;同步与异步冲突检测
&lt;ul&gt;
&lt;li&gt;同步冲突检测
&lt;ul&gt;
&lt;li&gt;等待写请求完成对所有副本的同步&lt;/li&gt;
&lt;li&gt;丧失多主的优势&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;避免冲突
&lt;ul&gt;
&lt;li&gt;在应用层保证对同一记录的写请求只通过同一个主节点&lt;/li&gt;
&lt;li&gt;由于主节点失效或者客户端漫游因为转到其他数据中心，此方法不再有效&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;收敛于一致状态的几个方案
&lt;ul&gt;
&lt;li&gt;给每个写入分配唯一的 ID，例如，一个时间戳，二个足够长的随机数，一个 UUID 或者一个基于键-值的哈希，挑选最高 ID 的写入作为胜利者，并将其他写入丢弃。如果基于时间戳，这种技术被称为最后写入者获胜。虽然这种方法很流行，但是很容易造成数据丢失。&lt;/li&gt;
&lt;li&gt;为每个副本分配一个唯一的 ID，并制定规则，例如序号高的副本写入始终优先于序号低的副本 。这种方法也可能会导致数据丢失。&lt;/li&gt;
&lt;li&gt;以某种方式将这些值合并在一起&lt;/li&gt;
&lt;li&gt;利用预定义好的格式来记录和保留冲突相关的所有信息，然后依靠应用层的逻辑，事后解决冲突&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自定义冲突解决逻辑
&lt;ul&gt;
&lt;li&gt;在写入时执行
&lt;ul&gt;
&lt;li&gt;只要数据库系统在复制变更日志时检测到冲突，就会调用应用层的冲突处理程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在读取时执行
&lt;ul&gt;
&lt;li&gt;当检测到冲突时，所有冲突写入值都会暂时保存下来。下一次读取数据时，会将数据的多个版本读返回给应用层。应用层可能会提示用户或自动解决冲突，并将最后的结果返回到数据库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动冲突解决
&lt;ul&gt;
&lt;li&gt;无冲突的数据结构&lt;/li&gt;
&lt;li&gt;可合并的持久数据结构，三向合并功能&lt;/li&gt;
&lt;li&gt;操作转换，为可同时编辑的有序列表设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拓扑结构
&lt;ul&gt;
&lt;li&gt;复制的拓扑结构描述了写请求从一个节点传播到其他节点的通信路径。&lt;/li&gt;
&lt;li&gt;多个主节点存在多个可能的同步的拓扑结构。
&lt;ul&gt;
&lt;li&gt;环形拓扑结构&lt;/li&gt;
&lt;li&gt;星型拓扑结构&lt;/li&gt;
&lt;li&gt;全部-至-全部型拓扑结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;环形和星形拓扑的问题是，如果某一个节点发生了故障，在修复之前，会影响其他节点之间复制日志的转发。&lt;/li&gt;
&lt;li&gt;全链接拓扑也存在一些自身的问题。主要是存在某些网络链路比其他链路更快的情况，从而导致复制日志之间的覆盖&lt;/li&gt;
&lt;li&gt;为了使得日志消息正确有序，可以使用一种称为版本向量的技术&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无主节点复制
&lt;ul&gt;
&lt;li&gt;选择放弃主节点，允许任何副本直接接受来自客户端的请求&lt;/li&gt;
&lt;li&gt;节点失效时写入数据库
&lt;ul&gt;
&lt;li&gt;半数写入确认即可认为写入成功，读取时从多个副本同时读取，按照版本号确定那个值是最新的&lt;/li&gt;
&lt;li&gt;读修复与反熵
&lt;ul&gt;
&lt;li&gt;失效节点上线后如何恢复错过的请求
&lt;ul&gt;
&lt;li&gt;读修复
&lt;ul&gt;
&lt;li&gt;当客户端并行读取多个副本时，可以检测到过期的返回值，然后将新值写入到该副本。这种方怯主要适合那些被频繁读取的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;反熵过程
&lt;ul&gt;
&lt;li&gt;数据存储用后台进程不断寻找副本之间的差异，将缺少的数据复制过去。如果没有反熵过程的存储系统只有在读的时候可以修复数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读写 quorum
&lt;ul&gt;
&lt;li&gt;如果有 n 个副本，写人需要 w 个节点确认，读取必须至少查询 r 个节点， 则只要 w + r &amp;gt; n ，读取的节点中一定会包含最新值，一个常见的选择是设置 n 为某奇数(通常为 3 或 5), w = r = (n + 1) / 2&lt;/li&gt;
&lt;li&gt;仲裁条件 w + r &amp;gt; n 定义了系统可容忍的失效节点数，如下所示:
&lt;ul&gt;
&lt;li&gt;当 w &amp;lt; n，如果一个节点不可用，仍然可以处理写入。&lt;/li&gt;
&lt;li&gt;当 r &amp;lt; n，如果一个节点不可用，仍然可以处理读取。&lt;/li&gt;
&lt;li&gt;假定 n=3, w=2, r=2，则可以容忍一个不可用的节点。&lt;/li&gt;
&lt;li&gt;假定 n=5, w=3, r=3，则可以容忍两个不可用的节点&lt;/li&gt;
&lt;li&gt;通常，读取和写入操作总是并行发送到所有的 n 个副本。参数 w 和参数 r 只是决定要等待的节点数。即有多少个节点需要返回结果，我们才能判断出结果的正确性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Quorum 一致性的局限性
&lt;ul&gt;
&lt;li&gt;w + r &amp;gt; n 一定可以读到最新值，但是不一定要多数，只要读写之间有重叠就可以，可以等待更少的时间就可以返回。&lt;/li&gt;
&lt;li&gt;即使 w + r &amp;gt; n 也可能读到旧值：
&lt;ul&gt;
&lt;li&gt;如果采用了 sloppy quorum，写操作的 w 节点和读取的 r 节点可能完全不同，因此无法保证读写请求一定存在重叠的节点&lt;/li&gt;
&lt;li&gt;如果两个写操作同时发生，则无法明确先后顺序，需要根据时间戳来确定胜者，但由于时钟偏差问题，某些写入可能会被错误的抛弃&lt;/li&gt;
&lt;li&gt;如果写操作与读操作同时发生 ，写操作可能仅在一部分副本上完成。此时，读取时返回旧值还是新值存在不确定性。&lt;/li&gt;
&lt;li&gt;如果某些副本上已经写入成功，而其他一些副本发生写入失败，且总的成功副本数少于 w，那些已成功的副本上不会做回滚。这意味着尽管这样的写操作被视为失败，后续的读操作仍可能返回新值。&lt;/li&gt;
&lt;li&gt;如果具有新值的节点后来发生失效，但恢复数据来自某个旧值， 则总的新值副本数会低于 w，这就打破了之前的判定条件&lt;/li&gt;
&lt;li&gt;即使一切正常工作，也会出现一些边界情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;监控旧值
&lt;ul&gt;
&lt;li&gt;即使应用可以容忍旧值，也需要了解复制当前的运行状态，如果出现了明显的滞后，它就是个重要的信号提醒我们需要采取必要的措施来排查原因。&lt;/li&gt;
&lt;li&gt;对于主从复制的系统，由于主节点和从节点上写人都遵从相同的顺序，而每个节点都维护了复制日志执行的当前偏移量。通过对比主节点和从节点当前偏移量的差值，即可衡量该从节点落后于主节点的程度&lt;/li&gt;
&lt;li&gt;对于无主节点的系统，还没有一个可用的方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;宽松的 quorum 与数据回传
&lt;ul&gt;
&lt;li&gt;当客户端连不上存储节点时，把数据写入一个可访问的节点，这个节点不在 n 的结合中，等到恢复后，把这个数据的节点回传到 n 原始节点中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多数据中心操作
&lt;ul&gt;
&lt;li&gt;副本的数量 n 是包含所有数据中心的节点总数。配置时，可以指定每个数据中心各有多少副本。每个客户端的写入都会发送到所有副本，但客户端通常只会等待来自本地数据中心内的 quorum 节点数的确认，这样避免了高延迟和跨数据中心可能的网络异常。尽管可以灵活配置，但对远程数据中心的写入由于延迟很高，通常都被配置为异步方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;检测并发写
&lt;ul&gt;
&lt;li&gt;最后写入者获胜
&lt;ul&gt;
&lt;li&gt;数据带上时间戳，丢弃较早的写入，牺牲了数据持久性，如果不能接收丢失数据的话，可以为每一次写入分配 UUID 主键&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Happen-before 关系和并发
&lt;ul&gt;
&lt;li&gt;如果一个操作无能意识到另一个操作，那么旧可以称他们时并发操作&lt;/li&gt;
&lt;li&gt;确定前后关系
&lt;ul&gt;
&lt;li&gt;服务器为每个主键维护一个版本号，每当主键新值写入时递增版本号，并将新版本号与写入的值一起保存。&lt;/li&gt;
&lt;li&gt;当客户端读取主键时，服务器将返回所有当前值以及最新的版本号。且要求写之前，客户必须先发送读请求。&lt;/li&gt;
&lt;li&gt;客户端写主键，写请求必须包含之前读到的版本号、读到的值和新值合并后的集合。写请求的响应可以像读操作一样，会返回所有当前值，这样就可以像购物车例子那样一步步链接起多个写入的值。&lt;/li&gt;
&lt;li&gt;当服务器收到带有特定版本号的写入时，覆盖该版本号或更低版本的所有值，但必须保存更高版本号的所有值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;合并同时写入的值
&lt;ul&gt;
&lt;li&gt;一个简单的方法是基于版本号或时间戳来选择其中的一个值，但这意味着会丢失部分数据。所以，需要在应用程序代码中额外做些工作。&lt;/li&gt;
&lt;li&gt;考虑到在应用代码中合并非常复杂且容易出错，因此可以设计一些专门的数据结构来自动执行合并，例如， Riak 支持称为 CRDT 一系列数据结构，以合理的方式高效自动合并，包括支持删除标记。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;版本矢量
&lt;ul&gt;
&lt;li&gt;当多个副本同时接受写入时，我们需要为每个副本和每个主键均定义一个版本号。每个副本在处理写入时增加自己的版本号，并且跟踪从其他副本看到的版本号。通过这些信息来指示要覆盖哪些值、该保留哪些并发值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据分区&#34;&gt;数据分区&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;面对一些海量数据集或非常高的查询压力，复制技术还不够，我们还需要将数据拆分成为分区，也称为分片&lt;/li&gt;
&lt;li&gt;分区通常是这样定义的，即每一条数据(或者每条记录，每行或每个文档)只属于某个特定分区&lt;/li&gt;
&lt;li&gt;采用数据分区的主要目的是提高可扩展性。不同的分区可以放在一个无共享集群的不同节点上。这样一个大数据集可以分散在更多的磁盘上，查询负载也随之分布到更多的处理器上。&lt;/li&gt;
&lt;li&gt;对单个分区进行查询时，每个节点对自己所在分区可以独立执行查询操作，因此添加更多的节点可以提高查询吞吐量。超大而复杂的查询尽管比较困难，但也可能做到跨节点的并行处理。&lt;/li&gt;
&lt;li&gt;数据分区与数据复制
&lt;ul&gt;
&lt;li&gt;分区通常与复制结合使用，即每个分区在多个节点都存有副本。这意味着某条记录属于特定的分区，而同样的内容会保存在不同的节点上以提高系统的容错性。&lt;/li&gt;
&lt;li&gt;一个节点可能即是某些分区的主副本，同时又是其他分区的从副本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;键-值数据的分区
&lt;ul&gt;
&lt;li&gt;分区的主要目标是将数据和查询负载均匀分布在所有节点上&lt;/li&gt;
&lt;li&gt;分区不均匀，则会出现某些分区节点比其他分区承担更多的数据量或查询负载，称之为倾斜。&lt;/li&gt;
&lt;li&gt;负载严重不成比例的分区即成为系统热点&lt;/li&gt;
&lt;li&gt;基于关键字区间分区
&lt;ul&gt;
&lt;li&gt;为每个分区分配一段连续的关键字或者关键宇区间范围，如果知道关键字区间的上下限，就可以轻松确定那个分区包含这些关键字。如果还知道哪个分区分配在哪个节点，就可以直接向该节点发出请求&lt;/li&gt;
&lt;li&gt;为了更均匀地分布数据，分区边界理应适配数据本身的分布特征&lt;/li&gt;
&lt;li&gt;每个分区内可以按照关键字排序保存，这样可以轻松支持区间查询，即将关键字作为一个拼接起来的索引项从而一次查询得到多个相关记录&lt;/li&gt;
&lt;li&gt;分区热点问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于关键字哈希值分区
&lt;ul&gt;
&lt;li&gt;一个好的哈希函数可以处理数据倾斜并使其均匀分布&lt;/li&gt;
&lt;li&gt;丧失了良好的区间查询特性&lt;/li&gt;
&lt;li&gt;Cassandra 中的表可以声明为由多个列组成的复合主键。复合主键只有第一部分可用于哈希分区，而其他列则用作组合索引来对 Cassandra SSTable 中的数据进行排序&lt;/li&gt;
&lt;li&gt;基于哈希的分区方法可以减轻热点，但是无法做到完全避免。&lt;/li&gt;
&lt;li&gt;一个简单的解决方法是对这小部分热点数据添加随机数再次分区，缺点是查询时需要查询所有分区再做合并。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分区与二级索引
&lt;ul&gt;
&lt;li&gt;基于文档的二级索引
&lt;ul&gt;
&lt;li&gt;每个列表都有一个唯一的文档 ID，用此 ID 对数据库进行分区&lt;/li&gt;
&lt;li&gt;每个分区完全独立，各自维护自己的二级索引&lt;/li&gt;
&lt;li&gt;二级索引的查询代价高昂，容易导致读延迟显著放大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于此条的二级索引分区
&lt;ul&gt;
&lt;li&gt;对所有的数据构建全局索引，而不是每个分区维护自己的本地索引&lt;/li&gt;
&lt;li&gt;全局索引也必须进行分区，且可以与数据关键字采用不同的分区策略&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分区再平衡
&lt;ul&gt;
&lt;li&gt;查询压力增加，因此需要更多的 CPU 来处理负载&lt;/li&gt;
&lt;li&gt;数据规模增加，因此需要更多的磁盘和内存来存储数据&lt;/li&gt;
&lt;li&gt;节点可能出现故障，因此需要其他机器来接管失效的节点&lt;/li&gt;
&lt;li&gt;所有这些变化都要求数据和请求可以从一个节点转移到另一个节点。这样一个迁移负载的过程称为再平衡&lt;/li&gt;
&lt;li&gt;需求
&lt;ul&gt;
&lt;li&gt;平衡之后，负载、数据存储、读写请求等应该在集群范围更均匀地分布。&lt;/li&gt;
&lt;li&gt;再平衡执行过程中，数据库应该可以继续正常提供读写服务。&lt;/li&gt;
&lt;li&gt;避免不必要的负载迁移，以加快动态再平衡，并尽量减少网络和磁盘 I/O 影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态再平衡策略
&lt;ul&gt;
&lt;li&gt;节点增加时，取模再平衡导致频繁的数据迁移&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;固定数量的分区
&lt;ul&gt;
&lt;li&gt;首先创建远超实际节点数的分区数，然后为每个节点分配多个分区。&lt;/li&gt;
&lt;li&gt;接下来，如果集群中添加了一个新节点，该新节点可以从每个现有的节点上匀走几个分区，直到分区再次达到全局平衡&lt;/li&gt;
&lt;li&gt;分区的数量再创建数据库时就确定好，原则上可以拆分和合并&lt;/li&gt;
&lt;li&gt;需要分区规模和数据规模相适应&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态分区
&lt;ul&gt;
&lt;li&gt;每个分区总是分配给一个节点，而每个节点可以承载多个分区，这点与固定数量的分区一样。当一个大的分区发生分裂之后，可以将其中的一半转移到其他某节点以平衡负载。&lt;/li&gt;
&lt;li&gt;分区数量可以自动适配数据总量
&lt;ul&gt;
&lt;li&gt;少量的数据，少量的分区就足够了&lt;/li&gt;
&lt;li&gt;大量的数据，每个分区的大小则被限制在一个可配的最大值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按节点比例分区
&lt;ul&gt;
&lt;li&gt;每个节点具有固定数量的分区。此时，当节点数不变时，每个分区的大小与数据集大小保持正比的增长关系;当节点数增加时，分区则会调整变得更小。较大的数据量通常需要大量的节点来存储，因此这种方式也使每个分区大小保持稳定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全自动的平衡会出现难以预测的结果，将自动平衡与自动故障相结合也可能存在一定风险，让管理员介入再平衡是个更好的选择&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;请求路由
&lt;ul&gt;
&lt;li&gt;允许客户端链接任意的节点。如果某节点恰好拥有所请求的分区，则直接处理该请求:否则，将请求转发到下一个合适的节点，接收答复，并将答复返回给客户端。&lt;/li&gt;
&lt;li&gt;将所有客户端的请求都发送到一个路由层，由后者负责将请求转发到对应的分区节点上&lt;/li&gt;
&lt;li&gt;客户端感知分区和节点分配关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并行查询执行
&lt;ul&gt;
&lt;li&gt;典型的数据仓库查询包含多个联合、过滤、分组和聚合操作。MPP 查询优化器会将复杂的查询分解成许多执行阶段和分区，以便在集群的不同节点上并行执行。尤其是涉及全表扫描这样的查询操作，可以通过并行执行获益颇多。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;事务&#34;&gt;事务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;出错
&lt;ul&gt;
&lt;li&gt;数据库软件或硬件可能会随时失效(包括正在执行写操作的过程中)。&lt;/li&gt;
&lt;li&gt;应用程序可能随时崩溃(包括一系列操作执行到中间某一步)。&lt;/li&gt;
&lt;li&gt;应用与数据库节点之间的链接可能随时会中断，数据库节点之间也存在同样问题。&lt;/li&gt;
&lt;li&gt;多个客户端可能同时写入数据库 ，导致数据覆盖。&lt;/li&gt;
&lt;li&gt;客户端可能读到一些无意义的、部分更新的数据。&lt;/li&gt;
&lt;li&gt;客户端之间由于边界条件竞争所引入的各种奇怪问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;深入理解事务
&lt;ul&gt;
&lt;li&gt;ACID
&lt;ul&gt;
&lt;li&gt;原子性(Atomicity)
&lt;ul&gt;
&lt;li&gt;在出错时中止事务，并将部分完成的写入全部丢弃。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一致性(Consistency)
&lt;ul&gt;
&lt;li&gt;指对数据有特定的预期状态，任何数据更改必须满足这些状态约束(或者恒等条件)&lt;/li&gt;
&lt;li&gt;如果某事务从一个有效的状态开始，并且事务中任何更新操作都没有违背约束，那么最后的结果依然符合有效状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;隔离性(Isolation)
&lt;ul&gt;
&lt;li&gt;并发执行的多个事务相互隔离，它们不能互相交叉，数据库系统要确保当事务提交时，其结果与串行执行完全相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;持久性(Durability)
&lt;ul&gt;
&lt;li&gt;提供一个安全可靠的地方来存储数据而不用担心数据丢失，一且事务提交成功，即使存在硬件故障或数据库崩溃，事务所写入的任何数据也不会消失&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单对象和多对象事务操作
&lt;ul&gt;
&lt;li&gt;单对象写入
&lt;ul&gt;
&lt;li&gt;基于日志恢复实现原子性，对每个对象采取加锁的方式来实现隔离&lt;/li&gt;
&lt;li&gt;通常意义上的事务针对的是多个对象，将多个操作聚合为一个逻辑执行单元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多对象事务的必要性
&lt;ul&gt;
&lt;li&gt;当出现跨分区时，多对象事务非常难以正确实现，同时在高可用或者极致性能的场景下也会带来很多负面影响&lt;/li&gt;
&lt;li&gt;没有原子性保证时，错误处理就会异常复杂，而缺乏隔离性则容易出现并发性方面的各种奇怪问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理错误与中止
&lt;ul&gt;
&lt;li&gt;如果存在违反原子性、隔离性或持久性的风险，则完全放弃整个事务，而不是部分放弃。&lt;/li&gt;
&lt;li&gt;支持安全的重试机制才是中止流程的重点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;弱隔离级别
&lt;ul&gt;
&lt;li&gt;某个事务修改数据而另一个事务同时要读取该数据，或者两个事务同时修改相同数据时，才会引发并发问题&lt;/li&gt;
&lt;li&gt;可串行化的隔离会严重影响性能，而许多数据库却不愿意牺牲性能，因而更多倾向于采用较弱的隔离级别，它可以防止某些但并非全部的并发问题&lt;/li&gt;
&lt;li&gt;RC
&lt;ul&gt;
&lt;li&gt;读数据库时，只能看到已成功提交的数据&lt;/li&gt;
&lt;li&gt;写数据库时，只会覆盖已成功提交的数据&lt;/li&gt;
&lt;li&gt;脏读
&lt;ul&gt;
&lt;li&gt;一个事物写入部分数据，但是没有提交，另一个事务可以看到尚未提交的数据，意味着出现了脏读&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;防止脏读
&lt;ul&gt;
&lt;li&gt;如果事务需要更新多个对象，脏读意味着另一个事物可能会看到部分实现&lt;/li&gt;
&lt;li&gt;事务中止，所有写入操作需要回滚，脏读导致另一个事务读取到需要被回滚的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;防止脏写
&lt;ul&gt;
&lt;li&gt;后面的事务覆盖前面事务对同一个值的修改，RC 隔离级别可以防止脏写，通常的方法是推迟第二个写请求，知道前面的事务完成提交。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现 RC
&lt;ul&gt;
&lt;li&gt;数据库通常采用行级锁来防止脏写:当事务想修改某个对象时，它必须首先获得该对象的锁;然后一直持有锁直到事务提交(或中止)&lt;/li&gt;
&lt;li&gt;同样采用行锁来防止脏读:所有试图读取该对象的事务必须先申请锁，事务完成后释放锁。从而确保不会发生读取一个脏的、未提交的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快照隔离级别与 RR
&lt;ul&gt;
&lt;li&gt;RC 存在不可重复读的问题，在同一事物的多次读取中读到不同的值&lt;/li&gt;
&lt;li&gt;场景
&lt;ul&gt;
&lt;li&gt;备份&lt;/li&gt;
&lt;li&gt;分析查询与完整性检查场景&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;总体想法
&lt;ul&gt;
&lt;li&gt;每个事务都从数据库的一致性快照中读取，事务一开始所看到是最近提交的数据，即使数据随后可能被另一个事务更改，但保证每个事务都只看到该特定时间点的旧数据。&lt;/li&gt;
&lt;li&gt;快照级别隔离对于长时间运行的只读查询(如备份和分析)非常有用。如果数据在执行查询的同时还在发生变化，那么查询结果对应的物理含义就难以理清。而如果查询的是数据库在某时刻点所冻结的一致性快照，则查询结果的含义非常明确。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现快照级别隔离
&lt;ul&gt;
&lt;li&gt;与读-提交隔离类似，快照级别隔离的实现通常采用写锁来防止脏写，这意味着正在进行写操作的事务会阻止同一对象上的其他事务&lt;/li&gt;
&lt;li&gt;读取时不需要加锁，这使得数据库在写入的同时不会影响长时间的只读查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多版本并发控制
&lt;ul&gt;
&lt;li&gt;考虑到多个正在进行的事务可能会在不同的时间点查看数据库状态，所以数据库保留了对象多个不同的提交版本&lt;/li&gt;
&lt;li&gt;实现快照级别隔离
&lt;ul&gt;
&lt;li&gt;事务开始时，首先赋予一个唯一的、单调递增的事务 ID(txid)。每当事务向数据库写入新内容时，所写的数据都会被标记写入者的事务 ID。表中的每一行都有一个 created_by 字段，其中包含了创建该行的事务 ID。每一行还有一个 deleted_by 字段，初始为空。如果事务要删除某行，主行实际上并未从数据库中删除，而只是将 deleted_by 字段设置为请求删除的事务 ID 。事后，当确定没有其他事务引用该标记删除的行时，数据库的垃圾回收进程才去真正删除并释放存储空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一致性快照的可见性规则
&lt;ul&gt;
&lt;li&gt;每笔事务开始时，数据库列出所有当时尚在进行中的其他事务，然后忽略这些事务完成的部分写入，即不可见。&lt;/li&gt;
&lt;li&gt;所有中止事务所做的修改全部不可见&lt;/li&gt;
&lt;li&gt;较晚事务 ID 所做的任何修改不可见，不管这些事务是否完成了提交。&lt;/li&gt;
&lt;li&gt;除此之外，其他所有的写入都对应用查询可见&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可见性条件
&lt;ul&gt;
&lt;li&gt;事务开始的时刻，创建该对象的事务已经完成了提交&lt;/li&gt;
&lt;li&gt;对象没有被标记为删除; 或者即使标记了，但删除事务在当前事务开始时还没有完成提交&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;索引与快照隔离级别
&lt;ul&gt;
&lt;li&gt;一种方案是索引直接指向对象的所有版本，然后想办法过滤对当前事务不可见的那些版本。当后台的垃圾回收进程决定删除某个旧对象版本时，对应的索引条目也需要随之删除&lt;/li&gt;
&lt;li&gt;另一种追加/写时复制的技术，当需要更新时，不会修改现有的页面，而总是创建一个新的修改副本，拷贝必要的内容，然后让父结点，或者递归向上直到树的 root 结点都指向新创建的结点。那些不受更新影响的页面都不需要复制，保持不变并被父结点所指向&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可重复读与命名混淆
&lt;ul&gt;
&lt;li&gt;快照级别隔离对于只读事务特别有效。但是，具体到实现，许多数据库却对它有着不同的命名。Oracle 称之为可串行化，PostgreSQL 和 MySQL 则称为可重复读&lt;/li&gt;
&lt;li&gt;SQL 标准对隔离级别的定义还是存在一些缺陷，某些定义模棱两可，不够精确，且不能做到与实现无关。尽管有几个数据库实现了可重复读，表面上看符合标准，但它们实际所提供的保证却大相径庭&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;防止更新丢失
&lt;ul&gt;
&lt;li&gt;应用程序从数据库读取某些值，根据应用逻辑做出修改，然后写回新值。 当有两个事务在同样的数 据对象上执行类似操作时，由于隔离性，第二个写操作并不包括第一个事务修改后的值，最终会导致第一个事务的修改值可能会丢失&lt;/li&gt;
&lt;li&gt;几种解决方案
&lt;ul&gt;
&lt;li&gt;原子写操作
&lt;ul&gt;
&lt;li&gt;原子操作通常采用对读取对象加独占锁的方式来实现，这样在更新被提交之前不会其他事务可以读它。这种技术有时被称为游标稳定性。另一种实现方式是强制所有的原子操作都在单线程上执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;显示加锁
&lt;ul&gt;
&lt;li&gt;FOR UPDATE 指令指示数据库对返回的所有结果行要加锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动检测更新丢失
&lt;ul&gt;
&lt;li&gt;先让他们并发执行，但如果事务管理器检测到了更新丢失风险，则会中止当前事务，并强制回退到安全的“读-修改-写回”方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原子比较与设置
&lt;ul&gt;
&lt;li&gt;UPDATE wiki_pages SET content = &amp;lsquo;new content&amp;rsquo; WHERE id = 1234 AND content = &amp;lsquo;old content&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;冲突解决与复制
&lt;ul&gt;
&lt;li&gt;对于多副本数据库，加锁和原子不再有效，通常采用异步的方式来更新，目前许多多副本数据库采用 LWW 策略，但是容易丢失更新&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;写倾斜与幻读
&lt;ul&gt;
&lt;li&gt;即如果两个事务读取相同的一组对象，然后更新其中一部分: 不同的事务可能更新不同的对象，则可能发生写倾斜; 而不同的事务如果更新的是同一个对象，则可能发生脏写或更新丢失&lt;/li&gt;
&lt;li&gt;先前方案的限制
&lt;ul&gt;
&lt;li&gt;单对象的原子操作无效&lt;/li&gt;
&lt;li&gt;自动检测不支持检测写倾斜&lt;/li&gt;
&lt;li&gt;数据库不支持此约束&lt;/li&gt;
&lt;li&gt;一个较优的选择是显示对依赖的数据加锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在一个事务中的写入改变了另一个事务查询结果的现象，称为幻读&lt;/li&gt;
&lt;li&gt;快照级别隔离可以避免只读查询时的幻读，但是对于我们上面所讨论那些读-写事务，它却无法解决棘手的写倾斜问题。&lt;/li&gt;
&lt;li&gt;实体化冲突
&lt;ul&gt;
&lt;li&gt;如果查询结果没有对象可以加锁，人为引入一些可以加锁的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;串行化
&lt;ul&gt;
&lt;li&gt;实际串行执行
&lt;ul&gt;
&lt;li&gt;解决并发问题最直接的方法是避免并发&lt;/li&gt;
&lt;li&gt;可行性
&lt;ul&gt;
&lt;li&gt;内存越来越便直，现在讲多应用可以将整个活动数据集都加载到内存中。当事务所需的所有数据都在内存中时，事务的执行速度要比等待磁盘 I/O 快得多。&lt;/li&gt;
&lt;li&gt;数据库设计人员意识到 OLTP 事务通常执行很快，只产生少量的读写操作。相比之下，运行时间较长的分析查询则通常是只读的，可以在一致性快照上运行，而不需要运行在串行主循环里。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;采用存储过程封装事务
&lt;ul&gt;
&lt;li&gt;数据库设计者认为，如果整个过程是一个事务，那么就可以方便地原子化执行。&lt;/li&gt;
&lt;li&gt;采用单线程串行执行的系统往往不支持交互式的多语句事务&lt;/li&gt;
&lt;li&gt;优缺点
&lt;ul&gt;
&lt;li&gt;语言并没有跟上通用编程语言的发展，语义都相当丑陋、过时，而且缺乏如今大多数编程语言所常用的函数库。&lt;/li&gt;
&lt;li&gt;在数据库中运行代码难以管理&lt;/li&gt;
&lt;li&gt;数据库中一个设计不好的存储过程要比同样低效的应用服务器代码带来更大的麻烦&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分区
&lt;ul&gt;
&lt;li&gt;为了扩展到多个 CPU 核和多节点，可以对数据进行分区&lt;/li&gt;
&lt;li&gt;对于跨分区的事务，数据库必须在涉及的所有分区之间协调事务。存储过程需要跨越所有分区加锁执行，以确保整个系统的可串行化。&lt;/li&gt;
&lt;li&gt;由于跨分区事务具有额外的协调开销，其性能比单分区内要慢得多&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;串行执行约束条件
&lt;ul&gt;
&lt;li&gt;事务必须简短而高效，否则一个缓慢的事务会影响到所有其他事务的执行性能&lt;/li&gt;
&lt;li&gt;仅限于活动数据集完全可以加载到内存的场景&lt;/li&gt;
&lt;li&gt;写入吞吐量必须足够低，才能在单个 CPU 核上处理; 否则就需要采用分区，最好没有跨分区事务。&lt;/li&gt;
&lt;li&gt;跨分区事务虽然也可以支持，但是占比必须很小。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;两段式加锁
&lt;ul&gt;
&lt;li&gt;多个事务可以同时读取同一对象，但只要出现任何写操作，则必须加锁以独占访问
&lt;ul&gt;
&lt;li&gt;如果事务 A 已经读取了某个对象，此时事务 B 想要写入该对象，那么 B 必须等到 A 提交或中止之才能继续。以确保 B 不会在事务 A 执行的过程中间去修改对象。&lt;/li&gt;
&lt;li&gt;如果事务 A 已经修改了对象，此时事务 B 想要读取该对象，则 B 必须等到 A 提交或中止之后才能继续。对于 2PL，不会出现读到旧值的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现
&lt;ul&gt;
&lt;li&gt;如果事务要读取对象，必须先以共享模式获得锁。可以有多个事务同时获得一个对象的共享锁，但是如果某个事务已经获得了对象的独占锁，则所有其他事务必须等待。&lt;/li&gt;
&lt;li&gt;如果事务要修改对象，必须以独占模式获取锁。不允许多个事务同时持有该锁(包括共享或独占模式)，换言之，如果对象上已被加锁，则修改事务必须等待。&lt;/li&gt;
&lt;li&gt;如果事务首先读取对象，然后尝试写入对象，则需要将共享锁升级为独占锁。升级锁的流程等价于直接获得独占锁。&lt;/li&gt;
&lt;li&gt;事务获得锁之后，一直持有锁直到事务结束(包括提交或中止)。这也是名字“两阶段”的来由，在第一阶段即事务执行之前要获取锁，第二阶段(即事务结束时)则释放锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;由于使用了这么多的锁机制，所以很容易出现死锁现象，数据库系统会自动检测事务之间的死锁情况，并强行中止其中的一个以打破僵局，这样另一个可以继续向前执行。而被中止的事务需要由应用层来重试。&lt;/li&gt;
&lt;li&gt;性能
&lt;ul&gt;
&lt;li&gt;降低了事务的并发性&lt;/li&gt;
&lt;li&gt;2PL 模式下数据库的访问延迟具有非常大的不确定性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;谓词锁
&lt;ul&gt;
&lt;li&gt;它的作用类似于之前描述的共享/独占锁，而区别在于，它并不属于某个特定的对象(如表的某一行)，而是作用于满足某些搜索条件的所有查询对象
&lt;ul&gt;
&lt;li&gt;如果事务 A 想要读取某些搞足匹配条件的对象，例如采用 SELECT 查询，它必须以共享模式获得查询条件的谓词锁。如果另一个事务 B 正持有任何一个匹配对象的互斥锁，那么 A 必须等到 B 释放锁之后才能继续执行查询。&lt;/li&gt;
&lt;li&gt;如果事务 A 想要插入、更新或删除任何对象，则必须首先检查所有旧值和新值是否与现有的任何谓词锁匹配(即冲突)。如果事务 B 持有这样的谓词锁，那么 A 必须等到 B 完成提交(或中止)后才能继续。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;索引区间锁
&lt;ul&gt;
&lt;li&gt;谓词锁性能不佳 :如果活动事务中存在许多锁，那么检查匹配这些锁就变得非常耗时&lt;/li&gt;
&lt;li&gt;大多数使用 2PL 的数据库实际上实现的是索引区间锁(或者 next­ key locking) ，本质上它是对谓词锁的简化或者近似&lt;/li&gt;
&lt;li&gt;索引区间锁扩大了锁定了对象的范围，但是开销低了很多&lt;/li&gt;
&lt;li&gt;如果没有合适的索引可以施加区间锁，数据库退回到添加表锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可串行化的快照隔离
&lt;ul&gt;
&lt;li&gt;悲观与乐观的并发控制
&lt;ul&gt;
&lt;li&gt;可串行化的快照隔离是一种乐观并发控制&lt;/li&gt;
&lt;li&gt;当事务提交时 (只有可串行化的事务被允许提交)，数据库会检查是否确实发生了冲突(即违反了隔离性原则)，如果是的话，中止事务并接下来重试。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于过期的条件做决定
&lt;ul&gt;
&lt;li&gt;读取之前已经有未提交的写入&lt;/li&gt;
&lt;li&gt;读取之后，又有新的写入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;检测是否读取了过期的 MVCC 对象
&lt;ul&gt;
&lt;li&gt;当事务提交时，数据库会检查是否存在一些当初被忽略的写操作现在已经完成了提交，如果是则必须中止当前事务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;检测写是否影响了之前的读
&lt;ul&gt;
&lt;li&gt;当另一个事务尝试修改时，它首先检查索引，从而确定是否最近存在一些读目标数据的其他事务。这个过程类似于在受影响的宇段范围上获取写锁，但它并不会阻塞读取，而是直到读事务提交时才进一步通知他们 :所读到的数据现在已经发生了变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可串行化快照隔离的性能
&lt;ul&gt;
&lt;li&gt;可串行化快照隔离的一大优点是事务不需要等待其他事务所持有的锁&lt;/li&gt;
&lt;li&gt;可串行化快照隔离可以突破单个 CPU 核的限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式系统的挑战&#34;&gt;分布式系统的挑战&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;即使系统面临各种出错可能，也需要完成预定工作&lt;/li&gt;
&lt;li&gt;故障与部分失效
&lt;ul&gt;
&lt;li&gt;单节点：要么工作，要么出错&lt;/li&gt;
&lt;li&gt;分布式系统：部分失效和不确定性&lt;/li&gt;
&lt;li&gt;云计算和超算
&lt;ul&gt;
&lt;li&gt;超算：定时备份任务状态，然后保存在持久存储上，当某节点出现故障，停止整个集群的任务，修复后从最近的检查点开始运行。&lt;/li&gt;
&lt;li&gt;云计算
&lt;ul&gt;
&lt;li&gt;都是在线服务，无法容忍完全不可用&lt;/li&gt;
&lt;li&gt;普通硬件，故障率较高&lt;/li&gt;
&lt;li&gt;基于 IP 和以太网通信&lt;/li&gt;
&lt;li&gt;总是会有部分组建故障&lt;/li&gt;
&lt;li&gt;容忍系统部分失败&lt;/li&gt;
&lt;li&gt;网络慢且不可靠&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;我们需要依靠软件提供容错，在不可靠系统上构建可靠的系统&lt;/li&gt;
&lt;li&gt;需要知道在发生故障时，系统的预期行为是什么&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不可靠的网络
&lt;ul&gt;
&lt;li&gt;系统的可靠性取决于最不可靠的组件&lt;/li&gt;
&lt;li&gt;常见出错场景
&lt;ul&gt;
&lt;li&gt;请求可能已经丢失&lt;/li&gt;
&lt;li&gt;请求还在队列，无法马上发送&lt;/li&gt;
&lt;li&gt;请求接收方已经宕机&lt;/li&gt;
&lt;li&gt;远程接收节点暂时无法响应&lt;/li&gt;
&lt;li&gt;消息在回复过程中丢失&lt;/li&gt;
&lt;li&gt;远程接收方已经处理请求，但回复却被延迟处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;现实中的网络故障
&lt;ul&gt;
&lt;li&gt;人为错误是故障的主要原因&lt;/li&gt;
&lt;li&gt;冗余硬件不见得降低故障率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;检测故障
&lt;ul&gt;
&lt;li&gt;负载均衡器需要避免向己失效的节点继续分发请求&lt;/li&gt;
&lt;li&gt;对于主从复制的分布式数据库，如果主节点失败，需要将某个从节点提升为主节点，不过由于网络的不确定性很难判断节点是否确实失效。&lt;/li&gt;
&lt;li&gt;然而不幸的是，由于网络的不确定性使得判断节点是否失效非常困难;而只有在某些特定场景下，或许你可以明确知道哪里出错了&lt;/li&gt;
&lt;li&gt;假设可以登录节点，但发现服务进程没有侦听目标端口，那么操作系统会返回 RST 或 FIN 标志的数据包来辅助关闭或拒绝 TCP 连接。但是，如果节点在处理请求的过程中发生了崩溃，则很难知道该节点实际处理了多少数据&lt;/li&gt;
&lt;li&gt;如果服务进程崩溃，但操作系统仍正常运行，可以通过脚本通知其他节点，以便新节点来快速接管而跳过等待超时。&lt;/li&gt;
&lt;li&gt;如果有权访问数据中心网络交换机，则可以通过管理接口查询是否存在硬件级别的链路故障&lt;/li&gt;
&lt;li&gt;如果路由器已经确认目标节点不可访问，则会返回 ICMP “目标不可达”数据包来回复请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;超时和无限期的延迟
&lt;ul&gt;
&lt;li&gt;较长的超时时间意味着更长时间的等待，才能宣告节点失败。&lt;/li&gt;
&lt;li&gt;较短的时间可以快速帮助检测，但是可能出现误判，导致同一操作在不同节点执行了两次。&lt;/li&gt;
&lt;li&gt;当一个节点故障，其承担的职责需要交给其他节点，这个过程会给其他节点和网络带来压力，特别是系统此时处于高负荷状态。转移负载会导致失效扩散，从而造成所有节点崩溃，服务完全不可用。&lt;/li&gt;
&lt;li&gt;网络拥塞与排队
&lt;ul&gt;
&lt;li&gt;当多个不同节点同时发送数据包到相同的目标节点时，网络交换机会出现排队，然后依次将数据包转发到目标网络。如果网络负载过重，数据包可能必须等待一段时间才能获得发送机会。如果数据量太大，交换机队列塞满，之后的数据包则会被丢弃，网络还在运转，但会引发大量数据包重传。&lt;/li&gt;
&lt;li&gt;当数据包到达目标机器后，如果所有 CPU 核都处于繁忙状态，则网络数据包请求会被操作系统排队，直到应用程序能够处理。根据机器的配置和负载情况，这里也会引人一段不确定的等待时间&lt;/li&gt;
&lt;li&gt;在虚拟化环境下，CPU 核会切换虚拟机，从而导致正在运行的操作系统会突然暂停几十毫秒。在这段时间，客户虚机无屈从网络中接收任何数据，入向的包会被虚拟机管理器排队缓冲，进一步增加了网络延迟的不确定性&lt;/li&gt;
&lt;li&gt;TCP 执行流量控制时，节点会主动限制自己的发送 速率以避免加重网络链路或接收节点负载。这意味着数据甚至在进入网络之前，已经在发送方开始了排队。&lt;/li&gt;
&lt;li&gt;如采延迟或丢弃的数据价值不大， UDP 是个不错的选择&lt;/li&gt;
&lt;li&gt;超时设置并不是一个不变的常量，而是持续测量响应时间及其变化，然后根据最新的响应时间分布来自动调整&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步和异步网络
&lt;ul&gt;
&lt;li&gt;固定电话有持续端到端的低延迟和足够的带宽来传输音频文件。
&lt;ul&gt;
&lt;li&gt;当通过电话网络拨打电话时，系统会动态建立一条电路:在整个线路上为呼叫分配一个固定的、带宽有保证通信链路，该电路一直维持到通话结束&lt;/li&gt;
&lt;li&gt;这种网络本质是同步的:即使数据中间经过了多个路由器，16bit 空间在电路建立时已经在网络中得到预留，不会受到排队的影响。由于没有排队，网络最大的端到端延迟是固定的。我们称之为有界延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络
&lt;ul&gt;
&lt;li&gt;固定电话独占一段连接，网络连接则是尽可能使用所有带宽。&lt;/li&gt;
&lt;li&gt;基于分组交换协议的网络注定收到排队的影响&lt;/li&gt;
&lt;li&gt;TCP 动态调整传输速率则可以充分利用所有可用的网络容量&lt;/li&gt;
&lt;li&gt;当前广泛部署的技术无法为我们提供延迟或可靠性方面的硬件级保证，我们必须假设会出现网络拥塞，排队和无上限的延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不可靠的时钟
&lt;ul&gt;
&lt;li&gt;但是由于网络的不确定延迟，精确测量面临着很多挑战。这些情况使得多节点通信时很难确定事情发生的先后顺序。&lt;/li&gt;
&lt;li&gt;通过 NTP 服务器同步机器时间的时钟&lt;/li&gt;
&lt;li&gt;单调时钟和墙上时钟
&lt;ul&gt;
&lt;li&gt;墙上时钟
&lt;ul&gt;
&lt;li&gt;与 NPT 同步，可以回退到过去，时间精度较为粗糙。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单调时钟
&lt;ul&gt;
&lt;li&gt;保证时间单调往前&lt;/li&gt;
&lt;li&gt;不同的 CPU 有不同过得单调时间，任务在不同 CPU 调度时需要调整之间偏差。&lt;/li&gt;
&lt;li&gt;精度高，可以计算微秒甚至更短的间隔。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时钟同步与准确性
&lt;ul&gt;
&lt;li&gt;计算机中的石英钟不够准确&lt;/li&gt;
&lt;li&gt;如果与 NTP 服务器的时钟差别过大，可能会出现拒绝同步，或者本地时间将被强制重置&lt;/li&gt;
&lt;li&gt;与 NTP 服务器同步失败&lt;/li&gt;
&lt;li&gt;网络延迟导致的 NTP 服务器延迟&lt;/li&gt;
&lt;li&gt;NTP 服务器故障，或者配置错误&lt;/li&gt;
&lt;li&gt;闰秒处理，在一天的周期内逐步调整闰秒&lt;/li&gt;
&lt;li&gt;虚拟机中的时钟会突然因为切换出现暂停，然后突然向前发生了跳跃&lt;/li&gt;
&lt;li&gt;不信任不可控设备上的时钟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;依赖同步的时钟
&lt;ul&gt;
&lt;li&gt;如果应用需要精确同步的时钟，最好仔细监控所有节点上的时钟偏差。如果某个节点的时钟漂移超出上限，应将其宣告为失效，并从集群中移除。这样的监控的目的是确保在造成重大影响之前尽早发现并处理问题&lt;/li&gt;
&lt;li&gt;时间戳与事件顺序
&lt;ul&gt;
&lt;li&gt;多主节点复制的分布式数据库依赖墙上时钟，导致在 LWW 中，错误写入旧值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时钟的置信区间
&lt;ul&gt;
&lt;li&gt;时间存在误差，因此，我们不应该将时钟读数视为一个精确的时间点，而更应该视为带有置信区间的时间范围。&lt;/li&gt;
&lt;li&gt;大多数系统不提供置信区间的信息，所以无法知道误差范围&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全局快照的同步时钟
&lt;ul&gt;
&lt;li&gt;当数据库分布在多台机器上时，由于需要复杂的协调以产生全局的单调递增的事务 ID&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程暂停
&lt;ul&gt;
&lt;li&gt;其他节点该如何确信该主节点没有被宣告失效，可以安全地写入
&lt;ul&gt;
&lt;li&gt;定时从其他节点获取租约，只要租约不过期它就是主节点
&lt;ul&gt;
&lt;li&gt;进程暂停导致租约过期，被其他节点接管
&lt;ul&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;虚拟机暂停&lt;/li&gt;
&lt;li&gt;终端休眠&lt;/li&gt;
&lt;li&gt;上下文切换&lt;/li&gt;
&lt;li&gt;磁盘 I/O 和网络 I/O&lt;/li&gt;
&lt;li&gt;内存访问出现缺页异常&lt;/li&gt;
&lt;li&gt;使用 SIGSTOP 暂停进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保证响应时间
&lt;ul&gt;
&lt;li&gt;实时操作系统&lt;/li&gt;
&lt;li&gt;内存分配收到严格限制或被禁止&lt;/li&gt;
&lt;li&gt;需要大量测试验证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调整 GC 的影响
&lt;ul&gt;
&lt;li&gt;把 GC 暂停视为节点的一个计划内的临时离线，当节点启动垃圾回收时，通知其他节点来接管客户端的请求。此外 ，系统可以提前为前端应用发出预警，应用会等待当前请求完成，但停止向该节点发送新的请求，这样垃圾回收可以在无干扰的情况下更加高效运行。这个技巧以某种方式对客户端隐藏垃圾回收，降低负面影响&lt;/li&gt;
&lt;li&gt;只对短期对象执行垃圾回收，然后在其变成长期存活对象之前，采取定期重启的策略从而避免对长期存活对象执行全面回收。每次选悻一个节点重新启动，在重启之前，重新平衡节点之间的流量，思路与读动升级类似&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;知识，真相与谎言
&lt;ul&gt;
&lt;li&gt;当节点不通时，无法判断是网络原因还是节点原因&lt;/li&gt;
&lt;li&gt;真相由多数决定
&lt;ul&gt;
&lt;li&gt;超过一半的节点收不到某节点的回复则视为失败&lt;/li&gt;
&lt;li&gt;节点不能判断自身的状态，需要依靠多数投票&lt;/li&gt;
&lt;li&gt;主节点与锁
&lt;ul&gt;
&lt;li&gt;只允许一个节点作为数据库分区的主节点，以防止出现脑裂&lt;/li&gt;
&lt;li&gt;只允许一个事务或客户端持有特定资源的锁，以防止同时写入从而导致数据破坏。&lt;/li&gt;
&lt;li&gt;只允许一个用户来使用特定的用户名，从而确保用户名可以唯一标识用户&lt;/li&gt;
&lt;li&gt;出错
&lt;ul&gt;
&lt;li&gt;节点的唯一锁失效之后认为自己还持有锁导致导致多个客户端同时写入出错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Fencing 令牌
&lt;ul&gt;
&lt;li&gt;我们假设每次锁服务在授予锁或租约时，还会同时返回一个 fencing 令牌，该令牌(数字)每授授予一次就会递增(列如，由锁服务增加)。然后，要求客户端每次向存储系统发送写请求时，都必须包含所持有的 fencing 令牌.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;靠客户端自己检查锁状态是不够的，这种机制要求资掘本身必须主动检查所持令牌信息，如果发现已经处理过更高令牌的请求，要拒绝持有低令牌的所有写请求&lt;/li&gt;
&lt;li&gt;服务端不能假设所有客户端都表现异常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拜占庭故障
&lt;ul&gt;
&lt;li&gt;节点返回了错误信息
&lt;ul&gt;
&lt;li&gt;节点发生故障&lt;/li&gt;
&lt;li&gt;不遵从协议&lt;/li&gt;
&lt;li&gt;恶意攻击&lt;/li&gt;
&lt;li&gt;干扰网络&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;弱的谎言形式
&lt;ul&gt;
&lt;li&gt;网络丢包，包损坏
&lt;ul&gt;
&lt;li&gt;在应用层添加校验&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;客户端的输入
&lt;ul&gt;
&lt;li&gt;进行基本的安全检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NTP 配置多个服务器得出正确的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;理论系统模型与现实
&lt;ul&gt;
&lt;li&gt;计时模型
&lt;ul&gt;
&lt;li&gt;同步模型
&lt;ul&gt;
&lt;li&gt;同步模型假定有上界的网络延迟，有上界的进程暂停和有上界的时钟误差&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;部分同步模型
&lt;ul&gt;
&lt;li&gt;部分同步意味着系统在大多数情况下像一个同步系统一样运行，但有时候会超出网络延迟，进程暂停和时钟漂移的预期上界&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异步模型
&lt;ul&gt;
&lt;li&gt;在这个模型中，一个算法不会对时机做任何的假设，甚至里面根本没有时钟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;失效模型
&lt;ul&gt;
&lt;li&gt;崩溃-中止模型
&lt;ul&gt;
&lt;li&gt;在崩溃-中止模型中，算在去假设一个节点只能以一种方式发生故障，即遭遇系统崩溃。这意味着节点可能在任何时候突然停止响应，且该节点以后永远消失，无法恢复。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;崩溃-恢复模型
&lt;ul&gt;
&lt;li&gt;节点可能会在任何时候发生崩溃，且可能会在一段(未知的)时间之后得到恢复并再次响应。在崩溃-恢复模型中，节点上持久性存储(即非易失性存储)的数据会在崩溃之后得以保存，而内存中状态可能会丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拜占庭(任意)失效模型
&lt;ul&gt;
&lt;li&gt;节点可能发生任何事情，包括试图作弊和欺骗其他节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;算法的正确性
&lt;ul&gt;
&lt;li&gt;唯一性
&lt;ul&gt;
&lt;li&gt;两个令牌请求不能获得相同的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单调递增
&lt;ul&gt;
&lt;li&gt;如果请求 x 返回了令牌 tx，请求 y 返回了令牌 ty，且 x 在 y 开始之前先完成，那么 tx&amp;lt;ty&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可用性
&lt;ul&gt;
&lt;li&gt;请求令牌的节点如果不发生崩溃则最终一定会收到响应&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全与活性
&lt;ul&gt;
&lt;li&gt;唯一性和单调递增属于安全属性，而可用性则属于活性。&lt;/li&gt;
&lt;li&gt;安全性通常可以理解为“没有发生意外”，而活性则类似“预期的事情最终一定会发生”&lt;/li&gt;
&lt;li&gt;如果违反了安全属性，我们可以明确指向发生的特定的时间点，且一旦违反安全属性，违规行为无法撤销，破坏已实际发生。&lt;/li&gt;
&lt;li&gt;活性则反过来:可能无法明确某个具体的时间点，但总是希望在未来某个时间点可以满足要求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将系统模型映射到现实世界
&lt;ul&gt;
&lt;li&gt;现实远比理论复杂，系统需要现实大量验证，理论性分析与实证性检验对最终的成功同等重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一致性与共识&#34;&gt;一致性与共识&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分布式系统最重要的抽象之一就是共识&lt;/li&gt;
&lt;li&gt;一致性保证
&lt;ul&gt;
&lt;li&gt;大多数多副本的数据库至少提供了最终一致性，不写入的情况下，经过足够长的时间，预期所有的副本会收敛到相同的值。
&lt;ul&gt;
&lt;li&gt;在最终一致性之前，系统可能会在多次请求中读到不一致的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;更强的一致性模型
&lt;ul&gt;
&lt;li&gt;分布式一致性主要是针对延迟和故障等问题来协调副本之间的状态&lt;/li&gt;
&lt;li&gt;线性化&lt;/li&gt;
&lt;li&gt;时间顺序问题，因果顺序和全局顺序&lt;/li&gt;
&lt;li&gt;自动提交事务达成共识&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可线性化
&lt;ul&gt;
&lt;li&gt;让每个客户端都拥有相同的数据视图，而不必担心复制滞后&lt;/li&gt;
&lt;li&gt;a.k.a 原子一致性，强一致性&lt;/li&gt;
&lt;li&gt;在一个可线性化的系统中，一旦某个客户端成功提交写请求，所有客户端的读请求一定都能看到刚刚写入的值&lt;/li&gt;
&lt;li&gt;如何达成线性化
&lt;ul&gt;
&lt;li&gt;基本思想：使系统看起来只有一个数据副本&lt;/li&gt;
&lt;li&gt;约束：一旦某个读操作返回了新值，那么后续的写操作都必须返回新值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线性化的依赖条件
&lt;ul&gt;
&lt;li&gt;加锁与主节点选举
&lt;ul&gt;
&lt;li&gt;主从复制的系统需要确保有且只有一个主节点，否则会产生脑裂&lt;/li&gt;
&lt;li&gt;选举新的主节点常见的方住是使用锁: 即每个启动的节点都试图获得锁，其中只有一个可以成功即成为主节点&lt;/li&gt;
&lt;li&gt;提供协调者服务的系统如 Apache ZooKeeper 和 etcd 等通常用来实现分布式锁和主节点选举&lt;/li&gt;
&lt;li&gt;线性化存储服务是所有这些协调服务的基础&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;约束与唯一性保证
&lt;ul&gt;
&lt;li&gt;唯一性约束在数据库中很常见, 用户名或电子邮件地址必须唯一, 这种情况本质上与加锁非常类似: 用户注册等同于试图对用户名进行加锁操作。该操作也类似于原子比较和设置: 如果当前用户名尚未被使用，就设置用户名与客户 ID 进行关联&lt;/li&gt;
&lt;li&gt;唯一性约束需要线性化保证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;跨通道的时间依赖
&lt;ul&gt;
&lt;li&gt;线性化违例之所以被注意到，是因为系统中存在其他的通信渠道&lt;/li&gt;
&lt;li&gt;图片服务器的例子，发送消息比存储更快导致图片处理模块读不到图片&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现线性化系统
&lt;ul&gt;
&lt;li&gt;主从复制
&lt;ul&gt;
&lt;li&gt;部分支持可线性化&lt;/li&gt;
&lt;li&gt;从主节点或者同步更新的节点读取满足线性化需要&lt;/li&gt;
&lt;li&gt;节点失效重连后依然认为自己是主节点对外服务违反线性化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共识算法
&lt;ul&gt;
&lt;li&gt;可线性化&lt;/li&gt;
&lt;li&gt;ZK 和 etcd 等系统用共识算法保证线性化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多主复制
&lt;ul&gt;
&lt;li&gt;不可线性化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无主复制
&lt;ul&gt;
&lt;li&gt;可能不可线性化
&lt;ul&gt;
&lt;li&gt;取决于 w + r &amp;gt; n 的配置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线性化与 quorum
&lt;ul&gt;
&lt;li&gt;严格遵从 quorum 可实现可线性化&lt;/li&gt;
&lt;li&gt;同步读损失性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线性化的代价
&lt;ul&gt;
&lt;li&gt;网络中断后无法实现可线性化&lt;/li&gt;
&lt;li&gt;不要求线性化，服务可用&lt;/li&gt;
&lt;li&gt;CAP
&lt;ul&gt;
&lt;li&gt;CAP 有时也代表一致性，可用性，分区容错性，系统只能支持其中两个特性&lt;/li&gt;
&lt;li&gt;分区是一种故障，当网络通常的时候可以满足 CAP，当网络出现的问题的时候需要在 CP 和 AP 中取舍&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可线性化与网络延迟
&lt;ul&gt;
&lt;li&gt;实际上很少有系统真正满足线性化&lt;/li&gt;
&lt;li&gt;现代多核 CPU 的内存屏障或者 fence 指令&lt;/li&gt;
&lt;li&gt;多数系统不选择可线性化是为了性能而不是容错，无论是否有网络故障，可线性化对性能的影响都是巨大的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;顺序保证
&lt;ul&gt;
&lt;li&gt;顺序与因果关系
&lt;ul&gt;
&lt;li&gt;果关系的依赖链条定义了系统中的因果页序，即某件事应该发生另一件事情之前&lt;/li&gt;
&lt;li&gt;如果系统服从因果关系所规定的顺序，我们称之为因果一致性&lt;/li&gt;
&lt;li&gt;因果关系并非全序
&lt;ul&gt;
&lt;li&gt;可线性化
&lt;ul&gt;
&lt;li&gt;在一个可线性化的系统中，存在全序操作关系。系统的行为就好像只有一个数据副本，且每个操作都是原子的，这意味着对于任何两个操作，我们总是可以指出哪个操作在先&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因果关系
&lt;ul&gt;
&lt;li&gt;如果两个操作都没有发生在对方之前，那么这两个操作是并发关系。换言之，如果两个事件是因果关系，那么这两个事件可以被排序;而并发的事件则无法排序比较。这表明因果关系至少可以定义为偏序，而非全序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可线性化系统里不存在并发操作，一定有一个时间线可以把所有操作都全序执行。&lt;/li&gt;
&lt;li&gt;并发意味着时间线出现分支和合并，而不同分支上的操作无法直接比较&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可线性化强于因果一致性
&lt;ul&gt;
&lt;li&gt;可线性化一定意味着因果关系&lt;/li&gt;
&lt;li&gt;线性化并非是保证因果关系的唯一途径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;捕获因果依赖关系
&lt;ul&gt;
&lt;li&gt;为保持因果关系，需要知道哪个操作发生在前&lt;/li&gt;
&lt;li&gt;为了确定请求的因果依赖关系，我们需要一些手段来描述系统中节点所知道的“知识”。如果节点在写入 Y 时已经看到 X 值，则 X 和 Y 可能是属于因果关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;序列号排序
&lt;ul&gt;
&lt;li&gt;使用序列号或时间戳来排序事件
&lt;ul&gt;
&lt;li&gt;它可以只是一个逻辑时钟，例如采用算法来产生一个数字序列用以识别操作，通常是递增的计数器。&lt;/li&gt;
&lt;li&gt;序列号很紧凑，但是他们保证了全序关系，总是可以通过比较来确定大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非因果序列发生器
&lt;ul&gt;
&lt;li&gt;如果系统不存在这样唯一的主节点, 如何产生序列号就不是那么简单了
&lt;ul&gt;
&lt;li&gt;每个节点都独立产生自己的一组序列号&lt;/li&gt;
&lt;li&gt;可以把墙上时间戳信息附加到每个操作上，LLW 采用这种方式。&lt;/li&gt;
&lt;li&gt;可以预先分配序列号的区间范围&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;相比于把所有请求全部压给唯一的主节点具有更好的扩展性&lt;/li&gt;
&lt;li&gt;所产生的序列号与因果关系并不严格一致
&lt;ul&gt;
&lt;li&gt;每个节点可能有不同的处理速度&lt;/li&gt;
&lt;li&gt;物理时钟的时间戳会受到时钟偏移的影响&lt;/li&gt;
&lt;li&gt;对于欲分配区间，操作被路由到不同分区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lamport 时间戳
&lt;ul&gt;
&lt;li&gt;首先每个节点都有一个唯一的标识符，且每个节点都有一个计数器来记录各自已处理的请求总数。&lt;/li&gt;
&lt;li&gt;Lamport 时间戳是一个值对(计数器，节点 ID)。两个节点可能会有相同的计数器值，但时间戳中还包含节点 ID 信息，因此可以确保每个时间戳都是唯一的。&lt;/li&gt;
&lt;li&gt;给定两个 Lamport 时间戳，计数器较大那个时间戳大;如计数器值正好相同，则节点 ID 越大，时间戳越大。&lt;/li&gt;
&lt;li&gt;每个节点以及每个客户端都跟踪迄今为止所见到的最大计数器值，并在每个请求中附带该最大计数器值。当节点收到某个请求(或者回复)时，如果发现请求内嵌的最大计数器值大于节点自身的计数器值，则它立即把自己的计数器修改为该最大值&lt;/li&gt;
&lt;li&gt;只要把最大计数器值嵌入到每一个请求中，该方案可以确保 Lamport 时间戳与因果关系一致，而请求的因果依赖性一定会保证后发生的请求得到更大的时间戳。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间戳排序依然不够
&lt;ul&gt;
&lt;li&gt;对于唯一性约束依然需要全序关系来保证。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全序关系广播
&lt;ul&gt;
&lt;li&gt;如何扩展系统的吞吐量使之突破单一主节点的限制，以及如何处理主节点失效时的故障切换，在分布式系统研究文献中，这些问题被称为全序关系广播或者原子广播&lt;/li&gt;
&lt;li&gt;全序关系广播通常指节点之间交换消息的某种协议
&lt;ul&gt;
&lt;li&gt;可靠发送
&lt;ul&gt;
&lt;li&gt;没有消息丢失，如果消息发送到了某一个节点，则它一定要发送到所有节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;严格有序
&lt;ul&gt;
&lt;li&gt;消息总是以相同的顺序发送给每个节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全序关系广播正是数据库复制所需要的: 如果每条消息代表数据库写请求，并且每个副本都按相同的顺序处理这些写请求，那么所有副本可以保持 一致&lt;/li&gt;
&lt;li&gt;可以使用全序关系广播来实现可串行化事务&lt;/li&gt;
&lt;li&gt;全序关系广播的另一个要点是顺序在发送消息时已确定&lt;/li&gt;
&lt;li&gt;采用全序广播实现线性化存储
&lt;ul&gt;
&lt;li&gt;全序关系广播是基于异步模型: 保证消息以固定的顺序可靠地发送，但是不保证消息何时发送成功&lt;/li&gt;
&lt;li&gt;可线性化则强调就近性:读取时保证能够看到最新的写入值。&lt;/li&gt;
&lt;li&gt;步骤
&lt;ul&gt;
&lt;li&gt;在日志中追加一条消息&lt;/li&gt;
&lt;li&gt;广播给所有节点，等待回复&lt;/li&gt;
&lt;li&gt;如果全都成功，那么返回给客户端成功的消息，否则失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;满足写顺序化，不满足读取顺序话
&lt;ul&gt;
&lt;li&gt;可以采用追加的方式把读请求排序、广播，然后各个节点获取该日志，当本节点收到消息时才执行真正的读操作&lt;/li&gt;
&lt;li&gt;如果可以以线性化的方式获取当前最新日志中消息的位置，则查询位置，等待直到该位置之前的所有条目都已经发送给你，接下来再执行读取。&lt;/li&gt;
&lt;li&gt;可以从同步更新的副本上进行读取，这样确保总是读取最新值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;采用线性化存储实现全序广播
&lt;ul&gt;
&lt;li&gt;假设有一个线性化的寄存器来存储一个计数，然后使其支持原子自增-读取操作或者原子比较-设置操作&lt;/li&gt;
&lt;li&gt;对于每个要通过全序关系广播的消息，原子递增并读取该线性化的计数，然后将其作为序列号附加到消息中。接下来，将消息广播到所有节点，而接受者也严格按照序列化来发送回复消息&lt;/li&gt;
&lt;li&gt;难点在于处理节点的网络中断，以及节点失效时如何恢复该值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分布式事务与共识
&lt;ul&gt;
&lt;li&gt;主节点选举
&lt;ul&gt;
&lt;li&gt;对于基于主从复制的数据库，由于网络问题出现节点之间无法通信，容易出争议。共识算法对于避免错误的故障切换非常重要。如果存在两个主节点，会导致数据不一致甚至丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原子事务提交
&lt;ul&gt;
&lt;li&gt;对于支持跨节点跨区事务的数据库，事务在部分节点成功了，为了维护原子性，要么全部成功要么全部回退。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原子提交与两段式提交
&lt;ul&gt;
&lt;li&gt;单节点的原子提交
&lt;ul&gt;
&lt;li&gt;当客户端请求数据库节点提交事务时，数据库首先使事务的写入持久化，然后把提交记录追加写入到磁盘的日志文件中。如果数据库在该过程中间发生了崩溃，那么当节点重启后，事务可以从日志中恢复: 如果在崩溃之前提交记录已成功写入磁盘，则认为事务己安全提交;否则，回滚该事务的所有写入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;两阶段提交是一种在多节点之间实现事务原子提交的算法，用来确保所有节点要么全部提交，要么全部中止
&lt;ul&gt;
&lt;li&gt;当应用程序启动一个分布式事务时，它首先向协调者请求事务 ID。该 ID 全局唯一。&lt;/li&gt;
&lt;li&gt;应用程序在每个参与节点上执行单节点事务，并将全局唯一事务 ID 附加到事务上。此时，读写都是在单节点内完成。如果在这个阶段出现问题，则协调者和其他参与者都可以安全中止。&lt;/li&gt;
&lt;li&gt;当应用程序准备提交时 ，协调者向所有参与者发送准备请求 ，并附带全局事务 ID。如果准备请求有任何一个发生失败或者超时，则协调者会通知所有参与者放弃事务。&lt;/li&gt;
&lt;li&gt;参与者在收到准备请求之后 ，确保在任何情况下都可以提交事务 ，包括安全地将事务数据写入磁盘，并检查是否存在冲突或约束违规。 一且向协调者回答“是”，节点就承诺会提交事务。换句话说，尽管还没有真正提交，但参与者已表态此后不会行使放弃事务的权利。&lt;/li&gt;
&lt;li&gt;当协调者收到所有准备请求的答复肘，就是否提交或放弃事务要做出明确的决定。协调者把最后的决定写入到磁盘的事务日志中，防止稍后系统崩愤，并可以恢复之前的决定。这个时刻称为提交点。&lt;/li&gt;
&lt;li&gt;协调者的决定写入磁盘之后 ，接下来向所有参与者发送提交或放弃请求。如果此请求出现失败或超时，则协调者必须一直重试，直到成功为止。此时，所有节点不允许有任何反悔:开弓没有回头箭，一旦做了决定，就必须贯彻执行，即使需要很多次重试。而如果有参与者在此期间出现故障，在其恢复之后，也必须继续执行。这是因为之前参与者都投票选择了“是”，对于做出的承诺同样没有反悔的余地。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;参与者发生故障
&lt;ul&gt;
&lt;li&gt;在第一阶段，任何一个准备请求发生了失败或者超时，那么协调者就会决定中止交易&lt;/li&gt;
&lt;li&gt;在第二阶段发生提交或中止请求失败，则协调者将无限期重试&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协调者发生故障
&lt;ul&gt;
&lt;li&gt;如果协调者在发送准备请求之前就已失败，则参与者可以安全地中止交易&lt;/li&gt;
&lt;li&gt;如果参与者接受了请求并做了投票是，它只能无限期等待协调者的决定。&lt;/li&gt;
&lt;li&gt;部分节点没有接收到提交确认请求，在超时过后决定丢弃，导致数据不一致。&lt;/li&gt;
&lt;li&gt;2PC 能够顺利完成的唯一方法就是等待协调者恢复。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实践中的分布式事务
&lt;ul&gt;
&lt;li&gt;数据库内部的分布式事务
&lt;ul&gt;
&lt;li&gt;某些分布式数据库支持跨数据库节点的内部事务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异构分布式事务
&lt;ul&gt;
&lt;li&gt;在异构分布式事务中，存在两种或两种以上不同的参与者实现技术。例如来自不同供应商的数据库，甚至是非数据库系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Exactly-once 消息处理
&lt;ul&gt;
&lt;li&gt;异构的分布式事务旨在无缝集成多种不同的系统&lt;/li&gt;
&lt;li&gt;当且仅当数据库中处理消息的事务成功提交，消息队列才会标记该消息已处理完毕&lt;/li&gt;
&lt;li&gt;这个过程是通过自动提交消息确认和数据库写入来实现的。即使消息系统和数据库两种不同的技术运行在不同的节点上，采用分布式事务也能达到上述目标。&lt;/li&gt;
&lt;li&gt;如果消息发送或数据库事务任何一个发生失败，则两者都须中止，消息队列可以在稍后再次重传消息。&lt;/li&gt;
&lt;li&gt;只有在所有受影响的系统都使用相同的原子提交协议的前提下，这种分布式事务才是可行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;XA 交易
&lt;ul&gt;
&lt;li&gt;异构环境下实施两阶段提交的一个工业标准&lt;/li&gt;
&lt;li&gt;协调所有实现 API 的参与者进行同一的提交或者回滚&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;停顿时仍持有锁
&lt;ul&gt;
&lt;li&gt;在与协调者失去连接的时间内，参与者持有的锁将不会释放，这可能导致部分上层服务崩溃&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从协调者故障中恢复
&lt;ul&gt;
&lt;li&gt;协调者崩溃恢复有各种不确定情况&lt;/li&gt;
&lt;li&gt;允许参与者节点可以在紧急情况下单方面做出决定，放弃或者继续那些停顿的事务，而不需要等到协调者发出指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分布式事务的限制
&lt;ul&gt;
&lt;li&gt;协调者不支持数据复制，单点故障&lt;/li&gt;
&lt;li&gt;协调者不是无状态&lt;/li&gt;
&lt;li&gt;XA 需要和各种数据系统兼容，无法深入不同系统的死锁条件&lt;/li&gt;
&lt;li&gt;2PC 事务失败有扩大事务失败的风险&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;支持容错的共识
&lt;ul&gt;
&lt;li&gt;共识算法必须满足一下性质
&lt;ul&gt;
&lt;li&gt;协商一致性, 所有的节点都接受相同的决议。&lt;/li&gt;
&lt;li&gt;诚实性，即对同一提议不能有两次决定&lt;/li&gt;
&lt;li&gt;合法性，如果决定了值 v，则 v 一定是由某个节点所提议的&lt;/li&gt;
&lt;li&gt;可中止性，节点不崩溃则最终一定可以达成决议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共识算法与全序广播
&lt;ul&gt;
&lt;li&gt;VSR，Paxos，Raft，Zab&lt;/li&gt;
&lt;li&gt;全序关系广播
&lt;ul&gt;
&lt;li&gt;由于协商一致性，所有节点决定以相同的顺序发送相同的消息&lt;/li&gt;
&lt;li&gt;由于诚实性，消息不能重复&lt;/li&gt;
&lt;li&gt;由于合法性，消息不会被破坏，也不是凭空捏造的&lt;/li&gt;
&lt;li&gt;由于可终止性，消息不会丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VSR，Raft 和 Zab 采用了全序关系广播，Paxos 的对应优化版本为 Multi-Paxos&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主从复制和共识
&lt;ul&gt;
&lt;li&gt;一些数据库支持自动选举主节点和故障切换，通过选举把某个从节点者提升为新的主节点&lt;/li&gt;
&lt;li&gt;所有的节点都需要同意主节点，否则两个主节点会导致数据库出现不一致。因此，我们需要共识算在去选出一位主节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Epoch 和 Quorum
&lt;ul&gt;
&lt;li&gt;目前所讨论的所有共识协议在其内部都使用了某种形式的主节点，虽然主节点并不是固定的。相反，他们都采用了一种弱化的保证 : 协议定义了一个世代编号(epoch number，对应于 Paxos 中的 ballot number，VSP 中 view number，以及 Raft 中的 term number)，并保证在每个世代里，主节点是唯一确定的。&lt;/li&gt;
&lt;li&gt;如果当前主节点失效，节点就开始议论投票选举新的主节点。选举会赋予一个单调自增的 epoch 号。如果出现了两个不同的主节点对应不同 epoch 号码，具有更好 epoch 号码的主节点将获胜。&lt;/li&gt;
&lt;li&gt;在主节点做出任何决定之前，它必须首先检查是否存在比它更高的 epoch 号码，否则就会产生冲突的决定&lt;/li&gt;
&lt;li&gt;它必须从 quorum 节点中收集投票，主节点如果想要做出某个决定，须将提议发送给其他所有节点，等待 quorum 节点的响应。quorum 通常由多数节点组成。并且，只有当没有发现更高 epoch 主节点存在时，节点才会对当前的提议进行投票。&lt;/li&gt;
&lt;li&gt;两轮投票
&lt;ul&gt;
&lt;li&gt;首先是投票决定谁是主节点，然后是对主节点的提议进行投票&lt;/li&gt;
&lt;li&gt;如果某个提议获得通过，那么其中参与投票的节点中必须至少有一个也参加了最近一次的主节点选举
&lt;ul&gt;
&lt;li&gt;换言之，如果在针对提议的投票中没有出现更高 epoch 号码，那么可以得出这样的结论:因为没有发生更高 epoch 的主节点选举，当前的主节点地位没有改变，所以可以安全地就提议进行投票。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共识的局限性
&lt;ul&gt;
&lt;li&gt;在达成一致性决议之前，节点投票的过程是一个同步复制过程&lt;/li&gt;
&lt;li&gt;共识体系需要严格的多数节点才能运行。这意味着需要至少三个节点才能容忍一个节点发生故障&lt;/li&gt;
&lt;li&gt;多数共识算在是假定一组固定参与投票的节点集，这意味着不能动态、添加或删除节点&lt;/li&gt;
&lt;li&gt;共识系统通常依靠超时机制来检测节点失效。在网络延迟高度不确定的环境中，特别是那些跨区域分布的系统，经常由于网络延迟的原因，导致节点错误地认为主节点发生了故障。虽然这种误判并不会损害安全属性，但频繁的主节点选举显著降低了性能，系统最终会花费更多的时间和资晾在选举主节点上而不是原本的服务任务&lt;/li&gt;
&lt;li&gt;共识算法往往对网络问题特别敏感，可能导致主节点频繁切换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;成员与协调服务
&lt;ul&gt;
&lt;li&gt;ZK 和 etcd 通常被成为分布式键值存储或者协调与服务配置。&lt;/li&gt;
&lt;li&gt;ZooKeeper 和 etcd 主要针对保存少量、可完全载入内存的数据而设计。&lt;/li&gt;
&lt;li&gt;特性
&lt;ul&gt;
&lt;li&gt;线性化的原子操作
&lt;ul&gt;
&lt;li&gt;多个节点同时加锁，只有一个会成功&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作全序
&lt;ul&gt;
&lt;li&gt;对每个操作都赋予了一个单调递增的事务 ID&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;故障检测
&lt;ul&gt;
&lt;li&gt;通过心跳检测对话，长时间不响应则释放锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;更改通知
&lt;ul&gt;
&lt;li&gt;客户端可以知道其他客户端何时加入以及是否发生故障&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用场景
&lt;ul&gt;
&lt;li&gt;节点任务分配
&lt;ul&gt;
&lt;li&gt;检测到新节点加入时，将任务调度到新节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务发现
&lt;ul&gt;
&lt;li&gt;把服务和 ip 注册到 ZK&lt;/li&gt;
&lt;li&gt;服务发现是否需要共识存在争论，可以起到复制作用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;成员服务
&lt;ul&gt;
&lt;li&gt;成员服务用来确定当前哪些节点处于活动状态并属于集群的有效成员&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>数据密集型应用系统设计::数据系统基础</title>
      <link>/notes/designing_data_intensive_application_foundations_of_data_systems/</link>
      <pubDate>Sat, 20 Mar 2021 21:57:43 +0800</pubDate>
      <guid>/notes/designing_data_intensive_application_foundations_of_data_systems/</guid>
      <description>&lt;h2 id=&#34;数据系统基础&#34;&gt;数据系统基础&lt;/h2&gt;
&lt;h3 id=&#34;可靠可扩展与可维护的应用系统&#34;&gt;可靠、可扩展与可维护的应用系统&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据密集型应用通常基于标准模块构建而成，每个模块负责单一的常用功能
&lt;ul&gt;
&lt;li&gt;数据库:用以存储数据，这样之后应用可以再次访问&lt;/li&gt;
&lt;li&gt;高速缓存:缓存那些复杂或操作代价昂贵的结果，以加快下一次访问&lt;/li&gt;
&lt;li&gt;索引:用户可以按关键字搜索数据并支持各种过滤&lt;/li&gt;
&lt;li&gt;流式处理:持续发送消息至另一个进程，处理采用异步方式&lt;/li&gt;
&lt;li&gt;批处理:定期处理大最的累积数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可靠性
&lt;ul&gt;
&lt;li&gt;当出现意外情况如硬件、软件故障、人为失误等，系统应可以继续正常运转&lt;/li&gt;
&lt;li&gt;对软件典型的期望
&lt;ul&gt;
&lt;li&gt;应用程序执行用户所期望的功能&lt;/li&gt;
&lt;li&gt;可以容忍用户出现错误或者不正确的软件使用方法&lt;/li&gt;
&lt;li&gt;性能可以应对典型场景、 合理负载压力和数据量&lt;/li&gt;
&lt;li&gt;系统可防止任何未经授权的访问和滥用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可能出错的事情称为错误(faults)或故障&lt;/li&gt;
&lt;li&gt;系统可应对错误则称为容错(fault­ tolerant)或者弹性(resilient)&lt;/li&gt;
&lt;li&gt;容错总是指特定类型的故障，这样的系统才更有实际意义&lt;/li&gt;
&lt;li&gt;故障通常被定义为组件偏离其正常规格&lt;/li&gt;
&lt;li&gt;失效意味系统作为一个整体停止，无法向用户提供所需的服务。&lt;/li&gt;
&lt;li&gt;通过故意引发故障的方式，来持续检验、测试系统的容错机制，增加对真实发生故障时应对的信心&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;硬件故障
&lt;ul&gt;
&lt;li&gt;采用硬件冗余方案对于大多数应用场景还是足够的&lt;/li&gt;
&lt;li&gt;多机冗余则只对少最的关键应用更有意义，对于这些应用，高可用性是绝对必要的&lt;/li&gt;
&lt;li&gt;通过软件容错的方式来容忍多机失效成为新的手段，或者至少成为硬件容错的有力补充&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件错误
&lt;ul&gt;
&lt;li&gt;因为节点之间是由软件关联的，因而往往会导致更多的系统故障&lt;/li&gt;
&lt;li&gt;避免软件故障需要考虑很多细节
&lt;ul&gt;
&lt;li&gt;认真检查依赖 的假设条件与系统之间交互&lt;/li&gt;
&lt;li&gt;进行全面的测试&lt;/li&gt;
&lt;li&gt;进程隔离&lt;/li&gt;
&lt;li&gt;允许进程崩溃并自动重启&lt;/li&gt;
&lt;li&gt;反复评估，监控并分析生产环节的行为表现&lt;/li&gt;
&lt;li&gt;等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;人为失误
&lt;ul&gt;
&lt;li&gt;人是不可靠的，该如何保证系统的可靠性呢
&lt;ul&gt;
&lt;li&gt;以最小出错的方式来设计系统。&lt;/li&gt;
&lt;li&gt;想办法分离最容易出错的地方、容易引发故障的接口&lt;/li&gt;
&lt;li&gt;充分的测试: 从各单元测试到全系统集成测试以及手动测试&lt;/li&gt;
&lt;li&gt;当出现人为失误时，提供快速的恢复机制以尽最减少故障影响&lt;/li&gt;
&lt;li&gt;设置详细而清晰的监控子系统，包括性能指标和错误率&lt;/li&gt;
&lt;li&gt;推行管理流程并加以培训&lt;/li&gt;
&lt;li&gt;等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可靠性的重要性
&lt;ul&gt;
&lt;li&gt;导致商誉下降，影响效率，营收损失&lt;/li&gt;
&lt;li&gt;即使在所谓 “非关键“ 应用中我们也应秉持对用户负责的态度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可扩展性
&lt;ul&gt;
&lt;li&gt;可扩展性是用来描述系统应对负载增加能力的术语&lt;/li&gt;
&lt;li&gt;随着规模的增长， 例如数据量、 流量或复杂性，系统应以合理的方式来匹配这种增长&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;描述负载
&lt;ul&gt;
&lt;li&gt;负载可以用称为负载参数的若干数字来描述
&lt;ul&gt;
&lt;li&gt;Web 服务器的每秒请求处理次数&lt;/li&gt;
&lt;li&gt;数据库中写入的比例&lt;/li&gt;
&lt;li&gt;聊天室的同时活动用户数量&lt;/li&gt;
&lt;li&gt;缓存命中率&lt;/li&gt;
&lt;li&gt;等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;描述性能
&lt;ul&gt;
&lt;li&gt;负载增加，但系统资源(如 CPU、内存、网络带宽等)保持不变，系统性能会发生什么变化&lt;/li&gt;
&lt;li&gt;负载增加，如果要保持性能不变，需要增加多少资源&lt;/li&gt;
&lt;li&gt;延迟与响应时间
&lt;ul&gt;
&lt;li&gt;响应时间是客户端看到的:除了处理请求时间(服务时间，service time)外，还包括来回网络延迟和各种排队延迟&lt;/li&gt;
&lt;li&gt;延迟则是请求花费在处理上的时间&lt;/li&gt;
&lt;li&gt;不要将响应时间视为一个固定的数字，而是可度量的一种数值分布&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;影响响应时间的因素
&lt;ul&gt;
&lt;li&gt;上下文切换和进程调度&lt;/li&gt;
&lt;li&gt;网络数据包丢失和 TCP 重传&lt;/li&gt;
&lt;li&gt;垃圾回收暂停&lt;/li&gt;
&lt;li&gt;缺页中断和磁盘 I/O&lt;/li&gt;
&lt;li&gt;服务器机架的机械振动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;我们经常考察的是服务请求的平均响应时间&lt;/li&gt;
&lt;li&gt;中位数指标非常适合描述多少用户需要等待多长时间&lt;/li&gt;
&lt;li&gt;采用较高的响应时间百分位数(tail latencies, 尾部延迟或长尾效应)很重要， 因为它们直接影响用户的总体服务体验&lt;/li&gt;
&lt;li&gt;系统响应时间取决于最慢的那个服务&lt;/li&gt;
&lt;li&gt;垂直扩展(升级到更强大的机器)&lt;/li&gt;
&lt;li&gt;水平扩展(将负载分布到多个更小的机器)&lt;/li&gt;
&lt;li&gt;最近通常的做法一直是，将数据库运行在一个节点上，直到高扩展性或高可用性的要求迫使不得不做水平扩展。&lt;/li&gt;
&lt;li&gt;超大规模的系统往往针对特定应用而高度定制，架构取决于多种因素
&lt;ul&gt;
&lt;li&gt;读取量、写入量&lt;/li&gt;
&lt;li&gt;待存储的数据量&lt;/li&gt;
&lt;li&gt;数据的复杂程度&lt;/li&gt;
&lt;li&gt;响应时间要求&lt;/li&gt;
&lt;li&gt;访问模式&lt;/li&gt;
&lt;li&gt;等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于早期的初创公司或者尚未定型的产品，快速迭代推出产品功能往往比投入精力来应对不可知的扩展性更为重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可维护性
&lt;ul&gt;
&lt;li&gt;软件的大部分成本在于整个生命周期的持续投入
&lt;ul&gt;
&lt;li&gt;开发阶段&lt;/li&gt;
&lt;li&gt;维护与缺陷修复&lt;/li&gt;
&lt;li&gt;监控系统来保持正常运行&lt;/li&gt;
&lt;li&gt;故障排查&lt;/li&gt;
&lt;li&gt;适配新平台&lt;/li&gt;
&lt;li&gt;搭配新场景&lt;/li&gt;
&lt;li&gt;技术缺陷的完善&lt;/li&gt;
&lt;li&gt;增加新功能&lt;/li&gt;
&lt;li&gt;等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可运维性
&lt;ul&gt;
&lt;li&gt;监视系统的健康状况，并在服务出现异常状态时快速恢复服务&lt;/li&gt;
&lt;li&gt;追踪问题的原因，例如系统故障或性能下降&lt;/li&gt;
&lt;li&gt;保持软件和平台至最新状态，例如安全补丁方面&lt;/li&gt;
&lt;li&gt;了解不同系统如何相互影响，避免执行带有破坏性的操作&lt;/li&gt;
&lt;li&gt;预测未来可能的问题，并在问题发生之前即使解决(例如容量规划)&lt;/li&gt;
&lt;li&gt;建立用于部署、配置管理等良好的实践规范和工具包&lt;/li&gt;
&lt;li&gt;执行复杂的维护任务，例如将应用程序从一个平台迁移到另一个平台&lt;/li&gt;
&lt;li&gt;当配置更改时，维护系统的安全稳健&lt;/li&gt;
&lt;li&gt;制定流程来规范操作行为，并保持生产环境稳定&lt;/li&gt;
&lt;li&gt;保持相关知识的传承&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;简单性
&lt;ul&gt;
&lt;li&gt;复杂性有各种各样的表现方式
&lt;ul&gt;
&lt;li&gt;状态空间的脖胀&lt;/li&gt;
&lt;li&gt;模块紧耦合&lt;/li&gt;
&lt;li&gt;令入纠结的相互依赖关系&lt;/li&gt;
&lt;li&gt;不一致的命名和术语&lt;/li&gt;
&lt;li&gt;为了性能而采取的特殊处理&lt;/li&gt;
&lt;li&gt;为解决某特定问题而引入的特殊框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消除意外复杂性最好手段之一是抽象
&lt;ul&gt;
&lt;li&gt;一个好的设计抽象可用于各种不同的应用程序&lt;/li&gt;
&lt;li&gt;也带来更高质量的软件&lt;/li&gt;
&lt;li&gt;设计好的抽象还是很有挑战性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可演化性
&lt;ul&gt;
&lt;li&gt;一成不变的系统需求几乎没有，想法和目标经常在不断变化&lt;/li&gt;
&lt;li&gt;组织流程方面，敏捷开发模式为适应变化提供了很好的参考&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据模型与查询语言&#34;&gt;数据模型与查询语言&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据模型可能是开发软件最重要的部分&lt;/li&gt;
&lt;li&gt;复杂的应用程序可能会有更多的中间层&lt;/li&gt;
&lt;li&gt;每层都通过提供一个简洁的数据模型来隐藏下层的复杂性&lt;/li&gt;
&lt;li&gt;关系模型
&lt;ul&gt;
&lt;li&gt;数据被组织成关系
&lt;ul&gt;
&lt;li&gt;每个关系都是元组(tuples)的无序集合(在 SQL 中称为行)&lt;/li&gt;
&lt;li&gt;如果数据存储在关系表中，那么应用层代码中的对象与表、行和列的数据库模型之间需要一个笨拙的转换层&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;查询优化器自动决定以何种顺序执行查询，以及使用哪些索引&lt;/li&gt;
&lt;li&gt;只需构建一次查询优化器，然后使用该数据库的所有应用程序都可以从中受益&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络模型
&lt;ul&gt;
&lt;li&gt;它也被称为 CODASYL 模型&lt;/li&gt;
&lt;li&gt;网络模型中，一个记录可能有多个父结点&lt;/li&gt;
&lt;li&gt;在网络模型中，记录之间的链接不是外键，而更像是编程语言中的指针&lt;/li&gt;
&lt;li&gt;访问记录的唯一方法是选择一条始于根记录的路径，并沿着相关链接依次访问。&lt;/li&gt;
&lt;li&gt;查询和更新数据库变得异常复杂而没有灵活性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文档模型
&lt;ul&gt;
&lt;li&gt;无强制模式&lt;/li&gt;
&lt;li&gt;数据的结构是隐式的，只有在读取时才解释&lt;/li&gt;
&lt;li&gt;文档通常存储为编码为 JSON、XML 或其二进制变体的连续字符串&lt;/li&gt;
&lt;li&gt;存储局部性具有性能优势&lt;/li&gt;
&lt;li&gt;局部性优势仅适用需要同时访问文档大部分内容的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NoSQL
&lt;ul&gt;
&lt;li&gt;Not Only SQL&lt;/li&gt;
&lt;li&gt;比关系数据库更好的扩展性需求，包括支持超大数据集或超高写入吞吐量&lt;/li&gt;
&lt;li&gt;普遍偏爱免费和开源软件而不是商业数据库产品&lt;/li&gt;
&lt;li&gt;关系模型不能很好地支持一些特定的查询操作&lt;/li&gt;
&lt;li&gt;对关系模式一些限制性感到沮丧，渴望更具动态和表达力的数据模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在可预见的将来，关系数据库可能仍将继续与各种非关系数据存储一起使用，这种思路有时也被称为混合持久化&lt;/li&gt;
&lt;li&gt;文档数据库的比较
&lt;ul&gt;
&lt;li&gt;在表示多对一和多对多的关系时，关系数据库和文档数据库并没有根本的不同&lt;/li&gt;
&lt;li&gt;相关项都由唯一的标识符引用
&lt;ul&gt;
&lt;li&gt;在关系模型中被称为外键&lt;/li&gt;
&lt;li&gt;文档模型中被称为文档引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;支持文档数据模型的主要论点是模式灵活性， 由于局部性而带来较好的性能&lt;/li&gt;
&lt;li&gt;关系模型则强在联结操作、多对一和多对多关系更简洁的表达上，与文档模型抗衡&lt;/li&gt;
&lt;li&gt;对于高度关联的数据，文档模型不太适合，关系模型可以胜任，而图模型则是最为自然的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;融合关系模型与文档模型是未来数据库发展的一条很好的途径&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据存储与检索&#34;&gt;数据存储与检索&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;哈希索引
&lt;ul&gt;
&lt;li&gt;Bitcask 默认存储引擎&lt;/li&gt;
&lt;li&gt;提供高性能的读和写，只要所有的 key 可以放入内存&lt;/li&gt;
&lt;li&gt;只需一次磁盘寻址&lt;/li&gt;
&lt;li&gt;只追加到文件末尾，不做原地更新&lt;/li&gt;
&lt;li&gt;适合每个键的值频繁更新的场景&lt;/li&gt;
&lt;li&gt;执行压缩的同时将多个段合并在一起以节省空间&lt;/li&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;追加和分段合并主要是顺序写，它通常比随机写入快得多&lt;/li&gt;
&lt;li&gt;如果段文件是追加的或不可变的，则并发和崩溃恢复要简单得多&lt;/li&gt;
&lt;li&gt;合并旧段可以避免随着时间的推移数据文件出现碎片化的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;局限性
&lt;ul&gt;
&lt;li&gt;hash 表必须全部放入内存，磁盘表现难以良好&lt;/li&gt;
&lt;li&gt;区间查询查询效率低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSTables
&lt;ul&gt;
&lt;li&gt;要求 key-value 对按照 key 排序&lt;/li&gt;
&lt;li&gt;每个键在每个合并的段文件中只能出现一次&lt;/li&gt;
&lt;li&gt;合并段更加简单高效&lt;/li&gt;
&lt;li&gt;在文件中查找特定的键时，不再需要在内存中保存所有键的索引&lt;/li&gt;
&lt;li&gt;在压缩块开头保存稀疏索引&lt;/li&gt;
&lt;li&gt;构建和维护 SSTables
&lt;ul&gt;
&lt;li&gt;当写入时，将其添加到内存中的平衡树数据结构中(例如如红黑树)。这个内存中的树有时被称为内存表。&lt;/li&gt;
&lt;li&gt;当内存表大于某个闹值(通常为几兆字节)时，将其作为 SSTable 文件写入磁盘。由于树已经维护了按键排序的 key-value 对，写磁盘可以比较高效。新的 SSTable 文件成为数据库的最新部分。当 SSTable 写磁盘的同时 ，写入可以继续添加到一个新的内存表实例&lt;/li&gt;
&lt;li&gt;为了处理读请求，首先尝试在内存表中查找键，然后是最新的磁盘段文件，接下来是次新的磁盘段文件，以此类推，直到找到目标(或为空)&lt;/li&gt;
&lt;li&gt;后台进程周期性地执行段合并与压缩过程，以合并多个段文件，并丢弃那些已被覆盖或删除的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;崩溃处理 - 在磁盘上保留单独的日志，每个写入都会立即追加到该日志，每当将内存表写入 SSTable 时，相应的日志可以被丢弃&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LSM-tree
&lt;ul&gt;
&lt;li&gt;Log-Structured Merge-Tree&lt;/li&gt;
&lt;li&gt;确定键不存在之前，必须先检查内存表，然后将段一直回溯访问到最旧的段文件
&lt;ul&gt;
&lt;li&gt;为了优化这种访问，存储引擎通常使用额外的布隆过滤器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以支持非常高的写入吞吐量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B-trees
&lt;ul&gt;
&lt;li&gt;经受了长久的时间考验&lt;/li&gt;
&lt;li&gt;是几乎所有关系数据库中的标准索引实现&lt;/li&gt;
&lt;li&gt;B-tree 将数据库分解成固定大小的块或页, 这种设计更接近底层硬件，因为磁盘也是以固定大小的块排列&lt;/li&gt;
&lt;li&gt;查找索引中的一个键时, 从根开始。&lt;/li&gt;
&lt;li&gt;孩子都负责一个连续范围内的键，相邻引用之间的键可以指示这些范围之间的边界。&lt;/li&gt;
&lt;li&gt;大多数数据库可以适合 3~4 层的 B-tree&lt;/li&gt;
&lt;li&gt;使 B-tree 可靠
&lt;ul&gt;
&lt;li&gt;B-tree 底层的基本写操作是使用新数据覆盖磁盘上的旧页, 对该页的所有引用保持不变&lt;/li&gt;
&lt;li&gt;从崩溃中恢复, 预写日志(write-ahead log, WAL)，也称为重做日志&lt;/li&gt;
&lt;li&gt;每个 B-tree 的修改必 须先更新 WAL 然后再修改树本身的页&lt;/li&gt;
&lt;li&gt;多个线程要同时访问 B-tree , 注意并发控制 ，否则线程可能会看到树处于不一致的状态。通常使用锁存器(轻量级的锁)保护树的数据结构来完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优化 B-tree
&lt;ul&gt;
&lt;li&gt;利用 COW 来做并发控制&lt;/li&gt;
&lt;li&gt;保存键的缩略信息，而不是完整的键，这样可以节省页空间&lt;/li&gt;
&lt;li&gt;对树进行布局，以便相邻叶子页可以按顺序保存在磁盘上&lt;/li&gt;
&lt;li&gt;添加额外的指针到树中。 例如，每个叶子页面可能会向左和向右引用其同级的兄弟页，这样可以顺序扫描键，而不用跳回到 父页&lt;/li&gt;
&lt;li&gt;分形树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对比 B-tree 和 LSM-tree
&lt;ul&gt;
&lt;li&gt;B-tree 的 实现比 LSM-tree 的实现更为成熟&lt;/li&gt;
&lt;li&gt;LSM-tree 通常对于写快&lt;/li&gt;
&lt;li&gt;而 B-tree 被认为对于读取更快。读取通常在 LSM-tree 上较慢&lt;/li&gt;
&lt;li&gt;LSM-tree 的优点
&lt;ul&gt;
&lt;li&gt;LSM-tree 通常能够承受比 B-tree 更高的写入吞吐量&lt;/li&gt;
&lt;li&gt;它们有时具有较低的写放大&lt;/li&gt;
&lt;li&gt;它们以顺序方式写入紧凑的 SSTable 文件&lt;/li&gt;
&lt;li&gt;磁盘的顺序写比随机写要快得多&lt;/li&gt;
&lt;li&gt;LSM-tree 可以支持更好地压缩，因此通常磁盘上的文件比 B-tree 小很多&lt;/li&gt;
&lt;li&gt;更少的碎片&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LSM-tree 的缺点
&lt;ul&gt;
&lt;li&gt;压缩过程有时会干扰正在进行的读写操作&lt;/li&gt;
&lt;li&gt;压缩和写入共享带宽, 数据库的数据量越大，压缩所需的磁盘带宽就越多&lt;/li&gt;
&lt;li&gt;写入高并且压缩没有仔细配置，随着未合并段的不断增加，读取会变慢&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他索引结构
&lt;ul&gt;
&lt;li&gt;二级索引
&lt;ul&gt;
&lt;li&gt;索引中的键是查询搜索的对象
&lt;ul&gt;
&lt;li&gt;实际存储的行&lt;/li&gt;
&lt;li&gt;对其他地方存储的行的引用&lt;/li&gt;
&lt;li&gt;存储行的具体文件被称为堆文件
&lt;ul&gt;
&lt;li&gt;避免数据复制，实际数据只存在一个地方&lt;/li&gt;
&lt;li&gt;当新值大于旧值时，需要将数据移动到新空间，在原地保存一个指向新地址的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将索引行直接存储在索引中，聚簇索引
&lt;ul&gt;
&lt;li&gt;在某些数据库中，表的主键始终是聚簇索引，表的二级索引引用主键索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;索引覆盖
&lt;ul&gt;
&lt;li&gt;索引中保存了一些表的列值，刚好满足查询条件&lt;/li&gt;
&lt;li&gt;加快读取速度，更大的写开销和事物开销&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多列索引
&lt;ul&gt;
&lt;li&gt;将几个字段按照顺序组成一个键&lt;/li&gt;
&lt;li&gt;专门的空间索引，R 树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全文索引
&lt;ul&gt;
&lt;li&gt;Lucene&lt;/li&gt;
&lt;li&gt;采用了类似 SSTable 的索引结构&lt;/li&gt;
&lt;li&gt;内存中的索引是键中的字符序列的有限状态自动机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在内存中保存所有内容
&lt;ul&gt;
&lt;li&gt;用于缓存的内存数据库可以容忍丢失&lt;/li&gt;
&lt;li&gt;不能丢失的可以持久化到磁盘或者冗余到其他机器&lt;/li&gt;
&lt;li&gt;关系型数据库的数据也可以完全存在数据库&lt;/li&gt;
&lt;li&gt;使用磁盘格式的编码开销大于 KV 结构的数据库&lt;/li&gt;
&lt;li&gt;基于内存的数据库可以提供更多的数据结构&lt;/li&gt;
&lt;li&gt;更容易水平扩展&lt;/li&gt;
&lt;li&gt;NVM 技术的发展&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事务处理与分析处理
&lt;ul&gt;
&lt;li&gt;ACID(原子性、一致性、隔离性和持久性)&lt;/li&gt;
&lt;li&gt;OLTP 和 OLAP 对比
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;属性&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;OLTP&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;OLAP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;主要读特征&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;基于键，每次查询返回少量的记录&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对大量记录进行汇总&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;主要写特征&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;随机访问，低延迟写入用户的输入&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;批量导入( ETL)或事件流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;典型使用场景&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;终端用户，通过网络应用程序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;内部分析师，为决策提供支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据表征&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;最新的数据状态(当前时间点)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;随着时间而变化的所有事件历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据规模&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;GB 到 TB&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TB 到 PB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;OLTP 存储引擎
&lt;ul&gt;
&lt;li&gt;日志结构&lt;/li&gt;
&lt;li&gt;原地更新&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SQL 可以同时胜任 OLAP 和 OLTP&lt;/li&gt;
&lt;li&gt;数据仓库
&lt;ul&gt;
&lt;li&gt;在线的数据分析影响 LATP 性能&lt;/li&gt;
&lt;li&gt;数据仓库可以针对分析访问模式进行优化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;星型和雪花型分析模式
&lt;ul&gt;
&lt;li&gt;星型模型
&lt;ul&gt;
&lt;li&gt;模式的中心是一个所谓的事实表，事实表的每一行表示特定时间发生的事件&lt;/li&gt;
&lt;li&gt;其他列可能会引用其他表的外键，称为维度表&lt;/li&gt;
&lt;li&gt;事实表中的每一行都代表一个事件，维度通常代表事件的对象(who)、什么(what)、地点(where)、时间(when)、方法(how)以及原因(why)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;雪花模型
&lt;ul&gt;
&lt;li&gt;在星型模型的基础上维度进一步细分为子空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在典型的数仓中，表的列非常宽，有时有几百列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;列式存储
&lt;ul&gt;
&lt;li&gt;访问的数据通常只有少数列&lt;/li&gt;
&lt;li&gt;来自表的一列的所有值相邻存储&lt;/li&gt;
&lt;li&gt;列压缩&lt;/li&gt;
&lt;li&gt;位图编码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存带宽和矢量化处理
&lt;ul&gt;
&lt;li&gt;CPU 缓存&lt;/li&gt;
&lt;li&gt;SIMD&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;列存储中的排序
&lt;ul&gt;
&lt;li&gt;行的存储顺序并不太重要&lt;/li&gt;
&lt;li&gt;第一列排序出现相同值时，可以指定第二列继续进行排序&lt;/li&gt;
&lt;li&gt;面向列的存储具有多个排序顺序，这有些类似在面向行的存储中具有多个二级索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;列存储的写操作
&lt;ul&gt;
&lt;li&gt;LSM-Tree&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物化聚合
&lt;ul&gt;
&lt;li&gt;物化视图，内容是一些查询的结果&lt;/li&gt;
&lt;li&gt;从虚拟视图查询时，SQL 引擎将其动态扩展到视图的底层查询，然后处理扩展查询&lt;/li&gt;
&lt;li&gt;OLAP 立方体，由不同唯独分组的聚合网格&lt;/li&gt;
&lt;li&gt;数据立方体缺乏像查询原始数据那样的灵活性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据编码与演化&#34;&gt;数据编码与演化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;双向的兼容性
&lt;ul&gt;
&lt;li&gt;较新的代码可以读取由旧代码编写的数据&lt;/li&gt;
&lt;li&gt;较旧的代码可以读取由新代码编写的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据编码格式
&lt;ul&gt;
&lt;li&gt;在内存中，数据保存在对象、结构体、列表、数组、哈希表和树等结构中。这些数据结构针对 CPU 的高效访问和操作进行了优化&lt;/li&gt;
&lt;li&gt;将数据写入文件或通过网络发送时，必须将其编码为某种自包含的字节序列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;语言特定的格式
&lt;ul&gt;
&lt;li&gt;语言绑定&lt;/li&gt;
&lt;li&gt;安全问题&lt;/li&gt;
&lt;li&gt;兼容性问题&lt;/li&gt;
&lt;li&gt;性能问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JSON，XML，CSV
&lt;ul&gt;
&lt;li&gt;数字编码有很多模糊之处。在 XML 和 csv 中，无怯区分数字和碰巧由数字组成的字符串&lt;/li&gt;
&lt;li&gt;JSON 区分字符串和数字，但不区分整数和浮点数，并且不指定精度。&lt;/li&gt;
&lt;li&gt;JSON 和 XML 对 Unicode 字符串(即人类可读文本)有很好的支持，但是它们不支持二进制字符串(没有字符编码的字节序列)&lt;/li&gt;
&lt;li&gt;XML 和 JSON 都有可选的模式支持&lt;/li&gt;
&lt;li&gt;CSV 没有任何模式，因此应用程序需要定义每行和每列的含义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二进制变体
&lt;ul&gt;
&lt;li&gt;大数据集收益明显&lt;/li&gt;
&lt;li&gt;MessagePack
&lt;ul&gt;
&lt;li&gt;一种 JSON 的二进制编码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Thrift 与 Protocol Buffers
&lt;ul&gt;
&lt;li&gt;需要模式来编码任意的数据&lt;/li&gt;
&lt;li&gt;Thrift 与使用 Thrift 接口定义语言来描述模式&lt;/li&gt;
&lt;li&gt;Protocol Buffers 使用类似模式&lt;/li&gt;
&lt;li&gt;没有字段名&lt;/li&gt;
&lt;li&gt;如果字段设置了 required，但字段未填充，则运行时检查将出现失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字段标签和模式演化
&lt;ul&gt;
&lt;li&gt;字段标签(field tag)对编码数据的含义至关重要。编码永远不直接引用字段名称&lt;/li&gt;
&lt;li&gt;可以添加新的字段到模式，只要给每个字段一个新的标记号码。如果旧的代码(不知道添加的新标记号码)试图读取新代码写入的数据，包括一个它不能识别的标记号码中新的字段，则它可以简单地忽略该字段&lt;/li&gt;
&lt;li&gt;只要每个字段都有一个唯一的标记号码，新的代码总是可以读取旧的数据，因为标记号码仍然具有相同的含义&lt;/li&gt;
&lt;li&gt;为了保持向后兼容性，在模式的初始部署之后添加的每个字段都必须是可选的或具有默认值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Avro
&lt;ul&gt;
&lt;li&gt;二进制编码格式&lt;/li&gt;
&lt;li&gt;Avro IDL 用于人工编辑&lt;/li&gt;
&lt;li&gt;另一种(基于 JSON)更易于机器读取&lt;/li&gt;
&lt;li&gt;只有当读取数据的代码使用与写入数据的代码完全相同的模式肘，才能正确解码二进制数据。读和写的模式如果有任何不匹配 都将无法解码数据&lt;/li&gt;
&lt;li&gt;模式演化
&lt;ul&gt;
&lt;li&gt;在不同的上下文环境中保存单一的模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;模式的优点
&lt;ul&gt;
&lt;li&gt;它们可以比各种“二进制 JSON”变体更紧凑，可以省略编码数据中的宇段名称。&lt;/li&gt;
&lt;li&gt;模式是一种有价值的文档形式，因为模式是解码所必需的，所以可以确定它是最新的&lt;/li&gt;
&lt;li&gt;模式数据库允许在部署任何内容之前检查模式更改的向前和向后兼容&lt;/li&gt;
&lt;li&gt;对于静态类型编程语言的用户来说，从模式生成代码的能力是有用的，它能够在编译时进行类型检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据流模式
&lt;ul&gt;
&lt;li&gt;进程间数据流动的方式
&lt;ul&gt;
&lt;li&gt;通过数据库&lt;/li&gt;
&lt;li&gt;通过服务调用&lt;/li&gt;
&lt;li&gt;通过异步消息传递&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于数据库的数据流
&lt;ul&gt;
&lt;li&gt;服务版本不一致&lt;/li&gt;
&lt;li&gt;向前兼容，旧版本的代码不处理新版本加入的值&lt;/li&gt;
&lt;li&gt;不同时间写入不同的值导致字段丢失&lt;/li&gt;
&lt;li&gt;创建归档时使用统一的编码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于服务的数据流
&lt;ul&gt;
&lt;li&gt;REST 和 RPC&lt;/li&gt;
&lt;li&gt;服务器公开的 API 称为服务&lt;/li&gt;
&lt;li&gt;服务器和客户端使用的数据编码必须在不同版本的服务 API 之间兼容&lt;/li&gt;
&lt;li&gt;网络服务
&lt;ul&gt;
&lt;li&gt;运行在用户设备上的客户端应用程序，通过 HTTP 向服务发出请求, 这些请求通常通过公共互联网进行&lt;/li&gt;
&lt;li&gt;一种服务向同一组织拥有的另一项服务提出请求，这些服务通常位于同一数据中心内 ，作为面向服务/微型架构的一部分。支持这种用例的软件有时被称为中间件&lt;/li&gt;
&lt;li&gt;一种服务向不同组织所拥有的服务提出请求，经常需通过互联网 。这用于不同组织后端系统之间的数据交换。此类别包括由在线服务(如信用卡处理系统)提供的公共 API，或用于共享访问用户数据的 OAuth&lt;/li&gt;
&lt;li&gt;有两种流行的 Web 服务方方法 : REST 和 SOAP
&lt;ul&gt;
&lt;li&gt;REST
&lt;ul&gt;
&lt;li&gt;它强调简单的数据格式，使用 URL 来标识资源，并使用 HTTP 功能进行缓存控制、身份验证和内容类型协商&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SOAP
&lt;ul&gt;
&lt;li&gt;基于 XML 的协议，用于发出网络 API 请求&lt;/li&gt;
&lt;li&gt;SOAP Web 服务的 API 使用被称为 WSDL&lt;/li&gt;
&lt;li&gt;过于复杂, 无法手动构建，SOAP 用户严重依赖工具支持、代码生成和 IDE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;远程过程调用(RPC)的问题
&lt;ul&gt;
&lt;li&gt;结果不可预测&lt;/li&gt;
&lt;li&gt;服务幂等&lt;/li&gt;
&lt;li&gt;网络波动&lt;/li&gt;
&lt;li&gt;大对象编码解析&lt;/li&gt;
&lt;li&gt;不同的语言的支持问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RPC 的发展方向
&lt;ul&gt;
&lt;li&gt;封装可能失败的异步操作&lt;/li&gt;
&lt;li&gt;并行请求多项服务&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RPC 方案的向后和向前兼容性属性取决于它所使用的具体编码技术&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于消息传递的数据流
&lt;ul&gt;
&lt;li&gt;如果接收方不可用或过载，它可以充当缓冲区，从而提高系统的可靠性。&lt;/li&gt;
&lt;li&gt;它可以自动将消息重新发送到崩溃的进程，从而防止消息丢失。&lt;/li&gt;
&lt;li&gt;它支持将一条消息发送给多个接收方&lt;/li&gt;
&lt;li&gt;它在逻辑上将发送方与接收方分离&lt;/li&gt;
&lt;li&gt;消息代理
&lt;ul&gt;
&lt;li&gt;一个进程向指定的队列或主题发送消息，并且代理确保消息被传递给队列或主题的一个或多个消费者或订阅者&lt;/li&gt;
&lt;li&gt;在同一主题上可以有许多生产者和许多消费者&lt;/li&gt;
&lt;li&gt;主题只提供单向数据流&lt;/li&gt;
&lt;li&gt;消息代理通常不会强制任何特定的数据模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分布式 Actor 框架
&lt;ul&gt;
&lt;li&gt;Actor 模型是用于单个进程中并发的编程模型&lt;/li&gt;
&lt;li&gt;逻辑被封装在 Actor 中，而不是直接处理线程&lt;/li&gt;
&lt;li&gt;每个 Actor 通常代表一个客户端或实体，它可能具有某些本地状态(不与其他任何 Actor 共享)&lt;/li&gt;
&lt;li&gt;它通过发送和接收异步消息与其他 Actor 通信。&lt;/li&gt;
&lt;li&gt;不保证消息传送: 在某些错误情况下，消息将丢失。&lt;/li&gt;
&lt;li&gt;由于每个 Actor 一次只处理一条消息，因此不需要担心线程，每个 Actor 都可以由框架独立调度。&lt;/li&gt;
&lt;li&gt;三种流行的分布式 Actor 框架处理消息编码的方式
&lt;ul&gt;
&lt;li&gt;默认情况下，Akka 使用 Java 的内置序列化，它不提供向前或向后兼容性。但是，可以用类似 Protocol Buffers 的东西替代它，从而获得滚动升级的能力&lt;/li&gt;
&lt;li&gt;默认情况下， Orleans 使用不支持滚动升级部署的自定义数据编码格式:要部署新版本的应用程序，需要建立一个新的集群，将流量从旧集群导入到新集群，然后关闭旧集群。像 Akka 一样，也可以使用自定义序列化插件。&lt;/li&gt;
&lt;li&gt;在 Erlang OTP 中，很难对记录模式进行更改, 滚动升级在技术上是可能的，但要求仔细规划。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>系统设计::从零到一百万</title>
      <link>/notes/system_design_interview_01/</link>
      <pubDate>Mon, 01 Feb 2021 22:20:24 +0800</pubDate>
      <guid>/notes/system_design_interview_01/</guid>
      <description>&lt;h2 id=&#34;从零到一百万&#34;&gt;从零到一百万&lt;/h2&gt;
&lt;p&gt;设计一个支持数百万用户的系统是一个挑战，这是一个需要不断完善和无止境改进的历程。在本章中，我们将构建一个支持单个用户的系统，并逐步将其扩展到服务数百万用户。读完本章，你将掌握一手的技巧，帮助你破解系统设计的面试题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单服务器设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;千里之行始于足下，构建一个复杂的系统也不例外。先从简单的东西开始，所有的东西都运行在一台服务器上。图 1-1 是单服务器设置的说明，所有的东西都在一台服务器上运行：Web 应用、数据库、缓存等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-6_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;为了理解这种设置，研究一下请求流程和流量来源是很有帮助的。我们先来看看请求流程（图 1-2）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-6_2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户通过域名访问网站，如 api.mysite.com。通常，域名系统（DNS）是由第三方提供的付费服务，而不是由我们的服务器托管。&lt;/li&gt;
&lt;li&gt;互联网协议（IP）地址返回给浏览器或移动应用。在本例中，返回的 IP 地址为 15.125.23.214。&lt;/li&gt;
&lt;li&gt;获得 IP 地址后，超文本传输协议（HTTP）[1]请求直接发送到您的网络服务器。&lt;/li&gt;
&lt;li&gt;Web 服务器返回 HTML 页面或 JSON 响应进行渲染。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来，我们来看看流量来源。你的 Web 服务器的流量来自两个方面：Web 应用和移动应用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web 应用：它使用服务器端语言（Java、Python 等）组合来处理业务逻辑、存储等，使用客户端语言（HTML 和 JavaScript）来进行展示。&lt;/li&gt;
&lt;li&gt;移动应用。HTTP 协议是移动应用与 Web 服务器之间的通信协议。JavaScript 对象符号（JSON）由于其简单性，是常用的 API 响应格式来传输数据。JSON 格式的 API 响应示例如下所示。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;firstName&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;John&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;lastName&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;Smith&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;address&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;streetAddress&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;21 2nd street&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;city&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;New York&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;state&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;NY&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;postal Code&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10021&lt;/span&gt;
  &lt;span style=&#34;color:#111&#34;&gt;},&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;phoneNumbers&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;212 555-1234&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;646 555-4567&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;]&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;GET /users/12 – Retrieve user object for id = 12&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着用户群的增长，一台服务器是不够的，我们需要多台服务器：一台用于 web/移动流量，另一台用于数据库（图 1-3）。将 web/移动流量（web 层）和数据库（数据层）服务器分开，可以让它们独立扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-8_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用哪种数据库?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以选择传统的关系型数据库和非关系型数据库。让我们来看看它们的区别。&lt;/p&gt;
&lt;p&gt;关系型数据库也叫关系型数据库管理系统（RDBMS）或 SQL 数据库。最流行的有 MySQL、Oracle 数据库、PostgreSQL 等。关系型数据库以表和行来表示和存储数据。你可以在不同的数据库表之间使用 SQL 进行连接操作。&lt;/p&gt;
&lt;p&gt;非关系型数据库也叫 NoSQL 数据库。常用的有 CouchDB、Neo4j、Cassandra、HBase、Amazon DynamoDB 等。[2]. 这些数据库分为四类：键值存储、图存储、列存储和文档存储。在非关系型数据库中，一般不支持 Join 操作。&lt;/p&gt;
&lt;p&gt;对于大多数开发人员来说，关系型数据库是最好的选择，因为关系型数据库已经存在了 40 多年，而且从历史上看，关系型数据库运行良好。然而，如果关系型数据库不适合你的特定用例，那么探索关系型数据库之外的东西是至关重要的。在以下情况下，非关系型数据库可能是正确的选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你的应用需要超低的延迟&lt;/li&gt;
&lt;li&gt;你的数据是非结构化的，或者你没有任何关系型数据。&lt;/li&gt;
&lt;li&gt;你只需要序列化和反序列化数据（JSON、XML、YAML 等）。&lt;/li&gt;
&lt;li&gt;你需要存储大量的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;垂直扩展与水平扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;垂直扩展，简称为 &amp;ldquo;扩容&amp;rdquo;，指的是为服务器增加更多功率（CPU、RAM 等）的过程。&lt;/p&gt;
&lt;p&gt;水平扩展，称为 &amp;ldquo;scale-out&amp;rdquo;，允许您通过向资源池中添加更多的服务器来扩展。&lt;/p&gt;
&lt;p&gt;当流量较低时，垂直扩展是一个很好的选择，垂直扩展的简单性是其主要优势。不幸的是，它有严重的局限性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垂直扩展有一个硬件限制。不可能在一台服务器上增加无限的 CPU 和内存。&lt;/li&gt;
&lt;li&gt;垂直扩展没有故障转移和冗余。如果一台服务器出现故障，网站/应用也会随之完全瘫痪。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于垂直扩展的局限性，水平扩展对于大规模的应用更为理想。
在之前的设计中，用户是直接连接到网站服务器的。如果 Web 服务器离线，用户将无法访问网站。在另一种情况下，如果很多用户同时访问 Web 服务器，达到了 Web 服务器的负载极限，用户一般会出现响应速度较慢或无法连接到服务器的情况。负载均衡是解决这些问题的最佳技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载均衡将传入的流量均匀地分配给定义在负载均衡集群中的 Web 服务器。图 1-4 显示了负载均衡器的工作原理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-10_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图 1-4 所示，用户直接连接到负载均衡器的公网 IP。通过这种设置，Web 服务器已经无法被客户端直接访问了。为了提高安全性，服务器之间的通信采用私有 IP。私有 IP 是指只有同一网络中的服务器之间才能到达的 IP 地址，但是，通过互联网是无法到达的。负载均衡器通过私有 IP 与 Web 服务器进行通信。&lt;/p&gt;
&lt;p&gt;在图 1-4 中，增加了一个负载均衡器和第二台 Web 服务器后，我们成功解决了无故障切换问题，提高了 Web 层的可用性。下面将详细说明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果服务器 1 离线，所有的流量将被路由到服务器 2。这样可以防止网站离线。我们也会在服务器池中增加一个新的健康网站服务器来平衡负载。&lt;/li&gt;
&lt;li&gt;如果网站流量快速增长，两台服务器不足以处理流量，负载均衡器可以优雅地处理这个问题。你只需要向 Web 服务器池添加更多的服务器，负载平衡器就会自动开始向它们发送请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在 web 层看起来不错，那数据层呢？目前的设计只有一个数据库，所以它不支持故障转移和冗余。数据库复制是解决这些问题的一个常用技术。让我们来看看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库复制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引自维基百科。&amp;ldquo;数据库复制可用于许多数据库管理系统，通常原始数据库(主数据库)和副本(从数据库)之间存在主/从关系&amp;rdquo;[3]。&lt;/p&gt;
&lt;p&gt;主数据库一般只支持写操作。从数据库从主数据库获取数据的副本，只支持读操作。所有的插入、删除、更新等数据修改命令都必须发送到主数据库。大多数应用对读与写的比例要求更高，因此，系统中从数据库的数量通常大于主数据库的数量。图 1-5 显示了一个主数据库与多个从数据库的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-12_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库复制的优势&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能更好。在主从模式中，所有写入和更新都发生在主节点上；而读操作则分布在从节点上。这种模式可以提高性能，因为它允许并行处理更多的查询。&lt;/li&gt;
&lt;li&gt;可靠性。如果你的一个数据库服务器被自然灾害摧毁，如台风或地震，数据仍然会被保存下来。您不必担心数据丢失，因为数据是在多个地点复制的。&lt;/li&gt;
&lt;li&gt;高可用性。通过在不同地点复制数据，即使数据库离线，您的网站仍然可以运行，因为您可以访问存储在另一个数据库服务器的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上一节中，我们讨论了负载均衡器如何帮助提高系统的可用性。我们在这里提出同样的问题：如果其中一个数据库离线了怎么办？图 1-5 中讨论的架构设计可以处理这种情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果只有一个从数据库可用，而它又脱机了，读操作将被暂时导向主数据库。一旦发现问题，新的从数据库将取代旧的数据库。如果有多个从数据库可用，读取操作将被重定向到其他健康的从数据库。新的数据库服务器将取代旧的数据库。&lt;/li&gt;
&lt;li&gt;如果主数据库下线，一个从数据库将被提升为新的主数据库。所有的数据库操作将暂时在新的主数据库上执行。新的从数据库将立即取代旧的数据库进行数据复制。在生产系统中，推广新的主数据库比较复杂，因为从数据库中的数据可能不是最新的。缺少的数据需要通过运行数据恢复脚本来更新。虽然其他一些复制方法，如多主站和循环复制可以帮助我们，但这些设置比较复杂；而且它们的讨论也超出了本书的范围。有兴趣的读者可以参考列出的参考资料[4][5]。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图 1-6 是增加负载均衡器和数据库复制后的系统设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-14_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们来看一下设计。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户从 DNS 获取负载均衡器的 IP 地址。&lt;/li&gt;
&lt;li&gt;用户用这个 IP 地址连接负载均衡器。&lt;/li&gt;
&lt;li&gt;HTTP 请求被路由到服务器 1 或服务器 2。&lt;/li&gt;
&lt;li&gt;Web 服务器从从属数据库读取用户数据。&lt;/li&gt;
&lt;li&gt;Web 服务器将任何数据修改操作路由到主数据库。这包括写入、更新和删除操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，你已经对网络和数据层有了坚实的了解，是时候提高加载/响应时间了。这可以通过添加缓存层和将静态内容（JavaScript/CSS/图片/视频文件）转移到内容传输网络（CDN）来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缓存是一个临时的存储区域，它将昂贵的响应结果或频繁访问的数据存储在内存中，以便后续的请求能够更快地得到服务。如图 1-6 所示，每次加载新的网页时，都会执行一次或多次数据库调用来获取数据。由于反复调用数据库，应用性能受到很大影响。缓存可以缓解这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缓存层是一个临时的数据存储层，比数据库快得多。单独设置缓存层的好处包括更好的系统性能，能够减少数据库的工作负载，以及能够独立地扩展缓存层。图 1-7 显示了一个缓存服务器的可能设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-15_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在收到请求后，Web 服务器首先检查缓存是否有可用的响应。如果有，它就把数据发回给客户端。如果没有，它就查询数据库，将响应存储在缓存中，然后再发回给客户端。这种缓存策略称为读通式缓存。根据数据类型、大小和访问模式，还有其他缓存策略可供选择。之前的一项研究解释了不同缓存策略的工作原理[6]。&lt;/p&gt;
&lt;p&gt;与缓存服务器的交互很简单，因为大多数缓存服务器都提供了通用编程语言的 API。下面的代码片段展示了典型的 Memcached API。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#75af00&#34;&gt;SECONDS&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#75af00&#34;&gt;cache&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;set&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;myKey&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;hi there&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3600&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;SECONDS&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#75af00&#34;&gt;cache&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;myKey&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;使用缓存的注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下是使用缓存系统的几个注意事项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;决定何时使用缓存。当数据经常被读取但不经常被修改时，考虑使用缓存。由于缓存数据存储在易失性内存中，因此缓存服务器并不是持久化数据的理想选择。例如，如果缓存服务器重新启动，内存中的所有数据都会丢失。因此，重要的数据应该保存在持久化数据存储中。&lt;/li&gt;
&lt;li&gt;过期策略。实施过期策略是一个很好的做法。一旦缓存数据过期，它就会从缓存中删除。当没有过期策略时，缓存数据将永久保存在内存中。建议不要把过期日期定得太短，否则会导致系统过于频繁地从数据库中重新加载数据。同时，建议不要把有效期做得太长，因为数据会变得陈旧。&lt;/li&gt;
&lt;li&gt;一致性。这涉及到保持数据存储和缓存的同步。由于对数据存储和缓存的数据修改操作不在一个事务中，所以会发生不一致的情况。当跨多个区域扩展时，保持数据存储和缓存之间的一致性是一个挑战。更多细节，请参考 Facebook 发布的题为 &amp;ldquo;Scaling Memcache at Facebook &amp;ldquo;的论文[7]。&lt;/li&gt;
&lt;li&gt;缓解故障。单个缓存服务器代表了一个潜在的单点故障（SPOF），在维基百科中的定义如下。&amp;ldquo;单点故障(SPOF)是指系统的一部分，如果它发生故障，将使整个系统停止工作&amp;rdquo;[8]。因此，建议在不同的数据中心设置多台缓存服务器，以避免 SPOF 的发生。另一种推荐的方法是按一定的百分比超额提供所需的内存。这样可以在内存使用量增加时提供一个缓冲区。&lt;/li&gt;
&lt;li&gt;驱逐政策。一旦缓存满了，任何向缓存添加项目的请求都可能导致现有项目被删除。这就是所谓的缓存驱逐。最少最近使用（LRU）是最流行的缓存驱逐策略。其他的驱逐策略，如最不常用(LFU)或先进先出(FIFO)，可以满足不同的用例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-16_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内容传输网络(CDN)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CDN 是一个由地理上分散的服务器组成的网络，用于传输静态内容。CDN 服务器缓存静态内容，如图片、视频、CSS、JavaScript 文件等。&lt;/p&gt;
&lt;p&gt;动态内容缓存是一个比较新的概念，超出了本书的范围。它可以实现基于请求路径、查询字符串、Cookie 和请求头的 HTML 页面的缓存。关于这方面的内容，请参考参考资料[9]中提到的文章。本书主要介绍如何使用 CDN 来缓存静态内容。&lt;/p&gt;
&lt;p&gt;下面是 CDN 的顶层工作原理：当用户访问一个网站时，离用户最近的 CDN 服务器将提供静态内容。直观地说，用户离 CDN 服务器越远，网站的加载速度越慢。例如，如果 CDN 服务器在旧金山，那么洛杉矶的用户将比欧洲的用户更快地获得内容。图 1-9 是一个很好的例子，它显示了 CDN 如何改善加载时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-17_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;图 1-10 展示了 CDN 的工作流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-17_2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户 A 试图通过图片 URL 获取 image.png。该 URL 的域名由 CDN 提供商提供。以下两个图片 URL 是用来演示 Amazon 和 Akamai CDN 上的图片 URL 的示例。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mysite.cloudfront.net/logo.jpg&#34;&gt;https://mysite.cloudfront.net/logo.jpg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mysite.akamai.com/image-manager/img/logo.jpg&#34;&gt;https://mysite.akamai.com/image-manager/img/logo.jpg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果 CDN 服务器的缓存中没有 image.png，CDN 服务器就会向原点请求该文件，这个原点可以是 Web 服务器，也可以是 Amazon S3 等在线存储。&lt;/li&gt;
&lt;li&gt;原点将 image.png 返回给 CDN 服务器，其中包括可选的 HTTP 头 Time-to-Live（TTL），它描述了图像被缓存的时间。&lt;/li&gt;
&lt;li&gt;CDN 缓存图像并将其返回给用户 A，图像一直在 CDN 中缓存，直到 TTL 过期。&lt;/li&gt;
&lt;li&gt;用户 B 发送一个请求来获取相同的图像。&lt;/li&gt;
&lt;li&gt;只要 TTL 没有过期，图像就会从缓存中返回。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;使用 CDN 的注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;费用。CDN 由第三方供应商运营，您需要为进出 CDN 的数据传输付费。缓存不经常使用的资产并不能提供显著的好处，所以你应该考虑将它们移出 CDN。&lt;/li&gt;
&lt;li&gt;设置一个合适的缓存到期时间。对于时间敏感的内容，设置一个缓存到期时间很重要。缓存到期时间既不能太长也不能太短。如果太长，内容可能过期。如果太短，可能会导致从源服务器到 CDN 的内容重复重载。&lt;/li&gt;
&lt;li&gt;CDN 回源。你应该考虑你的网站/应用如何应对 CDN 故障。如果 CDN 出现临时中断，客户端应该能够检测到问题，并从源服务器请求资源。&lt;/li&gt;
&lt;li&gt;使文件无效。您可以通过执行以下操作之一，在文件过期前从 CDN 中删除文件。
&lt;ul&gt;
&lt;li&gt;使用 CDN 供应商提供的 API 使 CDN 对象无效。&lt;/li&gt;
&lt;li&gt;使用对象版本化来服务对象的不同版本。要对对象进行版本管理，可以在 URL 中添加一个参数，例如版本号。例如，在查询字符串中添加版本号 2：image.png?v=2。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图 1-11 是添加 CDN 和缓存后的设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-19_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态资产（JS、CSS、图片等）不再由 Web 服务器提供服务。它们从 CDN 获取，以获得更好的性能。&lt;/li&gt;
&lt;li&gt;通过缓存数据，减轻了数据库的负载。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;无状态 Web 层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在是时候考虑横向扩展 Web 层了。为此，我们需要将状态（例如用户会话数据）移出 web 层。一个好的做法是将会话数据存储在持久性存储中，如关系型数据库或 NoSQL。集群中的每个 Web 服务器都可以从数据库中访问状态数据。这就是所谓的无状态 Web 层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有状态架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有状态服务器和无状态服务器有一些关键的区别。有状态的服务器会记住客户的数据（状态），从一个请求到下一个请求。无状态服务器不保留状态信息。&lt;/p&gt;
&lt;p&gt;图 1-12 显示了一个有状态架构的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-20_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在图 1-12 中，用户 A 的会话数据和配置文件图像存储在服务器 1 中。要对用户 A 进行身份验证，HTTP 请求必须路由到服务器 1。如果向服务器 2 等其他服务器发送请求，认证将失败，因为服务器 2 不包含用户 A 的会话数据。同样，所有来自用户 B 的 HTTP 请求必须路由到服务器 2；所有来自用户 C 的请求必须发送到服务器 3。&lt;/p&gt;
&lt;p&gt;问题是来自同一客户端的每个请求都必须路由到同一个服务器。这可以通过大多数负载均衡器中的粘性会话来实现[10]；然而，这增加了开销。使用这种方法增加或删除服务器要困难得多。处理服务器故障也是一个挑战。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无状态结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图 1-13 为无状态架构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-21_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在这种无状态架构中，用户的 HTTP 请求可以发送到任何 Web 服务器上，服务器从共享数据存储中获取状态数据。状态数据存储在共享数据存储中，不受 Web 服务器的影响。无状态系统更简单、更健壮、可扩展。&lt;/p&gt;
&lt;p&gt;图 1-14 为无状态网络层的更新设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-22_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在图 1-14 中，我们将会话数据从 Web 层移出，并将其存储在持久化数据存储中。共享数据存储可以是关系型数据库、Memcached/Redis、NoSQL 等。选择 NoSQL 数据存储是因为它易于扩展。自动伸缩是指根据流量负载自动增加或删除 Web 服务器。当状态数据从 web 服务器中取出后，根据流量负载增加或删除服务器，就可以轻松实现 web 层的自动伸缩。&lt;/p&gt;
&lt;p&gt;您的网站发展迅速，在国际上吸引了大量的用户。为了提高可用性，并在更广泛的地域提供更好的用户体验，支持多个数据中心至关重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据中心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图 1-15 是一个有两个数据中心的设置实例。在正常运行中，用户会被 geoDNS-routed，也就是地理路由，到最近的数据中心，美东地区的流量分成 x%，美西地区的流量分成(100 - x)%，geoDNS 是一种 DNS 服务，可以根据用户的位置将域名解析到 IP 地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-23_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在任何重大的数据中心中断的情况下，我们将所有的流量引导到一个健康的数据中心。在图 1-16 中，数据中心 2（US-West）处于离线状态，100%的流量被引导到数据中心 1（US-East）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-24_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;要实现多数据中心的设置，必须解决几个技术难题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流量重定向。需要有效的工具来引导流量到正确的数据中心。GeoDNS 可以根据用户所在的位置，将流量引导到最近的数据中心。&lt;/li&gt;
&lt;li&gt;数据同步。来自不同地区的用户可能使用不同的本地数据库或缓存。在故障转移情况下，流量可能会被路由到数据不可用的数据中心。一个常见的策略是在多个数据中心之间复制数据。之前的一项研究展示了 Netflix 如何实现异步多数据中心复制[11]。&lt;/li&gt;
&lt;li&gt;测试和部署。对于多数据中心的设置，在不同的位置测试你的网站/应用是很重要的。自动部署工具对于在所有数据中心保持服务的一致性至关重要[11]。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了进一步扩展我们的系统，我们需要对系统的不同组件进行解耦，以便它们可以独立地进行扩展。消息队列是许多现实世界的分布式系统采用的一个关键策略，以解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;消息队列是一个持久的组件，存储在内存中，支持异步通信。它作为一个缓冲区，分发异步请求。消息队列的基本架构很简单。输入服务，称为生产者/发布者，创建消息，并将它们发布到消息队列中。其他服务或服务器，称为消费者/订阅者，连接到队列，并执行由消息定义的操作。该模型如图 1-17 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-25_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;解耦使得消息队列成为构建可扩展和可靠应用的首选架构。通过消息队列，当消费者无法处理消息时，生产者可以将消息发布到队列中。即使在生产者不可用时，消费者也可以从队列中读取消息。&lt;/p&gt;
&lt;p&gt;考虑以下用例：你的应用程序支持照片定制，包括裁剪、锐化、模糊等。这些定制任务需要时间来完成。在图 1-18 中，Web 服务器将照片处理作业发布到消息队列中。照片处理工作者从消息队列中接取作业，并异步执行照片定制任务。生产者和消费者可以独立伸缩。当队列的规模变大时，会增加更多的工人以减少处理时间。但是，如果队列大部分时间是空的，可以减少工人的数量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-25_2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记录、指标、自动化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当与一个在少数服务器上运行的小型网站合作时，日志，指标和自动化支持是良好的实践，但不是必需品。然而，现在你的网站已经成长为服务于一个大型企业，投资于这些工具是必不可少的。&lt;/p&gt;
&lt;p&gt;日志记录。监控错误日志很重要，因为它有助于识别系统中的错误和问题。您可以在每个服务器级别监控错误日志，或者使用工具将它们汇总到一个集中的服务，以便于搜索和查看。&lt;/p&gt;
&lt;p&gt;指标。收集不同类型的指标有助于我们获得业务洞察力，了解系统的健康状况。以下一些指标是有用的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主机级指标： CPU、内存、磁盘 I/O 等。&lt;/li&gt;
&lt;li&gt;汇总级指标：例如，整个数据库层、缓存层的性能等。&lt;/li&gt;
&lt;li&gt;关键业务指标：日活跃用户、留存率、收入等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自动化。当一个系统变得庞大而复杂时，我们需要建立或利用自动化工具来提高生产力。持续集成是一个很好的实践，通过自动化来验证每一个代码的签入，让团队及早发现问题。此外，将构建、测试、部署等过程自动化，可以显著提高开发人员的生产力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加消息队列和不同的工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图 1-19 为更新后的设计。由于篇幅所限，图中只显示了一个数据中心。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设计中加入了消息队列，这有助于使系统更加松散耦合和故障恢复能力。&lt;/li&gt;
&lt;li&gt;包含了日志、监控、指标和自动化工具。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-27_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;随着数据每天的增长，你的数据库会越来越过载。是时候扩大数据层的规模了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库的扩展有两大方法：垂直扩展和水平扩展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;垂直扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;垂直扩展，也叫扩大规模，就是通过给现有的机器增加更多的功率（CPU、RAM、DISK 等）来进行扩展。有一些强大的数据库服务器。根据 Amazon Relational Database Service(RDS)[12]，你可以得到一个 24TB 内存的数据库服务器。这种强大的数据库服务器可以存储和处理大量的数据。例如，stackoverflow.com 在 2013 年有超过 1000 万的月度独立访客，但它只有 1 个主数据库[13]。然而，垂直扩展也有一些严重的缺点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你可以在数据库服务器上增加更多的 CPU、RAM 等，但有硬件限制。如果你有大量的用户群，单台服务器是不够的。&lt;/li&gt;
&lt;li&gt;单点故障的风险较大。&lt;/li&gt;
&lt;li&gt;垂直扩展的整体成本很高。强大的服务器要贵得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;水平扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;水平扩展，也称为 sharding，是增加更多服务器的做法。图 1- 20 比较了垂直扩展和水平扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-28_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Sharding 将大型数据库分离成更小、更容易管理的部分，称为 shard。每个分片共享相同的模式，尽管每个分片上的实际数据对该分片来说是独一无二的。&lt;/p&gt;
&lt;p&gt;图 1-21 显示了一个分片数据库的例子。用户数据是根据用户 ID 分配到数据库服务器上的。任何时候访问数据时，都会使用一个哈希函数来找到相应的分片。在我们的例子中，user_id % 4 被用作哈希函数。如果结果等于 0，则 0 号分片被用来存储和获取数据。如果结果等于 1，则使用分片 1。同样的逻辑也适用于其他分片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-29_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;图 1-22 是分片数据库中的用户表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-29_2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在实施分区策略时，需要考虑的最重要因素是分区密钥的选择。分区键（称为分区键）由一列或多列组成，决定数据的分布方式。如图 1-22 所示，&amp;ldquo;user_id &amp;ldquo;就是 sharding 键。通过 sharding 键，可以将数据库查询路由到正确的数据库，从而有效地检索和修改数据。在选择 sharding 键时，最重要的一个标准是选择一个能够均匀分布数据的键。&lt;/p&gt;
&lt;p&gt;Sharding 是一种很好的扩展数据库的技术，但它远不是一个完美的解决方案。它给系统带来了复杂性和新的挑战。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重置数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在以下情况下需要重新 sharding 数据：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于快速增长，单个分片无法再容纳更多的数据。&lt;/li&gt;
&lt;li&gt;由于数据分布不均，某些分片可能比其他分片更快地出现分片耗尽。当分片耗尽时，需要更新 sharding 函数，并移动数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第 5 章将讨论的一致性哈希是解决这个问题的常用技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;名人问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这也被称为热点问题。对特定分片的过度访问可能导致服务器过载。想象一下，Katy Perry、Justin Bieber 和 Lady Gaga 的数据最终都会出现在同一个分片上。对于社交应用来说，该分片将因读取操作而不堪重负。为了解决这个问题，我们可能需要为每个名人分配一个 shard。每个分片甚至可能需要进一步分区。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用和去范式化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦一个数据库被分片到多个服务器上 就很难在不同的数据库分片之间进行连接操作了一个常见的变通方法是对数据库进行去范式化，这样就可以在一张表中进行查询。&lt;/p&gt;
&lt;p&gt;在图 1-23 中，我们对数据库进行分片，以支持快速增加的数据流量。同时，将一些非关系型功能转移到 NoSQL 数据存储中，以减少数据库负载。这里有一篇文章，涵盖了 NoSQL 的很多用例[14]。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-31_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数百万用户及以上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;扩展系统是一个迭代的过程。迭代我们在本章所学到的知识可以让我们走得更远。要想扩展到数百万用户以上，还需要更多的微调和新的策略。例如，你可能需要优化你的系统，并将系统解耦到更小的服务。本章所学到的所有技术都应该为应对新的挑战打下良好的基础。在本章的最后，我们将对我们如何扩展系统以支持数百万用户进行总结。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持网络层无状态&lt;/li&gt;
&lt;li&gt;在每一层建立冗余&lt;/li&gt;
&lt;li&gt;尽可能多地缓存数据&lt;/li&gt;
&lt;li&gt;支持多个数据中心&lt;/li&gt;
&lt;li&gt;在 CDN 中托管静态资产&lt;/li&gt;
&lt;li&gt;通过分区来扩展您的数据层&lt;/li&gt;
&lt;li&gt;将层级划分为个别服务&lt;/li&gt;
&lt;li&gt;监控您的系统并使用自动化工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;恭喜你走到这一步！现在给自己拍拍背。做得好！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol&#34;&gt;[1] Hypertext Transfer Protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.teamtreehouse.com/should-you-go-beyond-relational-databases&#34;&gt;[2] Should you go Beyond Relational Databases?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Replication_(computing)&#34;&gt;[3] Replication&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Multi-master_replication&#34;&gt;[4] Multi-master replication&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster-replication-multi-master.html&#34;&gt;[5] NDB Cluster Replication: Multi-Master and Circular Replication&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/&#34;&gt;[6] Caching Strategies and How to Choose the Right One&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf&#34;&gt;[7] Scaling Memcache at Facebook &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Single_point_of_failure&#34;&gt;[8] Single point of failure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/cloudfront/dynamic-content/&#34;&gt;[9] Amazon CloudFront Dynamic Content Delivery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-sticky-sessions.html&#34;&gt;[10] Configure Sticky Sessions for Your Classic Load Balancer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://netflixtechblog.com/active-active-for-multi-regional-resiliency-c47719f6685b&#34;&gt;[11] Active-Active for Multi-Regional Resiliency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/ec2/instance-types/high-memory/&#34;&gt;[12] Amazon EC2 High Memory Instances&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nickcraver.com/blog/2013/11/22/what-it-takes-to-run-stack-overflow&#34;&gt;[13] What it takes to run Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://highscalability.com/blog/2010/12/6/what-the-heck-are-you-actually-using-nosql-for.html&#34;&gt;[14] What The Heck Are You Actually Using NoSQL For&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;粗略估算&#34;&gt;粗略估算&lt;/h2&gt;
&lt;p&gt;在系统设计面试中，有时会要求你评估系统容量或性能要求。根据 Google 高级研究员 Jeff Dean 的说法，&amp;ldquo;back-of-the-envelope calculations are estimates you create using a combination of thought experiments and common performance numbers to get a good feel for which designs will meet your requirements&amp;rdquo;[1]。&lt;/p&gt;
&lt;p&gt;你需要对扩展性基础知识有很好的认识，才能有效地进行评估。以下概念应该很好地理解：2 的幂[2]，每个程序员都应该知道的延迟，以及可用性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 的幂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然在处理分布式系统时，数据量可能会变得巨大，但计算都要归结为基本要素。为了获得正确的计算，了解使用 2 的幂的数据量单位是非常关键的。 一个字节是一个 8 位的序列，一个 ASCII 字符使用一个字节的内存（8 位）。一个 ASCII 字符使用一个字节的内存（8 位）。下面是解释数据量单位的表格（表 2-1）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-35_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个程序员都应该知道的延迟数字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来自 Google 的 Dean 博士展示了 2010 年典型的计算机操作所需的时间[1]。随着计算机的速度越来越快，功能越来越强大，有些数字已经过时了。不过，这些数字应该还是能够让我们了解不同计算机操作的快慢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-36_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Notes &amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/p&gt;
&lt;p&gt;ns = nanosecond&lt;/p&gt;
&lt;p&gt;μs = microsecond&lt;/p&gt;
&lt;p&gt;ms = millisecond&lt;/p&gt;
&lt;p&gt;1 ns = 10^-9 seconds&lt;/p&gt;
&lt;p&gt;1 μs= 10^-6 seconds = 1,000 ns&lt;/p&gt;
&lt;p&gt;1 ms = 10^-3 seconds = 1,000 μs = 1,000,000 ns&lt;/p&gt;
&lt;p&gt;谷歌的一位软件工程师打造了一个工具，将 Dr.Dean 的数据可视化。该工具还考虑了时间因素。图 2-1 是截至 2020 年的可视化延迟数据（数据来源：参考资料[3]）。&lt;/p&gt;
&lt;p&gt;通过分析图 2-1 中的数字，我们得到以下结论。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存快，但磁盘慢。&lt;/li&gt;
&lt;li&gt;尽可能避免磁盘寻道。&lt;/li&gt;
&lt;li&gt;简单的压缩算法速度快。&lt;/li&gt;
&lt;li&gt;如果可能的话，先压缩数据再通过互联网发送。&lt;/li&gt;
&lt;li&gt;数据中心通常在不同的地区，在不同地区之间发送数据需要时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-37_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可用性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高可用性是指一个系统在理想的长时间内连续运行的能力。高可用性是以百分比来衡量的，100%意味着服务的停机时间为 0。大多数服务介于 99%和 100%之间。&lt;/p&gt;
&lt;p&gt;服务水平协议（SLA）是服务提供商常用的术语。这是你（服务提供商）和客户之间的协议，这个协议正式定义了你的服务将提供的正常运行时间水平。云提供商亚马逊[4]、谷歌[5]和微软[6]将其 SLA 设定在 99.9%或以上。正常运行时间传统上是以 9 为单位来衡量的。9 越多，越好。如表 2-3 所示，9 次方的数量与预期的系统停机时间相关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-38_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;案例：估计 Twitter 的 QPS 和存储需求&lt;/p&gt;
&lt;p&gt;请注意，以下数字仅用于本练习，因为它们不是来自 Twitter 的真实数字。
假设。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3 亿月活跃用户。&lt;/li&gt;
&lt;li&gt;50%的用户每天使用 Twitter。&lt;/li&gt;
&lt;li&gt;用户平均每天发布 2 条推文。&lt;/li&gt;
&lt;li&gt;10%的推文包含媒体。&lt;/li&gt;
&lt;li&gt;数据存储 5 年。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;估计。
查询每秒（QPS）估计。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日活跃用户（DAU）=3 亿 * 50% = 1.5 亿&lt;/li&gt;
&lt;li&gt;推文 QPS = 1.5 亿 * 2 条推文 / 24 小时 / 3600 秒 = ~3500&lt;/li&gt;
&lt;li&gt;峰值 QPS = 2 * QPS = ~7000&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们在这里只估算媒体存储量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平均推文大小。
&lt;ul&gt;
&lt;li&gt;tweet_id 64 bytes&lt;/li&gt;
&lt;li&gt;text 140 bytes&lt;/li&gt;
&lt;li&gt;media 1MB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Media storage:1.5 亿 * 2 * 10% * 1MB = 30TB per day&lt;/li&gt;
&lt;li&gt;5 year media storage:30TB * 365l* 5 = ~55PB。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技巧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;估算是关于过程的。解决问题比获得结果更重要。面试官可能会测试你解决问题的能力。这里有几个技巧可以遵循。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;四舍五入和近似。在面试时，很难进行复杂的数学运算。例如，&amp;ldquo;99987 / 9.1 &amp;ldquo;的结果是什么？没有必要花费宝贵的时间去解决复杂的数学问题。不要求精确。利用四舍五入和近似值来发挥你的优势。除法题可以简化如下。“100,000 / 10”.&lt;/li&gt;
&lt;li&gt;写下你的假设。最好写下你的假设，以便以后参考。&lt;/li&gt;
&lt;li&gt;给你的单位贴上标签。当你写下 &amp;ldquo;5 &amp;ldquo;时，是指 5 KB 还是 5 MB？你可能会把自己搞混。写下单位，因为 &amp;ldquo;5 MB &amp;ldquo;有助于消除歧义。&lt;/li&gt;
&lt;li&gt;常见的问题包络后面的估计。QPS，峰值 QPS，存储，缓存，服务器数量等。你可以在准备面试的时候练习这些计算方法。熟能生巧。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;恭喜你走到这一步! 现在给自己拍拍背。做得很好!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html&#34;&gt;[1] J. Dean.Google Pro Tip: Use Back-Of-The-Envelope-Calculations To Choose The Best Design:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/donnemartin/system-design-primer&#34;&gt;[2] System design primer:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://colin-scott.github.io/personal_website/research/interactive_latency.html&#34;&gt;[3] Latency Numbers Every Programmer Should Know:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/compute/sla/&#34;&gt;[4] Amazon Compute Service Level Agreement:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/compute/sla&#34;&gt;[5] Compute Engine Service Level Agreement (SLA):&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/en-us/support/legal/sla/summary/&#34;&gt;[6] SLA summary for Azure services:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;系统设计面试框架&#34;&gt;系统设计面试框架&lt;/h2&gt;
&lt;p&gt;你刚刚获得了梦寐以求的公司的现场面试机会。招聘协调人给你发来了当天的日程安排。扫视了一下名单，你感觉还不错，直到你的目光落在这个面试环节上&amp;ndash;系统设计面试。&lt;/p&gt;
&lt;p&gt;系统设计面试往往让人望而生畏。它可能是模糊的，比如 &amp;ldquo;设计一个知名的产品 X？&amp;quot;。问题模棱两可，显得不合理宽泛。你的疲惫是可以理解的。毕竟，怎么可能有人在一个小时内设计出一个受欢迎的产品，而这个产品却花了几百甚至上千名工程师的时间来打造？&lt;/p&gt;
&lt;p&gt;好消息是，没有人指望你这样做。现实世界的系统设计是极其复杂的。例如，谷歌搜索是具有欺骗性的简单；然而，支撑这种简单的技术量确实令人吃惊。如果没有人指望你在一个小时内设计出一个真实世界的系统，那么系统设计面试有什么好处呢？&lt;/p&gt;
&lt;p&gt;系统设计面试模拟现实生活中的问题解决，两个同事合作解决一个模棱两可的问题，并提出一个符合自己目标的解决方案。这个问题是开放式的，没有完美的答案。与你在设计过程中所付出的努力相比，最终的设计并不那么重要。这可以让你展示你的设计技巧，捍卫你的设计选择，并以建设性的方式回应反馈。&lt;/p&gt;
&lt;p&gt;让我们翻开桌子，考虑一下当面试官走进会议室与你见面时，她的脑子里会想些什么。面试官的首要目标是准确评估你的能力。她最不希望的就是因为会议进行得不顺利，信号不足而给出一个不确定的评价。系统设计面试中，面试官要看什么？&lt;/p&gt;
&lt;p&gt;很多人认为系统设计面试就是看一个人的技术设计能力。它的意义远不止于此。一个有效的系统设计面试能给人强烈的信号，包括一个人的协作能力，在压力下工作的能力，以及建设性地解决模糊问题的能力。提出好问题的能力也是一项基本技能，许多面试官特别看重这项技能。&lt;/p&gt;
&lt;p&gt;一个好的面试官还会寻找危险信号。过度设计是很多工程师的真病，因为他们乐于设计的纯粹性，而忽略了权衡。他们往往不知道过度工程系统的复合成本，许多公司为这种无知付出了高昂的代价。你当然不希望在系统设计面试中表现出这种倾向。其他的危险信号还包括心胸狭窄、固执己见等。&lt;/p&gt;
&lt;p&gt;在本章中，我们将介绍一些有用的技巧，并介绍一个简单有效的框架来解决系统设计面试问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有效的系统设计面试四步曲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个系统设计面试都是不同的。一个优秀的系统设计面试是开放式的，没有一个放之四海而皆准的解决方案。但是，每一次系统设计面试都有一些步骤和共同点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步 了解问题，确定设计范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;为什么老虎会吼叫？&amp;rdquo;&lt;/p&gt;
&lt;p&gt;班级后面的同学们纷纷举手。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;是的，吉米？&amp;quot;，老师回应道。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;因为他饿了&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;很好，吉米&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;从小到大，吉米总是第一个在课堂上回答问题。每当老师提出问题时，教室里总有一个孩子喜欢抢答，不管他是否知道答案。他就是吉米。&lt;/p&gt;
&lt;p&gt;吉米是个王牌学生。他以快速知道所有答案为荣。在考试中，他通常是第一个做完题的人。他是老师在任何学术比赛中的首选。&lt;/p&gt;
&lt;p&gt;不要学吉米。&lt;/p&gt;
&lt;p&gt;在系统设计面试中，不假思索地快速给出答案，不会给你加分。在没有彻底了解需求的情况下回答，是一个巨大的危险信号，因为面试不是小题大做。没有正确的答案。&lt;/p&gt;
&lt;p&gt;所以，不要直接跳出来给出解决方案。放慢脚步。深入思考并提出问题，以澄清要求和假设。这一点极为重要。&lt;/p&gt;
&lt;p&gt;作为一名工程师，我们喜欢解决难点问题，然后跳到最终的设计中去；然而，这种方法很可能会导致你设计出错误的系统。作为工程师，最重要的技能之一就是提出正确的问题，做出正确的假设，并收集构建系统所需的所有信息。所以，不要害怕提问。&lt;/p&gt;
&lt;p&gt;当你提出问题时，面试官要么直接回答你的问题，要么要求你做出你的假设。如果是后者，就把你的假设写在白板或纸上。你以后可能会用到它们。&lt;/p&gt;
&lt;p&gt;要问什么样的问题？提出问题以了解确切的要求。这里有一个问题列表，可以帮助你开始。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们要建立什么具体功能？&lt;/li&gt;
&lt;li&gt;产品有多少用户？&lt;/li&gt;
&lt;li&gt;公司预计多快扩大规模？3 个月、6 个月和一年后的预期规模是多少？&lt;/li&gt;
&lt;li&gt;公司的技术栈是什么？你可以利用哪些现有的服务来简化设计？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你被要求设计一个新闻源系统，你要问一些有助于你明确需求的问题。你和面试官之间的对话可能是这样的。&lt;/p&gt;
&lt;p&gt;候选人：这是一个移动应用吗？还是一个网络应用？还是两者都有？&lt;/p&gt;
&lt;p&gt;面试官：是的。都有。&lt;/p&gt;
&lt;p&gt;候选人：产品最重要的功能是什么？&lt;/p&gt;
&lt;p&gt;面试官：可以发帖，可以看到朋友的新闻源。&lt;/p&gt;
&lt;p&gt;候选人：新闻源的排序是按时间倒序还是按特定顺序？特定顺序是指每个帖子的权重不同。比如，好友的帖子比群里的帖子更重要。&lt;/p&gt;
&lt;p&gt;面试官：为了简单起见，我们假设是按时间倒序排列的。&lt;/p&gt;
&lt;p&gt;候选人：一个用户可以有多少个好友？&lt;/p&gt;
&lt;p&gt;面试官：5000&lt;/p&gt;
&lt;p&gt;候选人：流量是多少？&lt;/p&gt;
&lt;p&gt;面试官：1000 万日活跃用户(DAU)&lt;/p&gt;
&lt;p&gt;候选人：订阅可以包含图片、视频，还是只包含文字？&lt;/p&gt;
&lt;p&gt;面试官：可以。可以包含媒体文件，包括图片和视频。&lt;/p&gt;
&lt;p&gt;以上是一些示例问题，你可以向面试官提问。重要的是要了解要求，澄清歧义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第 2 步 提出高层次的设计方案，并获得认同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这一步骤中，我们的目标是制定一个高水平的设计，并与面试官就设计达成一致。在这个过程中，与面试官合作是个不错的主意。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提出设计的初步蓝图。征求反馈意见。把面试官当做队友，共同合作。很多优秀的面试官都喜欢聊天，参与其中。&lt;/li&gt;
&lt;li&gt;在白板或纸上画出关键组件的框图。这可能包括客户端（移动/网络）、API、网络服务器、数据存储、缓存、CDN、消息队列等。&lt;/li&gt;
&lt;li&gt;进行错略估算，评估你的蓝图是否符合规模限制。努力思考。在深入研究之前，与面试官沟通是否有必要进行粗略估算。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果可能的话，通过一些具体的用例。这将帮助你构筑高层设计的框架。这些用例也很可能帮助你发现你尚未考虑的边缘案例。&lt;/p&gt;
&lt;p&gt;我们是否应该在这里包括 API 端点和数据库模式？这取决于问题。对于像 &amp;ldquo;设计 Google 搜索引擎 &amp;ldquo;这样的大型设计问题，这就有点太低级了。对于像设计多人扑克游戏的后端这样的问题，这是一个公平的游戏。与你的面试官沟通。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们用 &amp;ldquo;设计一个新闻源系统 &amp;ldquo;来演示如何进行高层设计。这里不要求你了解系统的实际工作原理。所有的细节将在第 11 章解释。
在高层，设计分为两个流程：feed 发布和新闻源构建。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Feed 发布：当用户发布一个帖子时，相应的数据会被写入缓存/数据库，该帖子会被填充到朋友的新闻源中。&lt;/li&gt;
&lt;li&gt;新闻源构建：将好友的帖子按照时间倒序聚合起来，构建新闻源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图 3-1 和图 3-2 分别展示了 feed 发布和新闻源构建流程的高层设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-45_1.jpg&#34; alt=&#34;&#34;&gt;
&lt;img src=&#34;../../../system_design_interview/index-46_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步 深入设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这一步，你和你的面试官应该已经实现了以下目标。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就总体目标和功能范围达成一致&lt;/li&gt;
&lt;li&gt;勾画出整体设计的高层蓝图。&lt;/li&gt;
&lt;li&gt;获得面试官对高层设计的反馈意见。&lt;/li&gt;
&lt;li&gt;根据她的反馈，对深挖的重点领域有了一些初步的想法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你应与面试官一起确定架构中的组成部分并确定其优先级。值得强调的是，每次面试都是不同的。有时，面试官可能会给出暗示，她喜欢关注高层设计。有时，对于资深候选人的面试，可能会讨论系统性能特点，很可能会关注瓶颈和资源估算。在大多数情况下，面试官可能希望你挖掘一些系统组件的细节。对于短网址服务来说，深入研究将长 URL 转化为短 URL 的哈希函数设计是很有意思的。对于聊天系统来说，如何降低延迟和如何支持在线/离线状态是两个有趣的话题。&lt;/p&gt;
&lt;p&gt;时间管理是必不可少的，因为很容易被一些不能体现你能力的微小细节所迷惑。你必须要用信号来武装你的面试官。尽量不要&lt;/p&gt;
&lt;p&gt;以进入不必要的细节。例如，在系统设计面试中，详细谈论 Facebook feed 排名的 EdgeRank 算法并不理想，因为这需要很多宝贵的时间，而且不能证明你设计一个可扩展系统的能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;至此，我们已经讨论了新闻源系统的高层设计，面试官对你的方案很满意。接下来，我们将研究两个最重要的用例。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新闻源发布&lt;/li&gt;
&lt;li&gt;新闻源检索&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;图 3-3 和图 3-4 显示了两个用例的详细设计，这将在第 11 章中详细说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-48_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-49_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步 收尾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这最后一步，面试官可能会问你几个后续问题，或者让你自由讨论其他附加点。这里有几个方向可以遵循。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面试官可能希望你找出系统瓶颈，并讨论潜在的改进措施。永远不要说你的设计是完美的，没有什么可以改进的。总有一些东西可以改进。这是一个展示你的批判性思维和留下良好最终印象的好机会。&lt;/li&gt;
&lt;li&gt;给面试官总结一下你的设计可能是有用的。如果你提出了一些解决方案，这一点尤其重要。在漫长的会议之后，刷新面试官的记忆会很有帮助。&lt;/li&gt;
&lt;li&gt;错误案例（服务器故障、网络丢失等）是很有趣的话题。&lt;/li&gt;
&lt;li&gt;运营问题值得一提。如何监控指标和错误日志？如何推出系统？&lt;/li&gt;
&lt;li&gt;如何处理下一个规模曲线也是一个有趣的话题。例如，如果你目前的设计支持 100 万用户，那么你需要做哪些改变才能支持 1000 万用户？&lt;/li&gt;
&lt;li&gt;如果你有更多的时间，提出你需要的其他完善措施。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上所述，我们总结了一份 &amp;ldquo;注意事项&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;该做的事和不该做的事&lt;/p&gt;
&lt;p&gt;需要做的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总是要求明确。不要认为你的假设是正确的。&lt;/li&gt;
&lt;li&gt;理解问题的要求。&lt;/li&gt;
&lt;li&gt;既没有正确的答案，也没有最好的答案。为解决一个年轻的初创公司的问题而设计的解决方案与一个拥有数百万用户的成熟公司的解决方案是不同的。确保你了解需求。&lt;/li&gt;
&lt;li&gt;让面试官知道你在想什么。与你的面试官沟通。&lt;/li&gt;
&lt;li&gt;如果可能的话，建议多种方法。&lt;/li&gt;
&lt;li&gt;一旦你与面试官在蓝图上达成一致，就去了解每个组件的细节。先设计最关键的部分。&lt;/li&gt;
&lt;li&gt;跟面试官交流想法。一个好的面试官会把你当成队友来合作。&lt;/li&gt;
&lt;li&gt;永远不要放弃。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不要去做&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要对典型的面试问题毫无准备。&lt;/li&gt;
&lt;li&gt;不要在没有明确需求和假设的情况下就跳进一个解决方案。&lt;/li&gt;
&lt;li&gt;不要一开始就对单个组件进行太详细的介绍。先给出高层次的设计，然后再钻研。&lt;/li&gt;
&lt;li&gt;如果你被卡住了，不要犹豫，请你给予提示。&lt;/li&gt;
&lt;li&gt;再次，沟通。不要默默地思考。&lt;/li&gt;
&lt;li&gt;不要以为你给了设计，你的面试就结束了。在面试官说你完成之前，你还没有完成。尽早、经常询问反馈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一步的时间分配&lt;/p&gt;
&lt;p&gt;系统设计的面试题一般都是很宽泛的，45 分钟或者一个小时都不足以涵盖整个设计。时间管理是必不可少的。你应该在每个步骤上花多少时间？以下是一个非常粗略的关于 45 分钟面试环节中时间分配的指南。请记住这是一个粗略的估计，实际的时间分配取决于问题的范围和面试官的要求。&lt;/p&gt;
&lt;p&gt;第一步 了解问题并确定设计范围。3 - 10 分钟&lt;/p&gt;
&lt;p&gt;第二步 提出高层次的设计方案并获得认同： 10 - 15 分钟&lt;/p&gt;
&lt;p&gt;第三步 深入设计：10&amp;ndash;25 分钟&lt;/p&gt;
&lt;p&gt;第四步 收尾。3-5 分钟&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>APUE::Threads</title>
      <link>/notes/advanced_programming_in_the_unix_environment_threads/</link>
      <pubDate>Mon, 11 Jan 2021 00:43:37 +0800</pubDate>
      <guid>/notes/advanced_programming_in_the_unix_environment_threads/</guid>
      <description>&lt;h2 id=&#34;threads&#34;&gt;Threads&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Thread Concepts
&lt;ul&gt;
&lt;li&gt;simplify code that deals with asynchronous events by assigning a separate thread to handle each event type&lt;/li&gt;
&lt;li&gt;Threads automatically have access to the same memory address space and file descriptors&lt;/li&gt;
&lt;li&gt;Some problems can be partitioned so that overall program throughput can be improved&lt;/li&gt;
&lt;li&gt;interactive programs can realize improved response time by using multiple threads&lt;/li&gt;
&lt;li&gt;The benefits of a multithreaded programming model can be realized even if your program is running on a uniprocessor&lt;/li&gt;
&lt;li&gt;A thread consists of the information necessary to represent an execution context within a process
&lt;ul&gt;
&lt;li&gt;a thread ID that identifies the thread within a process&lt;/li&gt;
&lt;li&gt;a set of register values&lt;/li&gt;
&lt;li&gt;a stack&lt;/li&gt;
&lt;li&gt;a scheduling priority and policy&lt;/li&gt;
&lt;li&gt;a signal mask&lt;/li&gt;
&lt;li&gt;an errno variable&lt;/li&gt;
&lt;li&gt;thread-specific data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Everything within a process is sharable among the threads in a process
&lt;ul&gt;
&lt;li&gt;text of the executable program&lt;/li&gt;
&lt;li&gt;the program’s global and heap memory, the stacks&lt;/li&gt;
&lt;li&gt;the file descriptors&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Thread Identification
&lt;ul&gt;
&lt;li&gt;every thread has a thread ID&lt;/li&gt;
&lt;li&gt;the thread ID has significance only within the context of the process to which it belongs&lt;/li&gt;
&lt;li&gt;A thread ID is represented by the pthread_t data type&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Thread Creation
&lt;ul&gt;
&lt;li&gt;When a thread is created, there is no guarantee which will run first: the newly created thread or the calling thread&lt;/li&gt;
&lt;li&gt;The memory location pointed to by tidp is set to the thread ID of the newly created thread when pthread_create returns successfully&lt;/li&gt;
&lt;li&gt;pthread functions usually return an error code when they fail. They don’t set errno like the other POSIX functions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Thread Termination
&lt;ul&gt;
&lt;li&gt;If any thread within a process calls exit, _Exit, or _exit, then the entire process terminates&lt;/li&gt;
&lt;li&gt;the default action is to terminate the process, a signal sent to a thread will terminate the entire process&lt;/li&gt;
&lt;li&gt;A single thread can exit in three ways, thereby stopping its flow of control, without terminating the entire process
&lt;ul&gt;
&lt;li&gt;The thread can simply return from the start routine. The return value is the thread’s exit code&lt;/li&gt;
&lt;li&gt;The thread can be canceled by another thread in the same process&lt;/li&gt;
&lt;li&gt;The thread can call pthread_exit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;One thread can request that another in the same process be canceled by calling the pthread_cancel function
&lt;ul&gt;
&lt;li&gt;However, a thread can elect to ignore or otherwise control how it is canceled&lt;/li&gt;
&lt;li&gt;thread_cancel doesn’t wait for the thread to terminate; it merely makes the request&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A thread can arrange for functions to be called when it exits pthread_cleanup_push
&lt;ul&gt;
&lt;li&gt;Makes a call to pthread_exit&lt;/li&gt;
&lt;li&gt;Responds to a cancellation request&lt;/li&gt;
&lt;li&gt;Makes a call to pthread_cleanup_pop with a nonzero execute argument&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Thread Synchronization
&lt;ul&gt;
&lt;li&gt;When multiple threads of control share the same memory, we need to make sure that each thread sees a consistent view of its data&lt;/li&gt;
&lt;li&gt;Mutexes
&lt;ul&gt;
&lt;li&gt;A mutex is basically a lock that we set (lock) before accessing a shared resource and release (unlock) when we’re done&lt;/li&gt;
&lt;li&gt;we must first initialize it by either setting it to the constant PTHREAD_MUTEX_INITIALIZER (for statically allocated mutexes only) or calling pthread_mutex_init&lt;/li&gt;
&lt;li&gt;To lock a mutex, we call pthread_mutex_lock&lt;/li&gt;
&lt;li&gt;To unlock a mutex, we call pthread_mutex_unlock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Deadlock Avoidance
&lt;ul&gt;
&lt;li&gt;Deadlocks can be avoided by carefully controlling the order in which mutexes are locked&lt;/li&gt;
&lt;li&gt;assume that you have two mutexes, A and B, that you need to lock at the same time. If all threads always lock mutex A before mutex B, no deadlock can occur from the use of the two mutexes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;pthread_mutex_timedlock
&lt;ul&gt;
&lt;li&gt;The timeout specifies how long we are willing to wait in terms of absolute time (as opposed to relative time; we specify that we are willing to block until time X instead of saying that we are willing to block for Y seconds)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reader–writer locks
&lt;ul&gt;
&lt;li&gt;Only one thread at a time can hold a reader–writer lock in write mode, but multiple threads can hold a reader–writer lock in read mode at the same time&lt;/li&gt;
&lt;li&gt;Reader–writer locks are well suited for situations in which data structures are read more often than they are modified&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reader–Writer Locking with Timeouts
&lt;ul&gt;
&lt;li&gt;pthread_rwlock_timedwrlock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Condition Variables
&lt;ul&gt;
&lt;li&gt;When used with mutexes, condition variables allow threads to wait in a race-free way for arbitrary conditions to occur&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Spin Locks
&lt;ul&gt;
&lt;li&gt;the process is blocked by busy-waiting (spinning) until the lock can be acquired
&lt;ul&gt;
&lt;li&gt;A spin lock could be used in situations where locks are held for short periods of times and threads don’t want to incur the cost of being descheduled&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Many mutex implementations are so efficient that the performance of applications using mutex locks is equivalent to their performance if they had used spin locks&lt;/li&gt;
&lt;li&gt;The interfaces for spin locks are similar to those for mutexes, making it relatively easy to replace one with the other&lt;/li&gt;
&lt;li&gt;if a spin lock is currently unlocked, then the pthread_spin_lock function can lock it without spinning. If the thread already has it locked, the results are undefined. The call to pthread_spin_lock could fail with the EDEADLK error (or some other error), or the call could spin indefinitely. The behavior depends on the implementation. If we try to unlock a spin lock that is not locked, the results are also undefined&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Barriers
&lt;ul&gt;
&lt;li&gt;Barriers are a synchronization mechanism that can be used to coordinate multiple threads working in parallel&lt;/li&gt;
&lt;li&gt;A barrier allows each thread to wait until all cooperating threads have reached the same point, and then continue executing from there&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>APUE::UNIX System Overview</title>
      <link>/notes/advanced_programming_in_the_unix_environment_overview/</link>
      <pubDate>Fri, 01 Jan 2021 00:43:37 +0800</pubDate>
      <guid>/notes/advanced_programming_in_the_unix_environment_overview/</guid>
      <description>&lt;h2 id=&#34;unix-system-overview&#34;&gt;UNIX System Overview&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;an operating system can be defined as the software that controls the hardware resources of the computer and provides an environment under which programs can run
&lt;ul&gt;
&lt;li&gt;Kernel is relatively small and resides at the core of the environment&lt;/li&gt;
&lt;li&gt;The interface to the kernel is a layer of software called the system calls&lt;/li&gt;
&lt;li&gt;Libraries of common functions are built on top of the system call interface, but applications are free to use both&lt;/li&gt;
&lt;li&gt;The shell is a special application that provides an interface for running other applications&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In a broad sense, an operating system consists of the kernel and all the other software that makes a computer useful and gives the computer its personality. This other software includes system utilities, applications, shells, libraries of common functions, and so on&lt;/li&gt;
&lt;li&gt;shell
&lt;ul&gt;
&lt;li&gt;Bourne shell&lt;/li&gt;
&lt;li&gt;C shell&lt;/li&gt;
&lt;li&gt;Korn shell&lt;/li&gt;
&lt;li&gt;Bourne-again shell&lt;/li&gt;
&lt;li&gt;TENEX C shell&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;File System
&lt;ul&gt;
&lt;li&gt;The UNIX file system is a hierarchical arrangement of directories and files&lt;/li&gt;
&lt;li&gt;Everything starts in the directory called root, whose name is the single character /&lt;/li&gt;
&lt;li&gt;A directory is a file that contains directory entries&lt;/li&gt;
&lt;li&gt;The stat and fstat functions return a structure of information containing all the attributes of a file&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Filename
&lt;ul&gt;
&lt;li&gt;The names in a directory are called filenames&lt;/li&gt;
&lt;li&gt;The only two characters that cannot appear in a filename are the slash character (/) and the null character.&lt;/li&gt;
&lt;li&gt;POSIX.1 recommends restricting filenames to consist of the following characters: letters (a-z, A-Z), numbers (0-9), period (.), dash (-), and underscore (_)&lt;/li&gt;
&lt;li&gt;Two filenames are automatically created whenever a new directory is created: . (called dot) and .. (called dot-dot). Dot refers to the current directory, and dot-dot refers to the parent directory. In the root directory, dot-dot is the same as dot.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pathname
&lt;ul&gt;
&lt;li&gt;A sequence of one or more filenames, separated by slashes and optionally starting with a slash, forms a pathname&lt;/li&gt;
&lt;li&gt;absolute pathname&lt;/li&gt;
&lt;li&gt;relative pathname&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Working Directory
&lt;ul&gt;
&lt;li&gt;the directory from which all relative pathnames are interpreted&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Home Directory
&lt;ul&gt;
&lt;li&gt;when we log in, the working directory is set to our home directory&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;File Descriptors
&lt;ul&gt;
&lt;li&gt;File descriptors are normally small non-negative integers that the kernel uses to identify the files accessed by a process.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Standard Input, Standard Output, and Standard Error
&lt;ul&gt;
&lt;li&gt;all shells open three descriptors whenever a new program is run&lt;/li&gt;
&lt;li&gt;then all three are connected to the terminal&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Unbuffered I/O
&lt;ul&gt;
&lt;li&gt;Unbuffered I/O is provided by the functions open, read, write, lseek, and close&lt;/li&gt;
&lt;li&gt;These functions all work with file descriptors&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Programs and Processes
&lt;ul&gt;
&lt;li&gt;Programs
&lt;ul&gt;
&lt;li&gt;A program is an executable file residing on disk in a directory&lt;/li&gt;
&lt;li&gt;A program is read into memory and is executed by the kernel as a result of one of the seven exec functions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Processes and Process ID
&lt;ul&gt;
&lt;li&gt;An executing instance of a program is called a process&lt;/li&gt;
&lt;li&gt;The UNIX System guarantees that every process has a unique numeric identifier called the process ID&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Process Control
&lt;ul&gt;
&lt;li&gt;fork&lt;/li&gt;
&lt;li&gt;exec&lt;/li&gt;
&lt;li&gt;waitpid&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Threads and Thread IDs
&lt;ul&gt;
&lt;li&gt;All threads within a process share the same address space, file descriptors, stacks, and process-related attributes&lt;/li&gt;
&lt;li&gt;Each thread executes on its own stack&lt;/li&gt;
&lt;li&gt;threads are identified by IDs - Thread IDs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Error Handling
&lt;ul&gt;
&lt;li&gt;When an error occurs in one of the UNIX System functions, a negative value is often returned, and the integer errno is usually set to a value that tells why&lt;/li&gt;
&lt;li&gt;The errors defined in &amp;lt;errno.h&amp;gt; can be divided into two categories: fatal and nonfatal&lt;/li&gt;
&lt;li&gt;A fatal error has no recovery action. The best we can do is print an error message on the user’s screen or to a log file, and then exit.&lt;/li&gt;
&lt;li&gt;Nonfatal errors, on the other hand, can sometimes be dealt with more robustly. Most nonfatal errors are temporary, such as a resource shortage, and might not occur when there is less activity on the system.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;User Identification
&lt;ul&gt;
&lt;li&gt;User ID
&lt;ul&gt;
&lt;li&gt;This user ID is assigned by the system administrator when our login name is assigned, and we cannot change it&lt;/li&gt;
&lt;li&gt;The user ID is normally assigned to be unique for every user&lt;/li&gt;
&lt;li&gt;the kernel uses the user ID to check whether we have the appropriate permissions to perform certain operations&lt;/li&gt;
&lt;li&gt;We call the user whose user ID is 0 either root or the superuser&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Group ID
&lt;ul&gt;
&lt;li&gt;Groups are normally used to collect users together into projects or departments. This allows the sharing of resources, such as files, among members of the same group.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Signals
&lt;ul&gt;
&lt;li&gt;Signals are a technique used to notify a process that some condition has occurred&lt;/li&gt;
&lt;li&gt;The process has three choices for dealing with the signal
&lt;ul&gt;
&lt;li&gt;Ignore the signal&lt;/li&gt;
&lt;li&gt;Let the default action occur&lt;/li&gt;
&lt;li&gt;Provide a function that is called when the signal occurs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Time Values
&lt;ul&gt;
&lt;li&gt;Calendar time
&lt;ul&gt;
&lt;li&gt;This value counts the number of seconds since the Epoch: 00:00:00 January 1, 1970&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Process time
&lt;ul&gt;
&lt;li&gt;This is also called CPU time and measures the central processor resources used by a process. Process time is measured in clock ticks, which have historically been 50, 60, or 100 ticks per second&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UNIX System maintains three values for a process:
&lt;ul&gt;
&lt;li&gt;Clock time
&lt;ul&gt;
&lt;li&gt;amount of time the process takes to run&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;User CPU time
&lt;ul&gt;
&lt;li&gt;CPU time attributed to user instructions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;system CPU
&lt;ul&gt;
&lt;li&gt;CPU time attributed to the kernel when it executes on behalf of the process&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;System Calls and Library Functions
&lt;ul&gt;
&lt;li&gt;All implementations of the UNIX System provide a well-defined, limited number of entry points directly into the kernel called system calls&lt;/li&gt;
&lt;li&gt;Its definition is in the C language&lt;/li&gt;
&lt;li&gt;The technique used on UNIX systems is for each system call to have a function of the same name in the standard C library&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>