<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes | Y.CH.Y</title>
    <link>/notes/</link>
      <atom:link href="/notes/index.xml" rel="self" type="application/rss+xml" />
    <description>Notes</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Y.CH.Y</copyright><lastBuildDate>Wed, 01 Sep 2021 04:45:33 +0800</lastBuildDate>
    <item>
      <title>论文::如何阅读一篇论文</title>
      <link>/notes/how_to_read_a_paper/</link>
      <pubDate>Wed, 01 Sep 2021 04:45:33 +0800</pubDate>
      <guid>/notes/how_to_read_a_paper/</guid>
      <description>&lt;h2 id=&#34;原始论文&#34;&gt;原始论文&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf&#34;&gt;HowtoReadPaper.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;
&lt;p&gt;研究人员花了大量的时间阅读研究论文。然而，这种技能很少被传授，导致了浪费了很多精力。本文概述了一种实用而有效的阅读研究论文的三段式方法。我还描述了如何使用这种方法来进行文献调查。&lt;/p&gt;
&lt;p&gt;类别和主题描述符。A.1 [介绍性和调查]。&lt;/p&gt;
&lt;p&gt;一般术语。文档。&lt;/p&gt;
&lt;p&gt;关键词: 论文，阅读，提示。&lt;/p&gt;
&lt;h2 id=&#34;1-介绍&#34;&gt;1 介绍&lt;/h2&gt;
&lt;p&gt;研究人员必须阅读论文的原因有几个：为会议或课程审阅论文，在他们的领域保持领先，或对一个新领域进行文献调查。一个典型的研究人员每年可能要花数百个小时来阅读论文。&lt;/p&gt;
&lt;p&gt;学会有效地阅读论文是一项重要的技能，但却很少有人教。因此，初学的研究生必须通过试验和错误来自学。在这个过程中，学生们浪费了大量的精力，而且经常被逼得灰心丧气。&lt;/p&gt;
&lt;p&gt;多年来，我一直使用一种简单的方法来有效地阅读论文。本文介绍了 &amp;ldquo;三段式 &amp;ldquo;方法及其在进行文献调查时的应用。&lt;/p&gt;
&lt;h2 id=&#34;2-三段式方法&#34;&gt;2 三段式方法&lt;/h2&gt;
&lt;p&gt;关键的想法是，你应该最多分三遍来阅读论文，而不是从头开始，一路耕耘到最后。每一遍都要达到特定的目标，并在前一遍的基础上进行。第一遍让你对这篇论文有一个大致的了解。第二遍让你掌握论文的内容，但不是其细节。第三遍帮助你深入了解该论文。&lt;/p&gt;
&lt;h3 id=&#34;21-第一遍&#34;&gt;2.1 第一遍&lt;/h3&gt;
&lt;p&gt;第一遍是快速扫描，以获得纸张的一个概览。你也可以决定是否需要做更多的扫描。这一遍应该需要大约 5 到 10 分钟，包括以下步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仔细阅读标题、摘要和导言&lt;/li&gt;
&lt;li&gt;阅读章节和分节的标题，但忽略其他内容&lt;/li&gt;
&lt;li&gt;阅读结论&lt;/li&gt;
&lt;li&gt;扫一眼参考资料，在心里勾出你已经读过的资料&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在第一遍结束时，你应该能够回答这五个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类别。这是什么类型的论文？一份测量论文？对一个现有系统的分析？对一个研究原型的描述？&lt;/li&gt;
&lt;li&gt;背景。它与哪些其他论文有关？使用了哪些理论基础来分析问题？&lt;/li&gt;
&lt;li&gt;正确性。假设是有效的吗？&lt;/li&gt;
&lt;li&gt;贡献。该论文的主要贡献是什么？&lt;/li&gt;
&lt;li&gt;清晰度。论文写得好吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;利用这些信息，你可以选择不再继续阅读。这可能是因为你对该论文不感兴趣，或者你对该领域的了解不足以理解该论文，或者作者做出了无效的假设。对于那些不属于你的研究领域，但有一天可能被证明是相关的论文，第一遍就足够了。&lt;/p&gt;
&lt;p&gt;顺便提一下，当你写一篇论文时，你可以期望大多数审稿人（和读者）只看一遍。请注意选择连贯的章节和分节标题，并写出简明而全面的摘要。如果审稿人在看完一遍后不能理解要点，论文很可能会被拒绝；如果读者在五分钟后不能理解论文的重点，论文很可能永远不会被阅读。&lt;/p&gt;
&lt;h3 id=&#34;22-第二遍&#34;&gt;2.2 第二遍&lt;/h3&gt;
&lt;p&gt;在第二遍时，要更仔细地阅读论文，但忽略诸如证明等细节。在阅读过程中，记下关键点，或在空白处做评论，会有帮助。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仔细观察论文中的数字、图表和其他插图。要特别注意图表。轴的标记是否正确？显示的结果是否有误差条，从而使结论具有统计学意义？诸如此类的常见错误会将仓促的、低劣的工作与真正优秀的工作区分开来。&lt;/li&gt;
&lt;li&gt;记得标记相关的未读参考文献以便进一步阅读（这是了解论文背景的一个好方法）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第二遍应该花上一个小时。经过这一关，你应该能够掌握论文的内容。 你应该能够向别人总结论文的主旨，并提供支持性证据。这种详细程度适合于你感兴趣的论文，但不属于你的研究专长。&lt;/p&gt;
&lt;p&gt;有时，即使在第二遍结束时，你也无法理解一篇论文。这可能是因为该主题对你来说是新的，有不熟悉的术语和缩略语。或者作者可能使用了你不理解的证明或实验技术，因此，论文的大部分内容是无法理解的。论文可能写得很差，没有事实依据的断言和大量的参考文献。也可能只是因为现在是深夜，你很累。你现在可以选择。(a)把论文放在一边，希望你不需要理解这些材料就能在事业上取得成功，(b)以后再回来看这篇论文，也许是在阅读背景材料之后，或者(c)坚持下去，进入第三关。&lt;/p&gt;
&lt;h3 id=&#34;23-第三遍&#34;&gt;2.3 第三遍&lt;/h3&gt;
&lt;p&gt;要完全理解一篇论文，特别是如果你是审稿人，需要第三遍。第三遍的关键是试图重现该论文：也就是说，在与作者相同的假设下，重新创造该工作。通过比较这种再创造和实际的论文，你不仅可以很容易地发现论文的创新，还可以发现其隐藏的失败和假设。&lt;/p&gt;
&lt;p&gt;这一关需要非常注意细节。你应该找出并挑战每一个陈述中的假设。此外，你应该思考你自己会如何陈述一个特定的想法。这种实际与虚拟的比较使你对论文中的证明和表述技巧有了敏锐的洞察力，你很可能将其加入你的工具库。在这个过程中，你还应该记下对未来工作的想法。&lt;/p&gt;
&lt;p&gt;这一关对于初学者来说可能需要四五个小时，而对于有经验的读者来说则需要一个小时左右。在这一阶段结束时，你应该能够根据记忆重建论文的整个结构，并能够确定其强点和弱点。特别是，你应该能够指出隐含的假设、缺少对相关工作的引用，以及实验或分析技术的潜在问题。&lt;/p&gt;
&lt;h2 id=&#34;3-进行文献调查&#34;&gt;3 进行文献调查&lt;/h2&gt;
&lt;p&gt;在做文献调查时，论文阅读能力受到考验。这将要求你阅读数十篇论文，也许是在一个不熟悉的领域。你应该阅读哪些论文？以下是你如何使用三段式方法来帮助。&lt;/p&gt;
&lt;p&gt;首先，使用学术搜索引擎，如 Google Scholar 或 CiteSeer 和一些精心选择的关键词，找到该领域的三到五篇最新论文。对每篇论文进行一次检索以了解其工作情况，然后阅读其相关工作部分。你会发现最近工作的缩略图，如果你幸运的话，也许会有一个指向最近的调查报告的指针。如果你能找到这样一份调查报告，你就完成了。阅读调查报告，祝贺自己的好运气。&lt;/p&gt;
&lt;p&gt;否则，在第二步，在书目中找到共同的引文和重复的作者名字。这些是该领域的关键论文和研究人员。下载关键论文并将其放在一边。然后进入关键研究人员的网站，看看他们最近在哪里发表过文章。这将帮助你确定该领域的顶级会议，因为最好的研究人员通常在顶级会议上发表文章。&lt;/p&gt;
&lt;p&gt;第三步是进入这些顶级会议的网站，查看他们最近的会议记录。快速扫描通常会发现最近的高质量相关工作。这些论文，连同你之前搁置的论文，构成了你调查的第一个版本。对这些论文进行两次扫描。如果他们都引用了你之前没有发现的关键论文，那么就获取并阅读它，必要时进行迭代。&lt;/p&gt;
&lt;h2 id=&#34;4-经验之谈&#34;&gt;4 经验之谈&lt;/h2&gt;
&lt;p&gt;在过去的 15 年里，我一直使用这种方法来阅读会议记录，写评论，做背景研究，以及在讨论前快速审查论文。这种有规律的方法可以防止我在得到一个概览之前迷失在细节中。它使我能够估计审查一组论文所需的时间。此外，我可以根据自己的需要和时间的多少来调整论文评估的深度。&lt;/p&gt;
&lt;h2 id=&#34;5-相关工作&#34;&gt;5 相关工作&lt;/h2&gt;
&lt;p&gt;如果你阅读论文是为了做评论，你还应该阅读 Timothy Roscoe 关于 &amp;ldquo;为系统会议撰写评论 &amp;ldquo;的论文[2]。如果你打算写一篇技术论文，你应该同时参考 Henning Schulzrinne 的综合网站[3]和 George Whitesides 对这个过程的出色概述[4]。最后，Simon Peyton Jones 有一个涵盖整个研究技能的网站 [1]。&lt;/p&gt;
&lt;h2 id=&#34;6-一个请求&#34;&gt;6 一个请求&lt;/h2&gt;
&lt;p&gt;我想把它变成一份保持更新的文件，在我收到意见的时候更新它。请花点时间给我发电子邮件，提出任何意见或改进建议。你也可以在 CCRo（CCR 的网络版）上添加评论[5]。&lt;/p&gt;
&lt;h2 id=&#34;7-致谢&#34;&gt;7 致谢&lt;/h2&gt;
&lt;p&gt;本文件的第一版是由我的学生起草的。Hossein Falaki, Earl Oliver, and Sumair Ur Rahman. 我对他们表示感谢。我还受益于 Christophe Diot 的敏锐评论和 Nicole Keshav 的鹰眼式审稿。&lt;/p&gt;
&lt;p&gt;这项工作得到了加拿大国家科学和工程委员会、加拿大研究主席计划、北电网络、微软、英特尔公司和 Sprint 公司的资助。&lt;/p&gt;
&lt;h2 id=&#34;8-参考&#34;&gt;8 参考&lt;/h2&gt;
&lt;p&gt;[1] S. Peyton Jones, &lt;a href=&#34;http://research.microsoft.com/simonpj/Papers/givinga-talk/giving-a-talk.htm&#34;&gt;Research Skills&lt;/a&gt;&lt;br&gt;
[2] T. Roscoe, &lt;a href=&#34;http://people.inf.ethz.ch/troscoe/pubs/reviewwriting.pdf&#34;&gt;Writing Reviews for Systems Conferences&lt;/a&gt;&lt;br&gt;
[3] H. Schulzrinne, &lt;a href=&#34;http://www.cs.columbia.edu/hgs/etc/writingstyle.html&#34;&gt;Writing Technical Articles&lt;/a&gt;&lt;br&gt;
[4] G.M. Whitesides, &lt;a href=&#34;http://www.che.iitm.ac.in/misc/dd/writepaper.pdf&#34;&gt;Whitesides’ Group: Writing a Paper&lt;/a&gt;&lt;br&gt;
[5] &lt;a href=&#34;http://www.sigcomm.org/ccr/drupal/&#34;&gt;ACM SIGCOMM Computer Communication Review Online&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>八股文::操作系统</title>
      <link>/notes/interview_questions_operating_system/</link>
      <pubDate>Sat, 21 Aug 2021 03:28:49 +0800</pubDate>
      <guid>/notes/interview_questions_operating_system/</guid>
      <description>&lt;h2 id=&#34;操作系统&#34;&gt;操作系统&lt;/h2&gt;
&lt;h3 id=&#34;进程和线程之间有什么区别&#34;&gt;进程和线程之间有什么区别？&lt;/h3&gt;
&lt;h3 id=&#34;进程间有哪些通信方式&#34;&gt;进程间有哪些通信方式？&lt;/h3&gt;
&lt;h3 id=&#34;简述-select-poll-epoll-的使用场景以及区别epoll-中水平触发以及边缘触发有什么不同&#34;&gt;简述 select, poll, epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？&lt;/h3&gt;
&lt;h3 id=&#34;简述-linux-进程调度的算法&#34;&gt;简述 Linux 进程调度的算法&lt;/h3&gt;
&lt;h3 id=&#34;简述几个常用的-linux-命令以及他们的功能&#34;&gt;简述几个常用的 Linux 命令以及他们的功能&lt;/h3&gt;
&lt;h3 id=&#34;简述操作系统如何进行内存管理&#34;&gt;简述操作系统如何进行内存管理&lt;/h3&gt;
&lt;h3 id=&#34;线程有多少种状态状态之间如何转换&#34;&gt;线程有多少种状态，状态之间如何转换&lt;/h3&gt;
&lt;h3 id=&#34;简述操作系统中的缺页中断&#34;&gt;简述操作系统中的缺页中断&lt;/h3&gt;
&lt;h3 id=&#34;线程间有哪些通信方式&#34;&gt;线程间有哪些通信方式？&lt;/h3&gt;
&lt;h3 id=&#34;什么时候会由用户态陷入内核态&#34;&gt;什么时候会由用户态陷入内核态？&lt;/h3&gt;
&lt;h3 id=&#34;进程有多少种状态&#34;&gt;进程有多少种状态？&lt;/h3&gt;
&lt;h3 id=&#34;简述自旋锁与互斥锁的使用场景&#34;&gt;简述自旋锁与互斥锁的使用场景&lt;/h3&gt;
&lt;h3 id=&#34;linux-下如何查看端口被哪个进程占用&#34;&gt;Linux 下如何查看端口被哪个进程占用？&lt;/h3&gt;
&lt;h3 id=&#34;操作系统中虚拟地址与物理地址之间如何映射&#34;&gt;操作系统中，虚拟地址与物理地址之间如何映射？&lt;/h3&gt;
&lt;h3 id=&#34;进程通信中的管道实现原理是什么&#34;&gt;进程通信中的管道实现原理是什么？&lt;/h3&gt;
&lt;h3 id=&#34;linux-下如何排查-cpu-以及-内存占用过多&#34;&gt;Linux 下如何排查 CPU 以及 内存占用过多？&lt;/h3&gt;
&lt;h3 id=&#34;简述-linux-系统态与用户态什么时候会进入系统态&#34;&gt;简述 Linux 系统态与用户态，什么时候会进入系统态？&lt;/h3&gt;
&lt;h3 id=&#34;多线程和多进程的区别是什么&#34;&gt;多线程和多进程的区别是什么？&lt;/h3&gt;
&lt;h3 id=&#34;简述-linux-虚拟内存的页面置换算法&#34;&gt;简述 Linux 虚拟内存的页面置换算法&lt;/h3&gt;
&lt;h3 id=&#34;创建线程有多少种方式&#34;&gt;创建线程有多少种方式？&lt;/h3&gt;
&lt;h3 id=&#34;简述-linux-零拷贝的原理&#34;&gt;简述 Linux 零拷贝的原理&lt;/h3&gt;
&lt;h3 id=&#34;简述同步与异步的区别阻塞与非阻塞的区别&#34;&gt;简述同步与异步的区别，阻塞与非阻塞的区别&lt;/h3&gt;
&lt;h3 id=&#34;linux-中虚拟内存和物理内存有什么区别有什么优点&#34;&gt;Linux 中虚拟内存和物理内存有什么区别？有什么优点？&lt;/h3&gt;
&lt;h3 id=&#34;bionio-有什么区别怎么判断写文件时-buffer-已经写满简述-linux-的-io-模型&#34;&gt;BIO、NIO 有什么区别？怎么判断写文件时 Buffer 已经写满？简述 Linux 的 IO 模型&lt;/h3&gt;
&lt;h3 id=&#34;简述-mmap-的使用场景以及原理&#34;&gt;简述 mmap 的使用场景以及原理&lt;/h3&gt;
&lt;h3 id=&#34;两个线程交替打印一个共享变量&#34;&gt;两个线程交替打印一个共享变量&lt;/h3&gt;
&lt;h3 id=&#34;简述操作系统中-malloc-的实现原理&#34;&gt;简述操作系统中 malloc 的实现原理&lt;/h3&gt;
&lt;h3 id=&#34;linux-下如何查看-cpu-荷载正在运行的进程某个端口对应的进程&#34;&gt;Linux 下如何查看 CPU 荷载，正在运行的进程，某个端口对应的进程？&lt;/h3&gt;
&lt;h3 id=&#34;lvs-的-nattundr-原理及区别&#34;&gt;LVS 的 NAT、TUN、DR 原理及区别&lt;/h3&gt;
&lt;h3 id=&#34;共享内存是如何实现的&#34;&gt;共享内存是如何实现的？&lt;/h3&gt;
&lt;h3 id=&#34;如何调试服务器内存占用过高的问题&#34;&gt;如何调试服务器内存占用过高的问题？&lt;/h3&gt;
&lt;h3 id=&#34;系统调用的过程是怎样的操作系统是通过什么机制触发系统调用的&#34;&gt;系统调用的过程是怎样的？操作系统是通过什么机制触发系统调用的？&lt;/h3&gt;
&lt;h3 id=&#34;linux-如何查看实时的滚动日志&#34;&gt;Linux 如何查看实时的滚动日志？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tail -f log&lt;/code&gt; 或者 &lt;code&gt;tail -F log&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;malloc-创建的对象在堆还是栈中&#34;&gt;malloc 创建的对象在堆还是栈中？&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;()&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;a_stack_pointer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;malloc&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;sizeof&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;));&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;a_stack_pointer 在栈上，保存了它所指向的内容给的地址，用 malloc 分配的动态内存在堆上&lt;/p&gt;
&lt;h3 id=&#34;为什么进程切换慢线程切换快&#34;&gt;为什么进程切换慢，线程切换快？&lt;/h3&gt;
&lt;h3 id=&#34;简述-cpu-l1-l2-l3-多级缓存的基本作用&#34;&gt;简述 CPU L1, L2, L3 多级缓存的基本作用&lt;/h3&gt;
&lt;h3 id=&#34;简述创建进程的流程&#34;&gt;简述创建进程的流程&lt;/h3&gt;
&lt;h3 id=&#34;进程空间从高位到低位都有些什么&#34;&gt;进程空间从高位到低位都有些什么？&lt;/h3&gt;
&lt;h3 id=&#34;什么情况下进程会进行切换&#34;&gt;什么情况下，进程会进行切换？&lt;/h3&gt;
&lt;h3 id=&#34;简述-linux-的-io-模型&#34;&gt;简述 Linux 的 I/O 模型&lt;/h3&gt;
&lt;h3 id=&#34;简述-traceroute-命令的原理&#34;&gt;简述 traceroute 命令的原理&lt;/h3&gt;
&lt;h3 id=&#34;linux-页大小是多少&#34;&gt;Linux 页大小是多少？&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Architecture&lt;/th&gt;
&lt;th&gt;Smallest page size&lt;/th&gt;
&lt;th&gt;Larger page sizes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;32-bit x86&lt;/td&gt;
&lt;td&gt;4 KiB&lt;/td&gt;
&lt;td&gt;4 MiB in PSE mode, 2 MiB in PAE mode&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x86-64&lt;/td&gt;
&lt;td&gt;4 KiB&lt;/td&gt;
&lt;td&gt;2 MiB, 1 GiB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IA-64 (Itanium)&lt;/td&gt;
&lt;td&gt;4 KiB&lt;/td&gt;
&lt;td&gt;8 KiB, 64 KiB, 256 KiB, 1 MiB, 4 MiB, 16 MiB, 256 MiB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Power ISA&lt;/td&gt;
&lt;td&gt;4 KiB&lt;/td&gt;
&lt;td&gt;64 KiB, 16 MiB, 16 GiB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SPARC v8 with SPARC Reference MMU&lt;/td&gt;
&lt;td&gt;4 KiB&lt;/td&gt;
&lt;td&gt;256 KiB, 16 MiB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UltraSPARC Architecture 2007 8 KiB 6&lt;/td&gt;
&lt;td&gt;4 KiB&lt;/td&gt;
&lt;td&gt;64KiB, 512 KiB , 4 MiB, 32 MiB , 256 MiB , 2 GiB , 16 GiB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ARMv7&lt;/td&gt;
&lt;td&gt;4 KiB&lt;/td&gt;
&lt;td&gt;64 KiB, 1 MiB , 16 MiB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;信号量是如何实现的&#34;&gt;信号量是如何实现的？&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;semaphore&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;raw_spinlock_t&lt;/span&gt;        &lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt;        &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;list_head&lt;/span&gt;    &lt;span style=&#34;color:#111&#34;&gt;wait_list&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;};&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * down - acquire the semaphore
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @sem: the semaphore to be acquired
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Acquires the semaphore.  If no more tasks are allowed to acquire the
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * semaphore, calling this function will put the task to sleep until the
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * semaphore is released.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Use of this function is deprecated, please use down_interruptible() or
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * down_killable() instead.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;down&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;semaphore&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;raw_spin_lock_irqsave&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;likely&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;))&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;else&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;__down&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;raw_spin_unlock_irqrestore&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * down_interruptible - acquire the semaphore unless interrupted
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @sem: the semaphore to be acquired
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Attempts to acquire the semaphore.  If no more tasks are allowed to
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * acquire the semaphore, calling this function will put the task to sleep.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * If the sleep is interrupted by a signal, this function will return -EINTR.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * If the semaphore is successfully acquired, this function returns 0.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;down_interruptible&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;semaphore&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;raw_spin_lock_irqsave&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;likely&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;))&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;else&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;__down_interruptible&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;raw_spin_unlock_irqrestore&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;result&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * down_killable - acquire the semaphore unless killed
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @sem: the semaphore to be acquired
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Attempts to acquire the semaphore.  If no more tasks are allowed to
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * acquire the semaphore, calling this function will put the task to sleep.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * If the sleep is interrupted by a fatal signal, this function will return
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * -EINTR.  If the semaphore is successfully acquired, this function returns
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * 0.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;down_killable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;semaphore&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;raw_spin_lock_irqsave&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;likely&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;))&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;else&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;__down_killable&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;raw_spin_unlock_irqrestore&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;result&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * down_trylock - try to acquire the semaphore, without waiting
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @sem: the semaphore to be acquired
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Try to acquire the semaphore atomically.  Returns 0 if the semaphore has
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * been acquired successfully or 1 if it cannot be acquired.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * NOTE: This return value is inverted from both spin_trylock and
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * mutex_trylock!  Be careful about this when converting code.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Unlike mutex_trylock, this function can be used from interrupt context,
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * and the semaphore can be released by any task or interrupt.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;down_trylock&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;semaphore&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;raw_spin_lock_irqsave&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;likely&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;))&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;raw_spin_unlock_irqrestore&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * down_timeout - acquire the semaphore within a specified time
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @sem: the semaphore to be acquired
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @timeout: how long to wait before failing
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Attempts to acquire the semaphore.  If no more tasks are allowed to
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * acquire the semaphore, calling this function will put the task to sleep.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * If the semaphore is not released within the specified number of jiffies,
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * this function returns -ETIME.  It returns 0 if the semaphore was acquired.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;down_timeout&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;semaphore&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;timeout&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;raw_spin_lock_irqsave&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;likely&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;))&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;else&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;__down_timeout&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;timeout&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;raw_spin_unlock_irqrestore&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#00a8c8&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;result&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * up - release the semaphore
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @sem: the semaphore to release
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Release the semaphore.  Unlike mutexes, up() may be called from any
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * context and even by tasks which have never called down().
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#00a8c8&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;up&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#00a8c8&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;semaphore&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00a8c8&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#111&#34;&gt;raw_spin_lock_irqsave&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;likely&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;list_empty&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;wait_list&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;)))&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;count&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#00a8c8&#34;&gt;else&lt;/span&gt;
        &lt;span style=&#34;color:#111&#34;&gt;__up&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#111&#34;&gt;raw_spin_unlock_irqrestore&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;sem&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;flags&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>八股文::网络</title>
      <link>/notes/interview_questions_network/</link>
      <pubDate>Fri, 20 Aug 2021 21:51:33 +0800</pubDate>
      <guid>/notes/interview_questions_network/</guid>
      <description>&lt;h2 id=&#34;网络&#34;&gt;网络&lt;/h2&gt;
&lt;h3 id=&#34;简述-tcp-三次握手以及四次挥手的流程为什么需要三次握手以及四次挥手&#34;&gt;简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？&lt;/h3&gt;
&lt;p&gt;三次握手流程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一次握手: 建立连接，客户端 A 发送 SYN = 1、随机产生 Seq = client_isn 的数据包到服务器 B，等待服务器确认。&lt;/li&gt;
&lt;li&gt;第二次握手: 服务器 B 收到请求后确认联机(可以接受数据)，发起第二次握手请求，ACK = (A 的 Seq + 1)、SYN = 1，随机产生 Seq = client_isn 的数据包到 A。&lt;/li&gt;
&lt;li&gt;第三次握手: A 收到后检查 ACK 是否正确，若正确，A 会在发送确认包 ACK = 服务器 B 的 Seq + 1、ACK = 1，服务器 B 收到后确认 Seq 值与 ACK 值，若正确，则建立连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;四次挥手流程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一次挥手：TCP 发送一个 FIN(结束)标识，用来关闭客户到服务端的连接。&lt;/li&gt;
&lt;li&gt;第二次挥手：服务端收到这个 FIN 标识，他发回一个 ACK(确认)标识，确认收到序号为收到序号+1，和 SYN 一样，一个 FIN 将占用一个序号。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。（服务器端继续发送未发送完的数据）&lt;/li&gt;
&lt;li&gt;第三次挥手：服务端发送一个 FIN(结束)标识到客户端，服务端关闭客户端的连接。&lt;/li&gt;
&lt;li&gt;第四次挥手：客户端发送 ACK(确认)标识报文确认，并将确认的序号+1，这样关闭完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为什么需要三次握手&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc793&#34;&gt;rfc793&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了防止旧重复连接初始化造成的混乱问题，导致服务器维护了无用的半连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/3rSeXxI.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;老的重传数据被当作新的数据接受。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/BJbiBqj.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;为什么需要四次挥手&lt;/p&gt;
&lt;p&gt;因为 TCP 是全双工通信的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次挥手：因此当主动方发送断开连接的请求（即 FIN 报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。&lt;/li&gt;
&lt;li&gt;第二次挥手：被动方此时有可能还有相应的数据报文需要发送，因此需要先发送 ACK 报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即 FIN 报文）。&lt;/li&gt;
&lt;li&gt;第三次挥手：被动方在处理完数据报文后，便发送给主动方 FIN 报文；这样可以保证数据通信正常可靠地完成。发送完 FIN 报文后，被动方进入 LAST_ACK 阶段（超时等待）。&lt;/li&gt;
&lt;li&gt;第四挥手：如果主动方及时发送 ACK 报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCP 状态机&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Ir7sNdS.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;异常状况&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://network.51cto.com/art/202002/610542.htm&#34;&gt;TCP 三次握手、四次挥手出现意外情况时，如何保证稳定可靠？&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;http-与-https-有哪些区别&#34;&gt;HTTP 与 HTTPS 有哪些区别？&lt;/h3&gt;
&lt;h3 id=&#34;从输入-url-到展现页面的全过程&#34;&gt;从输入 URL 到展现页面的全过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;输入地址&lt;/li&gt;
&lt;li&gt;浏览器查找域名的 IP 地址&lt;/li&gt;
&lt;li&gt;浏览器向 web 服务器发送一个 HTTP 请求&lt;/li&gt;
&lt;li&gt;服务器的永久重定向响应&lt;/li&gt;
&lt;li&gt;服务器处理请求&lt;/li&gt;
&lt;li&gt;服务器返回一个 HTTP 响应&lt;/li&gt;
&lt;li&gt;浏览器显示 HTML&lt;/li&gt;
&lt;li&gt;浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS 等等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp-与-udp-在网络协议中的哪一层他们之间有什么区别&#34;&gt;TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？&lt;/h3&gt;
&lt;h3 id=&#34;tcp-怎么保证可靠传输&#34;&gt;TCP 怎么保证可靠传输？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;检验和；用于检测在一个传输分组中的比特错误&lt;/li&gt;
&lt;li&gt;定时器：用于超时/重传一个分组，可能因为该分组〈或其 ACK) 在信道中丢失了。由于当一个分组延时但未丢失〈过早超时) ，或当一个分组已被接收方收到但从接收方到发送方的 ACK 丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余副本&lt;/li&gt;
&lt;li&gt;序号：用于为从发送方流向接收方的数据分组按顺序编号。所接收分组的序号间的空隙可使接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余副本&lt;/li&gt;
&lt;li&gt;确认：接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或累积的，这取决于协议&lt;/li&gt;
&lt;li&gt;否定确认：接收方用于告诉发送方某个分组未被正确地接收。否定确认报文通常据带着未被正确接收的分组的序号&lt;/li&gt;
&lt;li&gt;窗口、流水线：发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。我们很快将会看到，窗口长度可根据接收方接收和缓存报文的能力、网络中的拥塞程度或两者情况来进行设置&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简述-http-101120-的主要区别&#34;&gt;简述 HTTP 1.0，1.1，2.0 的主要区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;http1.0 特性
&lt;ul&gt;
&lt;li&gt;无状态：服务器不跟踪不记录请求过的状态
&lt;ul&gt;
&lt;li&gt;对于无状态的特性可以借助 cookie/session 机制来做身份认证和状态记录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无连接：浏览器每次请求都需要建立 tcp 连接
&lt;ul&gt;
&lt;li&gt;无法复用连接:每次发送请求，都需要进行一次 tcp 连接（即 3 次握手 4 次挥手），使得网络的利用率非常低&lt;/li&gt;
&lt;li&gt;队头阻塞:http1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;http1.1 特性：
&lt;ul&gt;
&lt;li&gt;长连接：新增 Connection 字段，可以设置 keep-alive 值保持连接不断开,http1.1 默认保持长连接，数据传输完成保持 tcp 连接不断开,继续用这个通道传输数据&lt;/li&gt;
&lt;li&gt;管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回&lt;/li&gt;
&lt;li&gt;缓存处理：新增字段 cache-control&lt;/li&gt;
&lt;li&gt;断点传输:在 Header 里两个参数实现的，客户端发请求时对应的是 Range 服务器端响应时对应的是 Content-Range&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;http2.0 特性
&lt;ul&gt;
&lt;li&gt;二进制分帧:将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码&lt;/li&gt;
&lt;li&gt;多路复用： 在共享 TCP 链接的基础上同时发送请求和响应，基于二进制分帧，在同一域名下所有访问都是从同一个 tcp 连接中走，http 消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来&lt;/li&gt;
&lt;li&gt;头部压缩&lt;/li&gt;
&lt;li&gt;服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp-中常见的拥塞控制算法有哪些&#34;&gt;TCP 中常见的拥塞控制算法有哪些？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Reno&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;慢启动阶段思路是不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小，在没有出现丢包时每收到一个 ACK 就将拥塞窗口大小加一（单位是 MSS，最大单个报文段长度），每轮次发送窗口增加一倍，呈指数增长，若出现丢包，则将拥塞窗口减半，进入拥塞避免阶段；&lt;/li&gt;
&lt;li&gt;当窗口达到慢启动阈值或出现丢包时，进入拥塞避免阶段，窗口每轮次加一，呈线性增长；当收到对一个报文的三个重复的 ACK 时，认为这个报文的下一个报文丢失了，进入快重传阶段，要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约 20%）而不要等到自己发送数据时捎带确认；&lt;/li&gt;
&lt;li&gt;快重传完成后进入快恢复阶段，将慢启动阈值修改为当前拥塞窗口值的一半，同时拥塞窗口值等于慢启动阈值，然后进入拥塞避免阶段，重复上述过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BBR&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BBR 算法不将出现丢包或时延增加作为拥塞的信号，而是认为当网络上的数据包总量大于瓶颈链路带宽和时延的乘积时才出现了拥塞，所以 BBR 也称为基于拥塞的拥塞控制算法（Congestion-Based Congestion Control），其适用网络为高带宽、高时延、有一定丢包率的长肥网络，可以有效降低传输时延，并保证较高的吞吐量.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BBR 算法周期性地探测网络的容量，交替测量一段时间内的带宽极大值和时延极小值，将其乘积作为作为拥塞窗口大小，使得拥塞窗口始的值始终与网络的容量保持一致。&lt;/p&gt;
&lt;p&gt;所以 BBR 算法解决了两个比较主要的问题：&lt;/p&gt;
&lt;p&gt;在有一定丢包率的网络链路上充分利用带宽。 适合高延迟、高带宽的网络链路。&lt;/p&gt;
&lt;p&gt;降低网络链路上的 buffer 占用率，从而降低延迟。 适合慢速接入网络的用户。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于丢包的拥塞控制：将丢包视为出现拥塞，采取缓慢探测的方式，逐渐增大拥塞窗口，当出现丢包时，将拥塞窗口减小，如 Reno、Cubic 等。&lt;/li&gt;
&lt;li&gt;基于时延的拥塞控制：将时延增加视为出现拥塞，延时增加时增大拥塞窗口，延时减小时减小拥塞窗口，如 Vegas、FastTCP 等。&lt;/li&gt;
&lt;li&gt;基于链路容量的拥塞控制：实时测量网络带宽和时延，认为网络上报文总量大于带宽时延乘积时出现了拥塞，如 BBR。&lt;/li&gt;
&lt;li&gt;基于学习的拥塞控制：没有特定的拥塞信号，而是借助评价函数，基于训练数据，使用机器学习的方法形成一个控制策略，如 Remy。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dns-查询服务器的基本流程是什么dns-劫持是什么&#34;&gt;DNS 查询服务器的基本流程是什么？DNS 劫持是什么？&lt;/h3&gt;
&lt;h3 id=&#34;cookie-和-session-的关系和区别是什么&#34;&gt;Cookie 和 Session 的关系和区别是什么？&lt;/h3&gt;
&lt;h3 id=&#34;简述-https-的加密与认证过程&#34;&gt;简述 HTTPS 的加密与认证过程&lt;/h3&gt;
&lt;h3 id=&#34;restful-是什么restful-请求的-url-有什么特点&#34;&gt;RestFul 是什么？RestFul 请求的 URL 有什么特点？&lt;/h3&gt;
&lt;h3 id=&#34;什么是-tcp-粘包和拆包&#34;&gt;什么是 TCP 粘包和拆包？&lt;/h3&gt;
&lt;h3 id=&#34;restful-与-rpc-的区别是什么restful-的优点在哪里&#34;&gt;RestFul 与 RPC 的区别是什么？RestFul 的优点在哪里？&lt;/h3&gt;
&lt;h3 id=&#34;tcp-挥手时出现大量-close_wait-或-time_wait-怎么解决&#34;&gt;TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？&lt;/h3&gt;
&lt;h3 id=&#34;什么是跨域什么情况下会发生跨域请求&#34;&gt;什么是跨域，什么情况下会发生跨域请求？&lt;/h3&gt;
&lt;h3 id=&#34;简述对称与非对称加密的概念&#34;&gt;简述对称与非对称加密的概念&lt;/h3&gt;
&lt;h3 id=&#34;http-中-get-和-post-区别&#34;&gt;HTTP 中 GET 和 POST 区别&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;GET&lt;/th&gt;
&lt;th&gt;POST&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;请求是否有主体&lt;/td&gt;
&lt;td&gt;N(可以携带，是否处理取决于服务器)&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;成功的响应是否有主体&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;安全&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;幂等&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可缓存&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y(带上有关刷新的信息)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HTML 表单是否支持&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.1&#34;&gt;rfc7231&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总而言之 RFC 只对 GET 和 POST 做了语义上的区别，他们的不同之处大多是浏览器行为&lt;/p&gt;
&lt;h3 id=&#34;tcp-的-keepalive-了解吗说一说它和-http-的-keepalive-的区别&#34;&gt;TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？&lt;/h3&gt;
&lt;h3 id=&#34;简述常见的-http-状态码的含义301304401403&#34;&gt;简述常见的 HTTP 状态码的含义（301，304，401，403）&lt;/h3&gt;
&lt;h3 id=&#34;简述-tcp-的-time_wait-和-close_wait&#34;&gt;简述 TCP 的 TIME_WAIT 和 CLOSE_WAIT&lt;/h3&gt;
&lt;h3 id=&#34;简述-tcp-滑动窗口以及重传机制&#34;&gt;简述 TCP 滑动窗口以及重传机制&lt;/h3&gt;
&lt;h3 id=&#34;简述-ddos-攻击原理如何防范它&#34;&gt;简述 DDOS 攻击原理，如何防范它？&lt;/h3&gt;
&lt;h3 id=&#34;简述-osi-七层模型tcpip-属于哪一层&#34;&gt;简述 OSI 七层模型，TCP，IP 属于哪一层？&lt;/h3&gt;
&lt;h3 id=&#34;从系统层面上udp-如何保证尽量可靠&#34;&gt;从系统层面上，UDP 如何保证尽量可靠？&lt;/h3&gt;
&lt;h3 id=&#34;简述-jwt-的原理和校验机制&#34;&gt;简述 JWT 的原理和校验机制&lt;/h3&gt;
&lt;h3 id=&#34;http-的方法有哪些&#34;&gt;HTTP 的方法有哪些？&lt;/h3&gt;
&lt;h3 id=&#34;tcp-长连接和短连接有那么不同的使用场景&#34;&gt;TCP 长连接和短连接有那么不同的使用场景？&lt;/h3&gt;
&lt;h3 id=&#34;什么是-arp-协议简述其使用场景&#34;&gt;什么是 ARP 协议？简述其使用场景&lt;/h3&gt;
&lt;h3 id=&#34;简述-rpc-的调用过程&#34;&gt;简述 RPC 的调用过程&lt;/h3&gt;
&lt;h3 id=&#34;tcp-中-syn-攻击是什么如何防止&#34;&gt;TCP 中 SYN 攻击是什么？如何防止？&lt;/h3&gt;
&lt;h3 id=&#34;简述-tcp-的报文头部结构&#34;&gt;简述 TCP 的报文头部结构&lt;/h3&gt;
&lt;h3 id=&#34;tcp-的拥塞控制具体是怎么实现的udp-有拥塞控制吗&#34;&gt;TCP 的拥塞控制具体是怎么实现的？UDP 有拥塞控制吗？&lt;/h3&gt;
&lt;h3 id=&#34;什么是中间人攻击如何防止攻击&#34;&gt;什么是中间人攻击？如何防止攻击？&lt;/h3&gt;
&lt;h3 id=&#34;简述什么是-xss-攻击以及-csrf-攻击&#34;&gt;简述什么是 XSS 攻击以及 CSRF 攻击？&lt;/h3&gt;
&lt;h3 id=&#34;如何防止传输内容被篡改&#34;&gt;如何防止传输内容被篡改？&lt;/h3&gt;
&lt;h3 id=&#34;如何设计-api-接口使其实现幂等性&#34;&gt;如何设计 API 接口使其实现幂等性？&lt;/h3&gt;
&lt;h3 id=&#34;简述-bgp-协议和-ospf-协议的区别&#34;&gt;简述 BGP 协议和 OSPF 协议的区别&lt;/h3&gt;
&lt;h3 id=&#34;http-是无状态的吗需要保持状态的场景应该怎么做&#34;&gt;HTTP 是无状态的吗？需要保持状态的场景应该怎么做？&lt;/h3&gt;
&lt;h3 id=&#34;简述-tcp-协议的延迟-ack-和累计应答&#34;&gt;简述 TCP 协议的延迟 ACK 和累计应答&lt;/h3&gt;
&lt;h3 id=&#34;ssl-握手流程为什么要使用非对称秘钥&#34;&gt;SSL 握手流程为什么要使用非对称秘钥？&lt;/h3&gt;
&lt;h3 id=&#34;简述-websocket-是如何进行传输的&#34;&gt;简述 WebSocket 是如何进行传输的&lt;/h3&gt;
&lt;h3 id=&#34;traceroute-有什么作用&#34;&gt;traceroute 有什么作用？&lt;/h3&gt;
&lt;h3 id=&#34;如何解决-tcp-传输丢包问题&#34;&gt;如何解决 TCP 传输丢包问题？&lt;/h3&gt;
&lt;h3 id=&#34;简述-http-的-keepalive-的原理和使用场景&#34;&gt;简述 HTTP 的 keepalive 的原理和使用场景&lt;/h3&gt;
&lt;h3 id=&#34;简述在四层和七层网络协议中负载均衡的原理&#34;&gt;简述在四层和七层网络协议中负载均衡的原理&lt;/h3&gt;
&lt;h3 id=&#34;简述-tcp-半连接发生场景&#34;&gt;简述 TCP 半连接发生场景&lt;/h3&gt;
&lt;h3 id=&#34;什么是-syn-flood如何防止这类攻击&#34;&gt;什么是 SYN flood，如何防止这类攻击？&lt;/h3&gt;
&lt;h3 id=&#34;简述-http-报文头部的组成结构&#34;&gt;简述 HTTP 报文头部的组成结构&lt;/h3&gt;
&lt;h3 id=&#34;为什么需要序列化有什么序列化的方式&#34;&gt;为什么需要序列化？有什么序列化的方式？&lt;/h3&gt;
&lt;h3 id=&#34;tcp-如何实现数据有序性&#34;&gt;TCP 如何实现数据有序性？&lt;/h3&gt;
&lt;h3 id=&#34;简述-http-短链接与长链接的区别&#34;&gt;简述 HTTP 短链接与长链接的区别&lt;/h3&gt;
&lt;h3 id=&#34;简述-ipv4-和-ipv6-的区别&#34;&gt;简述 iPv4 和 iPv6 的区别&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>八股文::Redis</title>
      <link>/notes/interview_questions_redis/</link>
      <pubDate>Fri, 20 Aug 2021 02:47:13 +0800</pubDate>
      <guid>/notes/interview_questions_redis/</guid>
      <description>&lt;h2 id=&#34;redis&#34;&gt;Redis&lt;/h2&gt;
&lt;h3 id=&#34;redis-有哪些数据结构分别有什么使用场景&#34;&gt;Redis 有哪些数据结构，分别有什么使用场景？&lt;/h3&gt;
&lt;h3 id=&#34;redis-zset-相同-score-如何排序&#34;&gt;Redis ZSET 相同 score 如何排序？&lt;/h3&gt;
&lt;h3 id=&#34;在爬虫中如何使用-redis-做-url-去重&#34;&gt;在爬虫中，如何使用 Redis 做 URL 去重？&lt;/h3&gt;
&lt;h3 id=&#34;redis-是否支持事务&#34;&gt;Redis 是否支持事务？&lt;/h3&gt;
&lt;h3 id=&#34;redis-中的-watch-命令是做什么的&#34;&gt;Redis 中的 WATCH 命令是做什么的？&lt;/h3&gt;
&lt;h3 id=&#34;redis-是如何保证高可用的&#34;&gt;Redis 是如何保证高可用的？&lt;/h3&gt;
&lt;h3 id=&#34;如何使用-redis-来实现分布式锁redlock&#34;&gt;如何使用 Redis 来实现分布式锁？Redlock？&lt;/h3&gt;
&lt;h3 id=&#34;redis-是单线程还是多线程为什么这么设计&#34;&gt;Redis 是单线程还是多线程？为什么这么设计？&lt;/h3&gt;
&lt;h3 id=&#34;redis-中的字符串对象和-c-语言中的字符串有什么区别&#34;&gt;Redis 中的字符串对象和 C 语言中的字符串有什么区别？&lt;/h3&gt;
&lt;h3 id=&#34;redis-中是如何实现链表的&#34;&gt;Redis 中是如何实现链表的？&lt;/h3&gt;
&lt;h3 id=&#34;redis-中是如何实现字典的&#34;&gt;Redis 中是如何实现字典的？&lt;/h3&gt;
&lt;h3 id=&#34;redis-中的字典是如何进行动态扩容的&#34;&gt;Redis 中的字典是如何进行动态扩容的？&lt;/h3&gt;
&lt;h3 id=&#34;redis-中的跳表是如何实现的&#34;&gt;Redis 中的跳表是如何实现的？&lt;/h3&gt;
&lt;h3 id=&#34;strlisthashsetzset-底层都是使用什么数据结构实现的&#34;&gt;STR/LIST/HASH/SET/ZSET 底层都是使用什么数据结构实现的？&lt;/h3&gt;
&lt;h3 id=&#34;zset-什么时候使用-ziplist-实现什么时候使用-skiplist-实现&#34;&gt;ZSET 什么时候使用 Ziplist 实现，什么时候使用 Skiplist 实现？&lt;/h3&gt;
&lt;h3 id=&#34;zset-为什么不用-bstavlb-tree红黑树而使用跳表&#34;&gt;ZSET 为什么不用 BST/AVL/B-Tree/红黑树，而使用跳表？&lt;/h3&gt;
&lt;h3 id=&#34;redis-的过期键删除策略是什么&#34;&gt;Redis 的过期键删除策略是什么？&lt;/h3&gt;
&lt;h3 id=&#34;redis-的主从服务器是如何同步过期键的&#34;&gt;Redis 的主从服务器是如何同步过期键的？&lt;/h3&gt;
&lt;h3 id=&#34;aof-和-rdb-持久化有什么区别&#34;&gt;AOF 和 RDB 持久化有什么区别？&lt;/h3&gt;
&lt;h3 id=&#34;redis-的主从是如何进行同步的&#34;&gt;Redis 的主从是如何进行同步的？&lt;/h3&gt;
&lt;h3 id=&#34;如何解决长时间使用后-aof-文件过大的问题&#34;&gt;如何解决长时间使用后 AOF 文件过大的问题？&lt;/h3&gt;
&lt;h3 id=&#34;redis-的哨兵机制是如何实现的&#34;&gt;Redis 的哨兵机制是如何实现的？&lt;/h3&gt;
&lt;h3 id=&#34;redis-的集群方案有哪些&#34;&gt;Redis 的集群方案有哪些？&lt;/h3&gt;
&lt;h3 id=&#34;redis-的整体架构是什么样的从客户端发出命令到客户端接收到结果这整个流程是什么样的&#34;&gt;Redis 的整体架构是什么样的，从客户端发出命令，到客户端接收到结果，这整个流程是什么样的？&lt;/h3&gt;
&lt;h3 id=&#34;redis-是如何实现-lru-机制的&#34;&gt;Redis 是如何实现 LRU 机制的？&lt;/h3&gt;
&lt;h3 id=&#34;redis-是如何实现-lfu-机制的&#34;&gt;Redis 是如何实现 LFU 机制的？&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>八股文::Java</title>
      <link>/notes/interview_questions_java/</link>
      <pubDate>Thu, 19 Aug 2021 21:51:33 +0800</pubDate>
      <guid>/notes/interview_questions_java/</guid>
      <description>&lt;h2 id=&#34;java&#34;&gt;Java&lt;/h2&gt;
&lt;h3 id=&#34;java-中垃圾回收机制中如何判断对象需要回收&#34;&gt;Java 中垃圾回收机制中如何判断对象需要回收？&lt;/h3&gt;
&lt;p&gt;引用计数法&lt;/p&gt;
&lt;p&gt;引用计数法的逻辑比较简单，对象维护一个 counter 计数器，如果有一个引用与之相连，则 counter++。如果一个与之相连的引用失效了，则 counter–。如果一个对象的 counter 为 0，则表明这个对象已经被废弃了，可以被 GC。&lt;/p&gt;
&lt;p&gt;对于循环引用的两个对象 A,B，引用计数法永远无法 A,B 对象。&lt;/p&gt;
&lt;p&gt;可达性分析算法&lt;/p&gt;
&lt;p&gt;所谓的可达性分析算法，就是通过一组 GC Roots 集合，或者说 tracing GC 的“根集合”，就是一组必须活跃的引用 作为起点，通过引用关系遍历对象图，能被遍历到的对象就判定为存活的，其余的对象判定为死亡。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常见的可以作为 GC Roots 引用的有:
&lt;ul&gt;
&lt;li&gt;虚拟机栈（栈帧中的本地变量表）中引用的对象。&lt;/li&gt;
&lt;li&gt;本地方法栈中 JNI（即一般说的 Native 方法）引用的对象&lt;/li&gt;
&lt;li&gt;方法区中类静态属性引用的对象&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常见的-gc-回收算法有哪些&#34;&gt;常见的 GC 回收算法有哪些？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;标记-复制:将内存划分为大小相等的两块，当一块用完后,将还存活的对象 copy 到另一块上
&lt;ul&gt;
&lt;li&gt;优点:实现简单，效率高，不产生内存碎片&lt;/li&gt;
&lt;li&gt;缺点:内存空间利用率低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;标记-清理:先标记需要回收的对象，完成标记后，清除对象。
&lt;ul&gt;
&lt;li&gt;优点:效率高,空间利用率高&lt;/li&gt;
&lt;li&gt;缺点:内存空间碎片化严重&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;标记-整理:先标记需要会后的对象，完成标记后，清除对象，将存活的对象都想一端移动。(标记-清除+整理)
&lt;ul&gt;
&lt;li&gt;优点:不会产生内存碎片&lt;/li&gt;
&lt;li&gt;缺点:效率低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hashmap-与-concurrenthashmap-的实现原理是怎样的&#34;&gt;HashMap 与 ConcurrentHashMap 的实现原理是怎样的？&lt;/h3&gt;
&lt;h3 id=&#34;concurrenthashmap-是如何保证线程安全的&#34;&gt;ConcurrentHashMap 是如何保证线程安全的？&lt;/h3&gt;
&lt;h3 id=&#34;synchronized-关键字底层是如何实现的它与-lock-相比优缺点分别是什么&#34;&gt;Synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？&lt;/h3&gt;
&lt;h3 id=&#34;jmm-中内存模型是怎样的什么是指令序列重排序&#34;&gt;JMM 中内存模型是怎样的？什么是指令序列重排序？&lt;/h3&gt;
&lt;h3 id=&#34;简述-arraylist-与-linkedlist-的底层实现以及常见操作的时间复杂度&#34;&gt;简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度&lt;/h3&gt;
&lt;h3 id=&#34;简述-bio-nio-aio-的区别&#34;&gt;简述 BIO, NIO, AIO 的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;BIO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BIO 全称是 Blocking IO，是 JDK1.4 之前的传统 IO 模型，本身是同步阻塞模式。线程发起 IO 请求后，一直阻塞 IO，直到缓冲区数据就绪后，再进入下一步操作。针对网络通信都是一请求一应答的方式，虽然简化了上层的应用开发，但在性能和可靠性方面存在着巨大瓶颈，试想一下如果每个请求都需要新建一个线程来专门处理，那么在高并发的场景下，机器资源很快就会被耗尽。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NIO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NIO 也叫 Non-Blocking IO 是同步非阻塞的 IO 模型。线程发起 io 请求后，立即返回（非阻塞 io）。同步指的是必须等待 IO 缓冲区内的数据就绪，而非阻塞指的是，用户线程不原地等待 IO 缓冲区，可以先做一些其他操作，但是要定时轮询检查 IO 缓冲区数据是否就绪。Java 中的 NIO 是 new IO 的意思。其实是 NIO 加上 IO 多路复用技术。普通的 NIO 是线程轮询查看一个 IO 缓冲区是否就绪，而 Java 中的 new IO 指的是线程轮询地去查看一堆 IO 缓冲区中哪些就绪，这是一种 IO 多路复用的思想。IO 多路复用模型中，将检查 IO 数据是否就绪的任务，交给系统级别的 select 或 epoll 模型，由系统进行监控，减轻用户线程负担。 NIO 主要有 buffer、channel、selector 三种技术的整合，通过零拷贝的 buffer 取得数据，每一个客户端通过 channel 在 selector（多路复用器）上进行注册。服务端不断轮询 channel 来获取客户端的信息。channel 上有 connect,accept（阻塞）、read（可读）、write(可写)四种状态标识。根据标识来进行后续操作。所以一个服务端可接收无限多的 channel。不需要新开一个线程。大大提升了性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AIO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AIO 是真正意义上的异步非阻塞 IO 模型。 上述 NIO 实现中，需要用户线程定时轮询，去检查 IO 缓冲区数据是否就绪，占用应用程序线程资源，其实轮询相当于还是阻塞的，并非真正解放当前线程，因为它还是需要去查询哪些 IO 就绪。而真正的理想的异步非阻塞 IO 应该让内核系统完成，用户线程只需要告诉内核，当缓冲区就绪后，通知我或者执行我交给你的回调函数。 AIO 可以做到真正的异步的操作，但实现起来比较复杂，支持纯异步 IO 的操作系统非常少，目前也就 windows 是 IOCP 技术实现了，而在 Linux 上，底层还是是使用的 epoll 实现的。&lt;/p&gt;
&lt;h3 id=&#34;java-类的加载流程是怎样的什么是双亲委派机制&#34;&gt;Java 类的加载流程是怎样的？什么是双亲委派机制？&lt;/h3&gt;
&lt;h3 id=&#34;volatile-关键字解决了什么问题它的实现原理是什么&#34;&gt;volatile 关键字解决了什么问题，它的实现原理是什么？&lt;/h3&gt;
&lt;h3 id=&#34;简述-synchronizedvolatile可重入锁的不同使用场景及优缺点&#34;&gt;简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点&lt;/h3&gt;
&lt;h3 id=&#34;实现单例设计模式懒汉饿汉&#34;&gt;实现单例设计模式（懒汉，饿汉）&lt;/h3&gt;
&lt;h3 id=&#34;-和-equals-的区别&#34;&gt;== 和 equals() 的区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;equals()&lt;/code&gt;方法和 == 运算符之间的主要区别在于，一个是方法，另一个是运算符。&lt;/li&gt;
&lt;li&gt;我们可以用==运算符进行引用比较（地址比较），用&lt;code&gt;equals()&lt;/code&gt;方法进行内容比较。简单地说，== 检查两个对象是否指向相同的内存位置，而&lt;code&gt;equals()&lt;/code&gt;则是对对象中的值进行评估比较。&lt;/li&gt;
&lt;li&gt;如果一个类没有覆盖 &lt;code&gt;equals()&lt;/code&gt; 方法，那么默认情况下，它使用最接近的父类的 &lt;code&gt;equals(Object o)&lt;/code&gt;方法，该父类已经覆盖了这个方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程池是如何实现的简述线程池的任务策略&#34;&gt;线程池是如何实现的？简述线程池的任务策略&lt;/h3&gt;
&lt;h3 id=&#34;简述-java-的反射机制及其应用场景&#34;&gt;简述 Java 的反射机制及其应用场景&lt;/h3&gt;
&lt;h3 id=&#34;简述-spring-aop-的原理&#34;&gt;简述 Spring AOP 的原理&lt;/h3&gt;
&lt;h3 id=&#34;jvm-内存是如何对应到操作系统内存的&#34;&gt;JVM 内存是如何对应到操作系统内存的？&lt;/h3&gt;
&lt;h3 id=&#34;简述-spring-bean-的生命周期&#34;&gt;简述 Spring bean 的生命周期&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Bean 容器在配置文件中找到 Spring Bean 的定义。&lt;/li&gt;
&lt;li&gt;Bean 容器使用 Java Reflection API 创建 Bean 的实例。&lt;/li&gt;
&lt;li&gt;如果声明了任何属性，声明的属性会被设置。如果属性本身是 Bean，则将对其进行解析和设置。&lt;/li&gt;
&lt;li&gt;如果 Bean 类实现 BeanNameAware 接口，则将通过传递 Bean 的名称来调用 setBeanName()方法。&lt;/li&gt;
&lt;li&gt;如果 Bean 类实现 BeanClassLoaderAware 接口，则将通过传递加载此 Bean 的 ClassLoader 对象的实例来调用 setBeanClassLoader()方法。&lt;/li&gt;
&lt;li&gt;如果 Bean 类实现 BeanFactoryAware 接口，则将通过传递 BeanFactory 对象的实例来调用 setBeanFactory()方法。&lt;/li&gt;
&lt;li&gt;如果有任何与 BeanFactory 关联的 BeanPostProcessors 对象已加载 Bean，则将在设置 Bean 属性之前调用 postProcessBeforeInitialization()方法。&lt;/li&gt;
&lt;li&gt;如果 Bean 类实现了 InitializingBean 接口，则在设置了配置文件中定义的所有 Bean 属性后，将调用 afterPropertiesSet()方法。&lt;/li&gt;
&lt;li&gt;如果配置文件中的 Bean 定义包含 init-method 属性，则该属性的值将解析为 Bean 类中的方法名称，并将调用该方法。&lt;/li&gt;
&lt;li&gt;如果为 Bean Factory 对象附加了任何 Bean 后置处理器，则将调用 postProcessAfterInitialization()方法。&lt;/li&gt;
&lt;li&gt;如果 Bean 类实现 DisposableBean 接口，则当 Application 不再需要 Bean 引用时，将调用 destroy()方法。&lt;/li&gt;
&lt;li&gt;如果配置文件中的 Bean 定义包含 destroy-method 属性，那么将调用 Bean 类中的相应方法定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;java-中接口和抽象类的区别&#34;&gt;Java 中接口和抽象类的区别&lt;/h3&gt;
&lt;p&gt;抽象类：如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用 abstract 关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。如果一个类继承抽象类，那么就必须为基类中的抽象方法提供定义。如果不这么做，那导出类也为抽象类。&lt;/p&gt;
&lt;p&gt;抽象类和普通类的主要有三点区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;抽象方法必须为 public 或者 protected（因为如果为 private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为 public。&lt;/li&gt;
&lt;li&gt;抽象类不能用来创建对象；&lt;/li&gt;
&lt;li&gt;如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为 abstract 类。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接口：可以含有变量和方法。但是要注意，接口中的变量会被隐式地指定为 public static final 变量（并且只能是 public static final 变量，用 private 修饰会报编译错误），而方法会被隐式地指定为 public abstract 方法且只能是 public abstract 方法（用其他关键字，比如 private、protected、static、final 等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。&lt;/p&gt;
&lt;p&gt;抽象类与接口区别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个 interface。&lt;/li&gt;
&lt;li&gt;在 abstract class 中可以有自己的数据成员，也可以有非 abstract 的成员方法，而在 interface 中，只能够有静态的不能被修改的数据成员（也就是必须是 static final 的，不过在 interface 中一般不定义数据成员），所以的成员方法都是 abstract 的。&lt;/li&gt;
&lt;li&gt;实现抽象类和接口的类必须实现其中的所有方法，如果子类没有实现抽象类的所有抽象方法，那么子类也必须是抽象类；但是子类实现接口，则必须把接口的所有抽象方法实现。接口也可以继承接口，此时不需要实现父类接口。抽象类中可以有非抽象方法。接口中则不能有实现方法。&lt;/li&gt;
&lt;li&gt;接口中定义的变量默认都是 public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。&lt;/li&gt;
&lt;li&gt;接口中的方法默认都是 public abstract 类型的，也只能是这个类型不能是 static 方法。static 方法是类方法，它是不允许子类覆写（override）的。但是抽象类允许有 static 方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;stringstringbufferstringbuilder-之间有什么区别&#34;&gt;String，StringBuffer，StringBuilder 之间有什么区别？&lt;/h3&gt;
&lt;h3 id=&#34;threadlocal-实现原理是什么&#34;&gt;ThreadLocal 实现原理是什么？&lt;/h3&gt;
&lt;h3 id=&#34;简述-cas-原理什么是-aba-问题怎么解决&#34;&gt;简述 CAS 原理，什么是 ABA 问题，怎么解决？&lt;/h3&gt;
&lt;h3 id=&#34;简述常见的工厂模式以及单例模式的使用场景&#34;&gt;简述常见的工厂模式以及单例模式的使用场景&lt;/h3&gt;
&lt;h3 id=&#34;java-常见锁有哪些reetrantlock-是怎么实现的&#34;&gt;Java 常见锁有哪些？ReetrantLock 是怎么实现的？&lt;/h3&gt;
&lt;h3 id=&#34;string-类能不能被继承为什么&#34;&gt;String 类能不能被继承？为什么？&lt;/h3&gt;
&lt;h3 id=&#34;hashmap-17--18-的实现区别&#34;&gt;HashMap 1.7 / 1.8 的实现区别&lt;/h3&gt;
&lt;h3 id=&#34;什么是公平锁什么是非公平锁&#34;&gt;什么是公平锁？什么是非公平锁？&lt;/h3&gt;
&lt;h3 id=&#34;简述动态代理与静态代理&#34;&gt;简述动态代理与静态代理&lt;/h3&gt;
&lt;h3 id=&#34;java-是如何实现线程安全的哪些数据结构是线程安全的&#34;&gt;Java 是如何实现线程安全的，哪些数据结构是线程安全的？&lt;/h3&gt;
&lt;h3 id=&#34;spring-mvc-的原理和流程&#34;&gt;Spring MVC 的原理和流程&lt;/h3&gt;
&lt;h3 id=&#34;java-怎么防止内存溢出&#34;&gt;Java 怎么防止内存溢出&lt;/h3&gt;
&lt;h3 id=&#34;简述-java-锁升级的机制&#34;&gt;简述 Java 锁升级的机制&lt;/h3&gt;
&lt;h3 id=&#34;hashmap-实现原理为什么使用红黑树&#34;&gt;HashMap 实现原理，为什么使用红黑树？&lt;/h3&gt;
&lt;h3 id=&#34;hashcode-和-equals-方法的联系&#34;&gt;hashcode 和 equals 方法的联系&lt;/h3&gt;
&lt;h3 id=&#34;什么是重写和重载&#34;&gt;什么是重写和重载？&lt;/h3&gt;
&lt;h3 id=&#34;java-中-sleep-与-wait-的区别&#34;&gt;Java 中 sleep() 与 wait() 的区别&lt;/h3&gt;
&lt;h3 id=&#34;什么是内存泄漏怎么确定内存泄漏&#34;&gt;什么是内存泄漏，怎么确定内存泄漏？&lt;/h3&gt;
&lt;h3 id=&#34;什么是设计模式描述几个常用的设计模式&#34;&gt;什么是设计模式，描述几个常用的设计模式&lt;/h3&gt;
&lt;h3 id=&#34;实现单例模式&#34;&gt;实现单例模式&lt;/h3&gt;
&lt;h3 id=&#34;简述-cms-与-g1-机制的区别&#34;&gt;简述 CMS 与 G1 机制的区别&lt;/h3&gt;
&lt;h3 id=&#34;集合类中的-list-和-map-的线程安全版本是什么如何保证线程安全的&#34;&gt;集合类中的 List 和 Map 的线程安全版本是什么，如何保证线程安全的？&lt;/h3&gt;
&lt;h3 id=&#34;java-的线程有哪些状态转换关系是怎么样的&#34;&gt;Java 的线程有哪些状态，转换关系是怎么样的？&lt;/h3&gt;
&lt;h3 id=&#34;简述-java-aqs-的原理以及使用场景&#34;&gt;简述 Java AQS 的原理以及使用场景&lt;/h3&gt;
&lt;h3 id=&#34;java-异常有哪些类型&#34;&gt;Java 异常有哪些类型？&lt;/h3&gt;
&lt;h3 id=&#34;hashmap-和-hashtable-的区别是什么&#34;&gt;hashmap 和 hashtable 的区别是什么？&lt;/h3&gt;
&lt;h3 id=&#34;简述-spring-注解的实现原理&#34;&gt;简述 Spring 注解的实现原理&lt;/h3&gt;
&lt;h3 id=&#34;java-线程和操作系统的线程是怎么对应的java-线程是怎样进行调度的&#34;&gt;Java 线程和操作系统的线程是怎么对应的？Java 线程是怎样进行调度的?&lt;/h3&gt;
&lt;h3 id=&#34;java-线程池里的-arrayblockingqueue-与-linkedblockingqueue-的使用场景和区别&#34;&gt;Java 线程池里的 arrayblockingqueue 与 linkedblockingqueue 的使用场景和区别&lt;/h3&gt;
&lt;h3 id=&#34;cas-实现原理是什么&#34;&gt;CAS 实现原理是什么？&lt;/h3&gt;
&lt;p&gt;在 Java 中可以通过 Unsafe 类实现 CAS 操作，而 Unsafe 类最终调用的是 native 方法，即具体实现是由 JVM 中的方法实现的。而 JVM 中通过 C++调用处理器的指令 cmpxchg 来实现的。&lt;/p&gt;
&lt;h3 id=&#34;jvm-是怎么去调优的了解哪些参数和指令&#34;&gt;JVM 是怎么去调优的？了解哪些参数和指令？&lt;/h3&gt;
&lt;h3 id=&#34;简述-netty-线程模型netty-为什么如此高效&#34;&gt;简述 Netty 线程模型，Netty 为什么如此高效？&lt;/h3&gt;
&lt;p&gt;netty 线程模型采用“服务端监听线程”和“IO 线程”分离的方式，与多线程 Reactor 模型类似。&lt;/p&gt;
&lt;p&gt;抽象出 NioEventLoop 来表示一个不断循环执行处理任务的线程，每个 NioEventLoop 有一个 selector，用于监听绑定在其上的 socket 链路。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Netty 抽象出两组线程池 BossGroup 专门负责接收客户端的连接， Worker Group 专门负责网络的读写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Boss Group 和 Worker Group 类型都是 NioEventLoopGroup&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NioEventLoop Giroup 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 NioEventLoop&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NioEventLoop 表示一个不断循环的执行处理任务的线程，每个 NioEventLoop 都有一个 selector,用于监听绑定在其上的 socket 的网络通讯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NioEventLoop Group 可以有多个线程，即可以含有多个 NioE:ventLoop&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 Boss NioEventLoop 循环执行的步骤有 3 步&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轮询 accept 事件&lt;/li&gt;
&lt;li&gt;处理 accept 事件，与 client 建立连接，生成 NioScocketchannel,并将其注册到某个 worker NIOEventLoop 上的 selector&lt;/li&gt;
&lt;li&gt;处理任务队列的任务，即 runAllTasks&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 Worker NIOEventLoop 循环执行的步骤 1.轮询 read, write 事件 2.处理 0 事件，即 ead,wite 事件，在对应 NioScocketChannel 处理 3.处理任务队列的任务，即 runAlllask&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 Worker NIOE ventloop 处理业务时，会使用 pipeline 管道， pipeline 中包含了 channel,即通过 pipeline 可以获取到对应通道，管道中维护了很多的处理器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非阻塞 IO&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Netty 采用了 IO 多路复用技术，让多个 IO 的阻塞复用到一个 select 线程阻塞上，能够有效的应对大量的并发请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高效的 Reactor 线程模型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Netty 服务端采用 Reactor 主从多线程模型
&lt;ul&gt;
&lt;li&gt;主线程：Acceptor 线程池用于监听 Client 的 TCP 连接请求&lt;/li&gt;
&lt;li&gt;从线程：Client 的 IO 操作都由一个特定的 NIO 线程池负责，负责消息的读取、解码、编码和发送&lt;/li&gt;
&lt;li&gt;Client 连接有很多，但是 NIO 线程数是比较少的，一个 NIO 线程可以同时绑定到多个 Client，同时一个 Client 只能对应一个线程，避免出现线程安全问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无锁化串行设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;串行设计：消息的处理尽可能在一个线程内完成，期间不进行线程切换，避免了多线程竞争和同步锁的使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高效的并发编程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Netty 的高效并发编程主要体现在如下几点
&lt;ul&gt;
&lt;li&gt;volatile 的大量、正确使用&lt;/li&gt;
&lt;li&gt;CAS 和原子类的广泛使用&lt;/li&gt;
&lt;li&gt;线程安全容器的使用&lt;/li&gt;
&lt;li&gt;通过读写锁提升并发性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高性能的序列化框架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Netty 默认提供了对 Google Protobuf 的支持，通过扩展 Netty 的编解码接口，可以实现其它的高性能序列化框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;零拷贝&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Netty 的接收和发送 ByteBuffer 采用 DirectByteBuffer，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HeapByteBuffer）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝&lt;/li&gt;
&lt;li&gt;Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。&lt;/li&gt;
&lt;li&gt;Netty 的文件传输采用了 transferTo()方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write()方式导致的内存拷贝问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存池&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于对象池的 ByteBuf 可以重用 ByteBuf 对象，内部维护了一个内存池，可以循环利用已创建的 ByteBuf，提升内存的使用效率，降低由于高负载导致的频繁 GC。测试表明使用内存池后的 Nety 在高负载、大并发的冲击下内存和 GC 更加平稳&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;灵活的 TCP 参数配置能力&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合理设置 TCP 参数在某些场景下对于性能的提升可以起到显著的效果，例如 SO_RCVBUF 和 SO_SNDBUF。如果设置不当，对性能的影响是非常大的&lt;/li&gt;
&lt;li&gt;SO_RCVBUF 和 SO_SNDBUF：通常建议值为 128K 或者 256K；&lt;/li&gt;
&lt;li&gt;SO_TCPNODELAY：NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；&lt;/li&gt;
&lt;li&gt;软中断：如果 Linux 内核版本支持 RPS（2.6.35 以上版本），开启 RPS 后可以实现软中断，提升网络吞吐量。RPS 根据数据包的源地址，目的地址以及目的和源端口，计算出一个 hash 值，然后根据这个 hash 值来选择软中断运行的 cpu，从上层来看，也就是说将每个连接和 cpu 绑定，并通过这个 hash 值，来均衡软中断在多个 cpu 上，提升网络并行处理性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;什么是-java-泛型有什么作用&#34;&gt;什么是 Java 泛型，有什么作用？&lt;/h3&gt;
&lt;h3 id=&#34;java-创建多线程的方法有哪些&#34;&gt;JAVA 创建多线程的方法有哪些？&lt;/h3&gt;
&lt;h3 id=&#34;如何解决-spring-的循环依赖问题&#34;&gt;如何解决 Spring 的循环依赖问题？&lt;/h3&gt;
&lt;h3 id=&#34;简述-synchronizedvolatile可重入锁的不同使用场景及优缺点-1&#34;&gt;简述 Synchronized，volatile，可重入锁的不同使用场景及优缺点&lt;/h3&gt;
&lt;h3 id=&#34;如何优化-jvm-频繁-minor-gc&#34;&gt;如何优化 JVM 频繁 minor GC&lt;/h3&gt;
&lt;h3 id=&#34;简述-spring-的-ioc-机制&#34;&gt;简述 Spring 的 IOC 机制&lt;/h3&gt;
&lt;h3 id=&#34;简述-dubbo-服务调用过程&#34;&gt;简述 Dubbo 服务调用过程&lt;/h3&gt;
&lt;h3 id=&#34;简述并实现工厂模式工厂模式有什么常见问题&#34;&gt;简述并实现工厂模式，工厂模式有什么常见问题？&lt;/h3&gt;
&lt;h3 id=&#34;产生死锁的必要条件有哪些如何解决死锁&#34;&gt;产生死锁的必要条件有哪些？如何解决死锁？&lt;/h3&gt;
&lt;h3 id=&#34;string-为什么是-final-类型&#34;&gt;String 为什么是 final 类型？&lt;/h3&gt;
&lt;h3 id=&#34;如何设计-java-的异常体系&#34;&gt;如何设计 Java 的异常体系？&lt;/h3&gt;
&lt;h3 id=&#34;常用的排序方式有哪些时间复杂度是多少&#34;&gt;常用的排序方式有哪些，时间复杂度是多少？&lt;/h3&gt;
&lt;h3 id=&#34;简述装饰者模式以及适配器模式&#34;&gt;简述装饰者模式以及适配器模式&lt;/h3&gt;
&lt;h3 id=&#34;简述-hashmap-和-treemap-的实现原理以及常见操作的时间复杂度&#34;&gt;简述 HashMap 和 TreeMap 的实现原理以及常见操作的时间复杂度&lt;/h3&gt;
&lt;h3 id=&#34;如何设计一个线程池&#34;&gt;如何设计一个线程池&lt;/h3&gt;
&lt;h3 id=&#34;java-线程间有多少通信方式&#34;&gt;Java 线程间有多少通信方式？&lt;/h3&gt;
&lt;h3 id=&#34;简述-java-中-final-关键字的作用&#34;&gt;简述 Java 中 final 关键字的作用&lt;/h3&gt;
&lt;h3 id=&#34;手写生产者消费者模型&#34;&gt;手写生产者消费者模型&lt;/h3&gt;
&lt;h3 id=&#34;简述-hashset-与-hashmap-的异同&#34;&gt;简述 HashSet 与 HashMap 的异同&lt;/h3&gt;
&lt;h3 id=&#34;深拷贝与浅拷贝区别是什么&#34;&gt;深拷贝与浅拷贝区别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。&lt;/li&gt;
&lt;li&gt;深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简述-spring-的初始化流程&#34;&gt;简述 Spring 的初始化流程&lt;/h3&gt;
&lt;h3 id=&#34;java-缓冲流-buffer-的用途和原理是什么&#34;&gt;Java 缓冲流 buffer 的用途和原理是什么？&lt;/h3&gt;
&lt;h3 id=&#34;简述-java-内置排序算法的实现原理&#34;&gt;简述 Java 内置排序算法的实现原理&lt;/h3&gt;
&lt;h3 id=&#34;jdk-18-有什么新特性&#34;&gt;JDK 1.8 有什么新特性？&lt;/h3&gt;
&lt;h3 id=&#34;有哪些解决哈希表冲突的方式&#34;&gt;有哪些解决哈希表冲突的方式？&lt;/h3&gt;
&lt;h3 id=&#34;简述-zookeeper-基础原理以及使用场景&#34;&gt;简述 Zookeeper 基础原理以及使用场景&lt;/h3&gt;
&lt;h3 id=&#34;简述标记清除算法的流程&#34;&gt;简述标记清除算法的流程&lt;/h3&gt;
&lt;h3 id=&#34;简述-sortedset-实现原理&#34;&gt;简述 SortedSet 实现原理&lt;/h3&gt;
&lt;p&gt;底层是基于&lt;code&gt;TreeMap&lt;/code&gt;来实现的，所以底层结构也是红黑树，因为他和&lt;code&gt;HashSet&lt;/code&gt;不同的是不需要重写&lt;code&gt;hashCode()&lt;/code&gt;和&lt;code&gt;equals()&lt;/code&gt;方法，因为它去重是依靠比较器来去重，因为结构是红黑树，所以每次插入都会遍历比较来寻找节点插入位置，如果发现某个节点的值是一样的那就会直接覆盖。&lt;/p&gt;
&lt;h3 id=&#34;java-有几种基本数据类型分别占多少字节&#34;&gt;Java 有几种基本数据类型，分别占多少字节？&lt;/h3&gt;
&lt;h3 id=&#34;简述-hashset-实现原理&#34;&gt;简述 HashSet 实现原理&lt;/h3&gt;
&lt;h3 id=&#34;数组与链表有什么区别&#34;&gt;数组与链表有什么区别？&lt;/h3&gt;
&lt;h3 id=&#34;简述偏向锁以及轻量级锁的区别&#34;&gt;简述偏向锁以及轻量级锁的区别&lt;/h3&gt;
&lt;h3 id=&#34;如何回收循环依赖的对象&#34;&gt;如何回收循环依赖的对象&lt;/h3&gt;
&lt;h3 id=&#34;linux-实现虚拟内存有什么方式&#34;&gt;Linux 实现虚拟内存有什么方式？&lt;/h3&gt;
&lt;h3 id=&#34;简述-java-的序列化和使用场景&#34;&gt;简述 Java 的序列化和使用场景&lt;/h3&gt;
&lt;h3 id=&#34;string-为什么是-final&#34;&gt;String 为什么是 final？&lt;/h3&gt;
&lt;h3 id=&#34;java-多线程有几种实现方式&#34;&gt;Java 多线程有几种实现方式&lt;/h3&gt;
&lt;h3 id=&#34;如何确定-eden-区的对象何时进入老年代&#34;&gt;如何确定 eden 区的对象何时进入老年代？&lt;/h3&gt;
&lt;h3 id=&#34;spring-mvc-如何处理一个请求&#34;&gt;Spring MVC 如何处理一个请求？&lt;/h3&gt;
&lt;h3 id=&#34;java-中-arrayblockingqueue-与-linkedblockingqueue-的用途和区别&#34;&gt;Java 中 arrayblockingqueue 与 linkedblockingqueue 的用途和区别&lt;/h3&gt;
&lt;h3 id=&#34;简述-java-的-happen-before-原则&#34;&gt;简述 Java 的 happen before 原则&lt;/h3&gt;
&lt;h3 id=&#34;springboot-是如何进行自动配置的&#34;&gt;SpringBoot 是如何进行自动配置的？&lt;/h3&gt;
&lt;h3 id=&#34;简述使用协程的优点&#34;&gt;简述使用协程的优点&lt;/h3&gt;
&lt;h3 id=&#34;error-和-exception-的区别是什么&#34;&gt;error 和 exception 的区别是什么？&lt;/h3&gt;
&lt;h3 id=&#34;简述生产者消费者模型&#34;&gt;简述生产者消费者模型&lt;/h3&gt;
&lt;h3 id=&#34;jvm-是怎么去调优的简述过程和调优的结果&#34;&gt;JVM 是怎么去调优的？简述过程和调优的结果&lt;/h3&gt;
&lt;h3 id=&#34;简述读写屏障底层原理&#34;&gt;简述读写屏障底层原理&lt;/h3&gt;
&lt;h3 id=&#34;什么是堆内存异常&#34;&gt;什么是堆内存异常？&lt;/h3&gt;
&lt;h3 id=&#34;简述有哪些同步锁以及它们的实现原理&#34;&gt;简述有哪些同步锁以及它们的实现原理&lt;/h3&gt;
&lt;h3 id=&#34;什么是-spring-容器有什么作用&#34;&gt;什么是 Spring 容器，有什么作用？&lt;/h3&gt;
&lt;h3 id=&#34;如何设计一个无锁队列&#34;&gt;如何设计一个无锁队列&lt;/h3&gt;
&lt;h3 id=&#34;如何停止一个线程&#34;&gt;如何停止一个线程？&lt;/h3&gt;
&lt;h3 id=&#34;在一个静态方法内调用一个非静态成员为什么是非法的&#34;&gt;在一个静态方法内调用一个非静态成员为什么是非法的？&lt;/h3&gt;
&lt;h3 id=&#34;spring-是怎么解析-json-数据的&#34;&gt;Spring 是怎么解析 JSON 数据的？&lt;/h3&gt;
&lt;h3 id=&#34;java-如何高效进行数组拷贝&#34;&gt;Java 如何高效进行数组拷贝&lt;/h3&gt;
&lt;p&gt;Arrays.copyOf 或 System.arraycopy，System.arraycopy 是系统的 native 方法，Arrays.copyOf 底层调用 System.arraycopy 方法&lt;/p&gt;
&lt;h3 id=&#34;成员变量和方法的区别&#34;&gt;成员变量和方法的区别？&lt;/h3&gt;
&lt;h3 id=&#34;阻塞队列都有哪几种有什么区别&#34;&gt;阻塞队列都有哪几种，有什么区别？&lt;/h3&gt;
&lt;h3 id=&#34;java-中如何进行-gc-调优&#34;&gt;Java 中如何进行 GC 调优？&lt;/h3&gt;
&lt;h3 id=&#34;mvc-模型和-mvvm-模型的区别&#34;&gt;MVC 模型和 MVVM 模型的区别&lt;/h3&gt;
&lt;h3 id=&#34;cookie-和-session-的关系和区别是什么&#34;&gt;Cookie 和 Session 的关系和区别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;session 在服务器端，cookie 在客户端（浏览器）&lt;/li&gt;
&lt;li&gt;session 默认被存在在服务器的一个文件里（不是内存）&lt;/li&gt;
&lt;li&gt;session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）&lt;/li&gt;
&lt;li&gt;session 可以放在 文件、数据库、或内存中都可以。&lt;/li&gt;
&lt;li&gt;用户验证这种场合一般会用 session&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简述-java-的逃逸分析机制&#34;&gt;简述 Java 的逃逸分析机制&lt;/h3&gt;
&lt;p&gt;1.逃逸分析的定义&lt;/p&gt;
&lt;p&gt;逃逸分析：是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。&lt;/p&gt;
&lt;p&gt;通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。&lt;/p&gt;
&lt;p&gt;Java 在 Java SE 6u23 以及以后的版本中支持并默认开启了逃逸分析的选项。Java 的 HotSpot JIT 编译器，能够在方法重载或者动态加载代码的时候对代码进行逃逸分析。&lt;/p&gt;
&lt;p&gt;逃逸分析的基本行为就是分析对象的动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用。&lt;/p&gt;
&lt;p&gt;方法逃逸：例如作为调用参数传递到其他方法中。&lt;/p&gt;
&lt;p&gt;线程逃逸：有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量。&lt;/p&gt;
&lt;p&gt;2.逃逸分析的理论基础&lt;/p&gt;
&lt;p&gt;基于 Jong-Deok Choi, Manish Gupta, Mauricio Seffano,Vugranam C. Sreedhar, Sam Midkiff 等在论文《Escape Analysis for Java》中描述的算法进行逃逸分析。&lt;/p&gt;
&lt;p&gt;该算法引入了连通图，用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。由于该算法是上下文相关和流敏感的，并且模拟了对象任意层次的嵌套关系，所以分析精度较高，只是运行时间和内存消耗相对较大。&lt;/p&gt;
&lt;p&gt;绝大多数逃逸分析的实现都基于“封闭世界(closed world)”的前提：所有可能被执行的，方法在做逃逸分析前都已经得知，并且，程序的实际运行不会改变它们之间的调用关系 。但当真实的 Java 程序运行时，这样的假设并不成立。Java 程序拥有的许多特性，例如动态类加载、调用本地函数以及反射程序调用等等，都将打破所谓“封闭世界”的约定。&lt;/p&gt;
&lt;p&gt;逃逸分析之后的处理操作&lt;/p&gt;
&lt;p&gt;经过逃逸分析之后，可以得到对象三种可能的逃逸状态：&lt;/p&gt;
&lt;p&gt;GlobalEscape(全局逃逸)： 即一个对象的引用逃出了方法或者线程。例如，一个对象的引用是复制给了一个类变量，或者存储在在一个已经逃逸的对象当中，或者这个对象的引用作为方法的返回值返回给了调用方法。&lt;/p&gt;
&lt;p&gt;ArgEscape(参数级逃逸)：即在方法调用过程当中传递对象的应用给一个方法。这种状态可以通过分析被调方法的二进制代码确定。&lt;/p&gt;
&lt;p&gt;NoEscape(没有逃逸)：一个可以进行标量替换的对象。该对象可以不被分配在传统的堆上。&lt;/p&gt;
&lt;p&gt;编译器可以使用逃逸分析的结果，对程序进行优化。&lt;/p&gt;
&lt;p&gt;堆分配对象变成栈分配对象：一个方法当中的对象，对象的引用没有发生逃逸，那么这个方法可能会被分配在栈内存上而非常见的堆内存上。&lt;/p&gt;
&lt;p&gt;消除同步：线程同步的代价是相当高的，同步的后果是降低并发性和性能。逃逸分析可以判断出某个对象是否始终只被一个线程访问，如果只被一个线程访问，那么对该对象的同步操作就可以转化成没有同步保护的操作，这样就能大大提高并发程度和性能。&lt;/p&gt;
&lt;p&gt;矢量替代：逃逸分析方法如果发现对象的内存存储结构不需要连续进行的话，就可以将对象的部分甚至全部都保存在 CPU 寄存器内，这样能大大提高访问速度。&lt;/p&gt;
&lt;h3 id=&#34;new-integer-和-integervalueof-的区别是什么&#34;&gt;new Integer 和 Integer.valueOf 的区别是什么？&lt;/h3&gt;
&lt;h3 id=&#34;简述-java-中的自动装箱与拆箱&#34;&gt;简述 Java 中的自动装箱与拆箱&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;自动装箱就是 Java 自动将原始类型值转换成对应的对象，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱，反之将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。&lt;/li&gt;
&lt;li&gt;原始类型 byte,short,char,int,long,float,double 和 boolean 对应的封装类为 Byte,Short,Character,Integer,Long,Float,Double,Boolean。&lt;/li&gt;
&lt;li&gt;自动装箱时编译器调用 valueOf 将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似 intValue(),doubleValue()这类的方法将对象转换成原始类型值。&lt;/li&gt;
&lt;li&gt;自动装箱是将 boolean 值转换成 Boolean 对象，byte 值转换成 Byte 对象，char 转换成 Character 对象，float 值转换成 Float 对象，int 转换成 Integer，long 转换成 Long，short 转换成 Short，自动拆箱则是相反的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简单介绍-mybatismybatis-是如何实现-orm-映射的&#34;&gt;简单介绍 MyBatis，MyBatis 是如何实现 ORM 映射的&lt;/h3&gt;
&lt;h3 id=&#34;简述-web-socket-与-http-的使用场景&#34;&gt;简述 Web socket 与 HTTP 的使用场景&lt;/h3&gt;
&lt;h3 id=&#34;java-编译后的-class-文件包含了什么内容&#34;&gt;Java 编译后的 .class 文件包含了什么内容？&lt;/h3&gt;
&lt;h3 id=&#34;java-中-int-的最大值是多少&#34;&gt;Java 中 int 的最大值是多少？&lt;/h3&gt;
&lt;h3 id=&#34;简述封装继承多态的特性及使用场景&#34;&gt;简述封装、继承、多态的特性及使用场景&lt;/h3&gt;
&lt;h3 id=&#34;aqs-在-countdownlatch-等类中的应用原理是什么&#34;&gt;AQS 在 CountDownLatch 等类中的应用原理是什么？&lt;/h3&gt;
&lt;h3 id=&#34;aqs-的内部原理是什么样的&#34;&gt;AQS 的内部原理是什么样的？&lt;/h3&gt;
&lt;h3 id=&#34;atomicinteger-和-synchronized-的异同点&#34;&gt;AtomicInteger 和 synchronized 的异同点？&lt;/h3&gt;
&lt;h3 id=&#34;atomicinteger-在高并发下性能不好如何解决为什么&#34;&gt;AtomicInteger 在高并发下性能不好，如何解决？为什么？&lt;/h3&gt;
&lt;h3 id=&#34;cas-和乐观锁的关系什么时候会用到-cas&#34;&gt;CAS 和乐观锁的关系，什么时候会用到 CAS？&lt;/h3&gt;
&lt;h3 id=&#34;cas-有什么缺点&#34;&gt;CAS 有什么缺点？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ABA 问题&lt;/li&gt;
&lt;li&gt;自旋时间过长&lt;/li&gt;
&lt;li&gt;不能控制范围&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;callable-和-runnable-的不同&#34;&gt;Callable 和 Runnable 的不同？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Callable 规定的方法是 call(),Runnable 规定的方法是 run().&lt;/li&gt;
&lt;li&gt;Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值得&lt;/li&gt;
&lt;li&gt;call 方法可以抛出异常，run 方法不可以&lt;/li&gt;
&lt;li&gt;运行 Callable 任务可以拿到一个 Future 对象，Future 表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。计算完成后只能使用 get 方法来获取结果，如果线程没有执行完，Future.get()方法可能会阻塞当前线程的执行；如果线程出现异常，Future.get()会 throws InterruptedException 或者 ExecutionException；如果线程已经取消，会跑出 CancellationException。取消由 cancel 方法来执行。isDone 确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&amp;lt;?&amp;gt; 形式类型、并返回 null 作为底层任务的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;concurrenthashmap-在-java7-和-8-有何不同&#34;&gt;ConcurrentHashMap 在 Java7 和 8 有何不同？&lt;/h3&gt;
&lt;h3 id=&#34;conditionobjectwait-和-notify-的关系&#34;&gt;Condition、object.wait() 和 notify() 的关系？&lt;/h3&gt;
&lt;h3 id=&#34;copyonwritearraylist-有什么特点&#34;&gt;CopyOnWriteArrayList 有什么特点？&lt;/h3&gt;
&lt;h3 id=&#34;countdownlatch-是如何安排线程执行顺序的&#34;&gt;CountDownLatch 是如何安排线程执行顺序的？&lt;/h3&gt;
&lt;h3 id=&#34;cyclicbarrier-和-countdownlatch-有什么异同&#34;&gt;CyclicBarrier 和 CountdownLatch 有什么异同？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的&lt;/li&gt;
&lt;li&gt;CountDownLatch 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。CyclicBarrier 参与的线程职责是一样的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;future-的主要功能是什么&#34;&gt;Future 的主要功能是什么？&lt;/h3&gt;
&lt;h3 id=&#34;hashmap-为什么是线程不安全的&#34;&gt;HashMap 为什么是线程不安全的？&lt;/h3&gt;
&lt;h3 id=&#34;jvm-中内存模型是怎样的哪些区域是线程安全的&#34;&gt;JVM 中内存模型是怎样的，哪些区域是线程安全的？&lt;/h3&gt;
&lt;h3 id=&#34;jvm-中内存模型是怎样的简述新生代与老年代的区别&#34;&gt;JVM 中内存模型是怎样的，简述新生代与老年代的区别？&lt;/h3&gt;
&lt;h3 id=&#34;jvm-对锁进行了哪些优化&#34;&gt;JVM 对锁进行了哪些优化？&lt;/h3&gt;
&lt;h3 id=&#34;java-8-中-adder-和-accumulator-有什么区别&#34;&gt;Java 8 中 Adder 和 Accumulator 有什么区别？&lt;/h3&gt;
&lt;h3 id=&#34;java-中的原子操作有哪些注意事项&#34;&gt;Java 中的原子操作有哪些注意事项？&lt;/h3&gt;
&lt;h3 id=&#34;lock-有哪几个常用方法分别有什么用&#34;&gt;Lock 有哪几个常用方法？分别有什么用？&lt;/h3&gt;
&lt;h3 id=&#34;threadlocal-是用来解决共享资源的多线程访问的问题吗&#34;&gt;ThreadLocal 是用来解决共享资源的多线程访问的问题吗？&lt;/h3&gt;
&lt;h3 id=&#34;threadlocal-适合用在哪些实际生产的场景中&#34;&gt;ThreadLocal 适合用在哪些实际生产的场景中？&lt;/h3&gt;
&lt;h3 id=&#34;final-的三种用法是什么&#34;&gt;final 的三种用法是什么？&lt;/h3&gt;
&lt;h3 id=&#34;hashmap-17--18-的实现区别-1&#34;&gt;hashMap 1.7 / 1.8 的实现区别&lt;/h3&gt;
&lt;h3 id=&#34;synchronized-和-lock-孰优孰劣如何选择&#34;&gt;synchronized 和 Lock 孰优孰劣，如何选择？&lt;/h3&gt;
&lt;h3 id=&#34;volatile-的作用是什么与-synchronized-有什么异同&#34;&gt;volatile 的作用是什么？与 synchronized 有什么异同？&lt;/h3&gt;
&lt;h3 id=&#34;wait-notify-notifyall-方法的使用注意事项&#34;&gt;wait notify notifyAll 方法的使用注意事项？&lt;/h3&gt;
&lt;h3 id=&#34;一共有哪几种类线程安全问题&#34;&gt;一共有哪几种类线程安全问题？&lt;/h3&gt;
&lt;h3 id=&#34;为什么-map-桶中超过-8-个才转为红黑树&#34;&gt;为什么 Map 桶中超过 8 个才转为红黑树？&lt;/h3&gt;
&lt;h3 id=&#34;为什么-string-被设计为是不可变的&#34;&gt;为什么 String 被设计为是不可变的？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;字符串常量&lt;/li&gt;
&lt;li&gt;用作 HashMap 的 key&lt;/li&gt;
&lt;li&gt;天然线程安全&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么不应该自动创建线程池&#34;&gt;为什么不应该自动创建线程池？&lt;/h3&gt;
&lt;h3 id=&#34;为什么加了-final-却依然无法拥有不变性&#34;&gt;为什么加了 final 却依然无法拥有“不变性”？&lt;/h3&gt;
&lt;h3 id=&#34;为什么多线程会带来性能问题&#34;&gt;为什么多线程会带来性能问题？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;调度开销：上下文切换&lt;/li&gt;
&lt;li&gt;缓存失效：线程在不同 CPU 上执行，导致 CPU 缓存失效&lt;/li&gt;
&lt;li&gt;协作开销：线程之间共享数据，为了数据一致性，不得不把数据刷回主存再读回来&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么需要-aqsaqs-的作用和重要性是什么&#34;&gt;为什么需要 AQS？AQS 的作用和重要性是什么？&lt;/h3&gt;
&lt;h3 id=&#34;主内存和工作内存的关系&#34;&gt;主内存和工作内存的关系？&lt;/h3&gt;
&lt;h3 id=&#34;什么情况下会发生死锁如何解决死锁&#34;&gt;什么情况下会发生死锁，如何解决死锁？&lt;/h3&gt;
&lt;h3 id=&#34;什么是-happens-before-规则&#34;&gt;什么是 happens-before 规则？&lt;/h3&gt;
&lt;h3 id=&#34;什么是内存可见性问题&#34;&gt;什么是“内存可见性”问题？&lt;/h3&gt;
&lt;h3 id=&#34;什么是指令重排序为什么要重排序&#34;&gt;什么是指令重排序？为什么要重排序？&lt;/h3&gt;
&lt;h3 id=&#34;什么是自旋锁自旋的好处和后果是什么呢&#34;&gt;什么是自旋锁？自旋的好处和后果是什么呢？&lt;/h3&gt;
&lt;h3 id=&#34;什么是阻塞队列&#34;&gt;什么是阻塞队列？&lt;/h3&gt;
&lt;h3 id=&#34;你知道什么是-cas-吗&#34;&gt;你知道什么是 CAS 吗？&lt;/h3&gt;
&lt;h3 id=&#34;你知道哪几种锁分别有什么特点&#34;&gt;你知道哪几种锁？分别有什么特点？&lt;/h3&gt;
&lt;h3 id=&#34;使用-future-有哪些注意点future-产生新的线程了吗&#34;&gt;使用 Future 有哪些注意点？Future 产生新的线程了吗？&lt;/h3&gt;
&lt;h3 id=&#34;使用线程池比手动创建线程好在哪里&#34;&gt;使用线程池比手动创建线程好在哪里？&lt;/h3&gt;
&lt;h3 id=&#34;信号量能被-fixedthreadpool-替代吗&#34;&gt;信号量能被 FixedThreadPool 替代吗？&lt;/h3&gt;
&lt;h3 id=&#34;内存泄漏为何每次用完-threadlocal-都要调用-remove&#34;&gt;内存泄漏——为何每次用完 ThreadLocal 都要调用 remove()？&lt;/h3&gt;
&lt;h3 id=&#34;单例模式的双重检查锁模式为什么必须加-volatile&#34;&gt;单例模式的双重检查锁模式为什么必须加 volatile？&lt;/h3&gt;
&lt;h3 id=&#34;原子类和-volatile-有什么异同&#34;&gt;原子类和 volatile 有什么异同？&lt;/h3&gt;
&lt;h3 id=&#34;原子类是如何利用-cas-保证线程安全的&#34;&gt;原子类是如何利用 CAS 保证线程安全的？&lt;/h3&gt;
&lt;h3 id=&#34;发生死锁必须满足哪-4-个条件&#34;&gt;发生死锁必须满足哪 4 个条件？&lt;/h3&gt;
&lt;h3 id=&#34;合适的线程数量是多少cpu-核心数和线程数的关系&#34;&gt;合适的线程数量是多少？CPU 核心数和线程数的关系？&lt;/h3&gt;
&lt;h3 id=&#34;同样是线程安全concurrenthashmap-和-hashtable-的区别&#34;&gt;同样是线程安全，ConcurrentHashMap 和 Hashtable 的区别&lt;/h3&gt;
&lt;h3 id=&#34;哪些场景需要额外注意线程安全问题&#34;&gt;哪些场景需要额外注意线程安全问题？&lt;/h3&gt;
&lt;h3 id=&#34;多个-threadlocal-在-thread-中的-threadlocals-里是怎么存储的&#34;&gt;多个 ThreadLocal 在 Thread 中的 threadlocals 里是怎么存储的？&lt;/h3&gt;
&lt;h3 id=&#34;如何写一个必然死锁的例子&#34;&gt;如何写一个必然死锁的例子？&lt;/h3&gt;
&lt;h3 id=&#34;如何利用-completablefuture-实现旅游平台问题&#34;&gt;如何利用 CompletableFuture 实现“旅游平台”问题？&lt;/h3&gt;
&lt;h3 id=&#34;如何根据实际需要定制自己的线程池&#34;&gt;如何根据实际需要，定制自己的线程池？&lt;/h3&gt;
&lt;h3 id=&#34;如何正确停止线程为什么-volatile-标记位的停止方法是错误的&#34;&gt;如何正确停止线程？为什么 volatile 标记位的停止方法是错误的？&lt;/h3&gt;
&lt;h3 id=&#34;如何正确关闭线程池shutdown-和-shutdownnow-的区别&#34;&gt;如何正确关闭线程池？shutdown 和 shutdownNow 的区别？&lt;/h3&gt;
&lt;h3 id=&#34;如何用命令行和代码定位死锁&#34;&gt;如何用命令行和代码定位死锁？&lt;/h3&gt;
&lt;h3 id=&#34;如何看到-synchronized-背后的monitor-锁&#34;&gt;如何看到 synchronized 背后的“monitor 锁”？&lt;/h3&gt;
&lt;h3 id=&#34;如何选择适合自己的阻塞队列&#34;&gt;如何选择适合自己的阻塞队列？&lt;/h3&gt;
&lt;h3 id=&#34;实现线程的方法&#34;&gt;实现线程的方法？&lt;/h3&gt;
&lt;h3 id=&#34;悲观锁和乐观锁的本质是什么&#34;&gt;悲观锁和乐观锁的本质是什么？&lt;/h3&gt;
&lt;h3 id=&#34;有哪-6-种常见的线程池什么是-java8-的-forkjoinpool&#34;&gt;有哪 6 种常见的线程池？什么是 Java8 的 ForkJoinPool？&lt;/h3&gt;
&lt;h3 id=&#34;有哪些解决死锁问题的策略&#34;&gt;有哪些解决死锁问题的策略？&lt;/h3&gt;
&lt;h3 id=&#34;有哪几种实现生产者消费者模式的方法&#34;&gt;有哪几种实现生产者消费者模式的方法？&lt;/h3&gt;
&lt;h3 id=&#34;有哪几种常见的阻塞队列&#34;&gt;有哪几种常见的阻塞队列？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ArrayBlockingQueue:有界队列，其内部是用数组存储元素的，利用 ReentrantLock 实现线程安全。&lt;/li&gt;
&lt;li&gt;LinkedBlockingQueue:内部用链表实现的 BlockingQueue。如果我们不指定它的初始容量，那么它容量默认就为整型的最大值 Integer.MAX_VALUE，由于这个数非常大，我们通常不可能放入这么多的数据，所以 LinkedBlockingQueue 也被称作无界队列，代表它几乎没有界限。&lt;/li&gt;
&lt;li&gt;SynchronousQueue:它的容量为 0，所以没有一个地方来暂存元素，导致每次取数据都要先阻塞，直到有数据被放入；同理，每次放数据的时候也会阻塞，直到有消费者来取。&lt;/li&gt;
&lt;li&gt;PriorityBlockingQueue:PriorityBlockingQueue 是一个支持优先级的无界阻塞队列，可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。同时，插入队列的对象必须是可比较大小的，也就是 Comparable 的，否则会抛出 ClassCastException 异常。它的 take 方法在队列为空的时候会阻塞，但是正因为它是无界队列，而且会自动扩容，所以它的队列永远不会满，所以它的 put 方法永远不会阻塞，添加操作始终都会成功，也正因为如此，它的成员变量里只有一个 Condition：&lt;/li&gt;
&lt;li&gt;DelayQueue:具有“延迟”的功能。我们可以设定让队列中的任务延迟多久之后执行，比如 10 秒钟之后执行，这在例如“30 分钟后未付款自动取消订单”等需要延迟执行的场景中被大量使用。它是无界队列，放入的元素必须实现 Delayed 接口，而 Delayed 接口又继承了 Comparable 接口，所以自然就拥有了比较和排序的能力&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简单介绍-mybatismybatis-是如何实现-orm-映射的-1&#34;&gt;简单介绍 mybatis，mybatis 是如何实现 ORM 映射的&lt;/h3&gt;
&lt;h3 id=&#34;简述-gc-引用链g1-收集器原理&#34;&gt;简述 GC 引用链，G1 收集器原理&lt;/h3&gt;
&lt;p&gt;final 修饰变量：一旦被赋值就不能被修改了
final 修饰方法：被 final 修饰的方法不可以被重写，不能被 override
final 修饰类：不能被继承&lt;/p&gt;
&lt;h3 id=&#34;简述-web-socket-与-http-的使用场景-1&#34;&gt;简述 Web socket 与 Http 的使用场景&lt;/h3&gt;
&lt;h3 id=&#34;简述-thread-和-runable-区别&#34;&gt;简述 thread 和 runable 区别&lt;/h3&gt;
&lt;h3 id=&#34;简述封装继承多态的特性及使用场景-1&#34;&gt;简述封装、继承、多态的特性及使用场景？&lt;/h3&gt;
&lt;h3 id=&#34;线程是如何在-6-种状态之间转换的&#34;&gt;线程是如何在 6 种状态之间转换的？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/NNL4TSl.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;线程池实现线程复用的原理&#34;&gt;线程池实现“线程复用”的原理？&lt;/h3&gt;
&lt;p&gt;线程池可以把线程和任务进行解耦，线程归线程，任务归任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制。在线程池中，同一个线程可以从 BlockingQueue 中不断提取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中，不停地检查是否还有任务等待被执行，如果有则直接去执行这个任务，也就是调用任务的 run 方法，把 run 方法当作和普通方法一样的地位去调用，相当于把每个任务的 run() 方法串联了起来，所以线程数量并不增加。&lt;/p&gt;
&lt;h3 id=&#34;线程池常用的阻塞队列有哪些&#34;&gt;线程池常用的阻塞队列有哪些？&lt;/h3&gt;
&lt;h3 id=&#34;线程池有哪-4-种拒绝策略&#34;&gt;线程池有哪 4 种拒绝策略？&lt;/h3&gt;
&lt;h3 id=&#34;线程池的各个参数的含义&#34;&gt;线程池的各个参数的含义？&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数名&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;corePoolSize&lt;/td&gt;
&lt;td&gt;核心线程数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;maxPoolSize&lt;/td&gt;
&lt;td&gt;最大线程数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;keepAliveTime + 时间单位&lt;/td&gt;
&lt;td&gt;空闲线程的存活时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ThreadFactory&lt;/td&gt;
&lt;td&gt;线程工厂、用来创建新线程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;workQueue&lt;/td&gt;
&lt;td&gt;用于存放任务的队列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Handler&lt;/td&gt;
&lt;td&gt;处理被拒绝的任务&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;讲一讲什么是-java-内存模型&#34;&gt;讲一讲什么是 Java 内存模型？&lt;/h3&gt;
&lt;h3 id=&#34;讲一讲公平锁和非公平锁为什么要非公平&#34;&gt;讲一讲公平锁和非公平锁，为什么要“非公平”？&lt;/h3&gt;
&lt;h3 id=&#34;讲一讲经典的哲学家就餐问题&#34;&gt;讲一讲经典的哲学家就餐问题&lt;/h3&gt;
&lt;h3 id=&#34;读写锁-readwritelock-获取锁有哪些规则&#34;&gt;读写锁 ReadWriteLock 获取锁有哪些规则？&lt;/h3&gt;
&lt;h3 id=&#34;读锁应该插队吗什么是读写锁的升降级&#34;&gt;读锁应该插队吗？什么是读写锁的升降级？&lt;/h3&gt;
&lt;h3 id=&#34;阻塞和非阻塞队列的并发安全原理是什么&#34;&gt;阻塞和非阻塞队列的并发安全原理是什么？&lt;/h3&gt;
&lt;h3 id=&#34;阻塞队列包含哪些常用的方法addofferput-等方法的区别&#34;&gt;阻塞队列包含哪些常用的方法？add、offer、put 等方法的区别？&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>编程::现代操作系统</title>
      <link>/notes/modern_operating_systems/</link>
      <pubDate>Sat, 24 Jul 2021 19:12:26 +0800</pubDate>
      <guid>/notes/modern_operating_systems/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_introduction&#34;&gt;现代操作系统::引论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_process_and_thread&#34;&gt;现代操作系统::进程与线程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_memory_manage&#34;&gt;现代操作系统::内存管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_file_system&#34;&gt;现代操作系统::文件系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_input_output&#34;&gt;现代操作系统::输入/输出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_deadlock&#34;&gt;现代操作系统::死锁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_virtualization_and_the_cloud&#34;&gt;现代操作系统::虚拟化与云&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_multiple_processor_systems&#34;&gt;现代操作系统::多处理器系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_security&#34;&gt;现代操作系统::系统安全&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/modern_operating_systems_operating_system_design&#34;&gt;现代操作系统::操作系统设计&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编程::计算机网络自顶向下方法</title>
      <link>/notes/computer_network_a_topdown_approach/</link>
      <pubDate>Thu, 24 Jun 2021 19:27:56 +0800</pubDate>
      <guid>/notes/computer_network_a_topdown_approach/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;../../notes/computer_network_a_topdown_approach_01&#34;&gt;计算机网络自顶向下方法::计算机网络和因特网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/computer_network_a_topdown_approach_02&#34;&gt;计算机网络自顶向下方法::应用层&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/computer_network_a_topdown_approach_03&#34;&gt;计算机网络自顶向下方法::运输层&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/computer_network_a_topdown_approach_04&#34;&gt;计算机网络自顶向下方法::网络层::数据平面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/computer_network_a_topdown_approach_05&#34;&gt;计算机网络自顶向下方法::网络层::控制平面&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编程::深入理解Java虚拟机</title>
      <link>/notes/understand_the_jvm/</link>
      <pubDate>Sat, 24 Apr 2021 19:12:26 +0800</pubDate>
      <guid>/notes/understand_the_jvm/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_01/&#34;&gt;深入理解 Java 虚拟机::走进 Java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_02/&#34;&gt;深入理解 Java 虚拟机::自动内存管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_03/&#34;&gt;深入理解 Java 虚拟机::垃圾收集器与内存分配策略&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_04/&#34;&gt;深入理解 Java 虚拟机::虚拟机性能监控、故障处理工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_05/&#34;&gt;深入理解 Java 虚拟机::调优案例分析与实战&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_06/&#34;&gt;深入理解 Java 虚拟机::类文件结构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_07/&#34;&gt;深入理解 Java 虚拟机::虚拟机类加载机制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_08/&#34;&gt;深入理解 Java 虚拟机::虚拟机字节码执行引擎&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_09/&#34;&gt;深入理解 Java 虚拟机::类加载及执行子系统的案例与实战&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_10/&#34;&gt;深入理解 Java 虚拟机::前段编译与优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_11/&#34;&gt;深入理解 Java 虚拟机::后端编译与优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_12/&#34;&gt;深入理解 Java 虚拟机::Java 内存模型与线程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/understand_the_jvm_13/&#34;&gt;深入理解 Java 虚拟机::线程安全和锁优化&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编程::数据密集型应用系统设计</title>
      <link>/notes/ddia/</link>
      <pubDate>Wed, 24 Mar 2021 19:27:56 +0800</pubDate>
      <guid>/notes/ddia/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;../../notes/designing_data_intensive_application_foundations_of_data_systems&#34;&gt;数据密集型应用系统设计::数据系统基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/designing_data_intensive_application_distributed_data&#34;&gt;数据密集型应用系统设计::分布式数据系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../../notes/designing_data_intensive_application_derived_data&#34;&gt;数据密集型应用系统设计::派生数据&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>系统设计::从零到一百万</title>
      <link>/notes/system_design_interview_01/</link>
      <pubDate>Mon, 01 Feb 2021 22:20:24 +0800</pubDate>
      <guid>/notes/system_design_interview_01/</guid>
      <description>&lt;h2 id=&#34;从零到一百万&#34;&gt;从零到一百万&lt;/h2&gt;
&lt;p&gt;设计一个支持数百万用户的系统是一个挑战，这是一个需要不断完善和无止境改进的历程。在本章中，我们将构建一个支持单个用户的系统，并逐步将其扩展到服务数百万用户。读完本章，你将掌握一手的技巧，帮助你破解系统设计的面试题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单服务器设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;千里之行始于足下，构建一个复杂的系统也不例外。先从简单的东西开始，所有的东西都运行在一台服务器上。图 1-1 是单服务器设置的说明，所有的东西都在一台服务器上运行：Web 应用、数据库、缓存等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-6_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;为了理解这种设置，研究一下请求流程和流量来源是很有帮助的。我们先来看看请求流程（图 1-2）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-6_2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户通过域名访问网站，如 api.mysite.com。通常，域名系统（DNS）是由第三方提供的付费服务，而不是由我们的服务器托管。&lt;/li&gt;
&lt;li&gt;互联网协议（IP）地址返回给浏览器或移动应用。在本例中，返回的 IP 地址为 15.125.23.214。&lt;/li&gt;
&lt;li&gt;获得 IP 地址后，超文本传输协议（HTTP）[1]请求直接发送到您的网络服务器。&lt;/li&gt;
&lt;li&gt;Web 服务器返回 HTML 页面或 JSON 响应进行渲染。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来，我们来看看流量来源。你的 Web 服务器的流量来自两个方面：Web 应用和移动应用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web 应用：它使用服务器端语言（Java、Python 等）组合来处理业务逻辑、存储等，使用客户端语言（HTML 和 JavaScript）来进行展示。&lt;/li&gt;
&lt;li&gt;移动应用。HTTP 协议是移动应用与 Web 服务器之间的通信协议。JavaScript 对象符号（JSON）由于其简单性，是常用的 API 响应格式来传输数据。JSON 格式的 API 响应示例如下所示。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;firstName&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;John&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;lastName&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;Smith&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;address&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;streetAddress&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;21 2nd street&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;city&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;New York&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;state&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;NY&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;postal Code&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10021&lt;/span&gt;
  &lt;span style=&#34;color:#111&#34;&gt;},&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;phoneNumbers&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#111&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;212 555-1234&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;646 555-4567&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;]&lt;/span&gt;
&lt;span style=&#34;color:#111&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;GET /users/12 – Retrieve user object for id = 12&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着用户群的增长，一台服务器是不够的，我们需要多台服务器：一台用于 web/移动流量，另一台用于数据库（图 1-3）。将 web/移动流量（web 层）和数据库（数据层）服务器分开，可以让它们独立扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-8_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用哪种数据库?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以选择传统的关系型数据库和非关系型数据库。让我们来看看它们的区别。&lt;/p&gt;
&lt;p&gt;关系型数据库也叫关系型数据库管理系统（RDBMS）或 SQL 数据库。最流行的有 MySQL、Oracle 数据库、PostgreSQL 等。关系型数据库以表和行来表示和存储数据。你可以在不同的数据库表之间使用 SQL 进行连接操作。&lt;/p&gt;
&lt;p&gt;非关系型数据库也叫 NoSQL 数据库。常用的有 CouchDB、Neo4j、Cassandra、HBase、Amazon DynamoDB 等。[2]. 这些数据库分为四类：键值存储、图存储、列存储和文档存储。在非关系型数据库中，一般不支持 Join 操作。&lt;/p&gt;
&lt;p&gt;对于大多数开发人员来说，关系型数据库是最好的选择，因为关系型数据库已经存在了 40 多年，而且从历史上看，关系型数据库运行良好。然而，如果关系型数据库不适合你的特定用例，那么探索关系型数据库之外的东西是至关重要的。在以下情况下，非关系型数据库可能是正确的选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你的应用需要超低的延迟&lt;/li&gt;
&lt;li&gt;你的数据是非结构化的，或者你没有任何关系型数据。&lt;/li&gt;
&lt;li&gt;你只需要序列化和反序列化数据（JSON、XML、YAML 等）。&lt;/li&gt;
&lt;li&gt;你需要存储大量的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;垂直扩展与水平扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;垂直扩展，简称为 &amp;ldquo;扩容&amp;rdquo;，指的是为服务器增加更多功率（CPU、RAM 等）的过程。&lt;/p&gt;
&lt;p&gt;水平扩展，称为 &amp;ldquo;scale-out&amp;rdquo;，允许您通过向资源池中添加更多的服务器来扩展。&lt;/p&gt;
&lt;p&gt;当流量较低时，垂直扩展是一个很好的选择，垂直扩展的简单性是其主要优势。不幸的是，它有严重的局限性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垂直扩展有一个硬件限制。不可能在一台服务器上增加无限的 CPU 和内存。&lt;/li&gt;
&lt;li&gt;垂直扩展没有故障转移和冗余。如果一台服务器出现故障，网站/应用也会随之完全瘫痪。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于垂直扩展的局限性，水平扩展对于大规模的应用更为理想。
在之前的设计中，用户是直接连接到网站服务器的。如果 Web 服务器离线，用户将无法访问网站。在另一种情况下，如果很多用户同时访问 Web 服务器，达到了 Web 服务器的负载极限，用户一般会出现响应速度较慢或无法连接到服务器的情况。负载均衡是解决这些问题的最佳技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载均衡将传入的流量均匀地分配给定义在负载均衡集群中的 Web 服务器。图 1-4 显示了负载均衡器的工作原理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-10_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图 1-4 所示，用户直接连接到负载均衡器的公网 IP。通过这种设置，Web 服务器已经无法被客户端直接访问了。为了提高安全性，服务器之间的通信采用私有 IP。私有 IP 是指只有同一网络中的服务器之间才能到达的 IP 地址，但是，通过互联网是无法到达的。负载均衡器通过私有 IP 与 Web 服务器进行通信。&lt;/p&gt;
&lt;p&gt;在图 1-4 中，增加了一个负载均衡器和第二台 Web 服务器后，我们成功解决了无故障切换问题，提高了 Web 层的可用性。下面将详细说明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果服务器 1 离线，所有的流量将被路由到服务器 2。这样可以防止网站离线。我们也会在服务器池中增加一个新的健康网站服务器来平衡负载。&lt;/li&gt;
&lt;li&gt;如果网站流量快速增长，两台服务器不足以处理流量，负载均衡器可以优雅地处理这个问题。你只需要向 Web 服务器池添加更多的服务器，负载平衡器就会自动开始向它们发送请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在 web 层看起来不错，那数据层呢？目前的设计只有一个数据库，所以它不支持故障转移和冗余。数据库复制是解决这些问题的一个常用技术。让我们来看看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库复制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引自维基百科。&amp;ldquo;数据库复制可用于许多数据库管理系统，通常原始数据库(主数据库)和副本(从数据库)之间存在主/从关系&amp;rdquo;[3]。&lt;/p&gt;
&lt;p&gt;主数据库一般只支持写操作。从数据库从主数据库获取数据的副本，只支持读操作。所有的插入、删除、更新等数据修改命令都必须发送到主数据库。大多数应用对读与写的比例要求更高，因此，系统中从数据库的数量通常大于主数据库的数量。图 1-5 显示了一个主数据库与多个从数据库的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-12_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库复制的优势&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能更好。在主从模式中，所有写入和更新都发生在主节点上；而读操作则分布在从节点上。这种模式可以提高性能，因为它允许并行处理更多的查询。&lt;/li&gt;
&lt;li&gt;可靠性。如果你的一个数据库服务器被自然灾害摧毁，如台风或地震，数据仍然会被保存下来。您不必担心数据丢失，因为数据是在多个地点复制的。&lt;/li&gt;
&lt;li&gt;高可用性。通过在不同地点复制数据，即使数据库离线，您的网站仍然可以运行，因为您可以访问存储在另一个数据库服务器的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上一节中，我们讨论了负载均衡器如何帮助提高系统的可用性。我们在这里提出同样的问题：如果其中一个数据库离线了怎么办？图 1-5 中讨论的架构设计可以处理这种情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果只有一个从数据库可用，而它又脱机了，读操作将被暂时导向主数据库。一旦发现问题，新的从数据库将取代旧的数据库。如果有多个从数据库可用，读取操作将被重定向到其他健康的从数据库。新的数据库服务器将取代旧的数据库。&lt;/li&gt;
&lt;li&gt;如果主数据库下线，一个从数据库将被提升为新的主数据库。所有的数据库操作将暂时在新的主数据库上执行。新的从数据库将立即取代旧的数据库进行数据复制。在生产系统中，推广新的主数据库比较复杂，因为从数据库中的数据可能不是最新的。缺少的数据需要通过运行数据恢复脚本来更新。虽然其他一些复制方法，如多主站和循环复制可以帮助我们，但这些设置比较复杂；而且它们的讨论也超出了本书的范围。有兴趣的读者可以参考列出的参考资料[4][5]。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图 1-6 是增加负载均衡器和数据库复制后的系统设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-14_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们来看一下设计。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户从 DNS 获取负载均衡器的 IP 地址。&lt;/li&gt;
&lt;li&gt;用户用这个 IP 地址连接负载均衡器。&lt;/li&gt;
&lt;li&gt;HTTP 请求被路由到服务器 1 或服务器 2。&lt;/li&gt;
&lt;li&gt;Web 服务器从从属数据库读取用户数据。&lt;/li&gt;
&lt;li&gt;Web 服务器将任何数据修改操作路由到主数据库。这包括写入、更新和删除操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，你已经对网络和数据层有了坚实的了解，是时候提高加载/响应时间了。这可以通过添加缓存层和将静态内容（JavaScript/CSS/图片/视频文件）转移到内容传输网络（CDN）来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缓存是一个临时的存储区域，它将昂贵的响应结果或频繁访问的数据存储在内存中，以便后续的请求能够更快地得到服务。如图 1-6 所示，每次加载新的网页时，都会执行一次或多次数据库调用来获取数据。由于反复调用数据库，应用性能受到很大影响。缓存可以缓解这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缓存层是一个临时的数据存储层，比数据库快得多。单独设置缓存层的好处包括更好的系统性能，能够减少数据库的工作负载，以及能够独立地扩展缓存层。图 1-7 显示了一个缓存服务器的可能设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-15_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在收到请求后，Web 服务器首先检查缓存是否有可用的响应。如果有，它就把数据发回给客户端。如果没有，它就查询数据库，将响应存储在缓存中，然后再发回给客户端。这种缓存策略称为读通式缓存。根据数据类型、大小和访问模式，还有其他缓存策略可供选择。之前的一项研究解释了不同缓存策略的工作原理[6]。&lt;/p&gt;
&lt;p&gt;与缓存服务器的交互很简单，因为大多数缓存服务器都提供了通用编程语言的 API。下面的代码片段展示了典型的 Memcached API。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#75af00&#34;&gt;SECONDS&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#75af00&#34;&gt;cache&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;set&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;myKey&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;hi there&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3600&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#75af00&#34;&gt;SECONDS&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#75af00&#34;&gt;cache&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#75af00&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#d88200&#34;&gt;&amp;#34;myKey&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;使用缓存的注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下是使用缓存系统的几个注意事项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;决定何时使用缓存。当数据经常被读取但不经常被修改时，考虑使用缓存。由于缓存数据存储在易失性内存中，因此缓存服务器并不是持久化数据的理想选择。例如，如果缓存服务器重新启动，内存中的所有数据都会丢失。因此，重要的数据应该保存在持久化数据存储中。&lt;/li&gt;
&lt;li&gt;过期策略。实施过期策略是一个很好的做法。一旦缓存数据过期，它就会从缓存中删除。当没有过期策略时，缓存数据将永久保存在内存中。建议不要把过期日期定得太短，否则会导致系统过于频繁地从数据库中重新加载数据。同时，建议不要把有效期做得太长，因为数据会变得陈旧。&lt;/li&gt;
&lt;li&gt;一致性。这涉及到保持数据存储和缓存的同步。由于对数据存储和缓存的数据修改操作不在一个事务中，所以会发生不一致的情况。当跨多个区域扩展时，保持数据存储和缓存之间的一致性是一个挑战。更多细节，请参考 Facebook 发布的题为 &amp;ldquo;Scaling Memcache at Facebook &amp;ldquo;的论文[7]。&lt;/li&gt;
&lt;li&gt;缓解故障。单个缓存服务器代表了一个潜在的单点故障（SPOF），在维基百科中的定义如下。&amp;ldquo;单点故障(SPOF)是指系统的一部分，如果它发生故障，将使整个系统停止工作&amp;rdquo;[8]。因此，建议在不同的数据中心设置多台缓存服务器，以避免 SPOF 的发生。另一种推荐的方法是按一定的百分比超额提供所需的内存。这样可以在内存使用量增加时提供一个缓冲区。&lt;/li&gt;
&lt;li&gt;驱逐政策。一旦缓存满了，任何向缓存添加项目的请求都可能导致现有项目被删除。这就是所谓的缓存驱逐。最少最近使用（LRU）是最流行的缓存驱逐策略。其他的驱逐策略，如最不常用(LFU)或先进先出(FIFO)，可以满足不同的用例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-16_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内容传输网络(CDN)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CDN 是一个由地理上分散的服务器组成的网络，用于传输静态内容。CDN 服务器缓存静态内容，如图片、视频、CSS、JavaScript 文件等。&lt;/p&gt;
&lt;p&gt;动态内容缓存是一个比较新的概念，超出了本书的范围。它可以实现基于请求路径、查询字符串、Cookie 和请求头的 HTML 页面的缓存。关于这方面的内容，请参考参考资料[9]中提到的文章。本书主要介绍如何使用 CDN 来缓存静态内容。&lt;/p&gt;
&lt;p&gt;下面是 CDN 的顶层工作原理：当用户访问一个网站时，离用户最近的 CDN 服务器将提供静态内容。直观地说，用户离 CDN 服务器越远，网站的加载速度越慢。例如，如果 CDN 服务器在旧金山，那么洛杉矶的用户将比欧洲的用户更快地获得内容。图 1-9 是一个很好的例子，它显示了 CDN 如何改善加载时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-17_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;图 1-10 展示了 CDN 的工作流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-17_2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户 A 试图通过图片 URL 获取 image.png。该 URL 的域名由 CDN 提供商提供。以下两个图片 URL 是用来演示 Amazon 和 Akamai CDN 上的图片 URL 的示例。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mysite.cloudfront.net/logo.jpg&#34;&gt;https://mysite.cloudfront.net/logo.jpg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mysite.akamai.com/image-manager/img/logo.jpg&#34;&gt;https://mysite.akamai.com/image-manager/img/logo.jpg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果 CDN 服务器的缓存中没有 image.png，CDN 服务器就会向原点请求该文件，这个原点可以是 Web 服务器，也可以是 Amazon S3 等在线存储。&lt;/li&gt;
&lt;li&gt;原点将 image.png 返回给 CDN 服务器，其中包括可选的 HTTP 头 Time-to-Live（TTL），它描述了图像被缓存的时间。&lt;/li&gt;
&lt;li&gt;CDN 缓存图像并将其返回给用户 A，图像一直在 CDN 中缓存，直到 TTL 过期。&lt;/li&gt;
&lt;li&gt;用户 B 发送一个请求来获取相同的图像。&lt;/li&gt;
&lt;li&gt;只要 TTL 没有过期，图像就会从缓存中返回。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;使用 CDN 的注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;费用。CDN 由第三方供应商运营，您需要为进出 CDN 的数据传输付费。缓存不经常使用的资产并不能提供显著的好处，所以你应该考虑将它们移出 CDN。&lt;/li&gt;
&lt;li&gt;设置一个合适的缓存到期时间。对于时间敏感的内容，设置一个缓存到期时间很重要。缓存到期时间既不能太长也不能太短。如果太长，内容可能过期。如果太短，可能会导致从源服务器到 CDN 的内容重复重载。&lt;/li&gt;
&lt;li&gt;CDN 回源。你应该考虑你的网站/应用如何应对 CDN 故障。如果 CDN 出现临时中断，客户端应该能够检测到问题，并从源服务器请求资源。&lt;/li&gt;
&lt;li&gt;使文件无效。您可以通过执行以下操作之一，在文件过期前从 CDN 中删除文件。
&lt;ul&gt;
&lt;li&gt;使用 CDN 供应商提供的 API 使 CDN 对象无效。&lt;/li&gt;
&lt;li&gt;使用对象版本化来服务对象的不同版本。要对对象进行版本管理，可以在 URL 中添加一个参数，例如版本号。例如，在查询字符串中添加版本号 2：image.png?v=2。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图 1-11 是添加 CDN 和缓存后的设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-19_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态资产（JS、CSS、图片等）不再由 Web 服务器提供服务。它们从 CDN 获取，以获得更好的性能。&lt;/li&gt;
&lt;li&gt;通过缓存数据，减轻了数据库的负载。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;无状态 Web 层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在是时候考虑横向扩展 Web 层了。为此，我们需要将状态（例如用户会话数据）移出 web 层。一个好的做法是将会话数据存储在持久性存储中，如关系型数据库或 NoSQL。集群中的每个 Web 服务器都可以从数据库中访问状态数据。这就是所谓的无状态 Web 层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有状态架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有状态服务器和无状态服务器有一些关键的区别。有状态的服务器会记住客户的数据（状态），从一个请求到下一个请求。无状态服务器不保留状态信息。&lt;/p&gt;
&lt;p&gt;图 1-12 显示了一个有状态架构的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-20_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在图 1-12 中，用户 A 的会话数据和配置文件图像存储在服务器 1 中。要对用户 A 进行身份验证，HTTP 请求必须路由到服务器 1。如果向服务器 2 等其他服务器发送请求，认证将失败，因为服务器 2 不包含用户 A 的会话数据。同样，所有来自用户 B 的 HTTP 请求必须路由到服务器 2；所有来自用户 C 的请求必须发送到服务器 3。&lt;/p&gt;
&lt;p&gt;问题是来自同一客户端的每个请求都必须路由到同一个服务器。这可以通过大多数负载均衡器中的粘性会话来实现[10]；然而，这增加了开销。使用这种方法增加或删除服务器要困难得多。处理服务器故障也是一个挑战。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无状态结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图 1-13 为无状态架构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-21_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在这种无状态架构中，用户的 HTTP 请求可以发送到任何 Web 服务器上，服务器从共享数据存储中获取状态数据。状态数据存储在共享数据存储中，不受 Web 服务器的影响。无状态系统更简单、更健壮、可扩展。&lt;/p&gt;
&lt;p&gt;图 1-14 为无状态网络层的更新设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-22_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在图 1-14 中，我们将会话数据从 Web 层移出，并将其存储在持久化数据存储中。共享数据存储可以是关系型数据库、Memcached/Redis、NoSQL 等。选择 NoSQL 数据存储是因为它易于扩展。自动伸缩是指根据流量负载自动增加或删除 Web 服务器。当状态数据从 web 服务器中取出后，根据流量负载增加或删除服务器，就可以轻松实现 web 层的自动伸缩。&lt;/p&gt;
&lt;p&gt;您的网站发展迅速，在国际上吸引了大量的用户。为了提高可用性，并在更广泛的地域提供更好的用户体验，支持多个数据中心至关重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据中心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图 1-15 是一个有两个数据中心的设置实例。在正常运行中，用户会被 geoDNS-routed，也就是地理路由，到最近的数据中心，美东地区的流量分成 x%，美西地区的流量分成(100 - x)%，geoDNS 是一种 DNS 服务，可以根据用户的位置将域名解析到 IP 地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-23_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在任何重大的数据中心中断的情况下，我们将所有的流量引导到一个健康的数据中心。在图 1-16 中，数据中心 2（US-West）处于离线状态，100%的流量被引导到数据中心 1（US-East）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-24_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;要实现多数据中心的设置，必须解决几个技术难题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流量重定向。需要有效的工具来引导流量到正确的数据中心。GeoDNS 可以根据用户所在的位置，将流量引导到最近的数据中心。&lt;/li&gt;
&lt;li&gt;数据同步。来自不同地区的用户可能使用不同的本地数据库或缓存。在故障转移情况下，流量可能会被路由到数据不可用的数据中心。一个常见的策略是在多个数据中心之间复制数据。之前的一项研究展示了 Netflix 如何实现异步多数据中心复制[11]。&lt;/li&gt;
&lt;li&gt;测试和部署。对于多数据中心的设置，在不同的位置测试你的网站/应用是很重要的。自动部署工具对于在所有数据中心保持服务的一致性至关重要[11]。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了进一步扩展我们的系统，我们需要对系统的不同组件进行解耦，以便它们可以独立地进行扩展。消息队列是许多现实世界的分布式系统采用的一个关键策略，以解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;消息队列是一个持久的组件，存储在内存中，支持异步通信。它作为一个缓冲区，分发异步请求。消息队列的基本架构很简单。输入服务，称为生产者/发布者，创建消息，并将它们发布到消息队列中。其他服务或服务器，称为消费者/订阅者，连接到队列，并执行由消息定义的操作。该模型如图 1-17 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-25_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;解耦使得消息队列成为构建可扩展和可靠应用的首选架构。通过消息队列，当消费者无法处理消息时，生产者可以将消息发布到队列中。即使在生产者不可用时，消费者也可以从队列中读取消息。&lt;/p&gt;
&lt;p&gt;考虑以下用例：你的应用程序支持照片定制，包括裁剪、锐化、模糊等。这些定制任务需要时间来完成。在图 1-18 中，Web 服务器将照片处理作业发布到消息队列中。照片处理工作者从消息队列中接取作业，并异步执行照片定制任务。生产者和消费者可以独立伸缩。当队列的规模变大时，会增加更多的工人以减少处理时间。但是，如果队列大部分时间是空的，可以减少工人的数量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-25_2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记录、指标、自动化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当与一个在少数服务器上运行的小型网站合作时，日志，指标和自动化支持是良好的实践，但不是必需品。然而，现在你的网站已经成长为服务于一个大型企业，投资于这些工具是必不可少的。&lt;/p&gt;
&lt;p&gt;日志记录。监控错误日志很重要，因为它有助于识别系统中的错误和问题。您可以在每个服务器级别监控错误日志，或者使用工具将它们汇总到一个集中的服务，以便于搜索和查看。&lt;/p&gt;
&lt;p&gt;指标。收集不同类型的指标有助于我们获得业务洞察力，了解系统的健康状况。以下一些指标是有用的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主机级指标： CPU、内存、磁盘 I/O 等。&lt;/li&gt;
&lt;li&gt;汇总级指标：例如，整个数据库层、缓存层的性能等。&lt;/li&gt;
&lt;li&gt;关键业务指标：日活跃用户、留存率、收入等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自动化。当一个系统变得庞大而复杂时，我们需要建立或利用自动化工具来提高生产力。持续集成是一个很好的实践，通过自动化来验证每一个代码的签入，让团队及早发现问题。此外，将构建、测试、部署等过程自动化，可以显著提高开发人员的生产力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加消息队列和不同的工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图 1-19 为更新后的设计。由于篇幅所限，图中只显示了一个数据中心。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设计中加入了消息队列，这有助于使系统更加松散耦合和故障恢复能力。&lt;/li&gt;
&lt;li&gt;包含了日志、监控、指标和自动化工具。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-27_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;随着数据每天的增长，你的数据库会越来越过载。是时候扩大数据层的规模了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库的扩展有两大方法：垂直扩展和水平扩展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;垂直扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;垂直扩展，也叫扩大规模，就是通过给现有的机器增加更多的功率（CPU、RAM、DISK 等）来进行扩展。有一些强大的数据库服务器。根据 Amazon Relational Database Service(RDS)[12]，你可以得到一个 24TB 内存的数据库服务器。这种强大的数据库服务器可以存储和处理大量的数据。例如，stackoverflow.com 在 2013 年有超过 1000 万的月度独立访客，但它只有 1 个主数据库[13]。然而，垂直扩展也有一些严重的缺点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你可以在数据库服务器上增加更多的 CPU、RAM 等，但有硬件限制。如果你有大量的用户群，单台服务器是不够的。&lt;/li&gt;
&lt;li&gt;单点故障的风险较大。&lt;/li&gt;
&lt;li&gt;垂直扩展的整体成本很高。强大的服务器要贵得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;水平扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;水平扩展，也称为 sharding，是增加更多服务器的做法。图 1- 20 比较了垂直扩展和水平扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-28_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Sharding 将大型数据库分离成更小、更容易管理的部分，称为 shard。每个分片共享相同的模式，尽管每个分片上的实际数据对该分片来说是独一无二的。&lt;/p&gt;
&lt;p&gt;图 1-21 显示了一个分片数据库的例子。用户数据是根据用户 ID 分配到数据库服务器上的。任何时候访问数据时，都会使用一个哈希函数来找到相应的分片。在我们的例子中，user_id % 4 被用作哈希函数。如果结果等于 0，则 0 号分片被用来存储和获取数据。如果结果等于 1，则使用分片 1。同样的逻辑也适用于其他分片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-29_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;图 1-22 是分片数据库中的用户表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-29_2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在实施分区策略时，需要考虑的最重要因素是分区密钥的选择。分区键（称为分区键）由一列或多列组成，决定数据的分布方式。如图 1-22 所示，&amp;ldquo;user_id &amp;ldquo;就是 sharding 键。通过 sharding 键，可以将数据库查询路由到正确的数据库，从而有效地检索和修改数据。在选择 sharding 键时，最重要的一个标准是选择一个能够均匀分布数据的键。&lt;/p&gt;
&lt;p&gt;Sharding 是一种很好的扩展数据库的技术，但它远不是一个完美的解决方案。它给系统带来了复杂性和新的挑战。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重置数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在以下情况下需要重新 sharding 数据：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于快速增长，单个分片无法再容纳更多的数据。&lt;/li&gt;
&lt;li&gt;由于数据分布不均，某些分片可能比其他分片更快地出现分片耗尽。当分片耗尽时，需要更新 sharding 函数，并移动数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第 5 章将讨论的一致性哈希是解决这个问题的常用技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;名人问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这也被称为热点问题。对特定分片的过度访问可能导致服务器过载。想象一下，Katy Perry、Justin Bieber 和 Lady Gaga 的数据最终都会出现在同一个分片上。对于社交应用来说，该分片将因读取操作而不堪重负。为了解决这个问题，我们可能需要为每个名人分配一个 shard。每个分片甚至可能需要进一步分区。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用和去范式化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦一个数据库被分片到多个服务器上 就很难在不同的数据库分片之间进行连接操作了一个常见的变通方法是对数据库进行去范式化，这样就可以在一张表中进行查询。&lt;/p&gt;
&lt;p&gt;在图 1-23 中，我们对数据库进行分片，以支持快速增加的数据流量。同时，将一些非关系型功能转移到 NoSQL 数据存储中，以减少数据库负载。这里有一篇文章，涵盖了 NoSQL 的很多用例[14]。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-31_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数百万用户及以上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;扩展系统是一个迭代的过程。迭代我们在本章所学到的知识可以让我们走得更远。要想扩展到数百万用户以上，还需要更多的微调和新的策略。例如，你可能需要优化你的系统，并将系统解耦到更小的服务。本章所学到的所有技术都应该为应对新的挑战打下良好的基础。在本章的最后，我们将对我们如何扩展系统以支持数百万用户进行总结。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持网络层无状态&lt;/li&gt;
&lt;li&gt;在每一层建立冗余&lt;/li&gt;
&lt;li&gt;尽可能多地缓存数据&lt;/li&gt;
&lt;li&gt;支持多个数据中心&lt;/li&gt;
&lt;li&gt;在 CDN 中托管静态资产&lt;/li&gt;
&lt;li&gt;通过分区来扩展您的数据层&lt;/li&gt;
&lt;li&gt;将层级划分为个别服务&lt;/li&gt;
&lt;li&gt;监控您的系统并使用自动化工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;恭喜你走到这一步！现在给自己拍拍背。做得好！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol&#34;&gt;[1] Hypertext Transfer Protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.teamtreehouse.com/should-you-go-beyond-relational-databases&#34;&gt;[2] Should you go Beyond Relational Databases?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Replication_(computing)&#34;&gt;[3] Replication&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Multi-master_replication&#34;&gt;[4] Multi-master replication&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster-replication-multi-master.html&#34;&gt;[5] NDB Cluster Replication: Multi-Master and Circular Replication&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/&#34;&gt;[6] Caching Strategies and How to Choose the Right One&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf&#34;&gt;[7] Scaling Memcache at Facebook &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Single_point_of_failure&#34;&gt;[8] Single point of failure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/cloudfront/dynamic-content/&#34;&gt;[9] Amazon CloudFront Dynamic Content Delivery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-sticky-sessions.html&#34;&gt;[10] Configure Sticky Sessions for Your Classic Load Balancer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://netflixtechblog.com/active-active-for-multi-regional-resiliency-c47719f6685b&#34;&gt;[11] Active-Active for Multi-Regional Resiliency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/ec2/instance-types/high-memory/&#34;&gt;[12] Amazon EC2 High Memory Instances&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nickcraver.com/blog/2013/11/22/what-it-takes-to-run-stack-overflow&#34;&gt;[13] What it takes to run Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://highscalability.com/blog/2010/12/6/what-the-heck-are-you-actually-using-nosql-for.html&#34;&gt;[14] What The Heck Are You Actually Using NoSQL For&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;粗略估算&#34;&gt;粗略估算&lt;/h2&gt;
&lt;p&gt;在系统设计面试中，有时会要求你评估系统容量或性能要求。根据 Google 高级研究员 Jeff Dean 的说法，&amp;ldquo;back-of-the-envelope calculations are estimates you create using a combination of thought experiments and common performance numbers to get a good feel for which designs will meet your requirements&amp;rdquo;[1]。&lt;/p&gt;
&lt;p&gt;你需要对扩展性基础知识有很好的认识，才能有效地进行评估。以下概念应该很好地理解：2 的幂[2]，每个程序员都应该知道的延迟，以及可用性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 的幂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然在处理分布式系统时，数据量可能会变得巨大，但计算都要归结为基本要素。为了获得正确的计算，了解使用 2 的幂的数据量单位是非常关键的。 一个字节是一个 8 位的序列，一个 ASCII 字符使用一个字节的内存（8 位）。一个 ASCII 字符使用一个字节的内存（8 位）。下面是解释数据量单位的表格（表 2-1）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-35_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个程序员都应该知道的延迟数字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来自 Google 的 Dean 博士展示了 2010 年典型的计算机操作所需的时间[1]。随着计算机的速度越来越快，功能越来越强大，有些数字已经过时了。不过，这些数字应该还是能够让我们了解不同计算机操作的快慢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-36_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Notes &amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/p&gt;
&lt;p&gt;ns = nanosecond&lt;/p&gt;
&lt;p&gt;μs = microsecond&lt;/p&gt;
&lt;p&gt;ms = millisecond&lt;/p&gt;
&lt;p&gt;1 ns = 10^-9 seconds&lt;/p&gt;
&lt;p&gt;1 μs= 10^-6 seconds = 1,000 ns&lt;/p&gt;
&lt;p&gt;1 ms = 10^-3 seconds = 1,000 μs = 1,000,000 ns&lt;/p&gt;
&lt;p&gt;谷歌的一位软件工程师打造了一个工具，将 Dr.Dean 的数据可视化。该工具还考虑了时间因素。图 2-1 是截至 2020 年的可视化延迟数据（数据来源：参考资料[3]）。&lt;/p&gt;
&lt;p&gt;通过分析图 2-1 中的数字，我们得到以下结论。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存快，但磁盘慢。&lt;/li&gt;
&lt;li&gt;尽可能避免磁盘寻道。&lt;/li&gt;
&lt;li&gt;简单的压缩算法速度快。&lt;/li&gt;
&lt;li&gt;如果可能的话，先压缩数据再通过互联网发送。&lt;/li&gt;
&lt;li&gt;数据中心通常在不同的地区，在不同地区之间发送数据需要时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-37_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可用性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高可用性是指一个系统在理想的长时间内连续运行的能力。高可用性是以百分比来衡量的，100%意味着服务的停机时间为 0。大多数服务介于 99%和 100%之间。&lt;/p&gt;
&lt;p&gt;服务水平协议（SLA）是服务提供商常用的术语。这是你（服务提供商）和客户之间的协议，这个协议正式定义了你的服务将提供的正常运行时间水平。云提供商亚马逊[4]、谷歌[5]和微软[6]将其 SLA 设定在 99.9%或以上。正常运行时间传统上是以 9 为单位来衡量的。9 越多，越好。如表 2-3 所示，9 次方的数量与预期的系统停机时间相关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-38_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;案例：估计 Twitter 的 QPS 和存储需求&lt;/p&gt;
&lt;p&gt;请注意，以下数字仅用于本练习，因为它们不是来自 Twitter 的真实数字。
假设。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3 亿月活跃用户。&lt;/li&gt;
&lt;li&gt;50%的用户每天使用 Twitter。&lt;/li&gt;
&lt;li&gt;用户平均每天发布 2 条推文。&lt;/li&gt;
&lt;li&gt;10%的推文包含媒体。&lt;/li&gt;
&lt;li&gt;数据存储 5 年。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;估计。
查询每秒（QPS）估计。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日活跃用户（DAU）=3 亿 * 50% = 1.5 亿&lt;/li&gt;
&lt;li&gt;推文 QPS = 1.5 亿 * 2 条推文 / 24 小时 / 3600 秒 = ~3500&lt;/li&gt;
&lt;li&gt;峰值 QPS = 2 * QPS = ~7000&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们在这里只估算媒体存储量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平均推文大小。
&lt;ul&gt;
&lt;li&gt;tweet_id 64 bytes&lt;/li&gt;
&lt;li&gt;text 140 bytes&lt;/li&gt;
&lt;li&gt;media 1MB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Media storage:1.5 亿 * 2 * 10% * 1MB = 30TB per day&lt;/li&gt;
&lt;li&gt;5 year media storage:30TB * 365l* 5 = ~55PB。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技巧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;估算是关于过程的。解决问题比获得结果更重要。面试官可能会测试你解决问题的能力。这里有几个技巧可以遵循。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;四舍五入和近似。在面试时，很难进行复杂的数学运算。例如，&amp;ldquo;99987 / 9.1 &amp;ldquo;的结果是什么？没有必要花费宝贵的时间去解决复杂的数学问题。不要求精确。利用四舍五入和近似值来发挥你的优势。除法题可以简化如下。“100,000 / 10”.&lt;/li&gt;
&lt;li&gt;写下你的假设。最好写下你的假设，以便以后参考。&lt;/li&gt;
&lt;li&gt;给你的单位贴上标签。当你写下 &amp;ldquo;5 &amp;ldquo;时，是指 5 KB 还是 5 MB？你可能会把自己搞混。写下单位，因为 &amp;ldquo;5 MB &amp;ldquo;有助于消除歧义。&lt;/li&gt;
&lt;li&gt;常见的问题包络后面的估计。QPS，峰值 QPS，存储，缓存，服务器数量等。你可以在准备面试的时候练习这些计算方法。熟能生巧。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;恭喜你走到这一步! 现在给自己拍拍背。做得很好!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html&#34;&gt;[1] J. Dean.Google Pro Tip: Use Back-Of-The-Envelope-Calculations To Choose The Best Design:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/donnemartin/system-design-primer&#34;&gt;[2] System design primer:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://colin-scott.github.io/personal_website/research/interactive_latency.html&#34;&gt;[3] Latency Numbers Every Programmer Should Know:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/compute/sla/&#34;&gt;[4] Amazon Compute Service Level Agreement:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/compute/sla&#34;&gt;[5] Compute Engine Service Level Agreement (SLA):&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/en-us/support/legal/sla/summary/&#34;&gt;[6] SLA summary for Azure services:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;系统设计面试框架&#34;&gt;系统设计面试框架&lt;/h2&gt;
&lt;p&gt;你刚刚获得了梦寐以求的公司的现场面试机会。招聘协调人给你发来了当天的日程安排。扫视了一下名单，你感觉还不错，直到你的目光落在这个面试环节上&amp;ndash;系统设计面试。&lt;/p&gt;
&lt;p&gt;系统设计面试往往让人望而生畏。它可能是模糊的，比如 &amp;ldquo;设计一个知名的产品 X？&amp;quot;。问题模棱两可，显得不合理宽泛。你的疲惫是可以理解的。毕竟，怎么可能有人在一个小时内设计出一个受欢迎的产品，而这个产品却花了几百甚至上千名工程师的时间来打造？&lt;/p&gt;
&lt;p&gt;好消息是，没有人指望你这样做。现实世界的系统设计是极其复杂的。例如，谷歌搜索是具有欺骗性的简单；然而，支撑这种简单的技术量确实令人吃惊。如果没有人指望你在一个小时内设计出一个真实世界的系统，那么系统设计面试有什么好处呢？&lt;/p&gt;
&lt;p&gt;系统设计面试模拟现实生活中的问题解决，两个同事合作解决一个模棱两可的问题，并提出一个符合自己目标的解决方案。这个问题是开放式的，没有完美的答案。与你在设计过程中所付出的努力相比，最终的设计并不那么重要。这可以让你展示你的设计技巧，捍卫你的设计选择，并以建设性的方式回应反馈。&lt;/p&gt;
&lt;p&gt;让我们翻开桌子，考虑一下当面试官走进会议室与你见面时，她的脑子里会想些什么。面试官的首要目标是准确评估你的能力。她最不希望的就是因为会议进行得不顺利，信号不足而给出一个不确定的评价。系统设计面试中，面试官要看什么？&lt;/p&gt;
&lt;p&gt;很多人认为系统设计面试就是看一个人的技术设计能力。它的意义远不止于此。一个有效的系统设计面试能给人强烈的信号，包括一个人的协作能力，在压力下工作的能力，以及建设性地解决模糊问题的能力。提出好问题的能力也是一项基本技能，许多面试官特别看重这项技能。&lt;/p&gt;
&lt;p&gt;一个好的面试官还会寻找危险信号。过度设计是很多工程师的真病，因为他们乐于设计的纯粹性，而忽略了权衡。他们往往不知道过度工程系统的复合成本，许多公司为这种无知付出了高昂的代价。你当然不希望在系统设计面试中表现出这种倾向。其他的危险信号还包括心胸狭窄、固执己见等。&lt;/p&gt;
&lt;p&gt;在本章中，我们将介绍一些有用的技巧，并介绍一个简单有效的框架来解决系统设计面试问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有效的系统设计面试四步曲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个系统设计面试都是不同的。一个优秀的系统设计面试是开放式的，没有一个放之四海而皆准的解决方案。但是，每一次系统设计面试都有一些步骤和共同点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步 了解问题，确定设计范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;为什么老虎会吼叫？&amp;rdquo;&lt;/p&gt;
&lt;p&gt;班级后面的同学们纷纷举手。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;是的，吉米？&amp;quot;，老师回应道。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;因为他饿了&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;很好，吉米&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;从小到大，吉米总是第一个在课堂上回答问题。每当老师提出问题时，教室里总有一个孩子喜欢抢答，不管他是否知道答案。他就是吉米。&lt;/p&gt;
&lt;p&gt;吉米是个王牌学生。他以快速知道所有答案为荣。在考试中，他通常是第一个做完题的人。他是老师在任何学术比赛中的首选。&lt;/p&gt;
&lt;p&gt;不要学吉米。&lt;/p&gt;
&lt;p&gt;在系统设计面试中，不假思索地快速给出答案，不会给你加分。在没有彻底了解需求的情况下回答，是一个巨大的危险信号，因为面试不是小题大做。没有正确的答案。&lt;/p&gt;
&lt;p&gt;所以，不要直接跳出来给出解决方案。放慢脚步。深入思考并提出问题，以澄清要求和假设。这一点极为重要。&lt;/p&gt;
&lt;p&gt;作为一名工程师，我们喜欢解决难点问题，然后跳到最终的设计中去；然而，这种方法很可能会导致你设计出错误的系统。作为工程师，最重要的技能之一就是提出正确的问题，做出正确的假设，并收集构建系统所需的所有信息。所以，不要害怕提问。&lt;/p&gt;
&lt;p&gt;当你提出问题时，面试官要么直接回答你的问题，要么要求你做出你的假设。如果是后者，就把你的假设写在白板或纸上。你以后可能会用到它们。&lt;/p&gt;
&lt;p&gt;要问什么样的问题？提出问题以了解确切的要求。这里有一个问题列表，可以帮助你开始。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们要建立什么具体功能？&lt;/li&gt;
&lt;li&gt;产品有多少用户？&lt;/li&gt;
&lt;li&gt;公司预计多快扩大规模？3 个月、6 个月和一年后的预期规模是多少？&lt;/li&gt;
&lt;li&gt;公司的技术栈是什么？你可以利用哪些现有的服务来简化设计？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你被要求设计一个新闻源系统，你要问一些有助于你明确需求的问题。你和面试官之间的对话可能是这样的。&lt;/p&gt;
&lt;p&gt;候选人：这是一个移动应用吗？还是一个网络应用？还是两者都有？&lt;/p&gt;
&lt;p&gt;面试官：是的。都有。&lt;/p&gt;
&lt;p&gt;候选人：产品最重要的功能是什么？&lt;/p&gt;
&lt;p&gt;面试官：可以发帖，可以看到朋友的新闻源。&lt;/p&gt;
&lt;p&gt;候选人：新闻源的排序是按时间倒序还是按特定顺序？特定顺序是指每个帖子的权重不同。比如，好友的帖子比群里的帖子更重要。&lt;/p&gt;
&lt;p&gt;面试官：为了简单起见，我们假设是按时间倒序排列的。&lt;/p&gt;
&lt;p&gt;候选人：一个用户可以有多少个好友？&lt;/p&gt;
&lt;p&gt;面试官：5000&lt;/p&gt;
&lt;p&gt;候选人：流量是多少？&lt;/p&gt;
&lt;p&gt;面试官：1000 万日活跃用户(DAU)&lt;/p&gt;
&lt;p&gt;候选人：订阅可以包含图片、视频，还是只包含文字？&lt;/p&gt;
&lt;p&gt;面试官：可以。可以包含媒体文件，包括图片和视频。&lt;/p&gt;
&lt;p&gt;以上是一些示例问题，你可以向面试官提问。重要的是要了解要求，澄清歧义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第 2 步 提出高层次的设计方案，并获得认同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这一步骤中，我们的目标是制定一个高水平的设计，并与面试官就设计达成一致。在这个过程中，与面试官合作是个不错的主意。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提出设计的初步蓝图。征求反馈意见。把面试官当做队友，共同合作。很多优秀的面试官都喜欢聊天，参与其中。&lt;/li&gt;
&lt;li&gt;在白板或纸上画出关键组件的框图。这可能包括客户端（移动/网络）、API、网络服务器、数据存储、缓存、CDN、消息队列等。&lt;/li&gt;
&lt;li&gt;进行错略估算，评估你的蓝图是否符合规模限制。努力思考。在深入研究之前，与面试官沟通是否有必要进行粗略估算。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果可能的话，通过一些具体的用例。这将帮助你构筑高层设计的框架。这些用例也很可能帮助你发现你尚未考虑的边缘案例。&lt;/p&gt;
&lt;p&gt;我们是否应该在这里包括 API 端点和数据库模式？这取决于问题。对于像 &amp;ldquo;设计 Google 搜索引擎 &amp;ldquo;这样的大型设计问题，这就有点太低级了。对于像设计多人扑克游戏的后端这样的问题，这是一个公平的游戏。与你的面试官沟通。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们用 &amp;ldquo;设计一个新闻源系统 &amp;ldquo;来演示如何进行高层设计。这里不要求你了解系统的实际工作原理。所有的细节将在第 11 章解释。
在高层，设计分为两个流程：feed 发布和新闻源构建。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Feed 发布：当用户发布一个帖子时，相应的数据会被写入缓存/数据库，该帖子会被填充到朋友的新闻源中。&lt;/li&gt;
&lt;li&gt;新闻源构建：将好友的帖子按照时间倒序聚合起来，构建新闻源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图 3-1 和图 3-2 分别展示了 feed 发布和新闻源构建流程的高层设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-45_1.jpg&#34; alt=&#34;&#34;&gt;
&lt;img src=&#34;../../../system_design_interview/index-46_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步 深入设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这一步，你和你的面试官应该已经实现了以下目标。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就总体目标和功能范围达成一致&lt;/li&gt;
&lt;li&gt;勾画出整体设计的高层蓝图。&lt;/li&gt;
&lt;li&gt;获得面试官对高层设计的反馈意见。&lt;/li&gt;
&lt;li&gt;根据她的反馈，对深挖的重点领域有了一些初步的想法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你应与面试官一起确定架构中的组成部分并确定其优先级。值得强调的是，每次面试都是不同的。有时，面试官可能会给出暗示，她喜欢关注高层设计。有时，对于资深候选人的面试，可能会讨论系统性能特点，很可能会关注瓶颈和资源估算。在大多数情况下，面试官可能希望你挖掘一些系统组件的细节。对于短网址服务来说，深入研究将长 URL 转化为短 URL 的哈希函数设计是很有意思的。对于聊天系统来说，如何降低延迟和如何支持在线/离线状态是两个有趣的话题。&lt;/p&gt;
&lt;p&gt;时间管理是必不可少的，因为很容易被一些不能体现你能力的微小细节所迷惑。你必须要用信号来武装你的面试官。尽量不要&lt;/p&gt;
&lt;p&gt;以进入不必要的细节。例如，在系统设计面试中，详细谈论 Facebook feed 排名的 EdgeRank 算法并不理想，因为这需要很多宝贵的时间，而且不能证明你设计一个可扩展系统的能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;至此，我们已经讨论了新闻源系统的高层设计，面试官对你的方案很满意。接下来，我们将研究两个最重要的用例。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新闻源发布&lt;/li&gt;
&lt;li&gt;新闻源检索&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;图 3-3 和图 3-4 显示了两个用例的详细设计，这将在第 11 章中详细说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-48_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../system_design_interview/index-49_1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步 收尾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这最后一步，面试官可能会问你几个后续问题，或者让你自由讨论其他附加点。这里有几个方向可以遵循。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面试官可能希望你找出系统瓶颈，并讨论潜在的改进措施。永远不要说你的设计是完美的，没有什么可以改进的。总有一些东西可以改进。这是一个展示你的批判性思维和留下良好最终印象的好机会。&lt;/li&gt;
&lt;li&gt;给面试官总结一下你的设计可能是有用的。如果你提出了一些解决方案，这一点尤其重要。在漫长的会议之后，刷新面试官的记忆会很有帮助。&lt;/li&gt;
&lt;li&gt;错误案例（服务器故障、网络丢失等）是很有趣的话题。&lt;/li&gt;
&lt;li&gt;运营问题值得一提。如何监控指标和错误日志？如何推出系统？&lt;/li&gt;
&lt;li&gt;如何处理下一个规模曲线也是一个有趣的话题。例如，如果你目前的设计支持 100 万用户，那么你需要做哪些改变才能支持 1000 万用户？&lt;/li&gt;
&lt;li&gt;如果你有更多的时间，提出你需要的其他完善措施。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上所述，我们总结了一份 &amp;ldquo;注意事项&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;该做的事和不该做的事&lt;/p&gt;
&lt;p&gt;需要做的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总是要求明确。不要认为你的假设是正确的。&lt;/li&gt;
&lt;li&gt;理解问题的要求。&lt;/li&gt;
&lt;li&gt;既没有正确的答案，也没有最好的答案。为解决一个年轻的初创公司的问题而设计的解决方案与一个拥有数百万用户的成熟公司的解决方案是不同的。确保你了解需求。&lt;/li&gt;
&lt;li&gt;让面试官知道你在想什么。与你的面试官沟通。&lt;/li&gt;
&lt;li&gt;如果可能的话，建议多种方法。&lt;/li&gt;
&lt;li&gt;一旦你与面试官在蓝图上达成一致，就去了解每个组件的细节。先设计最关键的部分。&lt;/li&gt;
&lt;li&gt;跟面试官交流想法。一个好的面试官会把你当成队友来合作。&lt;/li&gt;
&lt;li&gt;永远不要放弃。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不要去做&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要对典型的面试问题毫无准备。&lt;/li&gt;
&lt;li&gt;不要在没有明确需求和假设的情况下就跳进一个解决方案。&lt;/li&gt;
&lt;li&gt;不要一开始就对单个组件进行太详细的介绍。先给出高层次的设计，然后再钻研。&lt;/li&gt;
&lt;li&gt;如果你被卡住了，不要犹豫，请你给予提示。&lt;/li&gt;
&lt;li&gt;再次，沟通。不要默默地思考。&lt;/li&gt;
&lt;li&gt;不要以为你给了设计，你的面试就结束了。在面试官说你完成之前，你还没有完成。尽早、经常询问反馈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一步的时间分配&lt;/p&gt;
&lt;p&gt;系统设计的面试题一般都是很宽泛的，45 分钟或者一个小时都不足以涵盖整个设计。时间管理是必不可少的。你应该在每个步骤上花多少时间？以下是一个非常粗略的关于 45 分钟面试环节中时间分配的指南。请记住这是一个粗略的估计，实际的时间分配取决于问题的范围和面试官的要求。&lt;/p&gt;
&lt;p&gt;第一步 了解问题并确定设计范围。3 - 10 分钟&lt;/p&gt;
&lt;p&gt;第二步 提出高层次的设计方案并获得认同： 10 - 15 分钟&lt;/p&gt;
&lt;p&gt;第三步 深入设计：10&amp;ndash;25 分钟&lt;/p&gt;
&lt;p&gt;第四步 收尾。3-5 分钟&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>