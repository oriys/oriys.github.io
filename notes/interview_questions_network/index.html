<!DOCTYPE html>
<html lang="en-us">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> 面试::八股文::网络 | Y.CH.Y</title>
  <link rel = 'canonical' href = '/notes/interview_questions_network/'>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="面试::八股文::网络" />
<meta property="og:description" content="网络 简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？ 三次握手流程
 第一次握手: 建立连接，客户端 A 发送 SYN = 1、随机产生 Seq = client_isn 的数据包到服务器 B，等待服务器确认。 第二次握手: 服务器 B 收到请求后确认联机(可以接受数据)，发起第二次握手请求，ACK = (A 的 Seq &#43; 1)、SYN = 1，随机产生 Seq = client_isn 的数据包到 A。 第三次握手: A 收到后检查 ACK 是否正确，若正确，A 会在发送确认包 ACK = 服务器 B 的 Seq &#43; 1、ACK = 1，服务器 B 收到后确认 Seq 值与 ACK 值，若正确，则建立连接。  四次挥手流程
 第一次挥手：TCP 发送一个 FIN(结束)标识，用来关闭客户到服务端的连接。 第二次挥手：服务端收到这个 FIN 标识，他发回一个 ACK(确认)标识，确认收到序号为收到序号&#43;1，和 SYN 一样，一个 FIN 将占用一个序号。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。（服务器端继续发送未发送完的数据） 第三次挥手：服务端发送一个 FIN(结束)标识到客户端，服务端关闭客户端的连接。 第四次挥手：客户端发送 ACK(确认)标识报文确认，并将确认的序号&#43;1，这样关闭完成。  为什么需要三次握手" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/notes/interview_questions_network/" /><meta property="article:section" content="notes" />
<meta property="article:published_time" content="2021-08-20T21:51:33+08:00" />
<meta property="article:modified_time" content="2021-08-20T21:51:33+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="面试::八股文::网络"/>
<meta name="twitter:description" content="网络 简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？ 三次握手流程
 第一次握手: 建立连接，客户端 A 发送 SYN = 1、随机产生 Seq = client_isn 的数据包到服务器 B，等待服务器确认。 第二次握手: 服务器 B 收到请求后确认联机(可以接受数据)，发起第二次握手请求，ACK = (A 的 Seq &#43; 1)、SYN = 1，随机产生 Seq = client_isn 的数据包到 A。 第三次握手: A 收到后检查 ACK 是否正确，若正确，A 会在发送确认包 ACK = 服务器 B 的 Seq &#43; 1、ACK = 1，服务器 B 收到后确认 Seq 值与 ACK 值，若正确，则建立连接。  四次挥手流程
 第一次挥手：TCP 发送一个 FIN(结束)标识，用来关闭客户到服务端的连接。 第二次挥手：服务端收到这个 FIN 标识，他发回一个 ACK(确认)标识，确认收到序号为收到序号&#43;1，和 SYN 一样，一个 FIN 将占用一个序号。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。（服务器端继续发送未发送完的数据） 第三次挥手：服务端发送一个 FIN(结束)标识到客户端，服务端关闭客户端的连接。 第四次挥手：客户端发送 ACK(确认)标识报文确认，并将确认的序号&#43;1，这样关闭完成。  为什么需要三次握手"/>

  
  
    
  
  
  <link rel="stylesheet" href="/css/styles.ace637160e3ee466ac48adf2107be5e9e0b7f168aff4b05023ac0c573f8200b3f1ced7d604b86d1b519cf620f8b1bc3c13abec114d6d055da6327e8e79ac3dfb.css" integrity="sha512-rOY3Fg4&#43;5GasSK3yEHvl6eC38Wiv9LBQI6wMVz&#43;CALPxztfWBLhtG1Gc9iD4sbw8E6vsEU1tBV2mMn6Oeaw9&#43;w=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="/images/favicon.ico" />

  
  
  
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-X1L70M4MM0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="/">
  
    <div id="logo" style="background-image: url(/images/logo.png)"></div>
  
  <div id="title">
    <h1>Y.CH.Y</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/reading">Reading</a></li>
      
        <li><a href="/leetcode">Leetcode</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <h2 id="网络">网络</h2>
<h3 id="简述-tcp-三次握手以及四次挥手的流程为什么需要三次握手以及四次挥手">简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？</h3>
<p>三次握手流程</p>
<ol>
<li>第一次握手: 建立连接，客户端 A 发送 SYN = 1、随机产生 Seq = client_isn 的数据包到服务器 B，等待服务器确认。</li>
<li>第二次握手: 服务器 B 收到请求后确认联机(可以接受数据)，发起第二次握手请求，ACK = (A 的 Seq + 1)、SYN = 1，随机产生 Seq = client_isn 的数据包到 A。</li>
<li>第三次握手: A 收到后检查 ACK 是否正确，若正确，A 会在发送确认包 ACK = 服务器 B 的 Seq + 1、ACK = 1，服务器 B 收到后确认 Seq 值与 ACK 值，若正确，则建立连接。</li>
</ol>
<p>四次挥手流程</p>
<ol>
<li>第一次挥手：TCP 发送一个 FIN(结束)标识，用来关闭客户到服务端的连接。</li>
<li>第二次挥手：服务端收到这个 FIN 标识，他发回一个 ACK(确认)标识，确认收到序号为收到序号+1，和 SYN 一样，一个 FIN 将占用一个序号。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。（服务器端继续发送未发送完的数据）</li>
<li>第三次挥手：服务端发送一个 FIN(结束)标识到客户端，服务端关闭客户端的连接。</li>
<li>第四次挥手：客户端发送 ACK(确认)标识报文确认，并将确认的序号+1，这样关闭完成。</li>
</ol>
<p>为什么需要三次握手</p>
<p><a href="https://datatracker.ietf.org/doc/html/rfc793">rfc793</a></p>
<blockquote>
<p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion</p>
</blockquote>
<p>为了防止旧重复连接初始化造成的混乱问题，导致服务器维护了无用的半连接。</p>
<p><img src="https://i.imgur.com/3rSeXxI.png" alt="img"></p>
<p>老的重传数据被当作新的数据接受。</p>
<p><img src="https://i.imgur.com/BJbiBqj.png" alt="img"></p>
<p>为什么需要四次挥手</p>
<p>因为 TCP 是全双工通信的</p>
<ul>
<li>第一次挥手：因此当主动方发送断开连接的请求（即 FIN 报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。</li>
<li>第二次挥手：被动方此时有可能还有相应的数据报文需要发送，因此需要先发送 ACK 报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即 FIN 报文）。</li>
<li>第三次挥手：被动方在处理完数据报文后，便发送给主动方 FIN 报文；这样可以保证数据通信正常可靠地完成。发送完 FIN 报文后，被动方进入 LAST_ACK 阶段（超时等待）。</li>
<li>第四挥手：如果主动方及时发送 ACK 报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。</li>
</ul>
<p>TCP 状态机</p>
<p><img src="https://i.imgur.com/Ir7sNdS.png" alt="img"></p>
<p>异常状况</p>
<p><a href="https://network.51cto.com/art/202002/610542.htm">TCP 三次握手、四次挥手出现意外情况时，如何保证稳定可靠？</a></p>
<h3 id="http-与-https-有哪些区别">HTTP 与 HTTPS 有哪些区别？</h3>
<h3 id="从输入-url-到展现页面的全过程">从输入 URL 到展现页面的全过程</h3>
<h3 id="tcp-与-udp-在网络协议中的哪一层他们之间有什么区别">TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？</h3>
<h3 id="tcp-怎么保证可靠传输">TCP 怎么保证可靠传输？</h3>
<ul>
<li>检验和；用于检测在一个传输分组中的比特错误</li>
<li>定时器：用于超时/重传一个分组，可能因为该分组〈或其 ACK) 在信道中丢失了。由于当一个分组延时但未丢失〈过早超时) ，或当一个分组已被接收方收到但从接收方到发送方的 ACK 丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余副本</li>
<li>序号：用于为从发送方流向接收方的数据分组按顺序编号。所接收分组的序号间的空隙可使接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余副本</li>
<li>确认：接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或累积的，这取决于协议</li>
<li>否定确认：接收方用于告诉发送方某个分组未被正确地接收。否定确认报文通常据带着未被正确接收的分组的序号</li>
<li>窗口、流水线：发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。我们很快将会看到，窗口长度可根据接收方接收和缓存报文的能力、网络中的拥塞程度或两者情况来进行设置</li>
</ul>
<h3 id="简述-http-101120-的主要区别">简述 HTTP 1.0，1.1，2.0 的主要区别</h3>
<h3 id="tcp-中常见的拥塞控制算法有哪些">TCP 中常见的拥塞控制算法有哪些？</h3>
<h3 id="dns-查询服务器的基本流程是什么dns-劫持是什么">DNS 查询服务器的基本流程是什么？DNS 劫持是什么？</h3>
<h3 id="cookie-和-session-的关系和区别是什么">Cookie 和 Session 的关系和区别是什么？</h3>
<h3 id="简述-https-的加密与认证过程">简述 HTTPS 的加密与认证过程</h3>
<h3 id="restful-是什么restful-请求的-url-有什么特点">RestFul 是什么？RestFul 请求的 URL 有什么特点？</h3>
<h3 id="什么是-tcp-粘包和拆包">什么是 TCP 粘包和拆包？</h3>
<h3 id="restful-与-rpc-的区别是什么restful-的优点在哪里">RestFul 与 RPC 的区别是什么？RestFul 的优点在哪里？</h3>
<h3 id="tcp-挥手时出现大量-close_wait-或-time_wait-怎么解决">TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？</h3>
<h3 id="什么是跨域什么情况下会发生跨域请求">什么是跨域，什么情况下会发生跨域请求？</h3>
<h3 id="简述对称与非对称加密的概念">简述对称与非对称加密的概念</h3>
<h3 id="http-中-get-和-post-区别">HTTP 中 GET 和 POST 区别</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody>
<tr>
<td>请求是否有主体</td>
<td>N(可以携带，是否处理取决于服务器)</td>
<td>Y</td>
</tr>
<tr>
<td>成功的响应是否有主体</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>安全</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>幂等</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>可缓存</td>
<td>Y</td>
<td>Y(带上有关刷新的信息)</td>
</tr>
<tr>
<td>HTML 表单是否支持</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody>
</table>
<p><a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.1">rfc7231</a></p>
<blockquote>
<p>A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.</p>
</blockquote>
<p>总而言之 RFC 只对 GET 和 POST 做了语义上的区别，他们的不同之处大多是浏览器行为</p>
<h3 id="tcp-的-keepalive-了解吗说一说它和-http-的-keepalive-的区别">TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？</h3>
<h3 id="简述常见的-http-状态码的含义301304401403">简述常见的 HTTP 状态码的含义（301，304，401，403）</h3>
<h3 id="简述-tcp-的-time_wait-和-close_wait">简述 TCP 的 TIME_WAIT 和 CLOSE_WAIT</h3>
<h3 id="简述-tcp-滑动窗口以及重传机制">简述 TCP 滑动窗口以及重传机制</h3>
<h3 id="简述-ddos-攻击原理如何防范它">简述 DDOS 攻击原理，如何防范它？</h3>
<h3 id="简述-osi-七层模型tcpip-属于哪一层">简述 OSI 七层模型，TCP，IP 属于哪一层？</h3>
<h3 id="从系统层面上udp-如何保证尽量可靠">从系统层面上，UDP 如何保证尽量可靠？</h3>
<h3 id="简述-jwt-的原理和校验机制">简述 JWT 的原理和校验机制</h3>
<h3 id="http-的方法有哪些">HTTP 的方法有哪些？</h3>
<h3 id="tcp-长连接和短连接有那么不同的使用场景">TCP 长连接和短连接有那么不同的使用场景？</h3>
<h3 id="什么是-arp-协议简述其使用场景">什么是 ARP 协议？简述其使用场景</h3>
<h3 id="简述-rpc-的调用过程">简述 RPC 的调用过程</h3>
<h3 id="tcp-中-syn-攻击是什么如何防止">TCP 中 SYN 攻击是什么？如何防止？</h3>
<h3 id="简述-tcp-的报文头部结构">简述 TCP 的报文头部结构</h3>
<h3 id="tcp-的拥塞控制具体是怎么实现的udp-有拥塞控制吗">TCP 的拥塞控制具体是怎么实现的？UDP 有拥塞控制吗？</h3>
<h3 id="什么是中间人攻击如何防止攻击">什么是中间人攻击？如何防止攻击？</h3>
<h3 id="简述什么是-xss-攻击以及-csrf-攻击">简述什么是 XSS 攻击以及 CSRF 攻击？</h3>
<h3 id="如何防止传输内容被篡改">如何防止传输内容被篡改？</h3>
<h3 id="如何设计-api-接口使其实现幂等性">如何设计 API 接口使其实现幂等性？</h3>
<h3 id="简述-bgp-协议和-ospf-协议的区别">简述 BGP 协议和 OSPF 协议的区别</h3>
<h3 id="http-是无状态的吗需要保持状态的场景应该怎么做">HTTP 是无状态的吗？需要保持状态的场景应该怎么做？</h3>
<h3 id="从系统层面上udp-如何保证尽量可靠-1">从系统层面上，UDP 如何保证尽量可靠？</h3>
<h3 id="简述-tcp-协议的延迟-ack-和累计应答">简述 TCP 协议的延迟 ACK 和累计应答</h3>
<h3 id="ssl-握手流程为什么要使用非对称秘钥">SSL 握手流程为什么要使用非对称秘钥？</h3>
<h3 id="简述-websocket-是如何进行传输的">简述 WebSocket 是如何进行传输的</h3>
<h3 id="traceroute-有什么作用">traceroute 有什么作用？</h3>
<h3 id="如何解决-tcp-传输丢包问题">如何解决 TCP 传输丢包问题？</h3>
<h3 id="简述-http-的-keepalive-的原理和使用场景">简述 HTTP 的 keepalive 的原理和使用场景</h3>
<h3 id="简述在四层和七层网络协议中负载均衡的原理">简述在四层和七层网络协议中负载均衡的原理</h3>
<h3 id="简述-tcp-半连接发生场景">简述 TCP 半连接发生场景</h3>
<h3 id="什么是-syn-flood如何防止这类攻击">什么是 SYN flood，如何防止这类攻击？</h3>
<h3 id="简述-http-报文头部的组成结构">简述 HTTP 报文头部的组成结构</h3>
<h3 id="为什么需要序列化有什么序列化的方式">为什么需要序列化？有什么序列化的方式？</h3>
<h3 id="tcp-如何实现数据有序性">TCP 如何实现数据有序性？</h3>
<h3 id="简述-http-短链接与长链接的区别">简述 HTTP 短链接与长链接的区别</h3>
<h3 id="简述-ipv4-和-ipv6-的区别">简述 iPv4 和 iPv6 的区别</h3>

  
  </div>
</article>


    <footer id="footer">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
  <div class="footer-left">
    Copyright  &copy; 2021  Y.CH.Y 
    
    
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">Home</a></li>
         
        <li><a href="/reading">Reading</a></li>
         
        <li><a href="/leetcode">Leetcode</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
