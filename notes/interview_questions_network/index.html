<!DOCTYPE html>
<html lang="en-us">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> 八股文::网络 | Y.CH.Y</title>
  <link rel = 'canonical' href = '/notes/interview_questions_network/'>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="八股文::网络" />
<meta property="og:description" content="网络 简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？ 三次握手流程
 第一次握手: 建立连接，客户端 A 发送 SYN = 1、随机产生 Seq = client_isn 的数据包到服务器 B，等待服务器确认。 第二次握手: 服务器 B 收到请求后确认联机(可以接受数据)，发起第二次握手请求，ACK = (A 的 Seq &#43; 1)、SYN = 1，随机产生 Seq = client_isn 的数据包到 A。 第三次握手: A 收到后检查 ACK 是否正确，若正确，A 会在发送确认包 ACK = 服务器 B 的 Seq &#43; 1、ACK = 1，服务器 B 收到后确认 Seq 值与 ACK 值，若正确，则建立连接。  四次挥手流程
 第一次挥手：TCP 发送一个 FIN(结束)标识，用来关闭客户到服务端的连接。 第二次挥手：服务端收到这个 FIN 标识，他发回一个 ACK(确认)标识，确认收到序号为收到序号&#43;1，和 SYN 一样，一个 FIN 将占用一个序号。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。（服务器端继续发送未发送完的数据） 第三次挥手：服务端发送一个 FIN(结束)标识到客户端，服务端关闭客户端的连接。 第四次挥手：客户端发送 ACK(确认)标识报文确认，并将确认的序号&#43;1，这样关闭完成。  为什么需要三次握手" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/notes/interview_questions_network/" /><meta property="article:section" content="notes" />
<meta property="article:published_time" content="2021-08-20T21:51:33+08:00" />
<meta property="article:modified_time" content="2021-08-20T21:51:33+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="八股文::网络"/>
<meta name="twitter:description" content="网络 简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？ 三次握手流程
 第一次握手: 建立连接，客户端 A 发送 SYN = 1、随机产生 Seq = client_isn 的数据包到服务器 B，等待服务器确认。 第二次握手: 服务器 B 收到请求后确认联机(可以接受数据)，发起第二次握手请求，ACK = (A 的 Seq &#43; 1)、SYN = 1，随机产生 Seq = client_isn 的数据包到 A。 第三次握手: A 收到后检查 ACK 是否正确，若正确，A 会在发送确认包 ACK = 服务器 B 的 Seq &#43; 1、ACK = 1，服务器 B 收到后确认 Seq 值与 ACK 值，若正确，则建立连接。  四次挥手流程
 第一次挥手：TCP 发送一个 FIN(结束)标识，用来关闭客户到服务端的连接。 第二次挥手：服务端收到这个 FIN 标识，他发回一个 ACK(确认)标识，确认收到序号为收到序号&#43;1，和 SYN 一样，一个 FIN 将占用一个序号。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。（服务器端继续发送未发送完的数据） 第三次挥手：服务端发送一个 FIN(结束)标识到客户端，服务端关闭客户端的连接。 第四次挥手：客户端发送 ACK(确认)标识报文确认，并将确认的序号&#43;1，这样关闭完成。  为什么需要三次握手"/>

  
  
    
  
  
  <link rel="stylesheet" href="/css/styles.ace637160e3ee466ac48adf2107be5e9e0b7f168aff4b05023ac0c573f8200b3f1ced7d604b86d1b519cf620f8b1bc3c13abec114d6d055da6327e8e79ac3dfb.css" integrity="sha512-rOY3Fg4&#43;5GasSK3yEHvl6eC38Wiv9LBQI6wMVz&#43;CALPxztfWBLhtG1Gc9iD4sbw8E6vsEU1tBV2mMn6Oeaw9&#43;w=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="/images/favicon.ico" />

  
  
  
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-X1L70M4MM0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="/">
  
    <div id="logo" style="background-image: url(/images/logo.png)"></div>
  
  <div id="title">
    <h1>Y.CH.Y</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/algorithm">算法</a></li>
      
        <li><a href="/outline">大纲</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <h2 id="网络">网络</h2>
<h3 id="简述-tcp-三次握手以及四次挥手的流程为什么需要三次握手以及四次挥手">简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？</h3>
<p>三次握手流程</p>
<ol>
<li>第一次握手: 建立连接，客户端 A 发送 SYN = 1、随机产生 Seq = client_isn 的数据包到服务器 B，等待服务器确认。</li>
<li>第二次握手: 服务器 B 收到请求后确认联机(可以接受数据)，发起第二次握手请求，ACK = (A 的 Seq + 1)、SYN = 1，随机产生 Seq = client_isn 的数据包到 A。</li>
<li>第三次握手: A 收到后检查 ACK 是否正确，若正确，A 会在发送确认包 ACK = 服务器 B 的 Seq + 1、ACK = 1，服务器 B 收到后确认 Seq 值与 ACK 值，若正确，则建立连接。</li>
</ol>
<p>四次挥手流程</p>
<ol>
<li>第一次挥手：TCP 发送一个 FIN(结束)标识，用来关闭客户到服务端的连接。</li>
<li>第二次挥手：服务端收到这个 FIN 标识，他发回一个 ACK(确认)标识，确认收到序号为收到序号+1，和 SYN 一样，一个 FIN 将占用一个序号。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。（服务器端继续发送未发送完的数据）</li>
<li>第三次挥手：服务端发送一个 FIN(结束)标识到客户端，服务端关闭客户端的连接。</li>
<li>第四次挥手：客户端发送 ACK(确认)标识报文确认，并将确认的序号+1，这样关闭完成。</li>
</ol>
<p>为什么需要三次握手</p>
<p><a href="https://datatracker.ietf.org/doc/html/rfc793">rfc793</a></p>
<blockquote>
<p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion</p>
</blockquote>
<p>为了防止旧重复连接初始化造成的混乱问题，导致服务器维护了无用的半连接。</p>
<p><img src="https://i.imgur.com/3rSeXxI.png" alt="img"></p>
<p>老的重传数据被当作新的数据接受。</p>
<p><img src="https://i.imgur.com/BJbiBqj.png" alt="img"></p>
<p>为什么需要四次挥手</p>
<p>因为 TCP 是全双工通信的</p>
<ul>
<li>第一次挥手：因此当主动方发送断开连接的请求（即 FIN 报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。</li>
<li>第二次挥手：被动方此时有可能还有相应的数据报文需要发送，因此需要先发送 ACK 报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即 FIN 报文）。</li>
<li>第三次挥手：被动方在处理完数据报文后，便发送给主动方 FIN 报文；这样可以保证数据通信正常可靠地完成。发送完 FIN 报文后，被动方进入 LAST_ACK 阶段（超时等待）。</li>
<li>第四挥手：如果主动方及时发送 ACK 报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。</li>
</ul>
<p>TCP 状态机</p>
<p><img src="https://i.imgur.com/Ir7sNdS.png" alt="img"></p>
<p>异常状况</p>
<p><a href="https://network.51cto.com/art/202002/610542.htm">TCP 三次握手、四次挥手出现意外情况时，如何保证稳定可靠？</a></p>
<h3 id="http-与-https-有哪些区别">HTTP 与 HTTPS 有哪些区别？</h3>
<h3 id="从输入-url-到展现页面的全过程">从输入 URL 到展现页面的全过程</h3>
<ul>
<li>输入地址</li>
<li>浏览器查找域名的 IP 地址</li>
<li>浏览器向 web 服务器发送一个 HTTP 请求</li>
<li>服务器的永久重定向响应</li>
<li>服务器处理请求</li>
<li>服务器返回一个 HTTP 响应</li>
<li>浏览器显示 HTML</li>
<li>浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS 等等）</li>
</ul>
<h3 id="tcp-与-udp-在网络协议中的哪一层他们之间有什么区别">TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？</h3>
<h3 id="tcp-怎么保证可靠传输">TCP 怎么保证可靠传输？</h3>
<ul>
<li>检验和；用于检测在一个传输分组中的比特错误</li>
<li>定时器：用于超时/重传一个分组，可能因为该分组〈或其 ACK) 在信道中丢失了。由于当一个分组延时但未丢失〈过早超时) ，或当一个分组已被接收方收到但从接收方到发送方的 ACK 丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余副本</li>
<li>序号：用于为从发送方流向接收方的数据分组按顺序编号。所接收分组的序号间的空隙可使接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余副本</li>
<li>确认：接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或累积的，这取决于协议</li>
<li>否定确认：接收方用于告诉发送方某个分组未被正确地接收。否定确认报文通常据带着未被正确接收的分组的序号</li>
<li>窗口、流水线：发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。我们很快将会看到，窗口长度可根据接收方接收和缓存报文的能力、网络中的拥塞程度或两者情况来进行设置</li>
</ul>
<h3 id="简述-http-101120-的主要区别">简述 HTTP 1.0，1.1，2.0 的主要区别</h3>
<ul>
<li>http1.0 特性
<ul>
<li>无状态：服务器不跟踪不记录请求过的状态
<ul>
<li>对于无状态的特性可以借助 cookie/session 机制来做身份认证和状态记录</li>
</ul>
</li>
<li>无连接：浏览器每次请求都需要建立 tcp 连接
<ul>
<li>无法复用连接:每次发送请求，都需要进行一次 tcp 连接（即 3 次握手 4 次挥手），使得网络的利用率非常低</li>
<li>队头阻塞:http1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的</li>
</ul>
</li>
</ul>
</li>
<li>http1.1 特性：
<ul>
<li>长连接：新增 Connection 字段，可以设置 keep-alive 值保持连接不断开,http1.1 默认保持长连接，数据传输完成保持 tcp 连接不断开,继续用这个通道传输数据</li>
<li>管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回</li>
<li>缓存处理：新增字段 cache-control</li>
<li>断点传输:在 Header 里两个参数实现的，客户端发请求时对应的是 Range 服务器端响应时对应的是 Content-Range</li>
</ul>
</li>
<li>http2.0 特性
<ul>
<li>二进制分帧:将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码</li>
<li>多路复用： 在共享 TCP 链接的基础上同时发送请求和响应，基于二进制分帧，在同一域名下所有访问都是从同一个 tcp 连接中走，http 消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来</li>
<li>头部压缩</li>
<li>服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求</li>
</ul>
</li>
</ul>
<h3 id="tcp-中常见的拥塞控制算法有哪些">TCP 中常见的拥塞控制算法有哪些？</h3>
<ul>
<li>
<p>Reno</p>
<ul>
<li>慢启动阶段思路是不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小，在没有出现丢包时每收到一个 ACK 就将拥塞窗口大小加一（单位是 MSS，最大单个报文段长度），每轮次发送窗口增加一倍，呈指数增长，若出现丢包，则将拥塞窗口减半，进入拥塞避免阶段；</li>
<li>当窗口达到慢启动阈值或出现丢包时，进入拥塞避免阶段，窗口每轮次加一，呈线性增长；当收到对一个报文的三个重复的 ACK 时，认为这个报文的下一个报文丢失了，进入快重传阶段，要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约 20%）而不要等到自己发送数据时捎带确认；</li>
<li>快重传完成后进入快恢复阶段，将慢启动阈值修改为当前拥塞窗口值的一半，同时拥塞窗口值等于慢启动阈值，然后进入拥塞避免阶段，重复上述过程。</li>
</ul>
</li>
<li>
<p>BBR</p>
</li>
<li>
<p>BBR 算法不将出现丢包或时延增加作为拥塞的信号，而是认为当网络上的数据包总量大于瓶颈链路带宽和时延的乘积时才出现了拥塞，所以 BBR 也称为基于拥塞的拥塞控制算法（Congestion-Based Congestion Control），其适用网络为高带宽、高时延、有一定丢包率的长肥网络，可以有效降低传输时延，并保证较高的吞吐量.</p>
</li>
</ul>
<p>BBR 算法周期性地探测网络的容量，交替测量一段时间内的带宽极大值和时延极小值，将其乘积作为作为拥塞窗口大小，使得拥塞窗口始的值始终与网络的容量保持一致。</p>
<p>所以 BBR 算法解决了两个比较主要的问题：</p>
<p>在有一定丢包率的网络链路上充分利用带宽。 适合高延迟、高带宽的网络链路。</p>
<p>降低网络链路上的 buffer 占用率，从而降低延迟。 适合慢速接入网络的用户。</p>
<ul>
<li>基于丢包的拥塞控制：将丢包视为出现拥塞，采取缓慢探测的方式，逐渐增大拥塞窗口，当出现丢包时，将拥塞窗口减小，如 Reno、Cubic 等。</li>
<li>基于时延的拥塞控制：将时延增加视为出现拥塞，延时增加时增大拥塞窗口，延时减小时减小拥塞窗口，如 Vegas、FastTCP 等。</li>
<li>基于链路容量的拥塞控制：实时测量网络带宽和时延，认为网络上报文总量大于带宽时延乘积时出现了拥塞，如 BBR。</li>
<li>基于学习的拥塞控制：没有特定的拥塞信号，而是借助评价函数，基于训练数据，使用机器学习的方法形成一个控制策略，如 Remy。</li>
</ul>
<h3 id="dns-查询服务器的基本流程是什么dns-劫持是什么">DNS 查询服务器的基本流程是什么？DNS 劫持是什么？</h3>
<h3 id="cookie-和-session-的关系和区别是什么">Cookie 和 Session 的关系和区别是什么？</h3>
<h3 id="简述-https-的加密与认证过程">简述 HTTPS 的加密与认证过程</h3>
<h3 id="restful-是什么restful-请求的-url-有什么特点">RestFul 是什么？RestFul 请求的 URL 有什么特点？</h3>
<h3 id="什么是-tcp-粘包和拆包">什么是 TCP 粘包和拆包？</h3>
<h3 id="restful-与-rpc-的区别是什么restful-的优点在哪里">RestFul 与 RPC 的区别是什么？RestFul 的优点在哪里？</h3>
<h3 id="tcp-挥手时出现大量-close_wait-或-time_wait-怎么解决">TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？</h3>
<h3 id="什么是跨域什么情况下会发生跨域请求">什么是跨域，什么情况下会发生跨域请求？</h3>
<h3 id="简述对称与非对称加密的概念">简述对称与非对称加密的概念</h3>
<h3 id="http-中-get-和-post-区别">HTTP 中 GET 和 POST 区别</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody>
<tr>
<td>请求是否有主体</td>
<td>N(可以携带，是否处理取决于服务器)</td>
<td>Y</td>
</tr>
<tr>
<td>成功的响应是否有主体</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>安全</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>幂等</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>可缓存</td>
<td>Y</td>
<td>Y(带上有关刷新的信息)</td>
</tr>
<tr>
<td>HTML 表单是否支持</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody>
</table>
<p><a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.1">rfc7231</a></p>
<blockquote>
<p>A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.</p>
</blockquote>
<p>总而言之 RFC 只对 GET 和 POST 做了语义上的区别，他们的不同之处大多是浏览器行为</p>
<h3 id="tcp-的-keepalive-了解吗说一说它和-http-的-keepalive-的区别">TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？</h3>
<h3 id="简述常见的-http-状态码的含义301304401403">简述常见的 HTTP 状态码的含义（301，304，401，403）</h3>
<h3 id="简述-tcp-的-time_wait-和-close_wait">简述 TCP 的 TIME_WAIT 和 CLOSE_WAIT</h3>
<h3 id="简述-tcp-滑动窗口以及重传机制">简述 TCP 滑动窗口以及重传机制</h3>
<h3 id="简述-ddos-攻击原理如何防范它">简述 DDOS 攻击原理，如何防范它？</h3>
<h3 id="简述-osi-七层模型tcpip-属于哪一层">简述 OSI 七层模型，TCP，IP 属于哪一层？</h3>
<h3 id="从系统层面上udp-如何保证尽量可靠">从系统层面上，UDP 如何保证尽量可靠？</h3>
<h3 id="简述-jwt-的原理和校验机制">简述 JWT 的原理和校验机制</h3>
<h3 id="http-的方法有哪些">HTTP 的方法有哪些？</h3>
<h3 id="tcp-长连接和短连接有那么不同的使用场景">TCP 长连接和短连接有那么不同的使用场景？</h3>
<h3 id="什么是-arp-协议简述其使用场景">什么是 ARP 协议？简述其使用场景</h3>
<h3 id="简述-rpc-的调用过程">简述 RPC 的调用过程</h3>
<p>Client 首先会调用本地的代理 Proxy</p>
<p>Client 端 Proxy 会按照协议（Protocol），将调用中传入的数据序列化成字节流。</p>
<p>之后 Client 会通过网络，将字节数据发送到 Server 端。</p>
<p>Server 端接收到字节数据之后，会按照协议进行反序列化，得到相应的请求信息。</p>
<p>Server 端 Proxy 会根据序列化后的请求信息，调用相应的业务逻辑。</p>
<p>Server 端业务逻辑的返回值，也会按照上述逻辑返回给 Client 端。</p>
<h3 id="tcp-中-syn-攻击是什么如何防止">TCP 中 SYN 攻击是什么？如何防止？</h3>
<h3 id="简述-tcp-的报文头部结构">简述 TCP 的报文头部结构</h3>
<h3 id="tcp-的拥塞控制具体是怎么实现的udp-有拥塞控制吗">TCP 的拥塞控制具体是怎么实现的？UDP 有拥塞控制吗？</h3>
<h3 id="什么是中间人攻击如何防止攻击">什么是中间人攻击？如何防止攻击？</h3>
<h3 id="简述什么是-xss-攻击以及-csrf-攻击">简述什么是 XSS 攻击以及 CSRF 攻击？</h3>
<h3 id="如何防止传输内容被篡改">如何防止传输内容被篡改？</h3>
<h3 id="如何设计-api-接口使其实现幂等性">如何设计 API 接口使其实现幂等性？</h3>
<h3 id="简述-bgp-协议和-ospf-协议的区别">简述 BGP 协议和 OSPF 协议的区别</h3>
<h3 id="http-是无状态的吗需要保持状态的场景应该怎么做">HTTP 是无状态的吗？需要保持状态的场景应该怎么做？</h3>
<h3 id="简述-tcp-协议的延迟-ack-和累计应答">简述 TCP 协议的延迟 ACK 和累计应答</h3>
<h3 id="ssl-握手流程为什么要使用非对称秘钥">SSL 握手流程为什么要使用非对称秘钥？</h3>
<h3 id="简述-websocket-是如何进行传输的">简述 WebSocket 是如何进行传输的</h3>
<h3 id="traceroute-有什么作用">traceroute 有什么作用？</h3>
<h3 id="如何解决-tcp-传输丢包问题">如何解决 TCP 传输丢包问题？</h3>
<h3 id="简述-http-的-keepalive-的原理和使用场景">简述 HTTP 的 keepalive 的原理和使用场景</h3>
<h3 id="简述在四层和七层网络协议中负载均衡的原理">简述在四层和七层网络协议中负载均衡的原理</h3>
<h3 id="简述-tcp-半连接发生场景">简述 TCP 半连接发生场景</h3>
<h3 id="什么是-syn-flood如何防止这类攻击">什么是 SYN flood，如何防止这类攻击？</h3>
<h3 id="简述-http-报文头部的组成结构">简述 HTTP 报文头部的组成结构</h3>
<h3 id="为什么需要序列化有什么序列化的方式">为什么需要序列化？有什么序列化的方式？</h3>
<h3 id="tcp-如何实现数据有序性">TCP 如何实现数据有序性？</h3>
<h3 id="简述-http-短链接与长链接的区别">简述 HTTP 短链接与长链接的区别</h3>
<h3 id="简述-ipv4-和-ipv6-的区别">简述 iPv4 和 iPv6 的区别</h3>

  
  </div>
</article>


    <footer id="footer">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
  <div class="footer-left">
    Copyright  &copy; 2021  Y.CH.Y 
    
    
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">首页</a></li>
         
        <li><a href="/algorithm">算法</a></li>
         
        <li><a href="/outline">大纲</a></li>
         
        <li><a href="/about">关于</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
