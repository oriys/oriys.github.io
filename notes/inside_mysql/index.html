<!DOCTYPE html>
<html lang="en-us">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> MySQL技术内幕::InnoDB存储引擎 | Y.CH.Y</title>
  <link rel = 'canonical' href = '/notes/inside_mysql/'>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="MySQL技术内幕::InnoDB存储引擎" />
<meta property="og:description" content="MySQL 体系结构和存储引擎 定义数据库和实例  数据库  物理操作系统文件和其他形式文件类型的集合 frm、MYD、MYI、ibd 结尾的文件   实例  MySQL 数据库由后台线程和一个共享内存组成 数据库实例才是真正用来操作数据库的   实例与数据库一一对应 MySQL 数据库实例在系统上的表现就是一个进程 配置加载顺序  /etc/my.cnf =&gt; /etc/mysql/my.cnf =&gt; /usr/local/mysql/etc/my.cnf =&gt; $HOME/.my.cnf    MySQL 体系结构  组成  连接池组建 管理服务和工具组建 SQL 接口组件 查询分析器组件 优化器组件 缓冲组件 插件式存储引擎 物理文件   存储引擎是基于表的，而不是数据库  存储引擎  InnoDB 存储引擎  支持事务，面向 OLTP 应用 行锁，外键 支持裸设备 多版本并发控制，四种隔离级别 next-key locking 避免幻读 插入缓冲、二次写、自适应哈希索引、预读 采用索引组织表，每张表的存储都是按照转的顺序存放的   MyISAM 存储引擎  不支持事务 表锁设计 支持全文索引 面向 OLAP 只缓存索引文件 MyISAM 存储引擎表由 MYD 和 MYI 组成  MYD 存放数据文件 MYI 存放索引文件     NDB 存储引擎  集群存储引擎 share nothing 架构   Memory 存储引擎  表数据放在内存 使用哈希索引 用于存放临时结果集   Archive 存储引擎  只支持 INSERT 和 SELECT 使用 zlib 压缩数据，有较好的压缩率 适合归档数据   Federated 存储引擎  指向一台远程 MySQL 数据库服务器上的表   Maria 存储引擎  目标取代 MyISAM 特性同 InnoDB 存储引擎   其他存储引擎  Merge CSV Sphinx Infobright    存储引擎比较  MySQL :: 16 Alternative Storage Engines  连接 MySQL  TCP/IP  不同机器之间 在客户端和服务器端连接   命名管道和共享内存  在同一台机器上 通过 &ndash;enable-named-pipe 启用   UNIX 域套接字  同一台机器上使用 通过 &ndash;socket=/etc/mysql." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/notes/inside_mysql/" /><meta property="article:section" content="notes" />
<meta property="article:published_time" content="2021-09-11T10:03:18+08:00" />
<meta property="article:modified_time" content="2021-09-11T10:03:18+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MySQL技术内幕::InnoDB存储引擎"/>
<meta name="twitter:description" content="MySQL 体系结构和存储引擎 定义数据库和实例  数据库  物理操作系统文件和其他形式文件类型的集合 frm、MYD、MYI、ibd 结尾的文件   实例  MySQL 数据库由后台线程和一个共享内存组成 数据库实例才是真正用来操作数据库的   实例与数据库一一对应 MySQL 数据库实例在系统上的表现就是一个进程 配置加载顺序  /etc/my.cnf =&gt; /etc/mysql/my.cnf =&gt; /usr/local/mysql/etc/my.cnf =&gt; $HOME/.my.cnf    MySQL 体系结构  组成  连接池组建 管理服务和工具组建 SQL 接口组件 查询分析器组件 优化器组件 缓冲组件 插件式存储引擎 物理文件   存储引擎是基于表的，而不是数据库  存储引擎  InnoDB 存储引擎  支持事务，面向 OLTP 应用 行锁，外键 支持裸设备 多版本并发控制，四种隔离级别 next-key locking 避免幻读 插入缓冲、二次写、自适应哈希索引、预读 采用索引组织表，每张表的存储都是按照转的顺序存放的   MyISAM 存储引擎  不支持事务 表锁设计 支持全文索引 面向 OLAP 只缓存索引文件 MyISAM 存储引擎表由 MYD 和 MYI 组成  MYD 存放数据文件 MYI 存放索引文件     NDB 存储引擎  集群存储引擎 share nothing 架构   Memory 存储引擎  表数据放在内存 使用哈希索引 用于存放临时结果集   Archive 存储引擎  只支持 INSERT 和 SELECT 使用 zlib 压缩数据，有较好的压缩率 适合归档数据   Federated 存储引擎  指向一台远程 MySQL 数据库服务器上的表   Maria 存储引擎  目标取代 MyISAM 特性同 InnoDB 存储引擎   其他存储引擎  Merge CSV Sphinx Infobright    存储引擎比较  MySQL :: 16 Alternative Storage Engines  连接 MySQL  TCP/IP  不同机器之间 在客户端和服务器端连接   命名管道和共享内存  在同一台机器上 通过 &ndash;enable-named-pipe 启用   UNIX 域套接字  同一台机器上使用 通过 &ndash;socket=/etc/mysql."/>

  
  
    
  
  
  <link rel="stylesheet" href="/css/styles.799e452986b367cc888ea5995bc8cc4c4fb66d5b504c0a16cb0fdf4b1bb86b68090b3a1fc8d9eb26985d905c306e7bc2eefe764f17ebdf7156e1873bba2e07e1.css" integrity="sha512-eZ5FKYazZ8yIjqWZW8jMTE&#43;2bVtQTAoWyw/fSxu4a2gJCzofyNnrJphdkFwwbnvC7v52Txfr33FW4Yc7ui4H4Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="/images/favicon.ico" />

  
  
  
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-X1L70M4MM0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="/">
  
    <div id="logo" style="background-image: url(/images/logo.png)"></div>
  
  <div id="title">
    <h1>Y.CH.Y</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/oc">课程</a></li>
      
        <li><a href="/algo">算法</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <h2 id="mysql-体系结构和存储引擎">MySQL 体系结构和存储引擎</h2>
<h3 id="定义数据库和实例">定义数据库和实例</h3>
<ul>
<li>数据库
<ul>
<li>物理操作系统文件和其他形式文件类型的集合</li>
<li>frm、MYD、MYI、ibd 结尾的文件</li>
</ul>
</li>
<li>实例
<ul>
<li>MySQL 数据库由后台线程和一个共享内存组成</li>
<li>数据库实例才是真正用来操作数据库的</li>
</ul>
</li>
<li>实例与数据库一一对应</li>
<li>MySQL 数据库实例在系统上的表现就是一个进程</li>
<li>配置加载顺序
<ul>
<li>/etc/my.cnf =&gt; /etc/mysql/my.cnf =&gt; /usr/local/mysql/etc/my.cnf =&gt; $HOME/.my.cnf</li>
</ul>
</li>
</ul>
<h3 id="mysql-体系结构">MySQL 体系结构</h3>
<ul>
<li>组成
<ul>
<li>连接池组建</li>
<li>管理服务和工具组建</li>
<li>SQL 接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓冲组件</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ul>
</li>
<li>存储引擎是基于表的，而不是数据库</li>
</ul>
<h3 id="存储引擎">存储引擎</h3>
<ul>
<li>InnoDB 存储引擎
<ul>
<li>支持事务，面向 OLTP 应用</li>
<li>行锁，外键</li>
<li>支持裸设备</li>
<li>多版本并发控制，四种隔离级别</li>
<li>next-key locking 避免幻读</li>
<li>插入缓冲、二次写、自适应哈希索引、预读</li>
<li>采用索引组织表，每张表的存储都是按照转的顺序存放的</li>
</ul>
</li>
<li>MyISAM 存储引擎
<ul>
<li>不支持事务</li>
<li>表锁设计</li>
<li>支持全文索引</li>
<li>面向 OLAP</li>
<li>只缓存索引文件</li>
<li>MyISAM 存储引擎表由 MYD 和 MYI 组成
<ul>
<li>MYD 存放数据文件</li>
<li>MYI 存放索引文件</li>
</ul>
</li>
</ul>
</li>
<li>NDB 存储引擎
<ul>
<li>集群存储引擎</li>
<li>share nothing 架构</li>
</ul>
</li>
<li>Memory 存储引擎
<ul>
<li>表数据放在内存</li>
<li>使用哈希索引</li>
<li>用于存放临时结果集</li>
</ul>
</li>
<li>Archive 存储引擎
<ul>
<li>只支持 INSERT 和 SELECT</li>
<li>使用 zlib 压缩数据，有较好的压缩率</li>
<li>适合归档数据</li>
</ul>
</li>
<li>Federated 存储引擎
<ul>
<li>指向一台远程 MySQL 数据库服务器上的表</li>
</ul>
</li>
<li>Maria 存储引擎
<ul>
<li>目标取代 MyISAM</li>
<li>特性同 InnoDB 存储引擎</li>
</ul>
</li>
<li>其他存储引擎
<ul>
<li>Merge</li>
<li>CSV</li>
<li>Sphinx</li>
<li>Infobright</li>
</ul>
</li>
</ul>
<h3 id="存储引擎比较">存储引擎比较</h3>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html">MySQL :: 16 Alternative Storage Engines</a></li>
</ul>
<h3 id="连接-mysql">连接 MySQL</h3>
<ul>
<li>TCP/IP
<ul>
<li>不同机器之间</li>
<li>在客户端和服务器端连接</li>
</ul>
</li>
<li>命名管道和共享内存
<ul>
<li>在同一台机器上</li>
<li>通过 &ndash;enable-named-pipe 启用</li>
</ul>
</li>
<li>UNIX 域套接字
<ul>
<li>同一台机器上使用</li>
<li>通过 &ndash;socket=/etc/mysql.sock 指定套接字文件</li>
</ul>
</li>
</ul>
<h2 id="innodb-存储引擎">InnoDB 存储引擎</h2>
<h3 id="innodb-存储引擎概述">InnoDB 存储引擎概述</h3>
<ul>
<li>是第一个支持完整 ACID 事务的 MySQL 存储引擎</li>
<li>其特点是行锁设计、支持 MVCC、支持外键、提供一致性非锁定读</li>
<li>高效利用内存和 CPU</li>
</ul>
<h3 id="innodb-体系架构">InnoDB 体系架构</h3>
<ul>
<li>后台线程
<ul>
<li>描述
<ul>
<li>负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据</li>
<li>此外将以修改的数据文件刷新到磁盘文件</li>
<li>同时保证在数据库发生异常的情况下 InnoDB 能恢复到正常运行状态</li>
</ul>
</li>
<li>不同的线程
<ul>
<li>Master Thread
<ul>
<li>核心后台线程，负责将缓存池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲，UNDO 页的回收等</li>
</ul>
</li>
<li>IO Thread
<ul>
<li>InnoDB 中大量使用 AIO 处理请求</li>
<li>IO Thread 的工作是负责这些 IO 请求的回调处理</li>
</ul>
</li>
<li>Purge Thread
<ul>
<li>回收已经使用并分配的 undo 页</li>
</ul>
</li>
<li>Page Cleaner Thread
<ul>
<li>将之前版本中脏页的刷新操作放入到单独的线程中完成</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>内存
<ul>
<li>缓冲池
<ul>
<li>通过内存的速度弥补磁盘速度较慢对数据库性能的影响</li>
<li>对内容的读取先判断是否在缓冲池中，否则从磁盘读取到缓冲池中，再从缓冲池中读取</li>
<li>对内容的更性操作先在缓冲池中进行，然后通过 checkpoint 机制写入磁盘</li>
<li>缓冲池的大小直接影响数据库的性能</li>
<li>数据页类型
<ul>
<li>索引页</li>
<li>数据页</li>
<li>undo 页</li>
<li>插入缓冲</li>
<li>自适应哈希索引</li>
<li>InnoDB 存储的锁信息</li>
<li>数据字典信息</li>
<li>等</li>
</ul>
</li>
</ul>
</li>
<li>LRU List、Free List 和 Flush List
<ul>
<li>数据库中的缓冲池通过 LRU 算法来管理</li>
<li>最频繁使用的页面在最前面，最少使用的在 LRU 列表的尾端</li>
<li>当缓冲池不能存放新读取到的页面时，将首先释放 LRU 列表中尾端的页</li>
<li>优化，最新读区到的页放到列表中间位置，避免新页导致热点页被刷到磁盘</li>
<li>LRU 列表从 Free 列表分配页面</li>
<li>可以使用`show engine innodb status 来观察 LRU 列表和 Free 列表的使用情况和状态</li>
<li>非 16KB 的压缩页面通过伙伴算法分配</li>
<li>Flush List 用来管理需要被刷回磁盘的脏页</li>
</ul>
</li>
<li>redo 日志缓存
<ul>
<li>InnoDB 会把 redo 日志放入这个缓冲区，然后刷到磁盘上</li>
<li>时机
<ul>
<li>Master Thread 每一秒将重做日志缓存刷新到重做日志文件</li>
<li>每个事务提交前会将重做日志缓存刷新到重做日志文件</li>
<li>当重做日志缓冲池小于一半时，重做日志缓存刷新到重做日志文件</li>
</ul>
</li>
</ul>
</li>
<li>额外的内存池
<ul>
<li>在对一些数据结构本身的内存进行分配时，会从额外的内存池申请。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="checkpoint-技术">Checkpoint 技术</h3>
<ul>
<li>WAL 策略
<ul>
<li>当事务提交时，先写重做日式，再修改页</li>
<li>当发生宕机事故时，通过重做日志来完成对数据的恢复</li>
</ul>
</li>
<li>目标
<ul>
<li>缩短数据库的恢复时间
<ul>
<li>当数据库发生宕机时，数据库只需对 Checkpoint 后的重做日志进行恢复</li>
</ul>
</li>
<li>缓冲池日志不够用时，将脏页刷新到磁盘
<ul>
<li>根据 LRU 算法会移除最近最少使用的页，若此页为脏页，需要强制 Checkpoint，将脏页刷回磁盘</li>
</ul>
</li>
<li>重做日志不够用时，刷新脏页
<ul>
<li>重做日志被设计成可以循环使用，重做日志可以覆盖已经刷到磁盘的部分</li>
</ul>
</li>
</ul>
</li>
<li>LSN
<ul>
<li>InnoDB 通过 LSN 来管理版本</li>
<li>每个页有 LSN，重做日志有 LSN，Checkpoint 也有 LSN</li>
<li>InnoDB 内部有两种 Checkpoint
<ul>
<li>Sharp Checkpoint
<ul>
<li>当数据库关闭时，把所有脏页刷新到磁盘</li>
</ul>
</li>
<li>Fuzzy Checkpoint
<ul>
<li>Master Thread Checkpoint</li>
<li>FLUSH_LRU_LIST Checkpoint</li>
<li>Async/Sync Flush Point</li>
<li>Dirty Page too mush Checkpoint</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="master-thread-工作">Master Thread 工作</h3>
<ul>
<li>最高级别线程</li>
<li>主循环
<ul>
<li>每一秒
<ul>
<li>日志缓冲刷新到磁盘，即使这个事务没有提交</li>
<li>合并插入缓冲</li>
<li>之多刷新 100 个 InnoDB 的缓冲池中的脏页到磁盘</li>
<li>如果没有互动切换到后台循环</li>
</ul>
</li>
<li>每十秒
<ul>
<li>刷新 100 个脏页到磁盘</li>
<li>合并至多 5 个插入缓冲</li>
<li>将日志缓冲刷新到磁盘</li>
<li>删除无用的 Undo 页</li>
<li>刷新 10 个或 100 个脏页到磁磁盘</li>
</ul>
</li>
</ul>
</li>
<li>后台循环
<ul>
<li>删除无用的 Undo 页</li>
<li>合并 20 个插入缓冲</li>
<li>跳到主循环</li>
<li>不断刷新 100 个页直到符合条件</li>
</ul>
</li>
<li>刷新循环
<ul>
<li>刷新页面到磁盘</li>
</ul>
</li>
<li>暂停循环
<ul>
<li>将 Master Thread 挂起</li>
</ul>
</li>
<li>Master Thread 根据数据库状态在几个循环之间切换</li>
</ul>
<h3 id="innodb-关键特性">InnoDB 关键特性</h3>
<ul>
<li>插入缓冲</li>
<li>两次写</li>
<li>自适应哈希索引</li>
<li>异步 IO</li>
<li>刷新邻接页</li>
</ul>
<h3 id="启动关闭与恢复">启动、关闭与恢复</h3>
<ul>
<li>正常关闭时，下次启动也会很正常</li>
<li>非正常退出，下次启动时会进行数据恢复</li>
</ul>
<h2 id="文件">文件</h2>
<h3 id="参数文件">参数文件</h3>
<ul>
<li>告诉 MySQL 实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置，还会介绍各种参数的类型。</li>
<li>非必需，可以通过启动参数来配置</li>
<li>参数类型
<ul>
<li>动态参数：可以在运行中进行修改</li>
<li>静态参数：启动时读取，不可修改</li>
</ul>
</li>
</ul>
<h3 id="日志文件">日志文件</h3>
<ul>
<li>用来记录 MySQL 实例对某种条件做出响应时写人的文件，如错误日志文件、二进制日志文件、慢查询日志文件、查询日志文件等。</li>
<li>错误日志
<ul>
<li>对 MySQL 的启动、运行、关闭过程进行了记录，也记录一些告警信息和正确的信息，用来排查问题</li>
<li><code>SHOW VARIABLES LIKE 'log_error'</code></li>
</ul>
</li>
<li>慢查询日志
<ul>
<li>可以在 MySQL 启动时设置一个阈值，将运行时间超过该值的所有 SQL 语句都记录到慢查询日志中。</li>
<li><code>SHOW VARIABLES LIKE 'log_slow_queries'</code></li>
<li>log_queries_not_using_indexes
<ul>
<li>如果查询没有使用索引也会被记录</li>
</ul>
</li>
<li>mysqldumpslow 可以导出慢 sql</li>
</ul>
</li>
<li>二进制日志
<ul>
<li>记录了堆 MySQL 数据库执行更改的所有操作</li>
<li>作用
<ul>
<li>恢复(recovery):某些数据的恢复需要二进制日志，例如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复。</li>
<li>复制(replication):其原理与恢复类似，通过复制和执行二进制日志使一台远程的 MySQL 数据库(一般称为 slave 或 standby) 与一台 MySQL 数据库(一般称为 master 或 primary) 进行实时同步。</li>
<li>审计 (audit):用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入的攻击</li>
</ul>
</li>
<li>当使用事务的表存储引擎时，所有未提交的二进制日志会被记录到一个缓存中，等到事务提交的时候将缓存中的二进制日志写入二进制日志文件</li>
<li>当写入二进制文件一半时，数据库奔溃，写入的部分不能撤销，可以使用 innodb_support_xa 设置为 1 解决</li>
<li>binlog_format 参数
<ul>
<li>STATEMENT 格式和之前的 MySQL 版本一样，二进制日志文件记录的是日志的逻辑 SQL 语句。</li>
<li>在 ROW 格式下，二进制日志记录的不再是简单的 SQL 语句了，而是记录表的行更改情况。基于 ROW 格式的复制类似于 Oracle 的物理 Standby (当然，还是有些区别)。同时，对上述提及的 Statement 格式下复制的问题予以解决。从 MySQL 5.1 版本开始，如果设置了 binlog_format 为 ROW，可以将 InnoDB 的事务隔离基本设为 READ COMMITTED，以获得更好的并发性。</li>
<li>在 MIXED 格式下，MySQL 默认采用 STATEMENT 格式进行二进制日志文件的记录，但是在一些情况下会使用 ROW 格式，可能的情况有:
<ul>
<li>表的存储引擎为 NDB，这时对表的 DML 操作都会以 ROW 格式记录。</li>
<li>使用了 UUID()、USER()、CURRENT_USER()、FOUND_ROWS()、ROW_COUNT() 等不确定函数。</li>
<li>使用了 INSERT DELAY 语句。</li>
<li>使用了用户定义函数 (UDF)。</li>
<li>使用了临时表(temporary table)。</li>
</ul>
</li>
<li>ROW 格式可以为数据库的恢复和复制带来更好的可靠性，但是会增加二进制的大小，复制的网络开销也会变大。</li>
</ul>
</li>
<li>采用 mysqlbinlog 工具查看</li>
</ul>
</li>
</ul>
<h3 id="socket-文件">socket 文件</h3>
<ul>
<li>当用 UNIX 域套接字方式进行连接时需要的文件。</li>
</ul>
<h3 id="pid-文件">pid 文件</h3>
<ul>
<li>MySQL 实例的进程 ID 文件。</li>
</ul>
<h3 id="mysql-表结构文件">MySQL 表结构文件</h3>
<ul>
<li>用来存放 MySQL 表结构定义文件。</li>
</ul>
<h3 id="innodb-存储引擎文件">InnoDB 存储引擎文件</h3>
<ul>
<li>因为 MySQL 表存储引擎的关系，每个存储引擎都会有自己的文件来保存各种数据。这些存储引擎真正存储了记录和索引等数据。</li>
<li>表空间文件
<ul>
<li>InnoDB 采用将存储的数据按表空间进行存放的设计，每张表都有独立的表空间可以分担负载。</li>
</ul>
</li>
<li>重做日志
<ul>
<li>每个 InnoDB 存储引擎至少有 1 个重做日志文件组，每个文件组下至少有 2 个重做日志文件。</li>
<li>重做日志设置太大恢复需要很长时间，设置太小导致一个事务的日志需要多次切换重做日志文件，还会频繁发生 async checkpoint，造成性能的抖动。</li>
<li>目录结构
<ul>
<li><code>redo_log_type | space | page_no | redo_log_type</code>
<ul>
<li>redo_log_type 占用 1 字节，表示重做日志的类型</li>
<li>space 表示表空间的 ID，但采用压缩的方式，因此占用的空间可能小于 4 字节</li>
<li>page_no 表示页的偏移量，同样采用压缩的方式</li>
<li>redo_log_body 表示每个重做日志的数据部分，恢复时需要调用相应的函数进行解析</li>
</ul>
</li>
</ul>
</li>
<li>为了保证事务 ACID 的持久性，每次提交事务都要保证重做日志已经刷入磁盘</li>
</ul>
</li>
</ul>
<h2 id="表">表</h2>
<h3 id="索引组织表">索引组织表</h3>
<ul>
<li>在 InnoDB 存储引擎中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表</li>
<li>在 InnoDB 存储引擎表中，每张表都有个主键，如果在创建表时没有显式地定义主键，InnoDB 会优先使用第一个定义的非空唯一索引，否则自动添加一个 6 字节大小的指针。</li>
</ul>
<h3 id="innodb-逻辑存储结构">InnoDB 逻辑存储结构</h3>
<ul>
<li>所有数据被存放在一个空间内，称之为表空间</li>
<li>表空间又由段、区、页、行组成</li>
<li>表空间
<ul>
<li>InnoDB 存储引擎结构的最高层</li>
<li>每张表的表空间只存放数据，其他信息存放在共享表空间</li>
</ul>
</li>
<li>段
<ul>
<li>表空间是由各个段组成的</li>
<li>常见的段有数据段、索引段、回滚段、等</li>
<li>数据段为 B+ 树的非子节点</li>
<li>数据段即为 B+ 树的子节点</li>
</ul>
</li>
<li>区
<ul>
<li>由连续的页组成，在任何情况下每个区的大小都是 1MB</li>
<li>InnoDB 一次性申请 4 到 5 个区</li>
<li>一般 InnoDB 引擎存储页的大小为 16KB，一个区有 64 个页，启用压缩页或者调小默认页大小也保持 1MB 总大小</li>
</ul>
</li>
<li>页\块
<ul>
<li>页是 InnoDB 磁盘管理的最小单位</li>
<li>默认 16KB，可以调整为 4KB、8KB、16KB</li>
<li>常见类型
<ul>
<li>数据页 (B-tree Node)</li>
<li>undo 页 (undo Log Page)</li>
<li>系统页 (System Page)</li>
<li>事务数据页 (Transaction system Page)</li>
<li>插人缓冲位图页 (Insert Buffer Bitmap)</li>
<li>插入缓冲空闲列表页 (Insert Buffer Free List)</li>
<li>未压缩的二进制大对象页 (Uncompressed BLOB Page)</li>
<li>压缩的二进制大对象页 (compressed BLOB Page)</li>
</ul>
</li>
</ul>
</li>
<li>行
<ul>
<li>InnoDB 数据是按行存放的</li>
</ul>
</li>
</ul>
<h3 id="innodb-行记录格式">InnoDB 行记录格式</h3>
<h3 id="innodb-数据页结构">InnoDB 数据页结构</h3>
<h3 id="named-file-formats-机制">Named File Formats 机制</h3>
<h3 id="约束">约束</h3>
<h3 id="视图">视图</h3>
<h3 id="分区表">分区表</h3>
<h2 id="索引与算法">索引与算法</h2>
<h3 id="innodb-存储引擎索引概述">InnoDB 存储引擎索引概述</h3>
<ul>
<li>InnoDB 存储引擎支持以下几种常见的索引
<ul>
<li>B+ 树索引</li>
<li>全文索引</li>
<li>哈希索引</li>
</ul>
</li>
<li>人为不能干预存储引擎是否生成哈希索引</li>
<li>InnoDB 存储引擎以页为单位查找数据</li>
</ul>
<h3 id="数据结构与算法">数据结构与算法</h3>
<ul>
<li>二分查找法
<ul>
<li>基本思想：将记录按有序化（递增或递减）排列，在查找过程中采用跳跃式方式查找，即先以有序数列的中点位置为比较对象，如果要找的元素值小于该中点元素，则将待杳序列缩小为左半部分，否则为右半部分。通过一次比较，将查找区间缩小一半。</li>
</ul>
</li>
<li>二叉查找树与平衡二叉树
<ul>
<li>二叉查找树：在二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值。</li>
<li>平衡二叉树：首先符合二叉树的定义，其次必须满足任何节点的两个子树的高度最大差为 1。</li>
</ul>
</li>
</ul>
<h3 id="b-树">B+ 树</h3>
<h3 id="b-树索引">B+ 树索引</h3>
<h3 id="cardinality-值">Cardinality 值</h3>
<h3 id="哈希算法">哈希算法</h3>
<h3 id="全文检索">全文检索</h3>
<h2 id="锁">锁</h2>
<h3 id="什么是锁">什么是锁</h3>
<ul>
<li>锁机制用于管理对共享资源的并发访问</li>
<li>InnoDB 在数据库内部多处使用锁，从而允许对多种不同资源提供并发访问，提供数据的完整性和一致性。</li>
<li>不同的数据库系统实现锁的机制不同</li>
</ul>
<h3 id="lock-与-latch">lock 与 latch</h3>
<ul>
<li>lock 的对象时事务，用来锁定的是数据库中的对象，如表、页、行。lock 多在事务 commit 或 rollback 后释放，有死锁检测机制。</li>
<li>latch 一般称为闩锁，持续时间非常短，在 InnoDB 引擎中，latch 又可分为 mutex 和 rwlock。其目的是用来保证并发线程操作临界资源的正确性，无死锁检测。</li>
</ul>
<h3 id="innodb-存储引擎中的锁">InnoDB 存储引擎中的锁</h3>
<h3 id="锁的算法">锁的算法</h3>
<h3 id="锁问题">锁问题</h3>
<h3 id="阻塞">阻塞</h3>
<h3 id="死锁">死锁</h3>
<h3 id="锁升级">锁升级</h3>
<h2 id="事务">事务</h2>
<h3 id="认识事务">认识事务</h3>
<ul>
<li>概述
<ul>
<li>事务是访问并更新数据库中各种数据项的一个程序执行单元。在事务中的操作，要么都做修改，要么都不做，这就是事务的目的，也是事务模型区别与文件系统的重要特征之一</li>
<li>ACID
<ul>
<li>原子性(Atomicity)
<ul>
<li>原子性指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个 SQL 语句执行失败，已经执行成功的 SQL 语句也必须撤销，数据库状态应该退回到执行事务前的状态</li>
</ul>
</li>
<li>一致性(Consistency)
<ul>
<li>一致性指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏</li>
</ul>
</li>
<li>隔离性(Isolation)
<ul>
<li>事务的隔离性要求诶个读写事务的对象对其他事物的操作对象能相互分离，即该事务提交前对其他事务都不可见。</li>
</ul>
</li>
<li>持久性(Durability)
<ul>
<li>事务一旦提交，其结果就是永久的。即使发生宕机等故障，数据库也能将数据恢复。</li>
</ul>
</li>
</ul>
</li>
<li>分类
<ul>
<li>扁平事务
<ul>
<li>最简单的一种，其操作是原子性的，要么都执行要么都会滚</li>
<li>扁平事务时应用程序成为原子操作的基本组成模块</li>
<li>主要限制是不能提交和会滚事务的某一部分，或者分几个步骤提交</li>
</ul>
</li>
<li>带有保存点的扁平事务
<ul>
<li>在扁平事务的基础上，允许事务执行过程中会滚到同一个事务较早的一个状态</li>
<li>保存点在事务内部是递增的，ROLLBACK 不影响保存点的递增</li>
</ul>
</li>
<li>嵌套事务
<ul>
<li>是一个层次结构框架，由一个顶层事务控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务，其控制每一个局部的变换</li>
<li>可以用支持保存点的事务模拟</li>
<li>子事务可以时扁平事务也可以是嵌套事务</li>
<li>子事务既可以回滚也可以提交，但是它的提交要到父事务提交后才生效</li>
<li>任何一个事务回滚会引起它所有子事务一起回滚</li>
</ul>
</li>
<li>链事务
<ul>
<li>在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传递给下一个要开始的事务</li>
<li>提交事务操作和开始下一个事务操作将合并成为一个院子操作</li>
</ul>
</li>
<li>分布式事务
<ul>
<li>通常是一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="事务的实现">事务的实现</h3>
<ul>
<li>概述
<ul>
<li>原子性、一致性、持久性通过数据库的 redo log 和 undo log 来完成。redo log 称为重做日志，用来保证事务的原子性和持久性。undo log 用来保证事务的一致性。</li>
</ul>
</li>
<li>redo
<ul>
<li>基本概念
<ul>
<li>用来实现事务的持久性</li>
<li>由内存中的重做日志缓冲（易失）和重做日志文件（持久）组成</li>
<li>当事务提交时，必须先将事务的所有日志写入到重做日志文件进行持久化，待事务的 commit 操作完成才算完成</li>
<li>顺序写，使用 fsync 操作保证数据落盘，fsync 效率取决于磁盘性能，间接影响数据库的性能</li>
<li>物理格式日志，记录针对每个页的修改</li>
<li>binlog 在提交时写入，redo log 在整个事务执行过程中都在写入</li>
</ul>
</li>
<li>log block
<ul>
<li>以 512 字节的块进行保存，与磁盘扇区大小一致，不需要 doublewrite</li>
<li>由日志块头（12 字节），日志块内容（492 字节），日志块尾（8 字节）组成</li>
</ul>
</li>
<li>log group
<ul>
<li>重做日志组，其中有多个重做日志文件</li>
<li>存储的就是之前的 log buffer 中保存的 log block，块大小为 512 字节</li>
<li>写盘时机
<ul>
<li>事务提交时</li>
<li>当 log buffer 中有一半的内存空间已经被使用</li>
<li>当 log checkpoint 时</li>
</ul>
</li>
<li>通过 round-robin 的方式写入文件</li>
<li>每个 log group 的第一个文件的前 2kb 保存文件的元信息，不写入内容</li>
<li>log file header 的后面部分是 InnoDB 保存的 checkpoint 值，其设计是交替写入的，避免因为介质失败找不到可用的值</li>
</ul>
</li>
<li>redo log 格式
<ul>
<li><code>redo_log_type | space | page_no | redo_log_type</code>
<ul>
<li>redo_log_type 占用 1 字节，表示重做日志的类型</li>
<li>space 表示表空间的 ID，但采用压缩的方式，因此占用的空间可能小于 4 字节</li>
<li>page_no 表示页的偏移量，同样采用压缩的方式</li>
<li>redo_log_body 表示每个重做日志的数据部分，恢复时需要调用相应的函数进行解析，根据不同的类型会有不同的内容</li>
</ul>
</li>
</ul>
</li>
<li>LSN
<ul>
<li>Log Sequence Number 的缩写，代表日志序列号，单调递增</li>
<li>含义
<ul>
<li>重做日志写入的总量
<ul>
<li>例如当前重做日志的 LSN 为 1000，有一个事务 T1 写入了 100 字节的重做日志，那么 LSN 就变为了 1100，若又有事务 7 写人入 200 字节的重做日志，那么 LSN 就变为了 1300。可见 LSN 记录的是重做日志的总量，其单位为字节。</li>
</ul>
</li>
<li>checkpoint 的位置</li>
<li>页的版本
<ul>
<li>页头部的 FIL_PAGE_LSN 记录了该页的 LSN</li>
<li>用来判断是否需要进行恢复操作</li>
<li>如果重做日志日志中的 LSN 大于页的 LSN，并且事务已经提交则需要进行恢复操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>恢复
<ul>
<li>由于 checkpoint 表示已经被刷到磁盘上的 LSN，因此在恢复过程中仅需恢复 checkpoint 开始的日志部分</li>
<li>当数据库在 checkpoint 为 LSN 10000 时宕机器，只需恢复到 10000 到 13000 的数据</li>
</ul>
</li>
</ul>
</li>
<li>undo
<ul>
<li>基本概念
<ul>
<li>记录了事务的行为，用来把数据恢复回去</li>
<li>当 InnoDB 存储引擎回滚时，它实际上做的是与先前相反的工作。对于每个 INSERT， InnoDB 存储引擎会完成一个 DELETE；对于每个 DELETE, InnoDB 都会执行一个 INSERT；对于每一个 UPDATE InnoDB 引擎会执行一个相反的 UPDATE，将修改前的行放回去</li>
<li>undo 的另一个作用时 MVCC，InnoDB 存储引擎中的 MVCC 通过 undo 实现的</li>
<li>undo log 也会产生 redo log，undo log 也需要持久化的保护</li>
</ul>
</li>
<li>undo 存储管理</li>
</ul>
</li>
</ul>
<h3 id="事务控制语句">事务控制语句</h3>
<ul>
<li>STARTTRANSACTION |BEGIN: 显式地开启一个事务。</li>
<li>COMMIT : 要想使用这个语句的最简形式，只需发出 COMMIT。也可以更详细一些，写为 COMMIT WORK，不过这二者几乎是等价的。COMMIT 会提交事务，并使得已对数据库做的所有修改成为永久性的。</li>
<li>ROLLBACK : 要想使用这个语句的最简形式，只需发出 ROLLBACK。同样地，也可以写为 ROLLBACK WORK，但是二者几乎是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li>
<li>SAVEPOINT identifier : SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT。</li>
<li>RELEASE SAVEPOINT identitier : 删除一个事务的保存点，当没有一个保存点执行这句语句时，会抛出一个异常。</li>
<li>ROLLBACK TO [SAVEPOINT] identifier: 这个语句与 SAVEPOINT 命令一起使用。可以把事务回滚到标记点，而不回滚在此标记点之前的任何工作。例如可以发出两条 UPDATE 语句，后面跟一个 SAVEPOINT，然后又是两条 DELETE 语句。如果执行 DELETE 语句期间出现了某种异常情况，并且捕获到这个异常，同时发出了 ROLLBACK TO SAVEPOINT 命令，事务就会回滚到指定的 SAVEPOINT，撤销 DELETE 完成的所有工作，而 UPDATE 语句完成的工作不受影响。</li>
<li>SET TRANSACTION : 这个语句用来设置事务的隔离级别。InnoDB 存储引你提供的事务隔离级别有: READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE。</li>
</ul>
<h3 id="隐式提交的事务">隐式提交的事务</h3>
<ul>
<li>以下这些 SQL 语句会产生一个隐式的提交操作，即执行完这些语名后，会有一个隐式的 COMMIT 操作。
<ul>
<li>DDL 语句 : ALTER DATABASE&hellip;UPGRADE DATA DIRECTORY NAME，ALTER EVENT，ALTER PROCEDURE，ALTER TABLE，ALTER VIEW，CREATE DATABASE，CREATE EVENT，CREATE INDEX，CREATE PROCEDURE，CREATE TABLE，CREATE TRIGGER，CREATE VIEW，DROP DATABASE，DROP EVENT，DROP INDEX，DROP PROCEDURE，DROP TABLE，DROP TRIGGER，DROP VIEW，RENAME TABLE，TRUNCATE TABLE。</li>
<li>用来隐式地修改 MySQL 架构的操作 : CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SET PASSWORD。</li>
<li>管理语句，ANALYZE TABLE、CACHE INDEX、CHECK TABLE、LOAD INDEX INTO CACHE、OPTIMIZE TABLE、REPAIR TABLE。</li>
</ul>
</li>
</ul>
<h3 id="对于事务操作的统计">对于事务操作的统计</h3>
<ul>
<li>TPS = (com_commit + com_rollback) / time</li>
</ul>
<h3 id="事务的隔离级别">事务的隔离级别</h3>
<ul>
<li>四个隔离级别
<ul>
<li>READ UNCOMMITTED</li>
<li>READ COMMITTED</li>
<li>REPEATABLE READ</li>
<li>SERIALIZABLE</li>
</ul>
</li>
</ul>
<h3 id="分布式事务">分布式事务</h3>
<h3 id="不好的事务习惯">不好的事务习惯</h3>
<h3 id="长事务">长事务</h3>

  
  </div>
</article>


    <footer id="footer">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
  <div class="footer-left">
    Copyright  &copy; 2021  Y.CH.Y 
    
    
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">首页</a></li>
         
        <li><a href="/oc">课程</a></li>
         
        <li><a href="/algo">算法</a></li>
         
        <li><a href="/about">关于</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
