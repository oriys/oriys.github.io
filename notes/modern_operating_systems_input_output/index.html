<!doctype html><html lang=en-us>
<head>
<link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous>
<script type=text/javascript src=https://latest.cactus.chat/cactus.js></script>
<link rel=stylesheet href=https://latest.cactus.chat/style.css type=text/css>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title> 现代操作系统::输入/输出 | Y.CH.Y</title>
<link rel=canonical href=/notes/modern_operating_systems_input_output/>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="all,follow">
<meta name=googlebot content="index,follow,snippet,archive">
<meta property="og:title" content="现代操作系统::输入/输出">
<meta property="og:description" content="输入/输出  I/O 硬件原理  I/O 设备  分类  块设备，块设备把信息存储在固定大小的块中.每个块有自己的地址。通常块的大小在 512 字节至 65536 字节之间。所有传输以一个或多个完整的(连续的)块为单位。块设备的基本特征是每个块都能独立干其他块而读写。硬盘、蓝光光盘和 USB 盘是最常见的块设备。 字符设备，字符设备以字符为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。打印机、鼠标、键盘以及大多数与磁盘不同的设备都可以看作字符设备。   设备控制器  I/O 设备一般由机械部件和电子部件两部分组成。通常可以将这两部分分开处理，以提供更加模块化和更加通用的设计。电子部件称作设备控制器 (device controller) 或适配器 (adapter)。在个人计算机上，它经常以主板上的芯片的形式出现，或者以插入 (PCI) 扩展槽中的印刷电路板的形式出现。机械部件则是设备本身。 控制器与设备之间的接口通常是一个很低层次的接口。 控制器的任务是把串行的位流转换为字节块，井进行必要的错误校正工作。   内存映射 I/O  每个控制器有几个寄存器用来与 CPU 进行通信。通过写人这些寄存器，操作系统可以命令设备发送数据接收数据、开启或关闭，或者执行某些其他操作。通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。 除了这些控制寄存器以外，许多设备还有一个操作系统可以读写的数据缓冲区。 每个控制寄存器被分配一个 I/O 端口 (I/O port) 号，这是一个 8 位或 16 位的整数。所 有 I/O 端口形成 I/O 端口空间 (I/O port space), 井且受到保护使得普通的用户程序不能对其进行访问(只有操作系统可以访问)。CPU 通过这个 I/O 端口和控制器通信。 另一种方式是将所有控制寄存器映射到内存空间中，每个控制寄存器被分配唯一的一个内存地址，井且不会有内存被分配这一地址。这样的系统称为内存映射 I/O   直接存储器存取  CPU 从 I/O 控制器请求数据浪费 CPU 时间，所以经常用到一种称为直接存储器存取的方案。 DMA 的工作过程  CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA 控制器知道将什么数据传送到什么地方。 DMA 控制器通过在总线上发出一个读请求到磁盘控制器而发起 DMA 传送 磁盘控制器从其内部缓冲区读取内容后，写到内存中。 当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器 DMA 控制器步增要使用的内存地址，井且步减字节计数。如果字节计数仍然大于 O, 则重复第 2 步到第 4 步，直到字节计数到达 0。此时，DMA 控制器将中断 CPU 以便让 CPU 知道传送现在已经完成了。当操作系统开始工作时，用不着将磁盘块复制到内存中，因为它已经在内存中了。   总线操作模式  字模式：DMA 控制器请求传送一个字并且得到这个字。如果 CPU 也想使用总线，它必须等待。这一机制称为周期窃取(cycle stealing),因为设备控制器偶尔偷偷溜入并且从 CPU 偷走一个临时的总线周期，从而轻微地延迟 CPU。 块模式：在块模式中，DMA 控制器通知设备获得总线，发起一连串的传送，然后释放总线。这一操作形式称为突发模式 (burst mode)。它比周期窃取效率更高，因为获得总线占用了时间，井且以一次总线获得的代价能够传送多个字。突发模式的缺点是，如果正在进行的是长时间突发传送，有可能将 CPU 和其他设备阻塞相当长的周期。 飞跃模式：DMA 控制器通知设备控制器直接将数据传送到主存。某些 DMA 控制器使用的其他校式是让设备控制器将字发送给 DMA 控制器.">
<meta property="og:type" content="article">
<meta property="og:url" content="/notes/modern_operating_systems_input_output/"><meta property="article:section" content="notes">
<meta property="article:published_time" content="2021-07-18T02:11:01+08:00">
<meta property="article:modified_time" content="2021-07-18T02:11:01+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="现代操作系统::输入/输出">
<meta name=twitter:description content="输入/输出  I/O 硬件原理  I/O 设备  分类  块设备，块设备把信息存储在固定大小的块中.每个块有自己的地址。通常块的大小在 512 字节至 65536 字节之间。所有传输以一个或多个完整的(连续的)块为单位。块设备的基本特征是每个块都能独立干其他块而读写。硬盘、蓝光光盘和 USB 盘是最常见的块设备。 字符设备，字符设备以字符为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。打印机、鼠标、键盘以及大多数与磁盘不同的设备都可以看作字符设备。   设备控制器  I/O 设备一般由机械部件和电子部件两部分组成。通常可以将这两部分分开处理，以提供更加模块化和更加通用的设计。电子部件称作设备控制器 (device controller) 或适配器 (adapter)。在个人计算机上，它经常以主板上的芯片的形式出现，或者以插入 (PCI) 扩展槽中的印刷电路板的形式出现。机械部件则是设备本身。 控制器与设备之间的接口通常是一个很低层次的接口。 控制器的任务是把串行的位流转换为字节块，井进行必要的错误校正工作。   内存映射 I/O  每个控制器有几个寄存器用来与 CPU 进行通信。通过写人这些寄存器，操作系统可以命令设备发送数据接收数据、开启或关闭，或者执行某些其他操作。通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。 除了这些控制寄存器以外，许多设备还有一个操作系统可以读写的数据缓冲区。 每个控制寄存器被分配一个 I/O 端口 (I/O port) 号，这是一个 8 位或 16 位的整数。所 有 I/O 端口形成 I/O 端口空间 (I/O port space), 井且受到保护使得普通的用户程序不能对其进行访问(只有操作系统可以访问)。CPU 通过这个 I/O 端口和控制器通信。 另一种方式是将所有控制寄存器映射到内存空间中，每个控制寄存器被分配唯一的一个内存地址，井且不会有内存被分配这一地址。这样的系统称为内存映射 I/O   直接存储器存取  CPU 从 I/O 控制器请求数据浪费 CPU 时间，所以经常用到一种称为直接存储器存取的方案。 DMA 的工作过程  CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA 控制器知道将什么数据传送到什么地方。 DMA 控制器通过在总线上发出一个读请求到磁盘控制器而发起 DMA 传送 磁盘控制器从其内部缓冲区读取内容后，写到内存中。 当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器 DMA 控制器步增要使用的内存地址，井且步减字节计数。如果字节计数仍然大于 O, 则重复第 2 步到第 4 步，直到字节计数到达 0。此时，DMA 控制器将中断 CPU 以便让 CPU 知道传送现在已经完成了。当操作系统开始工作时，用不着将磁盘块复制到内存中，因为它已经在内存中了。   总线操作模式  字模式：DMA 控制器请求传送一个字并且得到这个字。如果 CPU 也想使用总线，它必须等待。这一机制称为周期窃取(cycle stealing),因为设备控制器偶尔偷偷溜入并且从 CPU 偷走一个临时的总线周期，从而轻微地延迟 CPU。 块模式：在块模式中，DMA 控制器通知设备获得总线，发起一连串的传送，然后释放总线。这一操作形式称为突发模式 (burst mode)。它比周期窃取效率更高，因为获得总线占用了时间，井且以一次总线获得的代价能够传送多个字。突发模式的缺点是，如果正在进行的是长时间突发传送，有可能将 CPU 和其他设备阻塞相当长的周期。 飞跃模式：DMA 控制器通知设备控制器直接将数据传送到主存。某些 DMA 控制器使用的其他校式是让设备控制器将字发送给 DMA 控制器.">
<link rel=stylesheet href=/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q==">
<link rel=stylesheet href=/css/custom.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]-->
<link rel=icon type=image/png href=/images/favicon.ico>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-X1L70M4MM0','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<meta name=referrer content="no-referrer-when-downgrade">
</head>
<body class="max-width mx-auto px3 ltr">
<div class="content index py4">
<header id=header>
<a href=/>
<div id=logo style=background-image:url(/images/logo.png)></div>
<div id=title>
<h1>Y.CH.Y</h1>
</div>
</a>
<div id=nav>
<ul>
<li class=icon>
<a href=# aria-label=Menu><i class="fas fa-bars fa-2x" aria-hidden=true></i></a>
</li>
<li><a href=/>首页</a></li>
<li><a href=/books>书单</a></li>
</ul>
</div>
</header>
<article class=post itemscope itemtype=http://schema.org/BlogPosting>
<div class=content itemprop=articleBody>
<h2 id=输入输出>输入/输出</h2>
<ul>
<li>I/O 硬件原理
<ul>
<li>I/O 设备
<ul>
<li>分类
<ul>
<li>块设备，块设备把信息存储在固定大小的块中.每个块有自己的地址。通常块的大小在 512 字节至 65536 字节之间。所有传输以一个或多个完整的(连续的)块为单位。块设备的基本特征是每个块都能独立干其他块而读写。硬盘、蓝光光盘和 USB 盘是最常见的块设备。</li>
<li>字符设备，字符设备以字符为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。打印机、鼠标、键盘以及大多数与磁盘不同的设备都可以看作字符设备。</li>
</ul>
</li>
<li>设备控制器
<ul>
<li>I/O 设备一般由机械部件和电子部件两部分组成。通常可以将这两部分分开处理，以提供更加模块化和更加通用的设计。电子部件称作设备控制器 (device controller) 或适配器 (adapter)。在个人计算机上，它经常以主板上的芯片的形式出现，或者以插入 (PCI) 扩展槽中的印刷电路板的形式出现。机械部件则是设备本身。</li>
<li>控制器与设备之间的接口通常是一个很低层次的接口。</li>
<li>控制器的任务是把串行的位流转换为字节块，井进行必要的错误校正工作。</li>
</ul>
</li>
<li>内存映射 I/O
<ul>
<li>每个控制器有几个寄存器用来与 CPU 进行通信。通过写人这些寄存器，操作系统可以命令设备发送数据接收数据、开启或关闭，或者执行某些其他操作。通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。</li>
<li>除了这些控制寄存器以外，许多设备还有一个操作系统可以读写的数据缓冲区。</li>
<li>每个控制寄存器被分配一个 I/O 端口 (I/O port) 号，这是一个 8 位或 16 位的整数。所 有 I/O 端口形成 I/O 端口空间 (I/O port space), 井且受到保护使得普通的用户程序不能对其进行访问(只有操作系统可以访问)。CPU 通过这个 I/O 端口和控制器通信。</li>
<li>另一种方式是将所有控制寄存器映射到内存空间中，每个控制寄存器被分配唯一的一个内存地址，井且不会有内存被分配这一地址。这样的系统称为内存映射 I/O</li>
</ul>
</li>
<li>直接存储器存取
<ul>
<li>CPU 从 I/O 控制器请求数据浪费 CPU 时间，所以经常用到一种称为直接存储器存取的方案。</li>
<li>DMA 的工作过程
<ul>
<li>CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA 控制器知道将什么数据传送到什么地方。</li>
<li>DMA 控制器通过在总线上发出一个读请求到磁盘控制器而发起 DMA 传送</li>
<li>磁盘控制器从其内部缓冲区读取内容后，写到内存中。</li>
<li>当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器</li>
<li>DMA 控制器步增要使用的内存地址，井且步减字节计数。如果字节计数仍然大于 O, 则重复第 2 步到第 4 步，直到字节计数到达 0。此时，DMA 控制器将中断 CPU 以便让 CPU 知道传送现在已经完成了。当操作系统开始工作时，用不着将磁盘块复制到内存中，因为它已经在内存中了。</li>
</ul>
</li>
<li>总线操作模式
<ul>
<li>字模式：DMA 控制器请求传送一个字并且得到这个字。如果 CPU 也想使用总线，它必须等待。这一机制称为周期窃取(cycle stealing),因为设备控制器偶尔偷偷溜入并且从 CPU 偷走一个临时的总线周期，从而轻微地延迟 CPU。</li>
<li>块模式：在块模式中，DMA 控制器通知设备获得总线，发起一连串的传送，然后释放总线。这一操作形式称为突发模式 (burst mode)。它比周期窃取效率更高，因为获得总线占用了时间，井且以一次总线获得的代价能够传送多个字。突发模式的缺点是，如果正在进行的是长时间突发传送，有可能将 CPU 和其他设备阻塞相当长的周期。</li>
<li>飞跃模式：DMA 控制器通知设备控制器直接将数据传送到主存。某些 DMA 控制器使用的其他校式是让设备控制器将字发送给 DMA 控制器. DMA 控制器然后发起第 2 个总线请求将该字写到它应该去的任何地方。采用这种方案，每传送一个字需要一个额外的总线周期，但是更加灵活，因为它可以执行设备到设备的复制甚至是内存到内存的复制。</li>
</ul>
</li>
</ul>
</li>
<li>重温中断
<ul>
<li>在硬件层面，中断的工作如下所述。当一个 I/O 设备完成交给它的工作时，它就产生一个中断(假设操作系统已经开放中断)，它是通过在分配给它的一条总线信号线上置起信号而产生中断的。该信号被主板上的中断控制器芯片检测到，由中断控制器芯片决定做什么。</li>
<li>中断信号导致 CPU 停止当前正在做的工作井且开始做其他的事情。地址线上的数字被用做指向一个称为中断向量 (interrupt vector) 的表格的索引，以便读取一个新的程序计数器。这一程序计数器指向相应的中断服务过程的开始.</li>
<li>中断服务过程开始运行后，它立刻通过将一个确定的值写到中断控制器的某个 I/O 端口来对中断做出应答。这一应答告诉中断控制器可以自由地发出另一个中断。通过让 CPU 延迟这一应答直到它准备好处理下一个中断，就可以避免与多个几乎同时发生的中断相牵涉的竞争状态。</li>
<li>在开始服务程序前，硬件需要保存必要的信息。</li>
<li>精确中断和不精确中断
<ul>
<li>将机器留在一个明确状态的中断称为精确中断
<ul>
<li>PC(程序计数器)保存在一个已知的地方 。</li>
<li>PC 所指向的指令之前的所有指令已经完全执行。</li>
<li>PC 所指向的指令之后的所有指令都没有执行。</li>
<li>PC 所指向的指令的执行状态是已知的。</li>
</ul>
</li>
<li>不满足以上条件的中断称为不精确中断
<ul>
<li>具有不精确中断的机器通常将大量的内部状态"吐出”到堆栈中，从而使操作系统有可能判断出正在发生什么事情。重新启动机器所必需的代码通常极其复杂。此外，在每次中断发生时将大让的信息保存在内存中使得中断响应十分缓慢，而恢复则更加糟糕。</li>
<li>某些超标量计算机(例如 x86 系列)具有精确中断，从而使老的软件正确工作。为与精确中断保持后向兼容付出的代价是 CPU 内部极其复杂的中断逻辑，以便确保当中断控制器发出信号想要导致一个中断时，允许直到某一点之前的所有指令完成而不允许这一点之后的指令对机器状态产生任何重要的影响。</li>
<li>此处付出的代价不是在时间上，而是在芯片面积和设计复杂性上。如果不是因为向后兼容的目的而要求精确中断的话，这一芯片面积就可以用于更大的片上高速缓存，从而使 CPU 的速度更快。另一方面，不精确中断使得操作系统更为复杂而且运行得更加缓慢，所以断定哪一种方法更好是十分困难的.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>I/O 软件原理
<ul>
<li>I/O 软件的目标
<ul>
<li>在设计 I/O 软件时一个关键的概念是设备独立性 (device independence)。它的意思是应该能够编写出这样的程序:它可以访问任意 I/O 设备而无需事先指定设备。</li>
<li>与设备独立性密切相关的是统一命名 (uniform naming) 这一目标。一个文件或一个设备的名字应该是一个简单的字符串或一个整数，它不应依赖于设备。</li>
<li>I/O 软件的另一个重要问题是错误处理 (error handling)。一般来说，错误应该尽可能地在接近硬件的层面得到处理。只有在低层软件处理不了的情况下，才将错误上交高层处理。在许多情况下，错误恢复可以在低层透明地得到解决，而高层软件甚至不知道存在这一错误。</li>
<li>同步 (synchronous 即阻塞)和异步 (asynchronous, 即中断驱动)传输。大多数物理 I/0 是异步的，CPU 启动传输后便转去做其他工作，直到中断发生。如果 I/O 操作是阻塞的，那么用户程序就更加容易编写一在 read 系统调用之后，程序将自动被挂起，直到缓冲区中的数据准备好。正是操作系统使实际上是中断驱动的操作变为在用户程序看来是阻塞式的操作。然而，某些性能极高的 应用程序需要控制 I/O 的所有细节，所以某些操作系统使异步 I/O 对这样的应用程序是可用的。</li>
<li>缓冲 (buffering)。数据离开一个设备之后通常并不能直接存放到其最终的目的地，而是放到了某个地方对它进行检查，才能确定最后需要发送到哪里，缓冲区填满和清空的速率也影响 I/O 性能。</li>
<li>设备独占和共享问题。打印机之类的只允许一个用户使用，某些文件被多人打开同时写入。</li>
</ul>
</li>
<li>程序控制 I/O
<ul>
<li>考虑一个用户进程，该进程想通过串行接口在打印机 上打印 8 个字符的字符串"ABCDEFGH"。</li>
<li>软件首先要在用户空间的一个缓冲区中组装字符串</li>
<li>用户进程通过发出打开打印机一类的系统调用来获得打印机以便进行写操作</li>
<li>操作系统(通常)将字符串缓冲区复制到内核空间中的一个数组(如 p)中</li>
<li>操作系统要查看打印机当前是否可用。如果不可用，就要等待直到它可用</li>
<li>操作系统就复制第一个字符到打印机的数据寄存器中，在这个例子中使用了内存映射 I/O</li>
<li>这时，操作系统将等待打印机状态再次变为就绪。打印机就绪事件发生时，操作系统就打印下一个字符，直到过程完成，返回用户进程。</li>
</ul>
</li>
<li>中断驱动 I/O
<ul>
<li>在不缓冲字符而是在每个字符到来时便打印的打印机上进行打印的情形。</li>
<li>当程序把字符写入打印机的寄存器后，在打印机就绪前切换上下文去执行别的程序。</li>
<li>当打印机就绪的时候发出一个中断，程序被调度回来继续执行直到完成。</li>
</ul>
</li>
<li>使用 DMA 的 I/O
<ul>
<li>让 DMA 控制器而不是 CPU 完成任务，中断次数每字节一次变成没缓冲区一次。</li>
</ul>
</li>
</ul>
</li>
<li>I/O 软件层次
<ul>
<li>中断处理程序
<ul>
<li>虽然程序控制 I/O 偶尔是有益的，但是对于大多数 I/O 而言，中断是令人不愉快的事情并且无法避免。应当将其深深隐藏在操作系统内部，一边系统的其他部分尽量不与它发生联系。隐藏它们的最好办法是将启动一个 I/O 操作的驱动程序阻塞起来，直到 I/O 操作完成并且产生一个中断。</li>
<li>当中断发生时，中断处理程序将做它必须要做的全部工作以便对中断进行处理。</li>
<li>中断最终的结果是使先前被阻塞的驱动程序现在能够继续运行。</li>
<li>处理过程
<ul>
<li>保存没有被中断硬件保存的所有寄存器(包括 PSW)。</li>
<li>为中断服务过程设置上下文，可能包括设置 TLB、 MMU 和页表。</li>
<li>为中断服务过程设置堆栈.</li>
<li>应答中断控制器，如果不存在集中的中断控制器，则再次开放中断。</li>
<li>将寄存器从它们被保存的地方(可能是某个堆栈)复制到进程表中。</li>
<li>运行中断服务过程，从发出中断的设备控制器的寄存器中提取信息.</li>
<li>选择下一次运行哪个进程，如果中断导致某个被阻塞的高优先级进程变为就绪，则可能选择它现在就运行。</li>
<li>为下一次要运行的进程设置 MMU 上下文，也许还蒂要设置某个 TLB。</li>
<li>装入新进程的寄存器，包括其 PSW。</li>
<li>开始运行新进程。</li>
</ul>
</li>
</ul>
</li>
<li>设备驱动程序
<ul>
<li>每一个控制器都设有某些设备寄存器用来向设备发出命令，或者设有某些设备寄存器用来读出设备的状态，或者设有这两种设备寄存器，寄存器的数量根据功能不同在不同的设备之间数量也不同。</li>
<li>每个连接到计算机上的 I/O 设备都需要某些设备特定的代码来对其进行控制。这样的代码称为设备驱动程序 (device driver), 它一般由设备的制造商编写并随同设备一起交付。</li>
<li>每个设备驱动程序通常处理一种类型的设备，或者至多处理一类紧密相关的设备。</li>
<li>不过在有些时候，极其不同的设备却基于相同的底层技术。众所周知的例子可能是 USB。</li>
<li>驱动程序必须是重入的 (reentrant), 这意味着一个正在运行的驱动程序必须预料到在第一次调用完成之前第二次被调用。</li>
<li>在一个可热插拔的系统中，设备可以在计算机运行时添加或删除。</li>
<li>驱动程序不允许进行系统调用，但是它们经常需要与内核的其余部分进行交互。对某些内核过程的调用通常是允许的。</li>
</ul>
</li>
<li>与设备无关的 I/O 软件
<ul>
<li>设备驱动程序的统一接口
<ul>
<li>操作系统定义一组驱动程序必须支持的函数。</li>
<li>设备无关的软件要负责把符号化的设备名映射到适当的驱动程序上。</li>
<li>所有设备都具有主设备号和次设备号，并且所有驱动程序都是通过使用主设备号来选择驱动程序而得到访问。</li>
<li>在 UNIX 和 Windows 中.设备是作为命名对象出现在文件系统中的，这意味着针对文件的常规的保护规则也适用千 I/O 设备。系统管理员可以为每一个设备设置适当的访问权限。</li>
</ul>
</li>
<li>缓冲
<ul>
<li>实现方案
<ul>
<li>用户进程在用户空间中提供了一个包含 n 个字符的缓冲区，并且执行读入 n 个字符的读操作。中断服务过程负责将到来的字符放入该缓冲区中直到缓冲区填满，然后唤醒用户进程。</li>
<li>在内核空间中创建一个缓冲区并且让中断处理程序将字符放到这个缓冲区中。</li>
</ul>
</li>
<li>结构
<ul>
<li>双缓冲，当一个缓冲区满的时候使用另一个缓冲区</li>
<li>环形缓冲区，它由一个内存区域和两个指针组成。一个指针指向下一个空闲的字，新的数据可以放置到此处。另一个指针指向缓冲区中数据的第一个字，该字尚未被取走。</li>
</ul>
</li>
</ul>
</li>
<li>错误报告
<ul>
<li>错误在 I/O 上下文中比在其他上下文中要常见得多。当错误发生时，操作系统必须尽最大努力对它们进行处理。许多错误是设备特定的并且必须由适当的驱动程序来处理，但是错误处理的框架是设备无关的.</li>
<li>一种类型的 I/O 错误是编程错误，解决方案是将错误码返回给调用者。</li>
<li>另一种类型的错误是实际的 I/O 错误，如磁盘损坏，在这些情形中，应该由驱动程序决定做什么。如果驱动程序不知道做什么，它应该将问题向上传递，返回给与设备无关的软件。</li>
</ul>
</li>
<li>分配与释放专用设备
<ul>
<li>某些设备，例如打印机，在任意给定的时刻只能由一个进程使用。这就要求操作系统对设备使用的诮求进行检查，并且根据被访求的设备是否可用来接受或者拒绝这些请求。</li>
</ul>
</li>
<li>与设备无关的块大小
<ul>
<li>应该由与设备无关的软件来隐藏这一事实井且向高层提供一个统一的块大小</li>
</ul>
</li>
<li>用户空间的 I/O 软件
<ul>
<li>大多数 I/O 事件都发生在内核，但还是有小部分发生在用户空间</li>
<li>假脱机目录，脱离操作系统的 I/O 事件，将需要发送的块放到文件目录中，稍后由守护进程发送出去</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>盘
<ul>
<li>盘硬件
<ul>
<li>磁盘
<ul>
<li>磁盘被组织成柱面，每一个柱面包含若干磁道，磁道数与垂直堆叠的磁头个数相同。磁道又被分成若干扇区，软盘上大约每条磁道有 8~32 个扇区，硬盘上每条磁道上扇区的数目可以多达几百个。磁头 数大约是 1 ~ 16 个。</li>
<li>磁盘驱动器本身包含一个微控制器，该微控制器承担了大员的工作并且允许实际的控制器发出一组高级命令。控制器经常做磁道高速缓存、坏块重映射以及更多的工作。</li>
<li>对磁盘驱动程序有重要意义的一个设备特性是:控制器是否可以同时控制两个或多个驱动器进行寻道，这就是重叠寻道 (overlapped seek)。当控制器和软件等待一个驱动器完成寻道时，控制器可以同时启动另一个驱动器进行寻道。许多控制器也可以在一个驱动器上进行读写操作，与此同时再对另一个或多个其他驱动器进行寻道，但是软盘控制器不能在两个驱动器上同时进行读写操作。</li>
<li>所有现代磁盘现在都支持一种称为逻辑块寻址，而不管磁盘的几何规格如何</li>
</ul>
</li>
<li>RAID
<ul>
<li>RAID 定义为 Redundant Array of Inexpensive Disk (廉价磁盘冗余阵列)，但是工业界将 I 重定义为 Independent (独立)而不是 Inexpensive (廉价)</li>
<li>RAID 背后的基本思想是将一个装满了磁盘的盒子安装到计算机(通常是一个大型服务器)上，用 RAID 控制器替换磁盘控制器卡，将数据复制到整个 RAID 上，然后继续常规的操作。</li>
<li>所有的 RAID 都具有同样的特性，那就是将数据分布在全部驱动器上，这样就可以并行操作。</li>
</ul>
</li>
</ul>
</li>
<li>磁盘格式化
<ul>
<li>一个扇区由前导码，数据，ECC 组成。
<ul>
<li>前导码以一定的位模式开始，位模式使硬件得以识别扇区的开始。前导码还包含柱面与扇区号以及某些其他信息。</li>
<li>数据部分的大小是由低级格式化程序决定的，大多数磁盘使用 512 字节的扇区。</li>
<li>ECC 域包含冗余信息，可以用来恢复读错误</li>
<li>低级格式化的结果是磁盘容量减少，减少的摄取决于前导码、扇区间间隙和 ECC 的大小以及保留的备用扇区的数目。通常格式化的容量比未格式化的容量低 20%。备用扇区不计人格式化的容量，所以一种给定类型的所有磁盘在出厂时具有完全相同的容址，与它们实际具有多少坏扇区无关</li>
<li>在低级格式化完成之后，要对磁盘进行分区。在逻辑上，每个分区就像是一个独立的磁盘.分区对于实现多个操作系统共存是必要的。</li>
</ul>
</li>
</ul>
</li>
<li>磁盘臂调度算法
<ul>
<li>影响读写磁盘块时间的因素
<ul>
<li>寻道时间</li>
<li>旋转延迟</li>
<li>实际数据传输延迟</li>
</ul>
</li>
<li>调度算法
<ul>
<li>先来先服务：磁盘驱动程序每次接收一个诘求井按照接收顺序完成请求</li>
<li>最短寻道优先：总是处理与磁头距离最近的请求以使寻道时间最小化</li>
<li>电梯算法：电梯保持按一个方向移动，直到在那个方向上没有请求为止，然后改变方向</li>
</ul>
</li>
<li>缓存
<ul>
<li>许多磁盘控制器总是读出多个扇区并对其进行高速缓存</li>
<li>高速缓存的使用是由控制器动态地决定的。在最简单的模式下，高速缓存被分成两个区段，一个用于读，一个用于写</li>
<li>磁盘控制器的高速缓存完全独立千操作系统的高速缓存</li>
</ul>
</li>
</ul>
</li>
<li>错误处理
<ul>
<li>对于坏块存在两种一般的处理方法:在控制器中对它们进行处理或者在操作系统中对它们进行处理。在前一种方法中，磁盘在从工厂出厂之前要进行测试，井且将一个坏扇区列表写在磁盘上。对千每一个坏扇区，用一个备用扇区替换它 。
<ul>
<li>有两种方法进行这样的替换
<ul>
<li>控制器所能够做的事情是将备用扇区之一重映射为坏扇区</li>
<li>另一种方法是将所有扇区向上移动一个扇区</li>
<li>在这两种情况下，控制器都必须知道哪个扇区是哪个扇区。它可以通过内部的表来跟踪这一信息(每个磁道一张表)，或者通过重写前导码来给出重映射的扇区号。</li>
</ul>
</li>
</ul>
</li>
<li>第二种操作系统必须首先获得一个坏扇区列表，或者是通过从磁盘中读出该列表，或者只是由它自己测试整个磁盘。一旦操作系统知道哪些扇区是坏的，它就可以建立项映射表。</li>
<li>除了磁盘坏块还有寻道错误，大多数磁盘可以自动回复，通过把磁臂往外移动，并把当前柱面重置为 0</li>
</ul>
</li>
<li>稳定存储器
<ul>
<li>一个磁盘子系统具有如下特性:当 一个写命令发给它时，磁盘要么正确地写数据，要么什么也不做，让现有的数据完整无缺地留下。</li>
<li>稳定存储器使用一对完全相同的磁盘，对应的块一同工作以形成一个无差错的块。当不存在错误时， 在两个驱动器上对应的块是相同的，读取任意一个都可以得到相同的结果。
<ul>
<li>稳定写 (stable write)。稳定写首先将块写到驱动器 1 上，然后将其读回以校验写的是正确的。如果写的不正确，那么就再次做写和重读操作，一直到 n 次，直到正常为止。经过 n 次连续的失败之后，就将该块重映射到一个备用块上，并且重复写和重读操作直到成功为止，无论要尝试多少个备用块。在对驱动器 1 的写成功之后，对驱动器 2 上对应的块进行写和重读，如果需要的话就重复这样的操作，直到最后成功为止。如果不存在 CPU 崩溃，那么当稳定写完成后，块就正确地被写到两个驱动器上，井且在两个驱动器上得到校验。</li>
<li>稳定读 (stable read)。稳定读首先从驱动器 1 上读取块。如果这一橾作产生错误的 ECC, 则再次尝试读操作，一直到 n 次。如果所有这些操作都给出错误的 ECC, 则从驱动器 2 上读取对应的数据块。给定一个成功的稳定写为数据块留下两个可靠的副本这样的事实，并且我们假设在合理的时间间隔内相同的块在两个驱动器上自发地变坏的概率可以忽略不计，那么稳定读就总是成功的 。</li>
<li>崩溃恢复 (crash recovery)。崩溃之后，恢复程序扫描两个磁盘，比较对应的块。如果一对块都是好的井且是相同的，就什么都不做。 如果其中一个具有 ECC 错误，那么坏块就用对应的好块来覆盖. 如果一对块都是好的但是不相同，那么就将驱动器 1 上的块写到驱动器 2 上。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>时钟
<ul>
<li>时钟硬件
<ul>
<li>时钟由三个部件构成: 晶体振荡器、计数器和存储寄存器</li>
<li>当把一块石英晶体适当地切割并且安装在一定的电压之下时，它就可以产生非常精确的周期性信号，典型的频率范围是几百兆赫兹，具体的频率值与所选的品体有关。</li>
<li>在任何一台计算机里通常都可以找到至少一个这样的电路，它给计算机的各种电路提供同步信号。该信号被送到计数器，使其递减计数至 0。当计数器变为 0 时，产生一个 CPU 中断。</li>
<li>可编程时钟通常具有几种操作模式
<ul>
<li>一次完成模式
<ul>
<li>当时钟启动时，它把存储寄存器的值复制到计数器中，然后，来自晶体的每一个脉冲使计数器减 1。当计数器变为 0 时，产生一个中断，井停止工作，直到软件再一次显式地启动它</li>
</ul>
</li>
<li>方波模式
<ul>
<li>当计数器变为 0 井且产生中断之后，存储寄存器的值自动复制到计数器中，并且整个过程无限期地再次重复下去。这些周期性的中断称为时钟滴答</li>
</ul>
</li>
</ul>
</li>
<li>可编程时钟芯片通常包含多个独立的可编程时钟</li>
</ul>
</li>
<li>时钟软件
<ul>
<li>时钟硬件所做的全部工作是根据已知的时间间隔产生中断。涉及时间的其他所有工作都必须由软件时钟驱动程序完成.
<ul>
<li>维护日时间
<ul>
<li>用 64 位寄存器存滴答数</li>
<li>以秒为单位维护时间</li>
<li>以秒为单位的系统引导时间</li>
</ul>
</li>
<li>防止进程超时运行
<ul>
<li>每当启动一个进程时，调度程序就将一个计数器初始化为 1，以时钟滴答为单位的该进程时间片的取值。每次时钟中断时，时钟驱动程序将时间片计数器减 1。当计数器变为 0 时，时钟驱动程序调用调度程序以激活另一个进程。</li>
</ul>
</li>
<li>对 CPU 的使用情况记账
<ul>
<li>启动一个不同于主系统定时器的辅助定时器。当进程终止时，读出这个定时器的值就可以知道该进程运行了多长时间</li>
</ul>
</li>
<li>处理用户进程提出的 alarm 系统调用
<ul>
<li>进程可以请求操作系统在一定的时间间隔之后向它报警。警报通常是信号、中断、消息或者类似的东西。需要这类报警的一个应用是网络，当一个数据包在一定时间间隔之内没有被确认时，该数据包必须重发。</li>
</ul>
</li>
<li>为系统本身的各个部分提供监视定时器
<ul>
<li>操作系统的组成部分也摇要设置定时器，这些定时器被称为监视定时器，并且经常用来检测死机之类的问题</li>
</ul>
</li>
<li>完成概要剖析、监视和统计信息收集
<ul>
<li>某些操作系统提供了一种机制，通过该机制用户程序可以让系统构造它的程序计数器的一个直方图，这样它就可以了解时间花在了什么地方。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>软定时器
<ul>
<li>无论何时当内核因某种其他原因在运行时，在它返回到用户态之前，它都要检查实时时钟以了解软定时器是否到期。如果这个定时器已经到期，则执行被调度的事件。如，传送数据包或者桧查到来的数据包，而无需切换到内核态，因为系统已经在内核态。在完成工作之后，软定时器被复位以便再次闹响。要做的全部工作是将当前时钟值复制给定时器并且将超时间隔加上。</li>
</ul>
</li>
</ul>
</li>
<li>用户界面:键盘、鼠标和监视器
<ul>
<li>输入软件
<ul>
<li>键盘软件
<ul>
<li>硬件所做的全部工作是给出键被按下和释放的中断，其他的事情由软件来做。</li>
<li>例如，当 A 键被按下时，扫描码(30)被写入一个 I/O 寄存器。驱动程序应该负责确定键入的是小写字母.大写字母、 CTRL-A、ALT-A、CTRL-ALT-A 还是某些其他组合。由于驱动程序以断定哪些键已经按下但是还没有被释放(例如 SHIFR), 所以它拥有足够多的信息来做这一工作。</li>
</ul>
</li>
<li>鼠标
<ul>
<li>当鼠标在随便哪个方向移动了一个确定的最小距离，或者按钮被按下或释放时，都会有一条消息发送给计算机。</li>
</ul>
</li>
</ul>
</li>
<li>输出软件
<ul>
<li>文本窗口
<ul>
<li>ASNI 标准，转移序列标准化，标准化移动光标等控制符的方式。</li>
</ul>
</li>
<li>X 窗口系统
<ul>
<li>几乎所有 UNIX 系统的用户界面都以 X 窗口系统 (X Window System) 为基础，</li>
<li>当 X 在一台机器上运行时，从键盘或鼠标采集输入并且将输出写到屏幕上的软件称为 X 服务器 (X server)。它必须跟踪当前选择了哪个窗口(鼠标指针所在处).这样它就知道将新的键盘输入发送给哪个客户。它与称为 X 客户 (X client) 的运行中的程序进行通信 (可能通过网络 )。它将键盘与鼠标输入发送给 X 客户，井且从 X 客户接收显示命令。</li>
<li>X 只是一个窗口系统，它不是一个完全的 GUI。为了获得完全的 GUI, 要在其上运行共他软件层。</li>
</ul>
</li>
<li>图形用户界面
<ul>
<li>GUI 软件可以在用户级代码中实现(如 UNIX 系统所做的那样)，也可以在操作系统中实现(如 Windows 的情况 ).</li>
<li>GUI 系统的输入仍然使用键盘和鼠标，但是输出几乎总是送往特殊的硬件电路板，称为 图形适配器(graphics adapter)。图形适配器包含特殊的内存，称为视频 RAM(video RAM),它保存出现在屏幕上的图像。</li>
</ul>
</li>
<li>位图
<ul>
<li>GDI 过程是矢量图形学的实例.它们用于在屏幕上放置几何图形和文本。</li>
<li>每一个网格方块的平均红、绿、蓝取值被采样井且保存为一个像素的值。这样的文件称为位图</li>
</ul>
</li>
<li>字体
<ul>
<li>TrueType 的引入解决了字体放大缩小都可以完整显示的问题。</li>
</ul>
</li>
<li>触摸屏
<ul>
<li>电阻屏，ITO 电荷移动获取位置</li>
<li>电容屏，有两层表面，手指触摸改变两层之间的电容。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>瘦客户机
<ul>
<li>大多数用户想要高性能的交互式计算，但是实在不想管理一台计算机。这一结论导致研究人员重新研究了分时系统使用的哑终端</li>
</ul>
</li>
<li>电源管理
<ul>
<li>硬件问题
<ul>
<li>电池一般分为两种类型: 一次性使用的和可再充电的。</li>
<li>通过电源按键休眠唤醒计算机</li>
<li>如何在休眠时候降低功耗</li>
</ul>
</li>
<li>操作系统问题
<ul>
<li>显示器，休眠唤醒，降低亮度</li>
<li>硬盘，在一定时间不读取时休眠，重新启动磁盘比较耗时，通过高速缓存降低延迟</li>
<li>CPU，cpu 降低电压和频率</li>
<li>内存，关闭高速缓存，将内容写到磁盘上然后关闭主存本身</li>
<li>无线通信，基站缓存消息，通行设备休眠并且不错过消息</li>
<li>热量管理，监控温度，在温度达到临界值时启动风扇</li>
<li>电池管理，当电量快耗尽提醒用户</li>
<li>驱动程序接口，操作系统可以发命令给驱动程序通知它们消减功耗</li>
</ul>
</li>
<li>应用程序问题
<ul>
<li>降低视频帧率，减少像素</li>
<li>降低语音识别器的功耗，使用比较小的词汇量和简单的声学模型</li>
<li>裁剪传输的内容，减少传输功耗</li>
<li>选择合适的 JPEG 算法</li>
</ul>
</li>
</ul>
</li>
<li>有关输入/输出的研究
<ul>
<li>改善输入/输出的底层结构</li>
<li>改善特定设备的表现</li>
<li>网络，服务质量和性能</li>
<li>减少能耗</li>
<li>时钟</li>
<li>中断延迟</li>
<li>设备驱动</li>
<li>瘦客户端</li>
</ul>
</li>
</ul>
</div>
</article>
<footer id=footer>
<div class=footer-left>
Copyright &copy; 2021 Y.CH.Y
</div>
<div class=footer-right>
<nav>
<ul>
<li><a href=/>首页</a></li>
<li><a href=/books>书单</a></li>
</ul>
</nav>
</div>
</footer>
</div>
</body>
<link rel=stylesheet href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>