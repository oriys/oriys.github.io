<!doctype html><html lang=en-us>
<head>
<link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous>
<script type=text/javascript src=https://latest.cactus.chat/cactus.js></script>
<link rel=stylesheet href=https://latest.cactus.chat/style.css type=text/css>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title> 计算机网络自顶向下方法::计算机网络中的安全 | Y.CH.Y</title>
<link rel=canonical href=/notes/computer_network_a_topdown_approach_08/>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="all,follow">
<meta name=googlebot content="index,follow,snippet,archive">
<meta property="og:title" content="计算机网络自顶向下方法::计算机网络中的安全">
<meta property="og:description" content="什么是网络中的安全  机密性 (confidentiality)。仅有发送方和希望的接收方能够理解传输报文的内容因为窃听者可以截获报文，这必须要求报文在一定程度上进行加密(encrypted),使截取的报文无法被截获者所理解。机密性的这个方面大概就是通常意义上对于术语安全通信的理解。 报文完整性 (message integrity)。Alice 和 Bob 希望确保其通信的内容在传输过程中未被改变——或者恶意篡改或者意外改动。我们在可靠传输和数据链路协议中遇到的检验和技术在扩展后能够用于提供这种报文完整性。 端点鉴别(end-point authentication)。发送方和接收方都应该能证实通信过程所涉及的另一方，以确信通信的另一方确实具有其所声称的身份。人类的面对面通信可以通过视觉识别轻易地解决这个问题。当通信实体在不能看到对方的媒体上交换报文时，鉴别就不是那么简单了。当某用户要访问一个邮箱时，邮件服务器如何证实该用户就是他所声称的那个人呢。 运行安全性(operational security)。几乎所有的机构（公司、大学等）今天都有了与公共因特网相连接的网络。这些网络都因此潜在地能够被危及安全。攻击者能够试图在网络主机中安放蠕虫，获取公司秘密，勘察内部网络配置并发起 DoS 攻击。我们将看到诸如防火墙和入侵检测系统等运行设备正被用于反制对机构网络的攻击。防火墙位于机构网络和公共网络之间，控制接入和来自网络的分组。入侵检测系统执行“深度分组检查“任务，向网络管理员发出有关可疑活动的警告。  密码学的原则  对称密钥密码体制  历史上的单密码  凯撒密码 单密码替换 多码代替密码   块密码  该密码用在多种因特网协议的加密中，包括 PGP (用于安全电子邮件）、SSL(用于使 TCP 连接更安全）和 IPsec(用于使网络层传输更安全）。 在块密码中，要加密的报文被处理为 K 比特的块。每块被独立加密。为了加密一个块，该密码采用了一对一映射，将 K 比特块的明文映射为 K 比特块的密文。 目前有一些流行的块密码，包括 DES (Data Encryption Standard, 数据加密标准）3DES 和 AES (Advanced Encryption Standard, 高级加密标准）。   密码块链接  在计算机网络应用中，通常需要加密长报文（或长数据流）。如果使用前面描述的块密码，通过直接将报文切割成 K 比特块并独立地加密每块，将出现一个微妙而重要的问题。为了理解这个问题，注意到两个或更多个明文块可能是相同的。例如，两个或更多块中的明文可能是 HHTTP/1.1 。对于这些相同的块，块密码当然将产生相同的密文。当攻击者看到相同的密文块时，它可能潜在地猜出其明文，并且通过识别相同的密文块和利用支撑协议结构的知识，甚至能够解密整个报文。为了解决这个问题，可以在密文中混合某些随机性，使得相同的明文块产生不同的密文块。     公开密钥加密  公开密钥密码学（英语：Public-key cryptography）也称非对称式密码学（英语：Asymmetric cryptography）是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；公钥用作加密，私钥则用作解密。使用公钥把明文加密后所得的密文，只能用相对应的私钥才能解密并得到原本的明文，最初用来加密的公钥不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。公钥可以公开，可任意向外发布；私钥不可以公开，必须由用户自行严格秘密保管，绝不透过任何途径向任何人提供，也不会透露给被信任的要通信的另一方。 RSA    报文完整性和数字签名  密码散列函数  MD5，SHA-1，SHA-256   报文鉴别码  发送发送方使用一个密钥和特定算法对明文产生一个短小的定长数据分组，即 MAC（报文鉴别码），并将它附加在报文中。在接收方，使用相同密钥的和算法对明文计算 MAC，如果新的 MAC 与报文中的 MAC 匹配，那么接受者确信报文未被修改过，接受者确信报文来自所期望的发送方。   数字签名  在数字领域，人们通常需要指出一个文件的所有者或创作者，或者表明某人认可一个文件内容。数字签名(digital signature) 就是一种在数字领域实现这些目标的密码技术。 Bob 让他的初始长报文通过一个散列函数。然后他用自己的私钥对得到的散列进行数字签名。明文形式的初始报文连同已经数字签名的报文摘要（从此以后可称为数字签名）一道被发送给 Alice。 Alice 先把发送方的公钥应用于报文获得一个散列结果。然后她再把该散列函数应用于明文报文以得到第二个散列结果。如果这两个散列匹配，则 Alice 可以确信报文的完整性及其发送方 。 公钥认证  数字签名的一个重要应用是公钥认证 (public key certification),即证实一个公钥属于某个特定的实体。公钥认证用在许多流行的安全网络协议中，包括 IPsec 和 SSL。 CA 证实一个实体（ 一个人 、一台路由器等）的真实身份。如何进行认证并没有强制的过程。当与一个 CA 打交道时，一方必须信任这个 CA 能够执行适当的严格身份验证。 一旦 CA 验证了某个实体的身份，这个 CA 会生成一个将其身份和实体的公钥绑定起来的证书(certificate)。这个证书包含这个公钥和公钥所有者全局唯一的身份标识信息（例如，一个人的名字或一个 IP 地址）。由 CA 对这个证书进行数字签名。      端点鉴别  当经网络进行鉴别时，通信各方不能依靠生物信息比如外表、声波纹等进行身份鉴别。的确，我们会在后面的实例研究中看到，诸如路由器、客户／服务器进程等网络元素通常必须相互鉴别。此处，鉴别应当在报文和数据交换的基础上，作为某鉴别协议 (authentication protocol)的一部分独立完成。鉴别协议通常在两个通信实体运行其他协议（例如，可靠数据传输协议、路由选择信息交换协议或电子邮件协议）之前运行。鉴别协议首先建立相互满意的各方的标识；仅当鉴别完成之后，各方才继续下面的工作。 不重数和对称密钥密码体制    Alice 向 Bob 发送报文“我是 Alice&#34; 。    Bob 选择一个不重数 R , 然后把这个值发送给 Alice 。    Alice 使用她与 Bob 共享的对称秘密密钥 \(K_{A-B}\) 来加密这个不重数，然后把加密的不 重数 \(K_{A-B}(R)\) 发回给 Bob。与在协议 ap3.">
<meta property="og:type" content="article">
<meta property="og:url" content="/notes/computer_network_a_topdown_approach_08/"><meta property="article:section" content="notes">
<meta property="article:published_time" content="2021-06-19T20:28:06+08:00">
<meta property="article:modified_time" content="2021-06-19T20:28:06+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="计算机网络自顶向下方法::计算机网络中的安全">
<meta name=twitter:description content="什么是网络中的安全  机密性 (confidentiality)。仅有发送方和希望的接收方能够理解传输报文的内容因为窃听者可以截获报文，这必须要求报文在一定程度上进行加密(encrypted),使截取的报文无法被截获者所理解。机密性的这个方面大概就是通常意义上对于术语安全通信的理解。 报文完整性 (message integrity)。Alice 和 Bob 希望确保其通信的内容在传输过程中未被改变——或者恶意篡改或者意外改动。我们在可靠传输和数据链路协议中遇到的检验和技术在扩展后能够用于提供这种报文完整性。 端点鉴别(end-point authentication)。发送方和接收方都应该能证实通信过程所涉及的另一方，以确信通信的另一方确实具有其所声称的身份。人类的面对面通信可以通过视觉识别轻易地解决这个问题。当通信实体在不能看到对方的媒体上交换报文时，鉴别就不是那么简单了。当某用户要访问一个邮箱时，邮件服务器如何证实该用户就是他所声称的那个人呢。 运行安全性(operational security)。几乎所有的机构（公司、大学等）今天都有了与公共因特网相连接的网络。这些网络都因此潜在地能够被危及安全。攻击者能够试图在网络主机中安放蠕虫，获取公司秘密，勘察内部网络配置并发起 DoS 攻击。我们将看到诸如防火墙和入侵检测系统等运行设备正被用于反制对机构网络的攻击。防火墙位于机构网络和公共网络之间，控制接入和来自网络的分组。入侵检测系统执行“深度分组检查“任务，向网络管理员发出有关可疑活动的警告。  密码学的原则  对称密钥密码体制  历史上的单密码  凯撒密码 单密码替换 多码代替密码   块密码  该密码用在多种因特网协议的加密中，包括 PGP (用于安全电子邮件）、SSL(用于使 TCP 连接更安全）和 IPsec(用于使网络层传输更安全）。 在块密码中，要加密的报文被处理为 K 比特的块。每块被独立加密。为了加密一个块，该密码采用了一对一映射，将 K 比特块的明文映射为 K 比特块的密文。 目前有一些流行的块密码，包括 DES (Data Encryption Standard, 数据加密标准）3DES 和 AES (Advanced Encryption Standard, 高级加密标准）。   密码块链接  在计算机网络应用中，通常需要加密长报文（或长数据流）。如果使用前面描述的块密码，通过直接将报文切割成 K 比特块并独立地加密每块，将出现一个微妙而重要的问题。为了理解这个问题，注意到两个或更多个明文块可能是相同的。例如，两个或更多块中的明文可能是 HHTTP/1.1 。对于这些相同的块，块密码当然将产生相同的密文。当攻击者看到相同的密文块时，它可能潜在地猜出其明文，并且通过识别相同的密文块和利用支撑协议结构的知识，甚至能够解密整个报文。为了解决这个问题，可以在密文中混合某些随机性，使得相同的明文块产生不同的密文块。     公开密钥加密  公开密钥密码学（英语：Public-key cryptography）也称非对称式密码学（英语：Asymmetric cryptography）是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；公钥用作加密，私钥则用作解密。使用公钥把明文加密后所得的密文，只能用相对应的私钥才能解密并得到原本的明文，最初用来加密的公钥不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。公钥可以公开，可任意向外发布；私钥不可以公开，必须由用户自行严格秘密保管，绝不透过任何途径向任何人提供，也不会透露给被信任的要通信的另一方。 RSA    报文完整性和数字签名  密码散列函数  MD5，SHA-1，SHA-256   报文鉴别码  发送发送方使用一个密钥和特定算法对明文产生一个短小的定长数据分组，即 MAC（报文鉴别码），并将它附加在报文中。在接收方，使用相同密钥的和算法对明文计算 MAC，如果新的 MAC 与报文中的 MAC 匹配，那么接受者确信报文未被修改过，接受者确信报文来自所期望的发送方。   数字签名  在数字领域，人们通常需要指出一个文件的所有者或创作者，或者表明某人认可一个文件内容。数字签名(digital signature) 就是一种在数字领域实现这些目标的密码技术。 Bob 让他的初始长报文通过一个散列函数。然后他用自己的私钥对得到的散列进行数字签名。明文形式的初始报文连同已经数字签名的报文摘要（从此以后可称为数字签名）一道被发送给 Alice。 Alice 先把发送方的公钥应用于报文获得一个散列结果。然后她再把该散列函数应用于明文报文以得到第二个散列结果。如果这两个散列匹配，则 Alice 可以确信报文的完整性及其发送方 。 公钥认证  数字签名的一个重要应用是公钥认证 (public key certification),即证实一个公钥属于某个特定的实体。公钥认证用在许多流行的安全网络协议中，包括 IPsec 和 SSL。 CA 证实一个实体（ 一个人 、一台路由器等）的真实身份。如何进行认证并没有强制的过程。当与一个 CA 打交道时，一方必须信任这个 CA 能够执行适当的严格身份验证。 一旦 CA 验证了某个实体的身份，这个 CA 会生成一个将其身份和实体的公钥绑定起来的证书(certificate)。这个证书包含这个公钥和公钥所有者全局唯一的身份标识信息（例如，一个人的名字或一个 IP 地址）。由 CA 对这个证书进行数字签名。      端点鉴别  当经网络进行鉴别时，通信各方不能依靠生物信息比如外表、声波纹等进行身份鉴别。的确，我们会在后面的实例研究中看到，诸如路由器、客户／服务器进程等网络元素通常必须相互鉴别。此处，鉴别应当在报文和数据交换的基础上，作为某鉴别协议 (authentication protocol)的一部分独立完成。鉴别协议通常在两个通信实体运行其他协议（例如，可靠数据传输协议、路由选择信息交换协议或电子邮件协议）之前运行。鉴别协议首先建立相互满意的各方的标识；仅当鉴别完成之后，各方才继续下面的工作。 不重数和对称密钥密码体制    Alice 向 Bob 发送报文“我是 Alice&#34; 。    Bob 选择一个不重数 R , 然后把这个值发送给 Alice 。    Alice 使用她与 Bob 共享的对称秘密密钥 \(K_{A-B}\) 来加密这个不重数，然后把加密的不 重数 \(K_{A-B}(R)\) 发回给 Bob。与在协议 ap3.">
<link rel=stylesheet href=/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q==">
<link rel=stylesheet href=/css/custom.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]-->
<link rel=icon type=image/png href=/images/favicon.ico>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-X1L70M4MM0','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<meta name=referrer content="no-referrer-when-downgrade">
</head>
<body class="max-width mx-auto px3 ltr">
<div class="content index py4">
<header id=header>
<a href=/>
<div id=logo style=background-image:url(/images/logo.png)></div>
<div id=title>
<h1>Y.CH.Y</h1>
</div>
</a>
<div id=nav>
<ul>
<li class=icon>
<a href=# aria-label=Menu><i class="fas fa-bars fa-2x" aria-hidden=true></i></a>
</li>
<li><a href=/>首页</a></li>
<li><a href></a></li>
</ul>
</div>
</header>
<article class=post itemscope itemtype=http://schema.org/BlogPosting>
<div class=content itemprop=articleBody>
<h2 id=什么是网络中的安全>什么是网络中的安全</h2>
<ul>
<li>机密性 (confidentiality)。仅有发送方和希望的接收方能够理解传输报文的内容因为窃听者可以截获报文，这必须要求报文在一定程度上进行加密(encrypted),使截取的报文无法被截获者所理解。机密性的这个方面大概就是通常意义上对于术语安全通信的理解。</li>
<li>报文完整性 (message integrity)。Alice 和 Bob 希望确保其通信的内容在传输过程中未被改变——或者恶意篡改或者意外改动。我们在可靠传输和数据链路协议中遇到的检验和技术在扩展后能够用于提供这种报文完整性。</li>
<li>端点鉴别(end-point authentication)。发送方和接收方都应该能证实通信过程所涉及的另一方，以确信通信的另一方确实具有其所声称的身份。人类的面对面通信可以通过视觉识别轻易地解决这个问题。当通信实体在不能看到对方的媒体上交换报文时，鉴别就不是那么简单了。当某用户要访问一个邮箱时，邮件服务器如何证实该用户就是他所声称的那个人呢。</li>
<li>运行安全性(operational security)。几乎所有的机构（公司、大学等）今天都有了与公共因特网相连接的网络。这些网络都因此潜在地能够被危及安全。攻击者能够试图在网络主机中安放蠕虫，获取公司秘密，勘察内部网络配置并发起 DoS 攻击。我们将看到诸如防火墙和入侵检测系统等运行设备正被用于反制对机构网络的攻击。防火墙位于机构网络和公共网络之间，控制接入和来自网络的分组。入侵检测系统执行“深度分组检查“任务，向网络管理员发出有关可疑活动的警告。</li>
</ul>
<h2 id=密码学的原则>密码学的原则</h2>
<ul>
<li>对称密钥密码体制
<ul>
<li>历史上的单密码
<ul>
<li>凯撒密码</li>
<li>单密码替换</li>
<li>多码代替密码</li>
</ul>
</li>
<li>块密码
<ul>
<li>该密码用在多种因特网协议的加密中，包括 PGP (用于安全电子邮件）、SSL(用于使 TCP 连接更安全）和 IPsec(用于使网络层传输更安全）。</li>
<li>在块密码中，要加密的报文被处理为 K 比特的块。每块被独立加密。为了加密一个块，该密码采用了一对一映射，将 K 比特块的明文映射为 K 比特块的密文。</li>
<li>目前有一些流行的块密码，包括 DES (Data Encryption Standard, 数据加密标准）3DES 和 AES (Advanced Encryption Standard, 高级加密标准）。</li>
</ul>
</li>
<li>密码块链接
<ul>
<li>在计算机网络应用中，通常需要加密长报文（或长数据流）。如果使用前面描述的块密码，通过直接将报文切割成 K 比特块并独立地加密每块，将出现一个微妙而重要的问题。为了理解这个问题，注意到两个或更多个明文块可能是相同的。例如，两个或更多块中的明文可能是 HHTTP/1.1 。对于这些相同的块，块密码当然将产生相同的密文。当攻击者看到相同的密文块时，它可能潜在地猜出其明文，并且通过识别相同的密文块和利用支撑协议结构的知识，甚至能够解密整个报文。为了解决这个问题，可以在密文中混合某些随机性，使得相同的明文块产生不同的密文块。</li>
</ul>
</li>
</ul>
</li>
<li>公开密钥加密
<ul>
<li>公开密钥密码学（英语：Public-key cryptography）也称非对称式密码学（英语：Asymmetric cryptography）是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；公钥用作加密，私钥则用作解密。使用公钥把明文加密后所得的密文，只能用相对应的私钥才能解密并得到原本的明文，最初用来加密的公钥不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。公钥可以公开，可任意向外发布；私钥不可以公开，必须由用户自行严格秘密保管，绝不透过任何途径向任何人提供，也不会透露给被信任的要通信的另一方。</li>
<li>RSA</li>
</ul>
</li>
</ul>
<h2 id=报文完整性和数字签名>报文完整性和数字签名</h2>
<ul>
<li>密码散列函数
<ul>
<li>MD5，SHA-1，SHA-256</li>
</ul>
</li>
<li>报文鉴别码
<ul>
<li>发送发送方使用一个密钥和特定算法对明文产生一个短小的定长数据分组，即 MAC（报文鉴别码），并将它附加在报文中。在接收方，使用相同密钥的和算法对明文计算 MAC，如果新的 MAC 与报文中的 MAC 匹配，那么接受者确信报文未被修改过，接受者确信报文来自所期望的发送方。</li>
</ul>
</li>
<li>数字签名
<ul>
<li>在数字领域，人们通常需要指出一个文件的所有者或创作者，或者表明某人认可一个文件内容。数字签名(digital signature) 就是一种在数字领域实现这些目标的密码技术。</li>
<li>Bob 让他的初始长报文通过一个散列函数。然后他用自己的私钥对得到的散列进行数字签名。明文形式的初始报文连同已经数字签名的报文摘要（从此以后可称为数字签名）一道被发送给 Alice。 Alice 先把发送方的公钥应用于报文获得一个散列结果。然后她再把该散列函数应用于明文报文以得到第二个散列结果。如果这两个散列匹配，则 Alice 可以确信报文的完整性及其发送方 。</li>
<li>公钥认证
<ul>
<li>数字签名的一个重要应用是公钥认证 (public key certification),即证实一个公钥属于某个特定的实体。公钥认证用在许多流行的安全网络协议中，包括 IPsec 和 SSL。</li>
<li>CA 证实一个实体（ 一个人 、一台路由器等）的真实身份。如何进行认证并没有强制的过程。当与一个 CA 打交道时，一方必须信任这个 CA 能够执行适当的严格身份验证。</li>
<li>一旦 CA 验证了某个实体的身份，这个 CA 会生成一个将其身份和实体的公钥绑定起来的证书(certificate)。这个证书包含这个公钥和公钥所有者全局唯一的身份标识信息（例如，一个人的名字或一个 IP 地址）。由 CA 对这个证书进行数字签名。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id=端点鉴别>端点鉴别</h2>
<ul>
<li>当经网络进行鉴别时，通信各方不能依靠生物信息比如外表、声波纹等进行身份鉴别。的确，我们会在后面的实例研究中看到，诸如路由器、客户／服务器进程等网络元素通常必须相互鉴别。此处，鉴别应当在报文和数据交换的基础上，作为某鉴别协议 (authentication protocol)的一部分独立完成。鉴别协议通常在两个通信实体运行其他协议（例如，可靠数据传输协议、路由选择信息交换协议或电子邮件协议）之前运行。鉴别协议首先建立相互满意的各方的标识；仅当鉴别完成之后，各方才继续下面的工作。</li>
<li>不重数和对称密钥密码体制
<ul>
<li>
<ol>
<li>Alice 向 Bob 发送报文“我是 Alice" 。</li>
</ol>
</li>
<li>
<ol start=2>
<li>Bob 选择一个不重数 R , 然后把这个值发送给 Alice 。</li>
</ol>
</li>
<li>
<ol start=3>
<li>Alice 使用她与 Bob 共享的对称秘密密钥 \(K_{A-B}\) 来加密这个不重数，然后把加密的不 重数 \(K_{A-B}(R)\) 发回给 Bob。与在协议 ap3.1 中一样，由于 Alice 知道 \(K_{A-B}\) 并用它加密一个值，就使得 Bob 知道收到的报文是由 Alice 产生的。这个不重数用于确定 Alice 是活跃的 。</li>
</ol>
</li>
<li>
<ol start=4>
<li>Bob 解密接收到的报文。如果解密得到的不重数等于他发送给 Alice 的那个不重数，则可鉴别 Alice 的身份 。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id=安全电子邮件>安全电子邮件</h2>
<ul>
<li>Alice 发送邮件时
<ul>
<li>Alice 对她要发送的报文 m 应用一个散列函数 H(例如 MD5), 从而得到一个报文摘要；</li>
<li>用她的私钥 SK 对散列函数的结果进行签名，从而得到一个数字签名；</li>
<li>把初始报文（未加密）和该数字签名级联起来生成一个包；</li>
<li>向 Bob 的电子邮件地址发送这个包。</li>
</ul>
</li>
<li>当 Bob 接收到这个包时
<ul>
<li>他将 Alice 的公钥 PBK 应用到被签名的报文摘要上；</li>
<li>将该操作的结果与他自己对该报的散列 H 进行比较</li>
</ul>
</li>
<li>PGP
<ul>
<li>安装 PGP 时，软件为用户产生一个公开密钥对。该公钥能被张贴到用户的网站上或放置在某台公钥服务器上。</li>
<li>私钥使用用户口令保护。</li>
<li>PGP 允许用户选择是否对报文加密，数字签名，并对数字签名加密。</li>
<li>PGP 也提供了一种公钥认证机制，但是这种机制与更为传统的 CA 差异很大。PGP 公钥由一个可信 Web 验证。当 Alice 相信 一个密钥／用户名对确实匹配时，她自己就可以验证这一密钥／用户名对。</li>
</ul>
</li>
</ul>
<h2 id=使-tcp-连接安全ssl>使 TCP 连接安全：SSL</h2>
<ul>
<li>TCP 的这种强化版本通常被称为安全套接字层(Secure Socket Layer, 修改的版本被称为运输层安全性(Transport Layer Secu1ily, SSL)。SSL 版本 3 的一个稍加修改的版本被称为运输层安全性（Transport Layer Securily，TLS), 已经由 IETF 标准化。</li>
<li>握手
<ul>
<li>Bob 与 Alice 创建一条 TCP 连接</li>
<li>验证 Alice 是真实的 Alice</li>
<li>发送给 Alice 一个主密钥，Bob 和 Alice 待用该主密钥生成 SSL 会话所需的所有对称密钥</li>
<li>一旦创建了 TCP 连接， Bob 就向 Alice 发送一个 hello 报文 。Alice 则用她的证书进行响应，证书中包含了她的公钥。因为该证书已被某 CA 证实过，Bob 明白无误地知道该公钥属于 Alice。</li>
<li>Bob 产生一个主密钥 (MS)(该 MS 将仅用于这个 SSL 会话），用 Alice 的公钥加密该 MS 以生成加密的主密钥 (EMS),并将该 EMS 发送给 Alice</li>
<li>Alice 用她的私钥解密该 EMS 从而得到该 MS</li>
</ul>
</li>
<li>SSL 握手
<ul>
<li>客户发送它支持的密码算法的列表，连同一个客户的不重数。</li>
<li>从该列表中，服务器选择一种对称算法（例如 AES)、一 种公钥算法（例如具有特定密钥长度的 RSA)和一种 MAC 算法。它把它的选择以及证书和一个服务器不重数返回给客户。</li>
<li>客户验证该证书，提取服务器的公钥，生成一个前主密钥（Pre-Master Secret,PMS），用服务器的公钥加密该 PMS, 并将加密的 PMS 发送给服务器 。</li>
<li>使用相同的密钥导出函数（就像 SSL 标准定义的那样），客户和服务器独立地从 PMS 和不重数中计算出主密钥(Master Secret,MS)。然后该 MS 被切片以生成两个密码和两个 MAC 密钥。此外，当选择的对称密码应用于 CBC(例如 3DES 或 AES),则两个初始化向量(Initialization Vector,IV)也从该 MS 获得，这两个 IV 分别用于该连接的两端。自此以后，客户和服务器之间发送的所有报文均被加密和鉴别（使用 MAC)。</li>
<li>客户发送所有握手报文的一个 MAC 。</li>
<li>服务器发送所有握手报文的一个 MAC 。</li>
</ul>
</li>
<li>关闭连接
<ul>
<li>在某个时刻，Bob 或者 Alice 将要终止 SSL 会话。一个方法是让 Bob 通过直接终止底层的 TCP 连接来结束该 SSL 会话，这就是说，通过让 Bob 向 Alice 发送一个 TCP FIN 报文段。但是这种幼稚设计为截断攻击(truncation attack)创造了条件，Trudy 再一次介入一个进行中的 SSL 会话中，并用 TCP FIN 过早地结束了该会话。如果 Trudy 这样做的话，Alice 将会认为她收到了 Bob 的所有数据，而实际上她仅收到了其中的一部分。对这个问题的解决方法是，在类型字段中指出该记录是否是用于终止该 SSL 会话的。（尽管 SSL 类型是以明文形式发送的，但在接收方使用了记录的 MAC 对它进行了鉴别。）通过包括这样一个字段，如果 Alice 在收到一个关闭 SSL 记录之前突然收到了一个 TCP FIN,她可能知道正在进行着某些耍花招的事情。</li>
</ul>
</li>
</ul>
<h2 id=网络层安全性ipsec-和虚拟安全网>网络层安全性：IPsec 和虚拟安全网</h2>
<ul>
<li>IP 安全(IP Security)协议更常被称为 IPsec,它为网络层提供了安全性。IPsec 为任意两个网络层实体（包括主机和路由器）之间的 IP 数据报提供了安全。如我们很快要描述的那样，许多机构（公司、政府部门、非营利组织等等）使用 IPsec 创建了运行在公共因特网之上的虚拟专用网 (Vir1ual Private, Network, VPN) 。</li>
<li>除了机密性，网络层安全协议潜在地能够提供其他安全性服务。例如，它能提供源鉴别，使得接收实体能够验证安全数据报的源。网络层安全协议能够提供数据完整性，使得接收实体能够核对在数据报传输过程中可能出现的任何篡改。网络层安全服务也能提供防止重放攻击功能，这意味着 Bob 能够检测任何攻击者可能插入的任何冗余数据报。我们将很快看到 IPsec 的确提供了用于些安全服务的机制，即机密性、源鉴别、数据完整性和重放攻击防护。</li>
<li>IPsec 和虚拟专用网
<ul>
<li>当总部中的一台主机向某旅馆中的某销售员发送一个 IP 数据报时，总部中的网关路由器将经典的 IPv4 转换成为 IPsec 数据报，然后将该 IPsec 数据报转发进因特网。该 IPsec 数据报实际上具有传统的 IPv4 首部，因此在公共因特网中的路由器处理该数据报，仿佛它对路由器而言是一个普通的 IPv4 数据报。IPsec 数据报的载荷包括了一个 IPsec 首部，该首部被用于 IPsec 处理；此外，IPsec 数据报的载荷是被加密的。当该 IPsec 数据报到达销售员的便携机时，便携机的操作系统解密载荷并提供其他安全服务，如验证数据完整性，并将解密的载荷传递给上层协议（例如，给 TCP 或 UDP)。</li>
</ul>
</li>
</ul>
<h2 id=运行安全性防火墙和入侵检测系统>运行安全性：防火墙和入侵检测系统</h2>
<ul>
<li>防火墙(firewall)是一个硬件和软件的结合体，它将一个机构的内部网络与整个因特网隔离开，允许一些数据分组通过而阻止另一些分组通过。防火墙允许网络管理员控制外部和被管理网络内部资源之间的访问，这种控制是通过管理流人和流出这些资源的流量实现的。
<ul>
<li>从外部到内部和从内部到外部的所有流量都通过防火墙。</li>
<li>仅被授权的流量（由本地安全策略定义）允许通过。</li>
<li>防火墙自身免于渗透。</li>
</ul>
</li>
<li>防火墙分类
<ul>
<li>传统分组过滤器 (traditional packet filter)
<ul>
<li>一个机构通常都有一个将其内部网络与其 ISP(并因此与更大的公共因特网相连）相连的网关路由器。所有离开和进入内部网络的流量都要经过这个路由器，而这个路由器正是分组过滤(packet filtering)出现的地方。分组过滤器独立地检查每个数据报，然后基于管理员特定的规则决定该数据报应当允许通过还是应当丢弃。</li>
</ul>
</li>
<li>状态过滤器 (slateful filter)
<ul>
<li>传统的防火墙无法管理连接，大量的连接仍然能使内部网络崩溃。状态过滤器通过用一张连接表来跟踪所有进行中的 TCP 连接来解决这个问题。防火墙能够通过观察三次握手(SYN、SYN ACK 和 ACK)来观察一条新连接的开始；而且当它看到该连接的一个 FIN 分组时，它能够观察该连接的结束，当防火墙经过比如说 60 秒还没有看到该连接的任何活动性，它也能够（保守地）假设该连接结束了。</li>
</ul>
</li>
<li>应用程序网关
<ul>
<li>为了得到更高水平的安全性，防火墙必须把分组过滤器和应用程序网关结合起来。应 用程序网关除了看 IP/TCP/UDP 首部外，还基于应用数据来做策略决定。一个应用程序网关 (application gateway )是一个应用程序特定的服务器，所有应用程序数据（入和出的）都必须通过它。多个应用程序网关可以在同一主机上运行，但是每一个网关都是有自己的进程的单独服务器 。</li>
</ul>
</li>
</ul>
</li>
<li>入侵检测程序
<ul>
<li>为了检测多种攻击类型，我们需要执行深度分组检查(deep packet inspection),即查看首部字段以外部分，深入查看分组携带的实际应用数据。应用程序网关经常做深度分组检查。而一个应用程序网关仅对一种特定的应用程序执行这种检查。</li>
<li>入侵检测设备仅能够检查所有通过它传递的分组的首部（类似于分组过滤器 ），而且能执行深度分组检查（与分组过滤器不同）的设备。当这样的设备观察到一个可疑的分组时，或一系列可疑的分组时，它能够防止这些分组进入该机构网络。或者仅仅是因为觉得该活动可疑，该设备虽说能够让这些分组通过，但要向网络管理员发出告警，网络管理员然后密切关注该流量并采取适当的行动。 当观察到潜在恶意流量时能产生告警的设备称为入侵检测系统 (Intrusion Detection System,IDS)。滤除可疑流量的设备称为入侵防止系统(Intrusion Prevention System , IPS) 。</li>
</ul>
</li>
</ul>
</div>
</article>
<footer id=footer>
<div class=footer-left>
Copyright &copy; 2021 Y.CH.Y
</div>
<div class=footer-right>
<nav>
<ul>
<li><a href=/>首页</a></li>
<li><a href></a></li>
</ul>
</nav>
</div>
</footer>
</div>
</body>
<link rel=stylesheet href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>