<!doctype html><html lang=en-us>
<head>
<link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous>
<script type=text/javascript src=https://latest.cactus.chat/cactus.js></script>
<link rel=stylesheet href=https://latest.cactus.chat/style.css type=text/css>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title> 深入理解Java虚拟机::前段编译与优化 | Y.CH.Y</title>
<link rel=canonical href=/notes/understand_the_jvm_10/>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="all,follow">
<meta name=googlebot content="index,follow,snippet,archive">
<meta property="og:title" content="深入理解Java虚拟机::前段编译与优化">
<meta property="og:description" content="前段编译与优化  前端编译器：把 *.java 文件转变成 *.class 文件 即时编译器：运行期把字节码转变成本地机器码 静态的提前编译器：直接把程序编译成与目标机器指令集相关的二进制代码 Javac 编译器  Java 语言实现 编译过程  准备过程:初始化插入式注解处理器。  提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程 我们可以把插入式注解处理器看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止   解析与填充符号表  词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树  词法分析是将源代码的字符流转变为标记(Token)集合的过程，单个字符是程序编写时的最小元素 词法分析过程由 com.sun.tools.javac.parser.Scanner 类来实现。   填充符号表。产生符号地址和符号信息  符号表(Symbol Table)是由一组符号地址和符号信息构成的数据结构 符号表中所登记的信息在编译的不同阶段都要被用到。 在 Javac 源代码中，填充符号表的过程由 com.sun.tools.javac.comp.Enter 类实现 该过程的产出物是一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级节点，     分析与字节码生成过程  标注检查。对语法的静态信息进行检查。  标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配 顺便进行一个称为常量折叠的代码优化   数据流及控制流分析。对程序动态运行过程进行检查。  数据流分析和控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。   解语法糖。将简化代码编写的语法糖还原为原有的形式。  计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响，但是却能更方便程序员使用该语言 Java 中最常见的语法糖包括了前面提到过的泛型、变长参数、自动装箱拆箱，等等   字节码生成。将前面各个步骤所生成的信息转化成字节码。  在 Javac 源码里面由 com.">
<meta property="og:type" content="article">
<meta property="og:url" content="/notes/understand_the_jvm_10/"><meta property="article:section" content="notes">
<meta property="article:published_time" content="2021-04-09T22:10:56+08:00">
<meta property="article:modified_time" content="2021-04-09T22:10:56+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="深入理解Java虚拟机::前段编译与优化">
<meta name=twitter:description content="前段编译与优化  前端编译器：把 *.java 文件转变成 *.class 文件 即时编译器：运行期把字节码转变成本地机器码 静态的提前编译器：直接把程序编译成与目标机器指令集相关的二进制代码 Javac 编译器  Java 语言实现 编译过程  准备过程:初始化插入式注解处理器。  提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程 我们可以把插入式注解处理器看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止   解析与填充符号表  词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树  词法分析是将源代码的字符流转变为标记(Token)集合的过程，单个字符是程序编写时的最小元素 词法分析过程由 com.sun.tools.javac.parser.Scanner 类来实现。   填充符号表。产生符号地址和符号信息  符号表(Symbol Table)是由一组符号地址和符号信息构成的数据结构 符号表中所登记的信息在编译的不同阶段都要被用到。 在 Javac 源代码中，填充符号表的过程由 com.sun.tools.javac.comp.Enter 类实现 该过程的产出物是一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级节点，     分析与字节码生成过程  标注检查。对语法的静态信息进行检查。  标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配 顺便进行一个称为常量折叠的代码优化   数据流及控制流分析。对程序动态运行过程进行检查。  数据流分析和控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。   解语法糖。将简化代码编写的语法糖还原为原有的形式。  计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响，但是却能更方便程序员使用该语言 Java 中最常见的语法糖包括了前面提到过的泛型、变长参数、自动装箱拆箱，等等   字节码生成。将前面各个步骤所生成的信息转化成字节码。  在 Javac 源码里面由 com.">
<link rel=stylesheet href=/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q==">
<link rel=stylesheet href=/css/custom.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]-->
<link rel=icon type=image/png href=/images/favicon.ico>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-X1L70M4MM0','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<meta name=referrer content="no-referrer-when-downgrade">
</head>
<body class="max-width mx-auto px3 ltr">
<div class="content index py4">
<header id=header>
<a href=/>
<div id=logo style=background-image:url(/images/logo.png)></div>
<div id=title>
<h1>Y.CH.Y</h1>
</div>
</a>
<div id=nav>
<ul>
<li class=icon>
<a href=# aria-label=Menu><i class="fas fa-bars fa-2x" aria-hidden=true></i></a>
</li>
<li><a href=/>首页</a></li>
</ul>
</div>
</header>
<article class=post itemscope itemtype=http://schema.org/BlogPosting>
<div class=content itemprop=articleBody>
<h2 id=前段编译与优化>前段编译与优化</h2>
<ul>
<li>前端编译器：把 *.java 文件转变成 *.class 文件</li>
<li>即时编译器：运行期把字节码转变成本地机器码</li>
<li>静态的提前编译器：直接把程序编译成与目标机器指令集相关的二进制代码</li>
<li>Javac 编译器
<ul>
<li>Java 语言实现</li>
<li>编译过程
<ul>
<li>准备过程:初始化插入式注解处理器。
<ul>
<li>提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程</li>
<li>我们可以把插入式注解处理器看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止</li>
</ul>
</li>
<li>解析与填充符号表
<ul>
<li>词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树
<ul>
<li>词法分析是将源代码的字符流转变为标记(Token)集合的过程，单个字符是程序编写时的最小元素</li>
<li>词法分析过程由 com.sun.tools.javac.parser.Scanner 类来实现。</li>
</ul>
</li>
<li>填充符号表。产生符号地址和符号信息
<ul>
<li>符号表(Symbol Table)是由一组符号地址和符号信息构成的数据结构</li>
<li>符号表中所登记的信息在编译的不同阶段都要被用到。</li>
<li>在 Javac 源代码中，填充符号表的过程由 com.sun.tools.javac.comp.Enter 类实现</li>
<li>该过程的产出物是一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级节点，</li>
</ul>
</li>
</ul>
</li>
<li>分析与字节码生成过程
<ul>
<li>标注检查。对语法的静态信息进行检查。
<ul>
<li>标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配</li>
<li>顺便进行一个称为常量折叠的代码优化</li>
</ul>
</li>
<li>数据流及控制流分析。对程序动态运行过程进行检查。
<ul>
<li>数据流分析和控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。</li>
</ul>
</li>
<li>解语法糖。将简化代码编写的语法糖还原为原有的形式。
<ul>
<li>计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响，但是却能更方便程序员使用该语言</li>
<li>Java 中最常见的语法糖包括了前面提到过的泛型、变长参数、自动装箱拆箱，等等</li>
</ul>
</li>
<li>字节码生成。将前面各个步骤所生成的信息转化成字节码。
<ul>
<li>在 Javac 源码里面由 com.sun.tools.javac.jvm.Gen 类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树、符号表)转化成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作。</li>
<li>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交到 com.sun.tools.javac.jvm.ClassWriter 类手上，由这个类的 writeClass()方法输出字节码，生成最终的 Class 文件，到此，整个编译过程宣告结束。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>语法糖
<ul>
<li>泛型
<ul>
<li>泛型的本质是参数化类型(Parameterized Type)或者参数化多态(Parametric Polymorphism)的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口 和方法的创建中，分别构成泛型类、泛型接口和泛型方法。泛型让程序员能够针对泛化的数据类型编写相同的算法，这极大地增强了编程语言的类型系统及抽象能力。</li>
<li>类型擦除式泛型</li>
<li>Java 语言中的泛型只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型了，并且在相应的地方插入了强制 转型代码，因此对于运行期的 Java 语言来说，ArrayList<int>与 ArrayList<string>其实是同一个类型</li>
<li>擦除式泛型的实现几乎只需要在 Javac 编译器上做出改进即可，不需要改动字节码、不需要改动 Java 虚拟机，也保证了以前没有使用泛型的库可以直接运行在 Java 5.0 之上。</li>
<li>擦除法实现泛型直接无法支持原生类型的泛型</li>
<li>运行期无法取到泛型类型信息，会让一些代码变得相当啰嗦，需要传 class 类型才能确定</li>
<li>类型擦除导致无法重载</li>
</ul>
</li>
<li>自动装箱、拆箱与遍历循环
<ul>
<li>自动装箱、拆箱在编译之后被转化成了对应的包装和还原方法</li>
<li>遍历循环则是把代码还原成了迭代器的实现</li>
</ul>
</li>
<li>条件编译
<ul>
<li>我不知道作者怎么理解条件编译的，但是他举的内容是编译优化里面的常见的死码消除</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</article>
<footer id=footer>
<div class=footer-left>
Copyright &copy; 2022 Y.CH.Y
</div>
<div class=footer-right>
<nav>
<ul>
<li><a href=/>首页</a></li>
</ul>
</nav>
</div>
</footer>
</div>
</body>
<link rel=stylesheet href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>