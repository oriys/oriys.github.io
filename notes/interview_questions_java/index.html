<!DOCTYPE html>
<html lang="en-us">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> 面试::八股文::Java | Y.CH.Y</title>
  <link rel = 'canonical' href = '/notes/interview_questions_java/'>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="面试::八股文::Java" />
<meta property="og:description" content="Java == 和 equals() 的区别？  equals()方法和 == 运算符之间的主要区别在于，一个是方法，另一个是运算符。 我们可以用==运算符进行引用比较（地址比较），用equals()方法进行内容比较。简单地说，== 检查两个对象是否指向相同的内存位置，而equals()则是对对象中的值进行评估比较。 如果一个类没有覆盖 equals() 方法，那么默认情况下，它使用最接近的父类的 equals(Object o)方法，该父类已经覆盖了这个方法。  AQS 在 CountDownLatch 等类中的应用原理是什么？ AQS 的内部原理是什么样的？ AtomicInteger 和 synchronized 的异同点？ AtomicInteger 在高并发下性能不好，如何解决？为什么？ CAS 和乐观锁的关系，什么时候会用到 CAS？ CAS 实现原理是什么？ CAS 有什么缺点？  ABA 问题 自旋时间过长 不能控制范围  Callable 和 Runnable 的不同？  Callable 规定的方法是 call(),Runnable 规定的方法是 run(). Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值得 call 方法可以抛出异常，run 方法不可以 运行 Callable 任务可以拿到一个 Future 对象，Future 表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。计算完成后只能使用 get 方法来获取结果，如果线程没有执行完，Future.get()方法可能会阻塞当前线程的执行；如果线程出现异常，Future.get()会 throws InterruptedException 或者 ExecutionException；如果线程已经取消，会跑出 CancellationException。取消由 cancel 方法来执行。isDone 确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/notes/interview_questions_java/" /><meta property="article:section" content="notes" />
<meta property="article:published_time" content="2021-08-19T21:51:33+08:00" />
<meta property="article:modified_time" content="2021-08-19T21:51:33+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="面试::八股文::Java"/>
<meta name="twitter:description" content="Java == 和 equals() 的区别？  equals()方法和 == 运算符之间的主要区别在于，一个是方法，另一个是运算符。 我们可以用==运算符进行引用比较（地址比较），用equals()方法进行内容比较。简单地说，== 检查两个对象是否指向相同的内存位置，而equals()则是对对象中的值进行评估比较。 如果一个类没有覆盖 equals() 方法，那么默认情况下，它使用最接近的父类的 equals(Object o)方法，该父类已经覆盖了这个方法。  AQS 在 CountDownLatch 等类中的应用原理是什么？ AQS 的内部原理是什么样的？ AtomicInteger 和 synchronized 的异同点？ AtomicInteger 在高并发下性能不好，如何解决？为什么？ CAS 和乐观锁的关系，什么时候会用到 CAS？ CAS 实现原理是什么？ CAS 有什么缺点？  ABA 问题 自旋时间过长 不能控制范围  Callable 和 Runnable 的不同？  Callable 规定的方法是 call(),Runnable 规定的方法是 run(). Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值得 call 方法可以抛出异常，run 方法不可以 运行 Callable 任务可以拿到一个 Future 对象，Future 表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。计算完成后只能使用 get 方法来获取结果，如果线程没有执行完，Future.get()方法可能会阻塞当前线程的执行；如果线程出现异常，Future.get()会 throws InterruptedException 或者 ExecutionException；如果线程已经取消，会跑出 CancellationException。取消由 cancel 方法来执行。isDone 确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?"/>

  
  
    
  
  
  <link rel="stylesheet" href="/css/styles.ace637160e3ee466ac48adf2107be5e9e0b7f168aff4b05023ac0c573f8200b3f1ced7d604b86d1b519cf620f8b1bc3c13abec114d6d055da6327e8e79ac3dfb.css" integrity="sha512-rOY3Fg4&#43;5GasSK3yEHvl6eC38Wiv9LBQI6wMVz&#43;CALPxztfWBLhtG1Gc9iD4sbw8E6vsEU1tBV2mMn6Oeaw9&#43;w=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="/images/favicon.ico" />

  
  
  
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-X1L70M4MM0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="/">
  
    <div id="logo" style="background-image: url(/images/logo.png)"></div>
  
  <div id="title">
    <h1>Y.CH.Y</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/reading">Reading</a></li>
      
        <li><a href="/leetcode">Leetcode</a></li>
      
        <li><a href="/flow">Flow</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <h2 id="java">Java</h2>
<h3 id="-和-equals-的区别">== 和 equals() 的区别？</h3>
<ul>
<li><code>equals()</code>方法和 == 运算符之间的主要区别在于，一个是方法，另一个是运算符。</li>
<li>我们可以用==运算符进行引用比较（地址比较），用<code>equals()</code>方法进行内容比较。简单地说，== 检查两个对象是否指向相同的内存位置，而<code>equals()</code>则是对对象中的值进行评估比较。</li>
<li>如果一个类没有覆盖 <code>equals()</code> 方法，那么默认情况下，它使用最接近的父类的 <code>equals(Object o)</code>方法，该父类已经覆盖了这个方法。</li>
</ul>
<h3 id="aqs-在-countdownlatch-等类中的应用原理是什么">AQS 在 CountDownLatch 等类中的应用原理是什么？</h3>
<h3 id="aqs-的内部原理是什么样的">AQS 的内部原理是什么样的？</h3>
<h3 id="atomicinteger-和-synchronized-的异同点">AtomicInteger 和 synchronized 的异同点？</h3>
<h3 id="atomicinteger-在高并发下性能不好如何解决为什么">AtomicInteger 在高并发下性能不好，如何解决？为什么？</h3>
<h3 id="cas-和乐观锁的关系什么时候会用到-cas">CAS 和乐观锁的关系，什么时候会用到 CAS？</h3>
<h3 id="cas-实现原理是什么">CAS 实现原理是什么？</h3>
<h3 id="cas-有什么缺点">CAS 有什么缺点？</h3>
<ul>
<li>ABA 问题</li>
<li>自旋时间过长</li>
<li>不能控制范围</li>
</ul>
<h3 id="callable-和-runnable-的不同">Callable 和 Runnable 的不同？</h3>
<ul>
<li>Callable 规定的方法是 call(),Runnable 规定的方法是 run().</li>
<li>Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值得</li>
<li>call 方法可以抛出异常，run 方法不可以</li>
<li>运行 Callable 任务可以拿到一个 Future 对象，Future 表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。计算完成后只能使用 get 方法来获取结果，如果线程没有执行完，Future.get()方法可能会阻塞当前线程的执行；如果线程出现异常，Future.get()会 throws InterruptedException 或者 ExecutionException；如果线程已经取消，会跑出 CancellationException。取消由 cancel 方法来执行。isDone 确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。</li>
</ul>
<h3 id="concurrenthashmap-在-java7-和-8-有何不同">ConcurrentHashMap 在 Java7 和 8 有何不同？</h3>
<h3 id="conditionobjectwait-和-notify-的关系">Condition、object.wait() 和 notify() 的关系？</h3>
<h3 id="cookie-和-session-的关系和区别是什么">Cookie 和 Session 的关系和区别是什么？</h3>
<ul>
<li>session 在服务器端，cookie 在客户端（浏览器）</li>
<li>session 默认被存在在服务器的一个文件里（不是内存）</li>
<li>session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）</li>
<li>session 可以放在 文件、数据库、或内存中都可以。</li>
<li>用户验证这种场合一般会用 session</li>
</ul>
<h3 id="copyonwritearraylist-有什么特点">CopyOnWriteArrayList 有什么特点？</h3>
<h3 id="countdownlatch-是如何安排线程执行顺序的">CountDownLatch 是如何安排线程执行顺序的？</h3>
<h3 id="cyclicbarrier-和-countdownlatch-有什么异同">CyclicBarrier 和 CountdownLatch 有什么异同？</h3>
<ul>
<li>CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的</li>
<li>CountDownLatch 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。CyclicBarrier 参与的线程职责是一样的</li>
</ul>
<h3 id="future-的主要功能是什么">Future 的主要功能是什么？</h3>
<h3 id="hashmap-与-concurrenthashmap-的实现原理是怎样的concurrenthashmap-是如何保证线程安全的">HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？</h3>
<h3 id="hashmap-为什么是线程不安全的">HashMap 为什么是线程不安全的？</h3>
<h3 id="hashmap-实现原理为什么使用红黑树">HashMap 实现原理，为什么使用红黑树？</h3>
<h3 id="java-创建多线程的方法有哪些">JAVA 创建多线程的方法有哪些？</h3>
<h3 id="jdk-18-有什么新特性">JDK 1.8 有什么新特性？</h3>
<h3 id="jvm-中内存模型是怎样的哪些区域是线程安全的">JVM 中内存模型是怎样的，哪些区域是线程安全的？</h3>
<h3 id="jvm-中内存模型是怎样的简述新生代与老年代的区别">JVM 中内存模型是怎样的，简述新生代与老年代的区别？</h3>
<h3 id="jvm-内存是如何对应到操作系统内存的">JVM 内存是如何对应到操作系统内存的？</h3>
<h3 id="jvm-对锁进行了哪些优化">JVM 对锁进行了哪些优化？</h3>
<h3 id="jvm-是怎么去调优的简述过程和调优的结果">JVM 是怎么去调优的？简述过程和调优的结果</h3>
<h3 id="java-8-中-adder-和-accumulator-有什么区别">Java 8 中 Adder 和 Accumulator 有什么区别？</h3>
<h3 id="java-中-arrayblockingqueue-与-linkedblockingqueue-的用途和区别">Java 中 arrayblockingqueue 与 linkedblockingqueue 的用途和区别</h3>
<h3 id="java-中-int-的最大值是多少">Java 中 int 的最大值是多少？</h3>
<h3 id="java-中-sleep-与-wait-的区别">Java 中 sleep() 与 wait() 的区别</h3>
<h3 id="java-中垃圾回收机制中如何判断对象需要回收">Java 中垃圾回收机制中如何判断对象需要回收？</h3>
<h3 id="常见的-gc-回收算法有哪些">常见的 GC 回收算法有哪些？</h3>
<h3 id="java-中如何进行-gc-调优">Java 中如何进行 GC 调优？</h3>
<h3 id="java-中接口和抽象类的区别">Java 中接口和抽象类的区别</h3>
<p>抽象类：如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用 abstract 关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。如果一个类继承抽象类，那么就必须为基类中的抽象方法提供定义。如果不这么做，那导出类也为抽象类。</p>
<p>抽象类和普通类的主要有三点区别：</p>
<ol>
<li>抽象方法必须为 public 或者 protected（因为如果为 private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为 public。</li>
<li>抽象类不能用来创建对象；</li>
<li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为 abstract 类。</li>
</ol>
<p>接口：可以含有变量和方法。但是要注意，接口中的变量会被隐式地指定为 public static final 变量（并且只能是 public static final 变量，用 private 修饰会报编译错误），而方法会被隐式地指定为 public abstract 方法且只能是 public abstract 方法（用其他关键字，比如 private、protected、static、final 等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</p>
<p>抽象类与接口区别</p>
<ol>
<li>abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个 interface。</li>
<li>在 abstract class 中可以有自己的数据成员，也可以有非 abstract 的成员方法，而在 interface 中，只能够有静态的不能被修改的数据成员（也就是必须是 static final 的，不过在 interface 中一般不定义数据成员），所以的成员方法都是 abstract 的。</li>
<li>实现抽象类和接口的类必须实现其中的所有方法，如果子类没有实现抽象类的所有抽象方法，那么子类也必须是抽象类；但是子类实现接口，则必须把接口的所有抽象方法实现。接口也可以继承接口，此时不需要实现父类接口。抽象类中可以有非抽象方法。接口中则不能有实现方法。</li>
<li>接口中定义的变量默认都是 public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。</li>
<li>接口中的方法默认都是 public abstract 类型的，也只能是这个类型不能是 static 方法。static 方法是类方法，它是不允许子类覆写（override）的。但是抽象类允许有 static 方法。</li>
</ol>
<h3 id="java-中的原子操作有哪些注意事项">Java 中的原子操作有哪些注意事项？</h3>
<h3 id="java-多线程有几种实现方式">Java 多线程有几种实现方式</h3>
<h3 id="java-如何高效进行数组拷贝">Java 如何高效进行数组拷贝</h3>
<p>Arrays.copyOf 或 System.arraycopy，System.arraycopy 是系统的 native 方法，Arrays.copyOf 底层调用 System.arraycopy 方法</p>
<h3 id="java-常见锁有哪些reetrantlock-是怎么实现的">Java 常见锁有哪些？ReetrantLock 是怎么实现的？</h3>
<h3 id="java-异常有哪些类型">Java 异常有哪些类型？</h3>
<h3 id="java-怎么防止内存溢出">Java 怎么防止内存溢出</h3>
<h3 id="java-是如何实现线程安全的哪些数据结构是线程安全的">Java 是如何实现线程安全的，哪些数据结构是线程安全的？</h3>
<h3 id="java-有几种基本数据类型分别占多少字节">Java 有几种基本数据类型，分别占多少字节？</h3>
<h3 id="java-的线程有哪些状态转换关系是怎么样的">Java 的线程有哪些状态，转换关系是怎么样的？</h3>
<h3 id="java-类的加载流程是怎样的什么是双亲委派机制">Java 类的加载流程是怎样的？什么是双亲委派机制？</h3>
<h3 id="java-线程和操作系统的线程是怎么对应的java-线程是怎样进行调度的">Java 线程和操作系统的线程是怎么对应的？Java 线程是怎样进行调度的?</h3>
<h3 id="java-线程池里的-arrayblockingqueue-与-linkedblockingqueue-的使用场景和区别">Java 线程池里的 arrayblockingqueue 与 linkedblockingqueue 的使用场景和区别</h3>
<h3 id="java-线程间有多少通信方式">Java 线程间有多少通信方式？</h3>
<h3 id="java-缓冲流-buffer-的用途和原理是什么">Java 缓冲流 buffer 的用途和原理是什么？</h3>
<h3 id="java-编译后的-class-文件包含了什么内容">Java 编译后的 .class 文件包含了什么内容？</h3>
<h3 id="linux-实现虚拟内存有什么方式">Linux 实现虚拟内存有什么方式？</h3>
<h3 id="lock-有哪几个常用方法分别有什么用">Lock 有哪几个常用方法？分别有什么用？</h3>
<h3 id="mvc-模型和-mvvm-模型的区别">MVC 模型和 MVVM 模型的区别</h3>
<h3 id="spring-mvc-如何处理一个请求">Spring MVC 如何处理一个请求？</h3>
<h3 id="spring-mvc-的原理和流程">Spring MVC 的原理和流程</h3>
<h3 id="spring-是怎么解析-json-数据的">Spring 是怎么解析 JSON 数据的？</h3>
<h3 id="springboot-是如何进行自动配置的">SpringBoot 是如何进行自动配置的？</h3>
<h3 id="string-为什么是-final">String 为什么是 final？</h3>
<h3 id="string-类能不能被继承为什么">String 类能不能被继承？为什么？</h3>
<h3 id="stringstringbufferstringbuilder-之间有什么区别">String，StringBuffer，StringBuilder 之间有什么区别？</h3>
<h3 id="synchronized-关键字底层是如何实现的它与-lock-相比优缺点分别是什么">Synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？</h3>
<h3 id="threadlocal-实现原理是什么">ThreadLocal 实现原理是什么？</h3>
<h3 id="threadlocal-是用来解决共享资源的多线程访问的问题吗">ThreadLocal 是用来解决共享资源的多线程访问的问题吗？</h3>
<h3 id="threadlocal-适合用在哪些实际生产的场景中">ThreadLocal 适合用在哪些实际生产的场景中？</h3>
<h3 id="error-和-exception-的区别是什么">error 和 exception 的区别是什么？</h3>
<h3 id="final-的三种用法是什么">final 的三种用法是什么？</h3>
<h3 id="hashmap-17--18-的实现区别">hashMap 1.7 / 1.8 的实现区别</h3>
<h3 id="hashcode-和-equals-方法的联系">hashcode 和 equals 方法的联系</h3>
<h3 id="hashmap-和-hashtable-的区别是什么">hashmap 和 hashtable 的区别是什么？</h3>
<h3 id="synchronized-和-lock-孰优孰劣如何选择">synchronized 和 Lock 孰优孰劣，如何选择？</h3>
<h3 id="volatile-关键字解决了什么问题它的实现原理是什么">volatile 关键字解决了什么问题，它的实现原理是什么？</h3>
<h3 id="volatile-的作用是什么与-synchronized-有什么异同">volatile 的作用是什么？与 synchronized 有什么异同？</h3>
<h3 id="wait-notify-notifyall-方法的使用注意事项">wait notify notifyAll 方法的使用注意事项？</h3>
<h3 id="一共有哪几种类线程安全问题">一共有哪几种类线程安全问题？</h3>
<h3 id="为什么-map-桶中超过-8-个才转为红黑树">为什么 Map 桶中超过 8 个才转为红黑树？</h3>
<h3 id="为什么-string-被设计为是不可变的">为什么 String 被设计为是不可变的？</h3>
<ul>
<li>字符串常量</li>
<li>用作 HashMap 的 key</li>
<li>天然线程安全</li>
</ul>
<h3 id="为什么不应该自动创建线程池">为什么不应该自动创建线程池？</h3>
<h3 id="为什么加了-final-却依然无法拥有不变性">为什么加了 final 却依然无法拥有“不变性”？</h3>
<h3 id="为什么多线程会带来性能问题">为什么多线程会带来性能问题？</h3>
<ul>
<li>调度开销：上下文切换</li>
<li>缓存失效：线程在不同 CPU 上执行，导致 CPU 缓存失效</li>
<li>协作开销：线程之间共享数据，为了数据一致性，不得不把数据刷回主存再读回来</li>
</ul>
<h3 id="为什么需要-aqsaqs-的作用和重要性是什么">为什么需要 AQS？AQS 的作用和重要性是什么？</h3>
<h3 id="主内存和工作内存的关系">主内存和工作内存的关系？</h3>
<h3 id="什么情况下会发生死锁如何解决死锁">什么情况下会发生死锁，如何解决死锁？</h3>
<h3 id="什么是-java-泛型有什么作用">什么是 Java 泛型，有什么作用？</h3>
<h3 id="什么是-spring-容器有什么作用">什么是 Spring 容器，有什么作用？</h3>
<h3 id="什么是-happens-before-规则">什么是 happens-before 规则？</h3>
<h3 id="什么是内存可见性问题">什么是“内存可见性”问题？</h3>
<h3 id="什么是公平锁什么是非公平锁">什么是公平锁？什么是非公平锁？</h3>
<h3 id="什么是内存泄漏怎么确定内存泄漏">什么是内存泄漏，怎么确定内存泄漏？</h3>
<h3 id="什么是堆内存异常">什么是堆内存异常？</h3>
<h3 id="什么是指令重排序为什么要重排序">什么是指令重排序？为什么要重排序？</h3>
<h3 id="什么是自旋锁自旋的好处和后果是什么呢">什么是自旋锁？自旋的好处和后果是什么呢？</h3>
<h3 id="什么是设计模式描述几个常用的设计模式">什么是设计模式，描述几个常用的设计模式</h3>
<h3 id="什么是重写和重载">什么是重写和重载？</h3>
<h3 id="什么是阻塞队列">什么是阻塞队列？</h3>
<h3 id="你知道什么是-cas-吗">你知道什么是 CAS 吗？</h3>
<h3 id="你知道哪几种锁分别有什么特点">你知道哪几种锁？分别有什么特点？</h3>
<h3 id="使用-future-有哪些注意点future-产生新的线程了吗">使用 Future 有哪些注意点？Future 产生新的线程了吗？</h3>
<h3 id="使用线程池比手动创建线程好在哪里">使用线程池比手动创建线程好在哪里？</h3>
<h3 id="信号量能被-fixedthreadpool-替代吗">信号量能被 FixedThreadPool 替代吗？</h3>
<h3 id="内存泄漏为何每次用完-threadlocal-都要调用-remove">内存泄漏——为何每次用完 ThreadLocal 都要调用 remove()？</h3>
<h3 id="单例模式的双重检查锁模式为什么必须加-volatile">单例模式的双重检查锁模式为什么必须加 volatile？</h3>
<h3 id="原子类和-volatile-有什么异同">原子类和 volatile 有什么异同？</h3>
<h3 id="原子类是如何利用-cas-保证线程安全的">原子类是如何利用 CAS 保证线程安全的？</h3>
<h3 id="发生死锁必须满足哪-4-个条件">发生死锁必须满足哪 4 个条件？</h3>
<h3 id="合适的线程数量是多少cpu-核心数和线程数的关系">合适的线程数量是多少？CPU 核心数和线程数的关系？</h3>
<h3 id="同样是线程安全concurrenthashmap-和-hashtable-的区别">同样是线程安全，ConcurrentHashMap 和 Hashtable 的区别</h3>
<h3 id="哪些场景需要额外注意线程安全问题">哪些场景需要额外注意线程安全问题？</h3>
<h3 id="在一个静态方法内调用一个非静态成员为什么是非法的">在一个静态方法内调用一个非静态成员为什么是非法的？</h3>
<h3 id="多个-threadlocal-在-thread-中的-threadlocals-里是怎么存储的">多个 ThreadLocal 在 Thread 中的 threadlocals 里是怎么存储的？</h3>
<h3 id="如何优化-jvm-频繁-minor-gc">如何优化 JVM 频繁 minor GC</h3>
<h3 id="如何停止一个线程">如何停止一个线程？</h3>
<h3 id="如何写一个必然死锁的例子">如何写一个必然死锁的例子？</h3>
<h3 id="如何判断一个-hash-函数好不好">如何判断一个 Hash 函数好不好？</h3>
<h3 id="如何利用-completablefuture-实现旅游平台问题">如何利用 CompletableFuture 实现“旅游平台”问题？</h3>
<h3 id="如何回收循环依赖的对象">如何回收循环依赖的对象</h3>
<h3 id="如何根据实际需要定制自己的线程池">如何根据实际需要，定制自己的线程池？</h3>
<h3 id="如何正确停止线程为什么-volatile-标记位的停止方法是错误的">如何正确停止线程？为什么 volatile 标记位的停止方法是错误的？</h3>
<h3 id="如何正确关闭线程池shutdown-和-shutdownnow-的区别">如何正确关闭线程池？shutdown 和 shutdownNow 的区别？</h3>
<h3 id="如何用命令行和代码定位死锁">如何用命令行和代码定位死锁？</h3>
<h3 id="如何看到-synchronized-背后的monitor-锁">如何看到 synchronized 背后的“monitor 锁”？</h3>
<h3 id="如何确定-eden-区的对象何时进入老年代">如何确定 eden 区的对象何时进入老年代？</h3>
<h3 id="如何解决-spring-的循环依赖问题">如何解决 Spring 的循环依赖问题？</h3>
<h3 id="如何设计-java-的异常体系">如何设计 Java 的异常体系？</h3>
<h3 id="如何设计一个无锁队列">如何设计一个无锁队列</h3>
<h3 id="如何设计一个线程池">如何设计一个线程池</h3>
<h3 id="如何选择适合自己的阻塞队列">如何选择适合自己的阻塞队列？</h3>
<h3 id="实现单例模式">实现单例模式</h3>
<h3 id="实现单例设计模式懒汉饿汉">实现单例设计模式（懒汉，饿汉）</h3>
<h3 id="实现线程的方法">实现线程的方法？</h3>
<h3 id="常用的排序方式有哪些时间复杂度是多少">常用的排序方式有哪些，时间复杂度是多少？</h3>
<h3 id="悲观锁和乐观锁的本质是什么">悲观锁和乐观锁的本质是什么？</h3>
<h3 id="成员变量和方法的区别">成员变量和方法的区别？</h3>
<h3 id="手写生产者消费者模型">手写生产者消费者模型</h3>
<h3 id="数组与链表有什么区别">数组与链表有什么区别？</h3>
<h3 id="有哪-6-种常见的线程池什么是-java8-的-forkjoinpool">有哪 6 种常见的线程池？什么是 Java8 的 ForkJoinPool？</h3>
<h3 id="有哪些解决哈希表冲突的方式">有哪些解决哈希表冲突的方式？</h3>
<h3 id="有哪些解决死锁问题的策略">有哪些解决死锁问题的策略？</h3>
<h3 id="有哪几种实现生产者消费者模式的方法">有哪几种实现生产者消费者模式的方法？</h3>
<h3 id="有哪几种常见的阻塞队列">有哪几种常见的阻塞队列？</h3>
<ul>
<li>ArrayBlockingQueue:有界队列，其内部是用数组存储元素的，利用 ReentrantLock 实现线程安全。</li>
<li>LinkedBlockingQueue:内部用链表实现的 BlockingQueue。如果我们不指定它的初始容量，那么它容量默认就为整型的最大值 Integer.MAX_VALUE，由于这个数非常大，我们通常不可能放入这么多的数据，所以 LinkedBlockingQueue 也被称作无界队列，代表它几乎没有界限。</li>
<li>SynchronousQueue:它的容量为 0，所以没有一个地方来暂存元素，导致每次取数据都要先阻塞，直到有数据被放入；同理，每次放数据的时候也会阻塞，直到有消费者来取。</li>
<li>PriorityBlockingQueue:PriorityBlockingQueue 是一个支持优先级的无界阻塞队列，可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。同时，插入队列的对象必须是可比较大小的，也就是 Comparable 的，否则会抛出 ClassCastException 异常。它的 take 方法在队列为空的时候会阻塞，但是正因为它是无界队列，而且会自动扩容，所以它的队列永远不会满，所以它的 put 方法永远不会阻塞，添加操作始终都会成功，也正因为如此，它的成员变量里只有一个 Condition：</li>
<li>DelayQueue:具有“延迟”的功能。我们可以设定让队列中的任务延迟多久之后执行，比如 10 秒钟之后执行，这在例如“30 分钟后未付款自动取消订单”等需要延迟执行的场景中被大量使用。它是无界队列，放入的元素必须实现 Delayed 接口，而 Delayed 接口又继承了 Comparable 接口，所以自然就拥有了比较和排序的能力</li>
</ul>
<h3 id="深拷贝与浅拷贝区别是什么">深拷贝与浅拷贝区别是什么？</h3>
<ul>
<li>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</li>
<li>深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</li>
</ul>
<h3 id="简单介绍-mybatismybatis-是如何实现-orm-映射的">简单介绍 mybatis，mybatis 是如何实现 ORM 映射的</h3>
<h3 id="简述-arraylist-与-linkedlist-的底层实现以及常见操作的时间复杂度">简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度</h3>
<h3 id="简述-bio-nio-aio-的区别">简述 BIO, NIO, AIO 的区别</h3>
<h3 id="简述-cas-原理什么是-aba-问题怎么解决">简述 CAS 原理，什么是 ABA 问题，怎么解决？</h3>
<h3 id="简述-dubbo-服务调用过程">简述 Dubbo 服务调用过程</h3>
<h3 id="简述-gc-引用链g1-收集器原理">简述 GC 引用链，G1 收集器原理</h3>
<h3 id="简述-hashmap-和-treemap-的实现原理以及常见操作的时间复杂度">简述 HashMap 和 TreeMap 的实现原理以及常见操作的时间复杂度</h3>
<h3 id="简述-hashset-与-hashmap-的异同">简述 HashSet 与 HashMap 的异同</h3>
<h3 id="简述-hashset-实现原理">简述 HashSet 实现原理</h3>
<h3 id="简述-java-aqs-的原理以及使用场景">简述 Java AQS 的原理以及使用场景</h3>
<h3 id="简述-java-中-final-关键字的作用">简述 Java 中 final 关键字的作用</h3>
<p>final 修饰变量：一旦被赋值就不能被修改了
final 修饰方法：被 final 修饰的方法不可以被重写，不能被 override
final 修饰类：不能被继承</p>
<h3 id="简述-java-中的自动装箱与拆箱">简述 Java 中的自动装箱与拆箱</h3>
<ul>
<li>自动装箱就是 Java 自动将原始类型值转换成对应的对象，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱，反之将 Integer 对象转换成 int 类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。</li>
<li>原始类型 byte,short,char,int,long,float,double 和 boolean 对应的封装类为 Byte,Short,Character,Integer,Long,Float,Double,Boolean。</li>
<li>自动装箱时编译器调用 valueOf 将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似 intValue(),doubleValue()这类的方法将对象转换成原始类型值。</li>
<li>自动装箱是将 boolean 值转换成 Boolean 对象，byte 值转换成 Byte 对象，char 转换成 Character 对象，float 值转换成 Float 对象，int 转换成 Integer，long 转换成 Long，short 转换成 Short，自动拆箱则是相反的操作。</li>
</ul>
<h3 id="简述-java-内置排序算法的实现原理">简述 Java 内置排序算法的实现原理</h3>
<h3 id="简述-java-的-happen-before-原则">简述 Java 的 happen before 原则</h3>
<h3 id="简述-java-的反射机制及其应用场景">简述 Java 的反射机制及其应用场景</h3>
<h3 id="简述-java-的序列化和使用场景">简述 Java 的序列化和使用场景</h3>
<h3 id="简述-java-的逃逸分析机制">简述 Java 的逃逸分析机制</h3>
<p>1.逃逸分析的定义</p>
<p>逃逸分析：是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p>
<p>通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>Java 在 Java SE 6u23 以及以后的版本中支持并默认开启了逃逸分析的选项。Java 的 HotSpot JIT 编译器，能够在方法重载或者动态加载代码的时候对代码进行逃逸分析。</p>
<p>逃逸分析的基本行为就是分析对象的动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用。</p>
<p>方法逃逸：例如作为调用参数传递到其他方法中。</p>
<p>线程逃逸：有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量。</p>
<p>2.逃逸分析的理论基础</p>
<p>基于 Jong-Deok Choi, Manish Gupta, Mauricio Seffano,Vugranam C. Sreedhar, Sam Midkiff 等在论文《Escape Analysis for Java》中描述的算法进行逃逸分析。</p>
<p>该算法引入了连通图，用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。由于该算法是上下文相关和流敏感的，并且模拟了对象任意层次的嵌套关系，所以分析精度较高，只是运行时间和内存消耗相对较大。</p>
<p>绝大多数逃逸分析的实现都基于“封闭世界(closed world)”的前提：所有可能被执行的，方法在做逃逸分析前都已经得知，并且，程序的实际运行不会改变它们之间的调用关系 。但当真实的 Java 程序运行时，这样的假设并不成立。Java 程序拥有的许多特性，例如动态类加载、调用本地函数以及反射程序调用等等，都将打破所谓“封闭世界”的约定。</p>
<p>逃逸分析之后的处理操作</p>
<p>经过逃逸分析之后，可以得到对象三种可能的逃逸状态：</p>
<p>GlobalEscape(全局逃逸)： 即一个对象的引用逃出了方法或者线程。例如，一个对象的引用是复制给了一个类变量，或者存储在在一个已经逃逸的对象当中，或者这个对象的引用作为方法的返回值返回给了调用方法。</p>
<p>ArgEscape(参数级逃逸)：即在方法调用过程当中传递对象的应用给一个方法。这种状态可以通过分析被调方法的二进制代码确定。</p>
<p>NoEscape(没有逃逸)：一个可以进行标量替换的对象。该对象可以不被分配在传统的堆上。</p>
<p>编译器可以使用逃逸分析的结果，对程序进行优化。</p>
<p>堆分配对象变成栈分配对象：一个方法当中的对象，对象的引用没有发生逃逸，那么这个方法可能会被分配在栈内存上而非常见的堆内存上。</p>
<p>消除同步：线程同步的代价是相当高的，同步的后果是降低并发性和性能。逃逸分析可以判断出某个对象是否始终只被一个线程访问，如果只被一个线程访问，那么对该对象的同步操作就可以转化成没有同步保护的操作，这样就能大大提高并发程度和性能。</p>
<p>矢量替代：逃逸分析方法如果发现对象的内存存储结构不需要连续进行的话，就可以将对象的部分甚至全部都保存在 CPU 寄存器内，这样能大大提高访问速度。</p>
<h3 id="简述-java-锁升级的机制">简述 Java 锁升级的机制</h3>
<h3 id="简述-netty-线程模型netty-为什么如此高效">简述 Netty 线程模型，Netty 为什么如此高效？</h3>
<h3 id="简述-sortedset-实现原理">简述 SortedSet 实现原理</h3>
<p>底层是基于<code>TreeMap</code>来实现的，所以底层结构也是红黑树，因为他和<code>HashSet</code>不同的是不需要重写<code>hashCode()</code>和<code>equals()</code>方法，因为它去重是依靠比较器来去重，因为结构是红黑树，所以每次插入都会遍历比较来寻找节点插入位置，如果发现某个节点的值是一样的那就会直接覆盖。</p>
<h3 id="简述-spring-aop-的原理">简述 Spring AOP 的原理</h3>
<h3 id="简述-spring-bean-的生命周期">简述 Spring bean 的生命周期</h3>
<h3 id="简述-spring-注解的实现原理">简述 Spring 注解的实现原理</h3>
<h3 id="简述-spring-的-ioc-机制">简述 Spring 的 IOC 机制</h3>
<h3 id="简述-spring-的初始化流程">简述 Spring 的初始化流程</h3>
<h3 id="简述-synchronizedvolatile可重入锁的不同使用场景及优缺点">简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点</h3>
<h3 id="简述-synchronizedvolatile可重入锁的不同使用场景及优缺点-1">简述 Synchronized，volatile，可重入锁的不同使用场景及优缺点</h3>
<h3 id="简述-web-socket-与-http-的使用场景">简述 Web socket 与 Http 的使用场景</h3>
<h3 id="简述-zookeeper-基础原理以及使用场景">简述 Zookeeper 基础原理以及使用场景</h3>
<h3 id="简述-thread-和-runable-区别">简述 thread 和 runable 区别</h3>
<h3 id="简述使用协程的优点">简述使用协程的优点</h3>
<h3 id="简述偏向锁以及轻量级锁的区别">简述偏向锁以及轻量级锁的区别</h3>
<h3 id="简述动态代理与静态代理">简述动态代理与静态代理</h3>
<h3 id="简述封装继承多态的特性及使用场景">简述封装、继承、多态的特性及使用场景？</h3>
<h3 id="简述常见的工厂模式以及单例模式的使用场景">简述常见的工厂模式以及单例模式的使用场景</h3>
<h3 id="简述并实现工厂模式工厂模式有什么常见问题">简述并实现工厂模式，工厂模式有什么常见问题？</h3>
<h3 id="简述有哪些同步锁以及它们的实现原理">简述有哪些同步锁以及它们的实现原理</h3>
<h3 id="简述标记清除算法的流程">简述标记清除算法的流程</h3>
<h3 id="简述生产者消费者模型">简述生产者消费者模型</h3>
<h3 id="简述装饰者模式以及适配器模式">简述装饰者模式以及适配器模式</h3>
<h3 id="简述读写屏障底层原理">简述读写屏障底层原理</h3>
<h3 id="线程是如何在-6-种状态之间转换的">线程是如何在 6 种状态之间转换的？</h3>
<p><img src="https://i.imgur.com/NNL4TSl.png" alt="img"></p>
<h3 id="线程池实现线程复用的原理">线程池实现“线程复用”的原理？</h3>
<p>线程池可以把线程和任务进行解耦，线程归线程，任务归任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制。在线程池中，同一个线程可以从 BlockingQueue 中不断提取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中，不停地检查是否还有任务等待被执行，如果有则直接去执行这个任务，也就是调用任务的 run 方法，把 run 方法当作和普通方法一样的地位去调用，相当于把每个任务的 run() 方法串联了起来，所以线程数量并不增加。</p>
<h3 id="线程池常用的阻塞队列有哪些">线程池常用的阻塞队列有哪些？</h3>
<h3 id="线程池是如何实现的简述线程池的任务策略">线程池是如何实现的？简述线程池的任务策略</h3>
<h3 id="线程池有哪-4-种拒绝策略">线程池有哪 4 种拒绝策略？</h3>
<h3 id="线程池的各个参数的含义">线程池的各个参数的含义？</h3>
<p>｜参数名 ｜ 含义｜
｜&ndash;｜&mdash;｜
｜ corePoolSize ｜ 核心线程数｜
｜ maxPoolSize ｜ 最大线程数｜
｜ keepAliveTime + 时间单位 ｜ 空闲线程的存活时间｜
｜ ThreadFactory ｜ 线程工厂、用来创建新线程｜
｜ workQueue ｜ 用于存放任务的队列｜
｜ Handler ｜ 处理被拒绝的任务｜</p>
<h3 id="讲一讲什么是-java-内存模型">讲一讲什么是 Java 内存模型？</h3>
<h3 id="讲一讲公平锁和非公平锁为什么要非公平">讲一讲公平锁和非公平锁，为什么要“非公平”？</h3>
<h3 id="讲一讲经典的哲学家就餐问题">讲一讲经典的哲学家就餐问题</h3>
<h3 id="读写锁-readwritelock-获取锁有哪些规则">读写锁 ReadWriteLock 获取锁有哪些规则？</h3>
<h3 id="读锁应该插队吗什么是读写锁的升降级">读锁应该插队吗？什么是读写锁的升降级？</h3>
<h3 id="阻塞和非阻塞队列的并发安全原理是什么">阻塞和非阻塞队列的并发安全原理是什么？</h3>
<h3 id="阻塞队列包含哪些常用的方法addofferput-等方法的区别">阻塞队列包含哪些常用的方法？add、offer、put 等方法的区别？</h3>
<h3 id="阻塞队列都有哪几种有什么区别">阻塞队列都有哪几种，有什么区别？</h3>
<h3 id="集合类中的-list-和-map-的线程安全版本是什么如何保证线程安全的">集合类中的 List 和 Map 的线程安全版本是什么，如何保证线程安全的？</h3>

  
  </div>
</article>


    <footer id="footer">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
  <div class="footer-left">
    Copyright  &copy; 2021  Y.CH.Y 
    
    
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">Home</a></li>
         
        <li><a href="/reading">Reading</a></li>
         
        <li><a href="/leetcode">Leetcode</a></li>
         
        <li><a href="/flow">Flow</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
