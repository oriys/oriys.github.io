<!DOCTYPE html>
<html lang="en-us">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> 深入理解Java虚拟机::虚拟机类加载机制 | Y.CH.Y</title>
  <link rel = 'canonical' href = '/post/understand_the_jvm_07/'>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="深入理解Java虚拟机::虚拟机类加载机制" />
<meta property="og:description" content="虚拟机类加载机制  概述  Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作虚拟机的类加载机制   类加载的时机  一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unload ing)七个阶段，其中验证、准备、解析三个部分统称为连接(Linking) 加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的 解析在某些情况下可以在初始化阶段之后再开始  为了支持 Java 语言的运行时绑定特性   JVM 规范严格规定了有且只有六种情况必须立即对类进行初始化  遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段  使用 new 关键字实例化对象的时候 读取或设置一个类型的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)的时候。 调用一个类型的静态方法的时候   使用 java.lang.reflect 包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的那个类)，虚拟机会先初始化这个主类。 当使用 JDK 7 新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。 当一个接口中定义了 JDK 8 新加入的默认方法(被 default 关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。   这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。   类加载的过程  加载  在加载阶段，Java 虚拟机需要完成以下三件事情:  通过一个类的全限定名来获取定义此类的二进制字节流。  从 ZIP 压缩包中读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础 从网络中获取，这种场景最典型的应用就是 Web Applet。 运行时计算生成，这种场景使用得最多的就是动态代理技术，在 java." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/understand_the_jvm_07/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-04-06T22:10:56+08:00" />
<meta property="article:modified_time" content="2021-04-06T22:10:56+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="深入理解Java虚拟机::虚拟机类加载机制"/>
<meta name="twitter:description" content="虚拟机类加载机制  概述  Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作虚拟机的类加载机制   类加载的时机  一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unload ing)七个阶段，其中验证、准备、解析三个部分统称为连接(Linking) 加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的 解析在某些情况下可以在初始化阶段之后再开始  为了支持 Java 语言的运行时绑定特性   JVM 规范严格规定了有且只有六种情况必须立即对类进行初始化  遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段  使用 new 关键字实例化对象的时候 读取或设置一个类型的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)的时候。 调用一个类型的静态方法的时候   使用 java.lang.reflect 包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类(包含 main()方法的那个类)，虚拟机会先初始化这个主类。 当使用 JDK 7 新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。 当一个接口中定义了 JDK 8 新加入的默认方法(被 default 关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。   这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。   类加载的过程  加载  在加载阶段，Java 虚拟机需要完成以下三件事情:  通过一个类的全限定名来获取定义此类的二进制字节流。  从 ZIP 压缩包中读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础 从网络中获取，这种场景最典型的应用就是 Web Applet。 运行时计算生成，这种场景使用得最多的就是动态代理技术，在 java."/>

  
  
    
  
  
  <link rel="stylesheet" href="/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css" integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="/images/favicon.ico" />

  
  
  
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-X1L70M4MM0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="/">
  
    <div id="logo" style="background-image: url(/images/logo.png)"></div>
  
  <div id="title">
    <h1>Y.CH.Y</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">Home</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <h2 id="虚拟机类加载机制">虚拟机类加载机制</h2>
<ul>
<li>概述
<ul>
<li>Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作虚拟机的类加载机制</li>
</ul>
</li>
<li>类加载的时机
<ul>
<li>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unload ing)七个阶段，其中验证、准备、解析三个部分统称为连接(Linking)</li>
<li>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的</li>
<li>解析在某些情况下可以在初始化阶段之后再开始
<ul>
<li>为了支持 Java 语言的运行时绑定特性</li>
</ul>
</li>
<li>JVM 规范严格规定了有且只有六种情况必须立即对类进行初始化
<ul>
<li>遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段
<ul>
<li>使用 new 关键字实例化对象的时候</li>
<li>读取或设置一个类型的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)的时候。</li>
<li>调用一个类型的静态方法的时候</li>
</ul>
</li>
<li>使用 java.lang.reflect 包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类(包含 <code>main()</code>方法的那个类)，虚拟机会先初始化这个主类。</li>
<li>当使用 JDK 7 新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了 JDK 8 新加入的默认方法(被 default 关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ul>
</li>
<li>这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。</li>
</ul>
</li>
<li>类加载的过程
<ul>
<li>加载
<ul>
<li>在加载阶段，Java 虚拟机需要完成以下三件事情:
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。
<ul>
<li>从 ZIP 压缩包中读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础</li>
<li>从网络中获取，这种场景最典型的应用就是 Web Applet。</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是 JSP 应用，由 JSP 文件生成对应的 Class 文件。</li>
<li>从数据库中读取，这种场景相对少见些，例如有些中间件服务器(如 SAP Netweaver)可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li>
<li>可以从加密文件中获取，这是典型的防 Class 文件被反编译的保护措施，通过加载时解密 Class 文件来保障程序运行逻辑不被窥探。</li>
</ul>
</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
</li>
<li>非数组类型的加载既可以使用 Java 虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成</li>
<li>数组类本身不通过类加载器创建，它是由 Java 虚拟机直接在内存中动态构造出来的
<ul>
<li>如果数组的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将被标识在加载该组件类型的类加载器的类名称空间上</li>
<li>如果数组的组件类型不是引用类型, Java 虚拟机将会把数组 C 标记为与引导类加载器关联。</li>
<li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为 public，可被所有的类和接口访问到。</li>
</ul>
</li>
<li>加载阶段结束后，Java 虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了</li>
<li>类型数据妥善安置在方法区之后，会在 Java 堆内存中实例化一个 java.lang.Class 类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</li>
</ul>
</li>
<li>验证
<ul>
<li>验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</li>
<li>文件格式验证
<ul>
<li>验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理</li>
</ul>
</li>
<li>元数据验证
<ul>
<li>对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java 语言规范》的要求</li>
</ul>
</li>
<li>字节码验证
<ul>
<li>通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的</li>
</ul>
</li>
<li>符号引用验证
<ul>
<li>对类自身以外的各类信息进行匹配性校验</li>
</ul>
</li>
<li>-Xverify:none 参数用来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</li>
</ul>
</li>
<li>准备
<ul>
<li>准备阶段是正式为类中定义的变量分配内存并设置类变量初始值的阶段</li>
</ul>
</li>
<li>解析
<ul>
<li>解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程
<ul>
<li>符号引用
<ul>
<li>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可</li>
<li>内存布局无关</li>
</ul>
</li>
<li>直接引用
<ul>
<li>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄</li>
<li>内存布局直接相关</li>
</ul>
</li>
</ul>
</li>
<li>虚拟机实现可以对第一次解析的结果进行缓存, invokedynamic 除外，针对动态语言支持</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这 7 类符号引用进行</li>
</ul>
</li>
<li>初始化
<ul>
<li>类的初始化阶段是类加载过程的最后一个步骤</li>
<li>根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源</li>
<li>与构造函数不同，编译期生成的私有方法</li>
<li>父类构造器优先子类构造器，父类静态块优先子类静态块</li>
</ul>
</li>
</ul>
</li>
<li>类加载器
<ul>
<li>类与类加载器
<ul>
<li>类加载器虽然只用于实现类的加载动作，但它在 Java 程序中起到的作用却远超类加载阶段</li>
<li>每一个类加载器，都拥有一个独立的类名称空间</li>
<li>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</li>
</ul>
</li>
<li>双亲委派模式
<ul>
<li>启动类加载器，C++语言实现，是虚拟机自身的一部分</li>
<li>其他所有的类加载器，这些类加载器都由 Java 语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。</li>
<li>启动类加载器
<ul>
<li>负责加载存放在 &lt;JAVA_HOME&gt;\lib 目录，或者被 -Xbootclasspath 参数所指定的路径中存放的，而且是 Java 虚拟机能够识别的类库加载到虚拟机的内存中</li>
</ul>
</li>
<li>扩展类加载器
<ul>
<li>这个类加载器是在类 sun.misc.Launcher$ExtClassLoader 中以 Java 代码的形式实现的。它负责加载&lt;JAVA_HOME&gt;\lib\ext 目录中，或者被 java.ext.dirs 系统变量所指定的路径中所有的类库</li>
</ul>
</li>
<li>应用程序类加载器
<ul>
<li>由 sun.misc.Launcher$AppClassLoader 来实现。由于应用程序类加载器是 ClassLoader 类中的 getSystem ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径(ClassPath)上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
</li>
<li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</li>
<li>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</li>
<li>java.lang 开头的包因为安全原因无法被加载</li>
</ul>
</li>
<li>破坏双亲委派模式
<ul>
<li>loadClass()加载类, 历史遗留问题</li>
<li>JNDI 服务, 线程上下文类加载器 (Thread Context ClassLoader)。这个类加载器可以通过 java.lang.Thread 类的 setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</li>
<li>追求动态性，热部署，热加载
<ul>
<li>在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索:</li>
<li>将以 java.*开头的类，委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类，委派给父类加载器加载。</li>
<li>否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载。</li>
<li>否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载。</li>
<li>否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Java 模块化系统
<ul>
<li>实现模块化的关键目标可配置的封装隔离机制</li>
<li>模块就可以声明对其他模块的显式依赖，这样 Java 虚拟机就能够在启动时验证应用程序开发阶段设定好的依赖关系在运行期是否完备，如有缺失那就直接启动失败，从而避免了很大一部分由于类型依赖而引发的运行时异常。</li>
<li>可配置的封装隔离机制还解决了原来类路径上跨 JAR 文件的 public 类型的可访问性问题。JDK 9 中的 public 类型不再意味着程序的所有地方的代码都可以随意访问到它们，模块提供了更精细的可访问性控制，必须明确声明其中哪一些 public 的类型可以被其他哪一些模块访问</li>
<li>兼容性
<ul>
<li>保持向后兼容</li>
<li>模块带有版本号，需要手动选择版本号打包</li>
</ul>
</li>
<li>类加载器
<ul>
<li>扩展类加载器(Extension Class Loader)被平台类加载器(Platform Class Loader)取代
<ul>
<li>&lt;JAVA_HOME&gt;\lib\ext 目录被舍弃</li>
</ul>
</li>
<li>平台类加载器和应用程序类加载器都不再派生自 java.net.URLClassLoader</li>
<li>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载，</li>
</ul>
</li>
</ul>
</li>
</ul>

  
  </div>
</article>


    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2021  Y.CH.Y 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">Home</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
