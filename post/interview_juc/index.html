<!DOCTYPE html>
<html lang="en-us">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> 面试题::JUC | Y.CH.Y</title>
  <link rel = 'canonical' href = '/post/interview_juc/'>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="面试题::JUC" />
<meta property="og:description" content="实现线程的几种方式？  继承 Thread 类，重写 run 方法 实现 Runnable 接口，重写 run 方法  实现 Runnable 接口于继承 Thread 的区别？  通过扩展 Thread 类创建的每个线程都会为其创建一个单独的对象，并与该对象关联。另一方面，通过实现 Runnable 接口创建的每个线程共享同一个 Runnable 实例。 由于通过扩展 Thread 类创建的每个线程都与一个唯一的对象相关联，因此需要更多的内存。另一方面，通过实现 Runnable 接口创建的每个线程共享相同的对象空间，因此，它需要的内存较少。 如果你扩展了 Thread 类，那么你可以进一步继承任何其他的类，因为 Java 不允许多重继承，而实现 Runnable 仍然为一个类提供了继承任何其他类的机会。 只有在必须 override Thread 类的某些其他方法时，才必须扩展 Thread 类。如果你只想实现 run 方法，你必须实现 Runnable 接口。 扩展 Thread 类会在代码中引入紧耦合，因为 Thread 的代码和线程的工作都包含在同一个类中。另一方面，实现 Runnable 接口在代码中引入了松耦合，因为 Thread 的代码与分配给线程的工作是分开的。  如何正确停止线程？ 使用 iterrupt 来通知线程停止，而不是强制其停止，在 java 中，停止线程能做到的就是发个通知：你被中断了。但最终是否中断，什么时候中断，是由线程本身决定的
ref
为什么 volatile 标记位的停止方法是错误的？ volatile 在某些特殊的情况下，比如线程被长时间阻塞的情况，就无法及时感受中断" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/interview_juc/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-05-01T06:26:17+08:00" />
<meta property="article:modified_time" content="2021-05-01T06:26:17+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="面试题::JUC"/>
<meta name="twitter:description" content="实现线程的几种方式？  继承 Thread 类，重写 run 方法 实现 Runnable 接口，重写 run 方法  实现 Runnable 接口于继承 Thread 的区别？  通过扩展 Thread 类创建的每个线程都会为其创建一个单独的对象，并与该对象关联。另一方面，通过实现 Runnable 接口创建的每个线程共享同一个 Runnable 实例。 由于通过扩展 Thread 类创建的每个线程都与一个唯一的对象相关联，因此需要更多的内存。另一方面，通过实现 Runnable 接口创建的每个线程共享相同的对象空间，因此，它需要的内存较少。 如果你扩展了 Thread 类，那么你可以进一步继承任何其他的类，因为 Java 不允许多重继承，而实现 Runnable 仍然为一个类提供了继承任何其他类的机会。 只有在必须 override Thread 类的某些其他方法时，才必须扩展 Thread 类。如果你只想实现 run 方法，你必须实现 Runnable 接口。 扩展 Thread 类会在代码中引入紧耦合，因为 Thread 的代码和线程的工作都包含在同一个类中。另一方面，实现 Runnable 接口在代码中引入了松耦合，因为 Thread 的代码与分配给线程的工作是分开的。  如何正确停止线程？ 使用 iterrupt 来通知线程停止，而不是强制其停止，在 java 中，停止线程能做到的就是发个通知：你被中断了。但最终是否中断，什么时候中断，是由线程本身决定的
ref
为什么 volatile 标记位的停止方法是错误的？ volatile 在某些特殊的情况下，比如线程被长时间阻塞的情况，就无法及时感受中断"/>

  
  
    
  
  
  <link rel="stylesheet" href="/css/styles.a1d8fc2f132c452937740993f66c1b7a35d39b0774f74823f917c8b66b7795716119b0af416457217bed8e35420077308b167d77d283c319f347c34500e4ca46.css" integrity="sha512-odj8LxMsRSk3dAmT9mwbejXTmwd090gj&#43;RfItmt3lXFhGbCvQWRXIXvtjjVCAHcwixZ9d9KDwxnzR8NFAOTKRg=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="/images/favicon.ico" />

  
  
  
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-X1L70M4MM0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="/">
  
    <div id="logo" style="background-image: url(/images/logo.png)"></div>
  
  <div id="title">
    <h1>Y.CH.Y</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">Home</a></li>
      
    </ul>
  </div>
</header>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-X1L70M4MM0"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-X1L70M4MM0', { 'anonymize_ip': false });
}
</script>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <h2 id="实现线程的几种方式">实现线程的几种方式？</h2>
<ul>
<li>继承 Thread 类，重写 run 方法</li>
<li>实现 Runnable 接口，重写 run 方法</li>
</ul>
<h2 id="实现-runnable-接口于继承-thread-的区别">实现 Runnable 接口于继承 Thread 的区别？</h2>
<ul>
<li>通过扩展 Thread 类创建的每个线程都会为其创建一个单独的对象，并与该对象关联。另一方面，通过实现 Runnable 接口创建的每个线程共享同一个 Runnable 实例。</li>
<li>由于通过扩展 Thread 类创建的每个线程都与一个唯一的对象相关联，因此需要更多的内存。另一方面，通过实现 Runnable 接口创建的每个线程共享相同的对象空间，因此，它需要的内存较少。</li>
<li>如果你扩展了 Thread 类，那么你可以进一步继承任何其他的类，因为 Java 不允许多重继承，而实现 Runnable 仍然为一个类提供了继承任何其他类的机会。</li>
<li>只有在必须 override Thread 类的某些其他方法时，才必须扩展 Thread 类。如果你只想实现 run 方法，你必须实现 Runnable 接口。</li>
<li>扩展 Thread 类会在代码中引入紧耦合，因为 Thread 的代码和线程的工作都包含在同一个类中。另一方面，实现 Runnable 接口在代码中引入了松耦合，因为 Thread 的代码与分配给线程的工作是分开的。</li>
</ul>
<h2 id="如何正确停止线程">如何正确停止线程？</h2>
<p>使用 iterrupt 来通知线程停止，而不是强制其停止，在 java 中，停止线程能做到的就是发个通知：你被中断了。但最终是否中断，什么时候中断，是由线程本身决定的</p>
<p><a href="https://www.infoq.cn/article/java-interrupt-mechanism">ref</a></p>
<h2 id="为什么-volatile-标记位的停止方法是错误的">为什么 volatile 标记位的停止方法是错误的？</h2>
<p>volatile 在某些特殊的情况下，比如线程被长时间阻塞的情况，就无法及时感受中断</p>
<h2 id="线程是如何在-6-种状态之间转换的">线程是如何在 6 种状态之间转换的？</h2>
<ul>
<li>Java 中线程的状态分为 6 种
<ul>
<li>初始(NEW)：新创建了一个线程对象，但还没有调用 start()方法。</li>
<li>运行(RUNNABLE)：Java 线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 CPU 的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得 CPU 时间片后变为运行中状态（running）。</li>
<li>阻塞(BLOCKED)：表示线程阻塞于锁。</li>
<li>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>超时等待(TIMED_WAITING)：该状态不同于 WAITING，它可以在指定的时间后自行返回。</li>
<li>终止(TERMINATED)：表示该线程已经执行完毕。</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/rxCc2o5.png" alt="img"></p>
<h2 id="为什么-wait-必须在-synchronized-保护的同步代码块中使用">为什么 wait 必须在 synchronized 保护的同步代码块中使用？</h2>
<ul>
<li>在同步方法或者同步块中被调用就不会抛出 java.lang.IllegalMonitorStateException 的异常。</li>
<li>避免 wait（）和 notify（），notifyAll（）之间产生竞态条件。</li>
<li>wait（）是让线程等待并将锁释放出来，让给期限线程使用；notify（），notifyAll（）是该线程在使用完锁后，通知其他线程可以获取锁继续执行下去。notify()是唤醒其中一个线程，notifyAll()是唤醒全部线程使其争抢。</li>
<li>当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</li>
</ul>
<h2 id="为什么-waitnotifynotifyall-被定义在-object-类中而-sleep-定义在-thread-类中">为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？</h2>
<ul>
<li>因为 Java 中每个对象都有一把称之为 monitor（监视器）的锁，由于每个对象都可以上锁，这就要求在对象头中有一个用来保存锁信息的位置。这个锁是对象级别的，而不是线程级别的，wait（）/notify（）/notifyAll（）也都是锁级别的操作，它们的锁属于对象，所以把它们定义在 Object 类中最合适。因为 Object 类是所有对象的父类，也就是说所有的对象都可以成为一个锁对象，所以 synchronized 是保证只有一个对象能在同一时刻获得锁的一种机制。</li>
<li>而把 wait（）/notify（）/notifyAll（）方法定义在 Thread 类中，会带来很大的局限性，比如一个线程可能持有多把锁，以便实现相互配合的复杂逻辑，假设此时 wait 方法定义在 Thread 类中，如何实现让一个线程持有多把锁呢？又如何明确线程等待的是哪把锁呢？没有办法灵活的实现这样的多锁逻辑，也会增加编程难度。</li>
</ul>
<h2 id="waitnotify-和-sleep-的区别">wait/notify 和 sleep 的区别？</h2>
<ul>
<li>相同点
<ul>
<li>它们都可以让线程阻塞</li>
<li>它们都可以响应 interrupt 中断: 在等待的过程中如果收到中断信号，都可以进行响应，并抛出 InterruptedException 异常</li>
</ul>
</li>
<li>不同点:
<ul>
<li>Wait 方法必须在 synchronized 保护的代码中使用，而 sleep 方法并没有这个要求</li>
<li>在同步代码中执行 sleep 方法时，并不会释放 monitor 锁，但执行 wait 方法时会主动释放 monitor 锁</li>
<li>sleep 方法中会要求必须定义一个时间，时间到期后会主动恢复，而对于没有参数的 wait 方法而言，意味着永久等待，直到被中断或被唤醒才能恢复，它并不会主动恢复</li>
<li>Wait/notify 是 Object 类的方法，而 sleep 是 Thread 类的方法</li>
</ul>
</li>
</ul>
<h2 id="哪些场景需要额外注意线程安全问题">哪些场景需要额外注意线程安全问题？</h2>
<ul>
<li>访问共享变量或资源</li>
<li>依赖时序的操作</li>
<li>不同数据之间存在绑定关系</li>
<li>对方没有声明自己是线程安全的</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/343420053">ref</a></p>
<h2 id="为什么多线程会带来性能问题">为什么多线程会带来性能问题？</h2>
<ul>
<li>线程调度</li>
<li>缓存开销</li>
</ul>
<h2 id="使用线程池比手动创建线程好在哪里">使用线程池比手动创建线程好在哪里？</h2>
<ul>
<li>第一点，线程池可以解决线程生命周期的系统开销问题，同时还可以加快响应速度。因为线程池中的线程是可以复用的，我们只用少量的线程去执行大量的任务，这就大大减小了线程生命周期的开销。而且线程通常不是等接到任务后再临时创建，而是已经创建好时刻准备执行任务，这样就消除了线程创建所带来的延迟，提升了响应速度，增强了用户体验。</li>
<li>第二点，线程池可以统筹内存和 CPU 的使用，避免资源使用不当。线程池会根据配置和任务数量灵活地控制线程数量，不够的时候就创建，太多的时候就回收，避免线程过多导致内存溢出，或线程太少导致 CPU 资源浪费，达到了一个完美的平衡。</li>
<li>第三点，线程池可以统一管理资源。比如线程池可以统一管理任务队列和线程，可以统一开始或结束任务，比单个线程逐一处理任务要更方便、更易于管理，同时也有利于数据统计，比如我们可以很方便地统计出已经执行过的任务的数量。对过多线程占用太多内存资源的问题，解决思路更直接，线程池会根据需要创建线程，控制线程的总数量，避免占用过多内存资源。</li>
</ul>
<h2 id="线程池的各个参数的含义">线程池的各个参数的含义？</h2>
<table>
<thead>
<tr>
<th>参数名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>corePoolsSize</td>
<td>核心线程数</td>
</tr>
<tr>
<td>maxPoolSize</td>
<td>最大线程数</td>
</tr>
<tr>
<td>keepAliveTime + timeUnit</td>
<td>空闲线程的存活时间</td>
</tr>
<tr>
<td>ThreadFactory</td>
<td>线程工厂、用来创建新线程</td>
</tr>
<tr>
<td>workQueue</td>
<td>用于存放任务的队列</td>
</tr>
<tr>
<td>Handter</td>
<td>处理被拒绝的任务</td>
</tr>
</tbody>
</table>
<h2 id="线程池有哪-4-种拒绝策略">线程池有哪 4 种拒绝策略？</h2>
<ul>
<li>拒绝时机
<ul>
<li>第一种情况是当我们调用 shutdown 等方法关闭线程池后，即便此时可能线程池内部依然有没执行完的任务正在执行，但是由于线程池已经关闭，此时如果再向线程池内提交任务，就会遭到拒绝。</li>
<li>第二种情况是线程池没有能力继续处理新提交的任务，也就是工作已经非常饱和的时候。</li>
</ul>
</li>
<li>拒绝策略</li>
<li>第一种拒绝策略是 AbortPolicy，这种拒绝策略在拒绝任务时，会直接抛出一个类型为 RejectedExecutionException 的 RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</li>
<li>第二种拒绝策略是 DiscardPolicy，这种拒绝策略正如它的名字所描述的一样，当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。</li>
<li>第三种拒绝策略是 DiscardOldestPolicy，如果线程池没被关闭且没有能力执行，则会丢弃任务队列中的头结点，通常是存活时间最长的任务，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。</li>
<li>第四种拒绝策略是 CallerRunsPolicy，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。这样做主要有两点好处。
<ul>
<li>第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。</li>
<li>第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</li>
</ul>
</li>
</ul>
<h2 id="有哪-6-种常见的线程池">有哪 6 种常见的线程池?</h2>
<p>FixedThreadPool：第一种线程池叫作 FixedThreadPool，它的核心线程数和最大线程数是一样的，所以可以把它看作是固定线程数的线程池，它的特点是线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。而且就算任务队列满了，到了本该继续增加线程数的时候，由于它的最大线程数和核心线程数是一样的，所以也无法再增加新的线程了。</p>
<p>CachedThreadPool：第二种线程池是 CachedThreadPool，可以称作可缓存线程池，它的特点在于线程数是几乎可以无限增加的，而当线程闲置时还可以对线程进行回收。也就是说该线程池的线程数量不是固定不变的，当然它也有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为 0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。</p>
<p>ScheduledThreadPool：第三个线程池是 ScheduledThreadPool，它支持定时或周期性执行任务。</p>
<ul>
<li>第一种方法 schedule 比较简单，表示延迟指定时间后执行一次任务，如果代码中设置参数为 10 秒，也就是 10 秒后执行一次任务后就结束。</li>
<li>第二种方法 scheduleAtFixedRate 表示以固定的频率执行任务，它的第二个参数 initialDelay 表示第一次延时时间，第三个参数 period 表示周期，也就是第一次延时后每次延时多长时间执行一次任务。</li>
<li>第三种方法 scheduleWithFixedDelay 与第二种方法类似，也是周期执行任务，区别在于对周期的定义，之前的 scheduleAtFixedRate 是以任务开始的时间为时间起点开始计时，时间到就开始执行第二次任务，而不管任务需要花多久执行；而 scheduleWithFixedDelay 方法以任务结束的时间为下一次循环的时间起点开始计时。</li>
</ul>
<p>SingleThreadExecutor：它会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。这种线程池由于只有一个线程，所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。</p>
<p>SingleThreadScheduledExecutor：它实际和第三种 ScheduledThreadPool 线程池非常相似，它只是 ScheduledThreadPool 的一个特例，内部只有一个线程</p>
<p>ForkJoinPool：它非常适合执行可以产生子任务的任务，之前的线程池所有的线程共用一个队列，但 ForkJoinPool 线程池中每个线程都有自己独立的任务队列</p>
<h2 id="线程池常用的阻塞队列有哪些">线程池常用的阻塞队列有哪些？</h2>
<p>第一种阻塞队列是 LinkedBlockingQueue。对于 FixedThreadPool 和 SingleThreadExector 而言，它们使用的阻塞队列是容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue，可以认为是无界队列。由于 FixedThreadPool 线程池的线程数是固定的，所以没有办法增加特别多的线程来处理任务，这时就需要 LinkedBlockingQueue 这样一个没有容量限制的阻塞队列来存放任务。这里需要注意，由于线程池的任务队列永远不会放满，所以线程池只会创建核心线程数量的线程，所以此时的最大线程数对线程池来说没有意义，因为并不会触发生成多于核心线程数的线程。</p>
<p>第二种阻塞队列是 SynchronousQueue，对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。CachedThreadPool 和上一种线程池 FixedThreadPool 的情况恰恰相反，FixedThreadPool 的情况是阻塞队列的容量是无限的，而这里 CachedThreadPool 是线程数可以无限扩展，所以 CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。我们自己创建使用 SynchronousQueue 的线程池时，如果不希望任务被拒绝，那么就需要注意设置最大线程数要尽可能大一些，以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行任务的情况。</p>
<p>第三种阻塞队列是 DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。</p>
<h2 id="合适的线程数量是多少cpu-核心数和线程数的关系">合适的线程数量是多少？CPU 核心数和线程数的关系？</h2>
<ul>
<li>
<p>CPU 密集型：线程数为 CPU 核心数的 1 ～ 2 倍</p>
</li>
<li>
<p>I/O 密集型：线程数 = CPU 核心数 *（1+平均等待时间/平均工作时间）</p>
</li>
<li>
<p>结论</p>
<ul>
<li>线程的平均工作时间所占比例越高，就需要越少的线程；</li>
<li>线程的平均等待时间所占比例越高，就需要越多的线程；</li>
<li>针对不同的程序，进行对应的实际测试就可以得到最合适的选择。</li>
</ul>
</li>
</ul>
<h2 id="如何根据实际需要定制自己的线程池">如何根据实际需要，定制自己的线程池？</h2>
<p>核心线程数：第一个需要设置的参数往往是 corePoolSize 核心线程数，合理的线程数量和任务类型，以及 CPU 核心数都有关系，基本结论是线程的平均工作时间所占比例越高，就需要越少的线程；线程的平均等待时间所占比例越高，就需要越多的线程。而对于最大线程数而言，如果我们执行的任务类型不是固定的，比如可能一段时间是 CPU 密集型，另一段时间是 I/O 密集型，或是同时有两种任务相互混搭。那么在这种情况下，我们可以把最大线程数设置成核心线程数的几倍，以便应对任务突发情况。当然更好的办法是用不同的线程池执行不同类型的任务，让任务按照类型区分开，而不是混杂在一起，这样就可以按照上一课时估算的线程数或经过压测得到的结果来设置合理的线程数了，达到更好的性能。</p>
<p>阻塞队列：对于阻塞队列这个参数而言，我们可以选择之前介绍过的 LinkedBlockingQueue 或者 SynchronousQueue 或者 DelayedWorkQueue，不过还有一种常用的阻塞队列叫 ArrayBlockingQueue，它也经常被用于线程池中，这种阻塞队列内部是用数组实现的，在新建对象的时候要求传入容量值，且后期不能扩容，所以 ArrayBlockingQueue 的最大的特点就是容量是有限的。这样一来，如果任务队列放满了任务，而且线程数也已经达到了最大值，线程池根据规则就会拒绝新提交的任务，这样一来就可能会产生一定的数据丢失。但相比于无限增加任务或者线程数导致内存不足，进而导致程序崩溃，数据丢失还是要更好一些的，如果我们使用了 ArrayBlockingQueue 这种阻塞队列，再加上我们限制了最大线程数量，就可以非常有效地防止资源耗尽的情况发生。此时的队列容量大小和 maxPoolSize 是一个 trade-off，如果我们使用容量更大的队列和更小的最大线程数，就可以减少上下文切换带来的开销，但也可能因此降低整体的吞吐量；如果我们的任务是 IO 密集型，则可以选择稍小容量的队列和更大的最大线程数，这样整体的效率就会更高，不过也会带来更多的上下文切换。</p>
<p>线程工厂：threadFactory 这个参数，我们可以使用默认的 defaultThreadFactory，也可以传入自定义的有额外能力的线程工厂，因为我们可能有多个线程池，而不同的线程池之间有必要通过不同的名字来进行区分，所以可以传入能根据业务信息进行命名的线程工厂，以便后续可以根据线程名区分不同的业务进而快速定位问题代码。</p>
<p>拒绝策略：我们可以根据业务需要，选择四种拒绝策略之一来使用：AbortPolicy，DiscardPolicy，DiscardOldestPolicy 或者 CallerRunsPolicy。除此之外，我们还可以通过实现 RejectedExecutionHandler 接口来实现自己的拒绝策略，在接口中我们需要实现 rejectedExecution 方法，在 rejectedExecution 方法中，执行例如打印日志、暂存任务、重新执行等自定义的拒绝策略，以便满足业务需求。</p>
<h2 id="如何正确关闭线程池shutdown-和-shutdownnow-的区别">如何正确关闭线程池？shutdown 和 shutdownNow 的区别？</h2>
<p><code>shutdown()</code></p>
<p>第一种方法叫作 shutdown()，它可以安全地关闭一个线程池，调用 shutdown() 方法之后线程池并不是立刻就被关闭，因为这时线程池中可能还有很多任务正在被执行，或是任务队列中有大量正在等待被执行的任务，调用 shutdown() 方法后线程池会在执行完正在执行的任务和队列中等待的任务后才彻底关闭。但这并不代表 shutdown() 操作是没有任何效果的，调用 shutdown() 方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。</p>
<p><code>isShutdown()</code></p>
<p>第二个方法叫作 isShutdown()，它可以返回 true 或者 false 来判断线程池是否已经开始了关闭工作，也就是是否执行了 shutdown 或者 shutdownNow 方法。这里需要注意，如果调用 isShutdown() 方法的返回的结果为 true 并不代表线程池此时已经彻底关闭了，这仅仅代表线程池开始了关闭的流程，也就是说，此时可能线程池中依然有线程在执行任务，队列里也可能有等待被执行的任务。</p>
<p><code>isTerminated()</code></p>
<p>第三种方法叫作 isTerminated()，这个方法可以检测线程池是否真正“终结”了，这不仅代表线程池已关闭，同时代表线程池中的所有任务都已经都执行完毕了，因为我们刚才说过，调用 shutdown 方法之后，线程池会继续执行里面未完成的任务，不仅包括线程正在执行的任务，还包括正在任务队列中等待的任务。比如此时已经调用了 shutdown 方法，但是有一个线程依然在执行任务，那么此时调用 isShutdown 方法返回的是 true ，而调用 isTerminated 方法返回的便是 false ，因为线程池中还有任务正在在被执行，线程池并没有真正“终结”。直到所有任务都执行完毕了，调用 isTerminated() 方法才会返回 true，这表示线程池已关闭并且线程池内部是空的，所有剩余的任务都执行完毕了。</p>
<p><code>awaitTermination()</code></p>
<p>第四个方法叫作 awaitTermination()，它本身并不是用来关闭线程池的，而是主要用来判断线程池状态的。比如我们给 awaitTermination 方法传入的参数是 10 秒，那么它就会陷入 10 秒钟的等待，直到发生以下三种情况之一：</p>
<ul>
<li>等待期间（包括进入等待状态之前）线程池已关闭并且所有已提交的任务（包括正在执行的和队列中等待的）都执行完毕，相当于线程池已经“终结”了，方法便会返回 true；</li>
<li>等待超时时间到后，第一种线程池“终结”的情况始终未发生，方法返回 false；</li>
<li>等待期间线程被中断，方法会抛出 InterruptedException 异常。</li>
</ul>
<p>也就是说，调用 awaitTermination 方法后当前线程会尝试等待一段指定的时间，如果在等待时间内，线程池已关闭并且内部的任务都执行完毕了，也就是说线程池真正“终结”了，那么方法就返回 true，否则超时返回 fasle。</p>
<p>我们则可以根据 awaitTermination() 返回的布尔值来判断下一步应该执行的操作。</p>
<p><code>shutdownNow()</code></p>
<p>最后一个方法是 shutdownNow()，也是 5 种方法里功能最强大的，它与第一种 shutdown 方法不同之处在于名字中多了一个单词 Now，也就是表示立刻关闭的意思。在执行 shutdownNow 方法之后，首先会给所有线程池中的线程发送 interrupt 中断信号，尝试中断这些任务的执行，然后会将任务队列中正在等待的所有任务转移到一个 List 中并返回，我们可以根据返回的任务 List 来进行一些补救的操作，例如记录在案并在后期重试。</p>
<h2 id="线程池实现线程复用的原理">线程池实现“线程复用”的原理？</h2>
<p>在线程池中，同一个线程可以从 workQueue 中不断提取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中，不停地检查是否还有任务等待被执行，如果有则直接去执行这个任务，也就是调用任务的 run 方法，把 run 方法当作和普通方法一样的地位去调用，相当于把每个任务的 run() 方法串联了起来，所以线程数量并不增加。</p>
<h2 id="如何看到-synchronized-背后的monitor-锁">如何看到 synchronized 背后的“monitor 锁”？</h2>
<p>用 javap 命令查看反汇编的结果，同步代码块是使用 monitorenter 和 monitorexit 指令实现的。而对于 synchronized 方法，并不是依靠 monitorenter 和 monitorexit 指令实现的，被 javap 反汇编后可以看到，synchronized 方法和普通方法大部分是一样的，不同在于，这个方法会有一个叫作 ACC_SYNCHRONIZED 的 flag 修饰符，来表明它是同步方法。</p>
<h2 id="讲一讲公平锁和非公平锁为什么要非公平">讲一讲公平锁和非公平锁，为什么要“非公平”？</h2>
<p>公平锁指的是按照线程请求的顺序，来分配锁；而非公平锁指的是不完全按照请求的顺序，当线程申请锁时，如果此时锁没有没其他线程持久，则直接申请成功。如果调用<code>tryAcquire</code>可以抢产锁，不管声明是否公平。</p>
<h2 id="读写锁-readwritelock-获取锁有哪些规则">读写锁 ReadWriteLock 获取锁有哪些规则？</h2>
<p>读写锁的获取规则</p>
<ul>
<li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请读锁，可以申请成功。</li>
<li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁，因为读写不能同时操作。</li>
<li>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，都必须等待之前的线程释放写锁，同样也因为读写不能同时，并且两个线程不应该同时写。</li>
</ul>
<p>所以我们用一句话总结：要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现。也可以总结为：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥）。</p>
<h2 id="读锁应该插队吗什么是读写锁的升降级">读锁应该插队吗？什么是读写锁的升降级？</h2>
<ul>
<li>插队策略
<ul>
<li>公平策略下，只要队列里有线程已经在排队，就不允许插队。</li>
<li>非公平策略下：
<ul>
<li>如果允许读锁插队，那么由于读锁可以同时被多个线程持有，所以可能造成源源不断的后面的线程一直插队成功，导致读锁一直不能完全释放，从而导致写锁一直等待，为了防止“饥饿”，在等待队列的头结点是尝试获取写锁的线程的时候，不允许读锁插队。</li>
<li>写锁可以随时插队，因为写锁并不容易插队成功，写锁只有在当前没有任何其他线程持有读锁和写锁的时候，才能插队成功，同时写锁一旦插队失败就会进入等待队列，所以很难造成“饥饿”的情况，允许写锁插队是为了提高效率。</li>
</ul>
</li>
</ul>
</li>
<li>升降级策略：只能从写锁降级为读锁，不能从读锁升级为写锁。</li>
</ul>
<h2 id="什么是自旋锁自旋的好处和后果是什么呢">什么是自旋锁？自旋的好处和后果是什么呢？</h2>
<p>“自旋”可以理解为“自我旋转”，这里的“旋转”指“循环”，比如 while 循环或者 for 循环。“自旋”就是自己在这里不停地循环，直到目标达成。而不像普通的锁那样，如果获取不到锁就进入阻塞。自旋锁适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。可是如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。</p>
<h2 id="jvm-对锁进行了哪些优化">JVM 对锁进行了哪些优化？</h2>
<ul>
<li>自适应的自旋锁：自适应意味着自旋的时间不再固定，而是会根据最近自旋尝试的成功率、失败率，以及当前锁的拥有者的状态等多种因素来共同决定。自旋的持续时间是变化的，自旋锁变“聪明”了。比如，如果最近尝试自旋获取某一把锁成功了，那么下一次可能还会继续使用自旋，并且允许自旋更长的时间；但是如果最近自旋获取某一把锁失败了，那么可能会省略掉自旋的过程，以便减少无用的自旋，提高效率。</li>
<li>锁消除：经过逃逸分析之后，如果发现某些对象不可能被其他线程访问到，那么就可以把它们当成栈上数据，栈上数据由于只有本线程可以访问，自然是线程安全的，也就无需加锁，所以会把这样的锁给自动去除掉。</li>
<li>锁粗化：如果我们把连续几个同步区域扩大，也就是只在最开始加一次锁，并且在最后直接解锁，那么就可以把中间这些无意义的解锁和加锁的过程消除，相当于是把几个 synchronized 块合并为一个较大的同步块。这样做的好处在于在线程执行这些代码时，就无须频繁申请与释放锁了，这样就减少了性能开销。</li>
<li>偏向锁，对于偏向锁而言，它的思想是如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只要打个标记就行了。一个对象在被初始化后，如果还没有任何线程来获取它的锁时，它就是可偏向的，当有第一个线程来访问它尝试获取锁的时候，它就记录下来这个线程，如果后面尝试获取锁的线程正是这个偏向锁的拥有者，就可以直接获取锁，开销很小。</li>
<li>轻量级锁，JVM 的开发者发现在很多情况下，synchronized 中的代码块是被多个线程交替执行的，也就是说，并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决。这种情况下，重量级锁是没必要的。轻量级锁指当锁原来是偏向锁的时候，被另一个线程所访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的方式尝试获取锁，不会阻塞。</li>
<li>重量级锁，这种锁利用操作系统的同步机制实现，所以开销比较大。当多个线程直接有实际竞争，并且锁竞争时间比较长的时候，此时偏向锁和轻量级锁都不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。</li>
</ul>
<h2 id="hashmap-为什么是线程不安全的">HashMap 为什么是线程不安全的？</h2>
<h2 id="concurrenthashmap-在-java7-和-8-有何不同">ConcurrentHashMap 在 Java7 和 8 有何不同？</h2>
<h2 id="同样是线程安全concurrenthashmap-和-hashtable-的区别">同样是线程安全，ConcurrentHashMap 和 Hashtable 的区别？</h2>
<h2 id="copyonwritearraylist-有什么特点">CopyOnWriteArrayList 有什么特点？</h2>
<ul>
<li>特点
<ul>
<li>允许并发读</li>
<li>允许迭代期间修改容器</li>
</ul>
</li>
<li>缺点
<ul>
<li>内存占用问题</li>
<li>在元素较多或者复杂的情况下，复制的开销很大</li>
<li>数据一致性问题</li>
</ul>
</li>
</ul>
<h2 id="什么是阻塞队列">什么是阻塞队列？</h2>
<p>阻塞队列，也就是 BlockingQueue，它是一个接口。BlockingQueue 是线程安全的，我们在很多场景下都可以利用线程安全的队列来优雅地解决我们业务自身的线程安全问题。阻塞功能使得生产者和消费者两端的能力得以平衡，当有任何一端速度过快时，阻塞队列便会把过快的速度给降下来。</p>
<h2 id="阻塞队列包含哪些常用的方法addofferput-等方法的区别">阻塞队列包含哪些常用的方法？add、offer、put 等方法的区别？</h2>
<h2 id="有哪几种常见的阻塞队列">有哪几种常见的阻塞队列？</h2>
<ul>
<li>ArrayBlockingQueue
<ul>
<li>有界队列</li>
<li>用数组存储</li>
</ul>
</li>
<li>LinkedBlockQueue
<ul>
<li>无界队列</li>
<li>用数组存储</li>
</ul>
</li>
<li>SynchronousQueue
<ul>
<li>容量为 0</li>
<li>负责把元素从生产者传给消费者</li>
</ul>
</li>
<li>PriorityBlockingQueue
<ul>
<li>支持优先级的无界阻塞队列</li>
</ul>
</li>
<li>DelayQueue
<ul>
<li>具有延迟功能的队列，可以指定元素多久之后被获取</li>
</ul>
</li>
</ul>
<h2 id="阻塞和非阻塞队列的并发安全原理是什么">阻塞和非阻塞队列的并发安全原理是什么？</h2>
<p>阻塞队列最主要是利用了 ReentrantLock 以及它的 Condition 来实现，而非阻塞队列则是利用 CAS 方法实现线程安全。</p>
<h2 id="如何选择适合自己的阻塞队列">如何选择适合自己的阻塞队列？</h2>
<ul>
<li>功能 第 1 个需要考虑的就是功能层面，比如是否需要阻塞队列帮我们排序，如优先级排序、延迟执行等。如果有这个需要，我们就必须选择类似于 PriorityBlockingQueue 之类的有排序能力的阻塞队列。</li>
<li>容量 第 2 个需要考虑的是容量，或者说是否有存储的要求，还是只需要“直接传递”。在考虑这一点的时候，我们知道前面介绍的那几种阻塞队列，有的是容量固定的，如 ArrayBlockingQueue；有的默认是容量无限的，如 LinkedBlockingQueue；而有的里面没有任何容量，如 SynchronousQueue；而对于 DelayQueue 而言，它的容量固定就是 Integer.MAX_VALUE。 所以不同阻塞队列的容量是千差万别的，我们需要根据任务数量来推算出合适的容量，从而去选取合适的 BlockingQueue。</li>
<li>能否扩容 第 3 个需要考虑的是能否扩容。因为有时我们并不能在初始的时候很好的准确估计队列的大小，因为业务可能有高峰期、低谷期。 如果一开始就固定一个容量，可能无法应对所有的情况，也是不合适的，有可能需要动态扩容。如果我们需要动态扩容的话，那么就不能选择 ArrayBlockingQueue ，因为它的容量在创建时就确定了，无法扩容。相反，PriorityBlockingQueue 即使在指定了初始容量之后，后续如果有需要，也可以自动扩容。 所以我们可以根据是否需要扩容来选取合适的队列。</li>
<li>内存结构 第 4 个需要考虑的点就是内存结构。在上一课时我们分析过 ArrayBlockingQueue 的源码，看到了它的内部结构是“数组”的形式。 和它不同的是，LinkedBlockingQueue 的内部是用链表实现的，所以这里就需要我们考虑到，ArrayBlockingQueue 没有链表所需要的“节点”，空间利用率更高。所以如果我们对性能有要求可以从内存的结构角度去考虑这个问题。</li>
<li>性能 第 5 点就是从性能的角度去考虑。比如 LinkedBlockingQueue 由于拥有两把锁，它的操作粒度更细，在并发程度高的时候，相对于只有一把锁的 ArrayBlockingQueue 性能会更好。 另外，SynchronousQueue 性能往往优于其他实现，因为它只需要“直接传递”，而不需要存储的过程。如果我们的场景需要直接传递的话，可以优先考虑 SynchronousQueue。</li>
</ul>
<h2 id="atomicinteger-在高并发下性能不好如何解决为什么">AtomicInteger 在高并发下性能不好，如何解决？为什么？</h2>
<p>在低竞争的情况下，AtomicLong 和 LongAdder 这两个类具有相似的特征，吞吐量也是相似的，因为竞争不高。但是在竞争激烈的情况下，LongAdder 的预期吞吐量要高得多，经过试验，LongAdder 的吞吐量大约是 AtomicLong 的十倍，不过凡事总要付出代价，LongAdder 在保证高效的同时，也需要消耗更多的空间。</p>
<p>那么我们就要考虑了，有了更高效的 LongAdder，那 AtomicLong 可否不使用了呢？是否凡是用到 AtomicLong 的地方，都可以用 LongAdder 替换掉呢？答案是不是的，这需要区分场景。</p>
<p>LongAdder 只提供了 add、increment 等简单的方法，适合的是统计求和计数的场景，场景比较单一，而 AtomicLong 还具有 compareAndSet 等高级方法，可以应对除了加减之外的更复杂的需要 CAS 的场景。</p>
<p>结论：如果我们的场景仅仅是需要用到加和减操作的话，那么可以直接使用更高效的 LongAdder，但如果我们需要利用 CAS 比如 compareAndSet 等操作的话，就需要使用 AtomicLong 来完成。</p>
<h2 id="原子类和-volatile-有什么异同">原子类和 volatile 有什么异同？</h2>
<p>volatile 和原子类的使用场景是不一样的，如果我们有一个可见性问题，那么可以使用 volatile 关键字，但如果我们的问题是一个组合操作，需要用同步来解决原子性问题的话，那么可以使用原子变量，而不能使用 volatile 关键字。 通常情况下，volatile 可以用来修饰 boolean 类型的标记位，因为对于标记位来讲，直接的赋值操作本身就是具备原子性的，再加上 volatile 保证了可见性，那么就是线程安全的了。 而对于会被多个线程同时操作的计数器 Counter 的场景，这种场景的一个典型特点就是，它不仅仅是一个简单的赋值操作，而是需要先读取当前的值，然后在此基础上进行一定的修改，再把它给赋值回去。这样一来，我们的 volatile 就不足以保证这种情况的线程安全了。我们需要使用原子类来保证线程安全。</p>
<h2 id="atomicinteger-和-synchronized-的异同点">AtomicInteger 和 synchronized 的异同点？</h2>
<p>第一点，我们来看一下它们背后原理的不同。 我们分析了 synchronized 背后的 monitor 锁，也就是 synchronized 原理，同步方法和同步代码块的背后原理会有少许差异，但总体思想是一致的：在执行同步代码之前，需要首先获取到 monitor 锁，执行完毕后，再释放锁。 关于原子类，它保证线程安全的原理是利用了 CAS 操作。从这一点上看，虽然原子类和 synchronized 都能保证线程安全，但是其实现原理是大有不同的。</p>
<p>第二点不同是使用范围的不同。 对于原子类而言，它的使用范围是比较局限的。因为一个原子类仅仅是一个对象，不够灵活。而 synchronized 的使用范围要广泛得多。比如说 synchronized 既可以修饰一个方法，又可以修饰一段代码，相当于可以根据我们的需要，非常灵活地去控制它的应用范围。 所以仅有少量的场景，例如计数器等场景，我们可以使用原子类。而在其他更多的场景下，如果原子类不适用，那么我们就可以考虑用 synchronized 来解决这个问题。</p>
<p>第三个区别是粒度的区别。 原子变量的粒度是比较小的，它可以把竞争范围缩小到变量级别。通常情况下，synchronized 锁的粒度都要大于原子变量的粒度。如果我们只把一行代码用 synchronized 给保护起来的话，有一点杀鸡焉用牛刀的感觉。</p>
<p>第四点是它们性能的区别，同时也是悲观锁和乐观锁的区别。 因为 synchronized 是一种典型的悲观锁，而原子类恰恰相反，它利用的是乐观锁。所以，我们在比较 synchronized 和 AtomicInteger 的时候，其实也就相当于比较了悲观锁和乐观锁的区别。 从性能上来考虑的话，悲观锁的操作相对来讲是比较重量级的。因为 synchronized 在竞争激烈的情况下，会让拿不到锁的线程阻塞，而原子类是永远不会让线程阻塞的。不过，虽然 synchronized 会让线程阻塞，但是这并不代表它的性能就比原子类差。 因为悲观锁的开销是固定的，也是一劳永逸的。随着时间的增加，这种开销并不会线性增长。 而乐观锁虽然在短期内的开销不大，但是随着时间的增加，它的开销也是逐步上涨的。 所以从性能的角度考虑，它们没有一个孰优孰劣的关系，而是要区分具体的使用场景。在竞争非常激烈的情况下，推荐使用 synchronized；而在竞争不激烈的情况下，使用原子类会得到更好的效果。 值得注意的是，synchronized 的性能随着 JDK 的升级，也得到了不断的优化。synchronized 会从无锁升级到偏向锁，再升级到轻量级锁，最后才会升级到让线程阻塞的重量级锁。因此 synchronized 在竞争不激烈的情况下，性能也是不错的，不需要“谈虎色变”。</p>
<h2 id="java-8-中-adder-和-accumulator-有什么区别">Java 8 中 Adder 和 Accumulator 有什么区别？</h2>
<h2 id="threadlocal-是用来解决共享资源的多线程访问的问题吗">ThreadLocal 是用来解决共享资源的多线程访问的问题吗？</h2>
<h2 id="多个-threadlocal-在-thread-中的-threadlocals-里是怎么存储的">多个 ThreadLocal 在 Thread 中的 threadlocals 里是怎么存储的？</h2>
<h2 id="内存泄漏为何每次用完-threadlocal-都要调用-remove">内存泄漏——为何每次用完 ThreadLocal 都要调用 remove()？</h2>
<h2 id="callable-和-runnable-的不同">Callable 和 Runnable 的不同？</h2>
<h2 id="future-的主要功能是什么">Future 的主要功能是什么？</h2>
<p>Future 最主要的作用是，比如当做一定运算的时候，运算过程可能比较耗时，有时会去查数据库，或是繁重的计算，比如压缩、加密等，在这种情况下，如果我们一直在原地等待方法返回，显然是不明智的，整体程序的运行效率会大大降低。我们可以把运算的过程放到子线程去执行，再通过 Future 去控制子线程执行的计算过程，最后获取到计算结果。这样一来就可以把整个程序的运行效率提高，是一种异步的思想。</p>
<h2 id="使用-future-有哪些注意点future-产生新的线程了吗">使用 Future 有哪些注意点？Future 产生新的线程了吗？</h2>
<p>信号量可以在在执行到特定条件的时候再去限制线程数量。</p>
<p>信号量具有跨线程、跨线程池的特性，所以即便这些请求来自于不同的线程池，我们也可以限制它们的访问。如果用 FixedThreadPool 去限制，那就做不到跨线程池限制了，这样的话会让功能大大削弱。</p>
<h2 id="如何利用-completablefuture-实现旅游平台问题">如何利用 CompletableFuture 实现“旅游平台”问题？</h2>
<h2 id="信号量能被-fixedthreadpool-替代吗">信号量能被 FixedThreadPool 替代吗？</h2>
<h2 id="countdownlatch-是如何安排线程执行顺序的">CountDownLatch 是如何安排线程执行顺序的？</h2>
<h2 id="cyclicbarrier-和-countdownlatch-有什么异同">CyclicBarrier 和 CountdownLatch 有什么异同？</h2>
<h2 id="conditionobjectwait-和-notify-的关系">Condition、object.wait() 和 notify() 的关系？</h2>
<h2 id="讲一讲什么是-java-内存模型">讲一讲什么是 Java 内存模型？</h2>
<h2 id="什么是指令重排序为什么要重排序">什么是指令重排序？为什么要重排序？</h2>
<h2 id="java-中的原子操作有哪些注意事项">Java 中的原子操作有哪些注意事项？</h2>
<h2 id="什么是内存可见性问题">什么是“内存可见性”问题？</h2>
<h2 id="主内存和工作内存的关系">主内存和工作内存的关系？</h2>
<h2 id="什么是-happens-before-规则">什么是 happens-before 规则？</h2>
<h2 id="volatile-的作用是什么与-synchronized-有什么异同">volatile 的作用是什么？与 synchronized 有什么异同？</h2>
<h2 id="单例模式的双重检查锁模式为什么必须加-volatile">单例模式的双重检查锁模式为什么必须加 volatile？</h2>
<h2 id="你知道什么是-cas-吗">你知道什么是 CAS 吗？</h2>
<p>Compare-And-Swap，通过将内存中的值与指定数据进行比较，当这两个数值一样时，才将内存中的数据替换为新的值，整个过程是具备原子性的</p>
<p>CAS 有三个操作数：内存值 V、预期值 A、要修改的值 B。CAS 最核心的思路就是，仅当预期值 A 和当前的内存值 V 相同时，才将内存值修改为 B。</p>
<h2 id="cas-和乐观锁的关系什么时候会用到-cas">CAS 和乐观锁的关系，什么时候会用到 CAS？</h2>
<ul>
<li>并发容器</li>
<li>数据库</li>
<li>原子类</li>
</ul>
<h2 id="cas-有什么缺点">CAS 有什么缺点？</h2>
<p>ABA 问题：通过添加版本号解决
自旋时间时间过长：配合场景决定是否使用 CAS
范围不能灵活控制：我们不能针对多个共享变量同时进行 CAS 操作，需要通过一个新的类把这些共享变量整合到一起。</p>
<h2 id="发生死锁必须满足哪-4-个条件">发生死锁必须满足哪 4 个条件？</h2>
<ul>
<li>第 1 个叫互斥条件，它的意思是每个资源每次只能被一个线程（或进程，下同）使用，为什么资源不能同时被多个线程或进程使用呢？这是因为如果每个人都可以拿到想要的资源，那就不需要等待，所以是不可能发生死锁的。</li>
<li>第 2 个是请求与保持条件，它是指当一个线程因请求资源而阻塞时，则需对已获得的资源保持不放。如果在请求资源时阻塞了，并且会自动释放手中资源（例如锁）的话，那别人自然就能拿到我刚才释放的资源，也就不会形成死锁。</li>
<li>第 3 个是不剥夺条件，它是指线程已获得的资源，在未使用完之前，不会被强行剥夺。比如我们在上一课时中介绍的数据库的例子，它就有可能去强行剥夺某一个事务所持有的资源，这样就不会发生死锁了。所以要想发生死锁，必须满足不剥夺条件，也就是说当现在的线程获得了某一个资源后，别人就不能来剥夺这个资源，这才有可能形成死锁。</li>
<li>第 4 个是循环等待条件，只有若干线程之间形成一种头尾相接的循环等待资源关系时，才有可能形成死锁，比如在两个线程之间，这种“循环等待”就意味着它们互相持有对方所需的资源、互相等待；而在三个或更多线程中，则需要形成环路，例如依次请求下一个线程已持有的资源等。</li>
</ul>
<h2 id="如何用命令行和代码定位死锁">如何用命令行和代码定位死锁？</h2>
<ul>
<li>jstack</li>
<li>ThreadMXBean</li>
</ul>
<h2 id="有哪些解决死锁问题的策略">有哪些解决死锁问题的策略？</h2>
<ul>
<li>一是避免策略，其主要思路就是去改变锁的获取顺序，防止相反顺序获取锁这种情况的发生；</li>
<li>二是检测与恢复策略，它是允许死锁发生，但是一旦发生之后它有解决方案；</li>
<li>三是鸵鸟策略。</li>
</ul>
<h2 id="final-的几种用法是什么">final 的几种用法是什么？</h2>
<ul>
<li>final 修饰变量：关键字 final 修饰变量的作用是很明确的，那就是意味着这个变量一旦被赋值就不能被修改了，也就是说只能被赋值一次</li>
<li>final 修饰参数：没有办法在方法内部对这个参数进行修改</li>
<li>final 修饰方法：被 final 修饰的方法不可以被重写，不能被 override。</li>
<li>final 修饰类：无法被继承</li>
</ul>
<h2 id="为什么加了-final-却依然无法拥有不变性">为什么加了 final 却依然无法拥有“不变性”？</h2>
<p>用 final 修饰一个对象类型的变量的时候，只能保证它的引用不变，但是对象内容自身依然是可以变的。</p>
<h2 id="为什么-string-被设计为是不可变的">为什么 String 被设计为是不可变的？</h2>
<ul>
<li>字符串常量池,节省大量的内存空间</li>
<li>缓存 HashCode，可以直接返回缓存的 HashCode，不需要重新计算</li>
<li>天然的线程安全</li>
<li>适合作为 HashMap 的 key</li>
</ul>
<h2 id="为什么需要-aqsaqs-的作用和重要性是什么">为什么需要 AQS？AQS 的作用和重要性是什么？</h2>
<h2 id="aqs-的内部原理是什么样的">AQS 的内部原理是什么样的？</h2>
<h2 id="aqs-在-countdownlatch-等类中的应用原理是什么">AQS 在 CountDownLatch 等类中的应用原理是什么？</h2>

  
  </div>
</article>


    <footer id="footer">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
  <div class="footer-left">
    Copyright  &copy; 2021  Y.CH.Y 
    <span id="busuanzi_container_page_pv">Page PV : <span id="busuanzi_value_page_pv"></span></span>
    <span id="busuanzi_container_site_uv">Site UV : <span id="busuanzi_value_site_uv"></span></span>
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">Home</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
