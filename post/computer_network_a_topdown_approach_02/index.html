<!DOCTYPE html>
<html lang="en-us">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> 计算机网络自顶向下方法::应用层 | Y.CH.Y</title>
  <link rel = 'canonical' href = '/post/computer_network_a_topdown_approach_02/'>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="计算机网络自顶向下方法::应用层" />
<meta property="og:description" content="应用层协议原理  应用层协议原理  研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序 当研发新应用程序时，你需要编写将在多台端系统上运行的软件   网络应用体系结构  从应用程序研发者的角度看，网络体系结构是固定的，并为应用程序提供了特定的服务集合 应用程序体系结构 (application architecture) 由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。  客户-服务器体系结构  有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求 客户-服务器体系结构，客户相互之间不直接通信 服务器具有固定的、周知的地址，该地址称为 IP 地址 具有客户-服务器体系结构的非常著名的应用程序包括 Web、FTP、Telnet 和电子邮件 一个流行的社交网络站点如果仅有一台服务器来处理所有请求，将很快变得不堪重负。为此，配备大量主机的数据中心(data center)常被用于创建强大的虚拟服务器。   P2P 体系结构  对数据中心服务器有最小的依赖 应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为对等方 具有自扩展性，成本效率高，不需要庞大的基础设施 具有 P2P 体系结构的应用包括 BitTorrent、因特网电话和视频会议(例如 Skype)       进程通信  客户与服务器通信  网络应用程序由成对的进程组成，这些进程通过网络相互发送报文 对每对通信进程，我们通常将这两个进程之一标识为客户(client) , 而另一个进程标识为服务器 在 P2P 文件共享的某些应用中，一个进程能够既是客户又是服务器 我们定义客户和服务器进程如下: 在一对进程之间的通信会话场景中，发起通信(即在该会话开始时发起与其他进程的联系)的进程被标识为客户，在会话开始时等待联系的进程是服务器   进程与计算机网络之问的接口  进程通过一个称为套接字(socket)的软件接口向网络发送报文和从网络接收报文 套接字是同一台主机内应用层与运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口   进程寻址  为了标识该接收进程，需要定义两种信息  主机的地址 目的主机中指定接受进程的标识符   在因特网中，主机由其 IP 地址 (IP adress) 标识 目的地端口号 (port number) 用于指定运行在接收主机上的接收进程(更具体地说，接收套接字)     可供应用程序使用的运输服务  可靠数据传输  确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端   吞吐量  运输层协议能够以某种特定的速率提供确保的可用吞吐量 带宽敏感的应用具有特定的吞吐量要求，而弹性应用 (elastic application) 能够根据当时可用的带宽或多或少地利用可供使用的吞吐量   定时  运输层协议也能提供定时保证，能够以多种形式实现。这种服务将对交互式实时应用程序有吸引力。   安全性  在发送和接收进程之间提供机密性，以防该数据以某种方式在这两个进程之间被观察到。运输协议还能提供除了机密性以外的其他安全性服务，包括数据完整性和端点鉴别     因特网的提供的运输服务  TCP 服务  面向连接服务和可靠数据传输服务 在应用层数据报文开始流动之前，TCP 让客户端和服务器互相交换运输层控制信息。在握手后，一个全双工 TCP 连接就在两者之间建立了。当应用程序结束报文发送时，必须拆除该连接。 通信进程能够依靠 TCP, 无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠 TCP 将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。 TCP 也提供拥塞控制机制，当发送方和接收方之间的网络出现拥塞时，TCP 的拥塞控制机制会抑制发送进程，TCP 拥塞控制也试图限制每个 TCP 连接，使它们达到公平共享网络带宽的目的。   UDP 服务  UDP 是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP 是无连接的，因此在两个进程通信前没有握手过程。 UDP 协议提供一种不可靠数据传送服务，不保证报文能到达接受进程，也不保证顺序。 UDP 没有拥塞控制机制，可以以任意速率向下层注入数据。   运输协议不提供的服务  吞吐量和定时保证     应用层协议  交换的报文类型，例如请求报文和响应报文。 各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。 字段的语义，即这些字段中的信息的含义。 确定一个进程何时以及如何发送报文，对报文进行响应的规则。    Web 和 HTTP   HTTP 概况" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/computer_network_a_topdown_approach_02/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-16T20:26:06+08:00" />
<meta property="article:modified_time" content="2021-06-16T20:26:06+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="计算机网络自顶向下方法::应用层"/>
<meta name="twitter:description" content="应用层协议原理  应用层协议原理  研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序 当研发新应用程序时，你需要编写将在多台端系统上运行的软件   网络应用体系结构  从应用程序研发者的角度看，网络体系结构是固定的，并为应用程序提供了特定的服务集合 应用程序体系结构 (application architecture) 由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。  客户-服务器体系结构  有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求 客户-服务器体系结构，客户相互之间不直接通信 服务器具有固定的、周知的地址，该地址称为 IP 地址 具有客户-服务器体系结构的非常著名的应用程序包括 Web、FTP、Telnet 和电子邮件 一个流行的社交网络站点如果仅有一台服务器来处理所有请求，将很快变得不堪重负。为此，配备大量主机的数据中心(data center)常被用于创建强大的虚拟服务器。   P2P 体系结构  对数据中心服务器有最小的依赖 应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为对等方 具有自扩展性，成本效率高，不需要庞大的基础设施 具有 P2P 体系结构的应用包括 BitTorrent、因特网电话和视频会议(例如 Skype)       进程通信  客户与服务器通信  网络应用程序由成对的进程组成，这些进程通过网络相互发送报文 对每对通信进程，我们通常将这两个进程之一标识为客户(client) , 而另一个进程标识为服务器 在 P2P 文件共享的某些应用中，一个进程能够既是客户又是服务器 我们定义客户和服务器进程如下: 在一对进程之间的通信会话场景中，发起通信(即在该会话开始时发起与其他进程的联系)的进程被标识为客户，在会话开始时等待联系的进程是服务器   进程与计算机网络之问的接口  进程通过一个称为套接字(socket)的软件接口向网络发送报文和从网络接收报文 套接字是同一台主机内应用层与运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口   进程寻址  为了标识该接收进程，需要定义两种信息  主机的地址 目的主机中指定接受进程的标识符   在因特网中，主机由其 IP 地址 (IP adress) 标识 目的地端口号 (port number) 用于指定运行在接收主机上的接收进程(更具体地说，接收套接字)     可供应用程序使用的运输服务  可靠数据传输  确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端   吞吐量  运输层协议能够以某种特定的速率提供确保的可用吞吐量 带宽敏感的应用具有特定的吞吐量要求，而弹性应用 (elastic application) 能够根据当时可用的带宽或多或少地利用可供使用的吞吐量   定时  运输层协议也能提供定时保证，能够以多种形式实现。这种服务将对交互式实时应用程序有吸引力。   安全性  在发送和接收进程之间提供机密性，以防该数据以某种方式在这两个进程之间被观察到。运输协议还能提供除了机密性以外的其他安全性服务，包括数据完整性和端点鉴别     因特网的提供的运输服务  TCP 服务  面向连接服务和可靠数据传输服务 在应用层数据报文开始流动之前，TCP 让客户端和服务器互相交换运输层控制信息。在握手后，一个全双工 TCP 连接就在两者之间建立了。当应用程序结束报文发送时，必须拆除该连接。 通信进程能够依靠 TCP, 无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠 TCP 将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。 TCP 也提供拥塞控制机制，当发送方和接收方之间的网络出现拥塞时，TCP 的拥塞控制机制会抑制发送进程，TCP 拥塞控制也试图限制每个 TCP 连接，使它们达到公平共享网络带宽的目的。   UDP 服务  UDP 是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP 是无连接的，因此在两个进程通信前没有握手过程。 UDP 协议提供一种不可靠数据传送服务，不保证报文能到达接受进程，也不保证顺序。 UDP 没有拥塞控制机制，可以以任意速率向下层注入数据。   运输协议不提供的服务  吞吐量和定时保证     应用层协议  交换的报文类型，例如请求报文和响应报文。 各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。 字段的语义，即这些字段中的信息的含义。 确定一个进程何时以及如何发送报文，对报文进行响应的规则。    Web 和 HTTP   HTTP 概况"/>

  
  
    
  
  
  <link rel="stylesheet" href="/css/styles.ace637160e3ee466ac48adf2107be5e9e0b7f168aff4b05023ac0c573f8200b3f1ced7d604b86d1b519cf620f8b1bc3c13abec114d6d055da6327e8e79ac3dfb.css" integrity="sha512-rOY3Fg4&#43;5GasSK3yEHvl6eC38Wiv9LBQI6wMVz&#43;CALPxztfWBLhtG1Gc9iD4sbw8E6vsEU1tBV2mMn6Oeaw9&#43;w=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="/images/favicon.ico" />

  
  
  
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-X1L70M4MM0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="/">
  
    <div id="logo" style="background-image: url(/images/logo.png)"></div>
  
  <div id="title">
    <h1>Y.CH.Y</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">Home</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <h2 id="应用层协议原理">应用层协议原理</h2>
<ul>
<li>应用层协议原理
<ul>
<li>研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序</li>
<li>当研发新应用程序时，你需要编写将在多台端系统上运行的软件</li>
</ul>
</li>
<li>网络应用体系结构
<ul>
<li>从应用程序研发者的角度看，网络体系结构是固定的，并为应用程序提供了特定的服务集合</li>
<li>应用程序体系结构 (application architecture) 由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。
<ul>
<li>客户-服务器体系结构
<ul>
<li>有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求</li>
<li>客户-服务器体系结构，客户相互之间不直接通信</li>
<li>服务器具有固定的、周知的地址，该地址称为 IP 地址</li>
<li>具有客户-服务器体系结构的非常著名的应用程序包括 Web、FTP、Telnet 和电子邮件</li>
<li>一个流行的社交网络站点如果仅有一台服务器来处理所有请求，将很快变得不堪重负。为此，配备大量主机的数据中心(data center)常被用于创建强大的虚拟服务器。</li>
</ul>
</li>
<li>P2P 体系结构
<ul>
<li>对数据中心服务器有最小的依赖</li>
<li>应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为对等方</li>
<li>具有自扩展性，成本效率高，不需要庞大的基础设施</li>
<li>具有 P2P 体系结构的应用包括 BitTorrent、因特网电话和视频会议(例如 Skype)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程通信
<ul>
<li>客户与服务器通信
<ul>
<li>网络应用程序由成对的进程组成，这些进程通过网络相互发送报文</li>
<li>对每对通信进程，我们通常将这两个进程之一标识为客户(client) , 而另一个进程标识为服务器</li>
<li>在 P2P 文件共享的某些应用中，一个进程能够既是客户又是服务器</li>
<li>我们定义客户和服务器进程如下: 在一对进程之间的通信会话场景中，发起通信(即在该会话开始时发起与其他进程的联系)的进程被标识为客户，在会话开始时等待联系的进程是服务器</li>
</ul>
</li>
<li>进程与计算机网络之问的接口
<ul>
<li>进程通过一个称为套接字(socket)的软件接口向网络发送报文和从网络接收报文</li>
<li>套接字是同一台主机内应用层与运输层之间的接口。由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口</li>
</ul>
</li>
<li>进程寻址
<ul>
<li>为了标识该接收进程，需要定义两种信息
<ul>
<li>主机的地址</li>
<li>目的主机中指定接受进程的标识符</li>
</ul>
</li>
<li>在因特网中，主机由其 IP 地址 (IP adress) 标识</li>
<li>目的地端口号 (port number) 用于指定运行在接收主机上的接收进程(更具体地说，接收套接字)</li>
</ul>
</li>
</ul>
</li>
<li>可供应用程序使用的运输服务
<ul>
<li>可靠数据传输
<ul>
<li>确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端</li>
</ul>
</li>
<li>吞吐量
<ul>
<li>运输层协议能够以某种特定的速率提供确保的可用吞吐量</li>
<li>带宽敏感的应用具有特定的吞吐量要求，而弹性应用 (elastic application) 能够根据当时可用的带宽或多或少地利用可供使用的吞吐量</li>
</ul>
</li>
<li>定时
<ul>
<li>运输层协议也能提供定时保证，能够以多种形式实现。这种服务将对交互式实时应用程序有吸引力。</li>
</ul>
</li>
<li>安全性
<ul>
<li>在发送和接收进程之间提供机密性，以防该数据以某种方式在这两个进程之间被观察到。运输协议还能提供除了机密性以外的其他安全性服务，包括数据完整性和端点鉴别</li>
</ul>
</li>
</ul>
</li>
<li>因特网的提供的运输服务
<ul>
<li>TCP 服务
<ul>
<li>面向连接服务和可靠数据传输服务</li>
<li>在应用层数据报文开始流动之前，TCP 让客户端和服务器互相交换运输层控制信息。在握手后，一个全双工 TCP 连接就在两者之间建立了。当应用程序结束报文发送时，必须拆除该连接。</li>
<li>通信进程能够依靠 TCP, 无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠 TCP 将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。</li>
<li>TCP 也提供拥塞控制机制，当发送方和接收方之间的网络出现拥塞时，TCP 的拥塞控制机制会抑制发送进程，TCP 拥塞控制也试图限制每个 TCP 连接，使它们达到公平共享网络带宽的目的。</li>
</ul>
</li>
<li>UDP 服务
<ul>
<li>UDP 是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP 是无连接的，因此在两个进程通信前没有握手过程。</li>
<li>UDP 协议提供一种不可靠数据传送服务，不保证报文能到达接受进程，也不保证顺序。</li>
<li>UDP 没有拥塞控制机制，可以以任意速率向下层注入数据。</li>
</ul>
</li>
<li>运输协议不提供的服务
<ul>
<li>吞吐量和定时保证</li>
</ul>
</li>
</ul>
</li>
<li>应用层协议
<ul>
<li>交换的报文类型，例如请求报文和响应报文。</li>
<li>各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。</li>
<li>字段的语义，即这些字段中的信息的含义。</li>
<li>确定一个进程何时以及如何发送报文，对报文进行响应的规则。</li>
</ul>
</li>
</ul>
<h2 id="web-和-http">Web 和 HTTP</h2>
<ul>
<li>
<p>HTTP 概况</p>
<ul>
<li>Web 的应用层协议是超文本传输协议 (HyperText Transfer Protocol, HTTP) , 它是 Web 的核心</li>
<li>HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的方式</li>
<li>Web 页面 (Web page) (也叫文档)是由对象组成的。一个对象 (objeel) 只是一个文件，诸如一个 HTML 文件、一个 JPEG 图形、一个 Java 小程序或一个视频片段这样的文件，且它们可通过一个 URL 地址寻址。多数 Web 页面含有一个 HTML 基本文件 (baseHTML file) 以及几个引用对象。</li>
<li>每个 URL 地址由两部分组成:存放对象的服务器主机名和对象的路径名</li>
<li>Web 浏览器 (Web browser) (例如 IE 和 Firefox) 实现了 HTTP 的客户端</li>
<li>Web 服务器 (Weh server) 实现了 HTTP 的服务器端，它用于存储 Web 对象，每个对象由 URL 寻址。</li>
<li>HTTP 定义了 Web 客户向 Web 服务器请求 Web 页面的方式，以及服务器向客户传送 Web 页面的方式</li>
<li>HTTP 使用 TCP 作为它的支撑运输协议</li>
<li>因为 HTTP 服务器并不保存关于客户的任何信息，所以我们说 HTTP 是一个无状态协议</li>
</ul>
</li>
<li>
<p>非连续连接和连续连接</p>
<ul>
<li>考虑一个 HTML 页面，包含了额外 10 个对象</li>
<li>采用非连续连接会产生 11 个连接，以及额外的 10 个 RTT</li>
<li>采用连续连接会产生 1 个连接</li>
</ul>
</li>
<li>
<p>HTTP 报文格式</p>
<ul>
<li>
<p>请求报文</p>
<ul>
<li>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#75af00">GET</span> <span style="color:#111">/somedir/page.html</span> <span style="color:#00a8c8">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span>
<span style="color:#111">Host</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">www.someschool.edu</span>
<span style="color:#111">Connection</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">close</span>
<span style="color:#111">User-agent</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">Mozilla/5.0</span>
<span style="color:#111">Accept-language</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">fr</span>

(data data data data data ...)
</code></pre></div></li>
<li>
<p>HTTP 请求报文的第一行叫作请求行 ( request line) , 其后继的行叫作首部行 (header line)。</p>
</li>
<li>
<p>请求行有 3 个字段:方法字段、URL 字段和 HTTP 版本字段。方法字段可以取几种不同的值，包括 GET、POST、HEAD 、PUT 和 DELETE 等，绝大部分的 HTTP 请求报文使用 GET 方法。当浏览器请求一个对象时，使用 GET 方法，在 URL 字段带有请求对象的标识。在本例中，该浏览器正在请求对象 /somedir/page.html。其版本字段是自解释的，在本例中，浏览器实现的是 HTTP/1.1 版本。</p>
</li>
<li>
<p>首部行 Host: <a href="http://www.someschool.edu">www.someschool.edu</a> 指明了对象所在的主机。</p>
</li>
<li>
<p>connection: close 首部行，该浏览器告诉服务器不要麻烦地使用持续连接，它要求服务器在发送完被请求的对象后就关闭这条连接。</p>
</li>
<li>
<p>User-agent: 首部行用来指明用户代理即向服务器发送请求的浏览器的类型。这里浏览器类型是 Mozilla/5.0, 即 Firefox 浏览器。这个首部行是有用的，因为服务器可以有效地为不同类型的用户代理实际发送相同对象的不同版本。</p>
</li>
<li>
<p>最后，Accept-language: 首部行表示用户想得到该对象的法语版本(如果服务器中有这样的对象的话);否则，服务器应当发送它的默认版本。Accept-language: 首部行仅是 HTTP 中可用的众多内容协商首部之一</p>
</li>
<li>
<p>GET 请求也可以携带 body，但大多数服务器不会处理</p>
</li>
</ul>
</li>
<li>
<p>响应报文</p>
<ul>
<li>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#00a8c8">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span> <span style="color:#ae81ff">200</span> <span style="color:#75af00">OK</span>
<span style="color:#111">Connection</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">close</span>
<span style="color:#111">Date</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">Tue, 18 Aug 2015 15:44:04 GMT</span>
<span style="color:#111">Server</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">Apache/2.2.3 (CentOS)</span>
<span style="color:#111">Last-Modified</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">Tue, 18 Aug 2015 15:11:03 GMT</span>
<span style="color:#111">Content-Length</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">6821</span>
<span style="color:#111">Content-Type</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">text/html</span>

(data data data data data ...)
</code></pre></div></li>
<li>
<p>它有三个部分:一个初始状态行 (stalus line), 6 个 首部行 (headerline) , 然后是实体体 (entity body)。 实体体部分是报文的主要部分，即它包含了所请求的对象本身 (表示为 data data data data data ···)。状态行有 3 个字段:协议版本字段、状态码和相应状态信息。在这个例子中，状态行指示服务器正在使用 HTTP/1.1 并且一切正常。</p>
</li>
<li>
<p>服务器用 Connection: close 首部行告诉客户，发送完报文后将关闭该 TCP 连接 。</p>
</li>
<li>
<p>Date: 首部行指示服务器产生并发送该响应报文的日期和时间。值得一提的是，这个时间不是指对象创建或者最后修改的时间，而是服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间。</p>
</li>
<li>
<p>Server: 首部行指示该报文是由一台 Apache Web 服务器产生的、它类似于 HTTP 请求报文中的 User-agent : 首部行。</p>
</li>
<li>
<p>Last-Modified: 首部行指示了对象创建或者最后修改的日期和时间。Last-Modified : 首部行对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非状态行常重要。</p>
</li>
<li>
<p>Content-Length: 首部行指示了被发送对象中的字节数。</p>
</li>
<li>
<p>Content-Type : 首部行指示了实体体中的对象是 HTML 文本。</p>
</li>
</ul>
</li>
<li>
<p>常见 HTTP 状态码和说明</p>
<ul>
<li>200 OK: 请求成功，信息在返回的响应报文中。</li>
<li>301 Moved Permanently: 请求的对象已经被永久转移了，新的 URL 定义在响应报的 Location: 首部行中。客户软件将自动获取新的 URL</li>
<li>400 Bad Request : 一个通用差错代码，指示该请求不能被服务器理解。</li>
<li>404 Not Found: 被请求的文档不在服务器上。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Cookie</p>
<ul>
<li>HTTP 使用 cookie 识别客户端</li>
<li>cookie 技术有 4 个组件:
<ul>
<li>在 HTTP 响应报文中的一个 cookie 首部行</li>
<li>在 HTTP 请求报文中的一个 cookie 首部行</li>
<li>在用户端系统中保留有一个 cookie 文件，并由用户的浏览器进行管理</li>
<li>位于 Web 站点的一个后端数据库</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Web 缓存</p>
<ul>
<li>web 缓存器 (Web cache) 也叫代理服务器 (proxy server),它是能够代表初始 Web 服务器来满足 HTTP 请求的网络 实体。Web 缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。</li>
<li>通过使用内容分发网络(Content Distribution Network, CDN),Web 缓存器正在因特网中发挥着越来越重要的作用。CDN 公司在因特网上安装了许多地理上分散的缓存器，因而使大量流量实现了本地化。有多个共享的 CDN (例如 Akamai 和 Limelight) 和专用的 CDN (例如谷歌和 Netflix) 。</li>
</ul>
</li>
<li>
<p>条件 GET 方法</p>
<ul>
<li>针对缓存过期问题，HTTP 协议有一种机制，允许缓存器证实它的对象是最新的。这种机制就是条件 GET (conditional GET)方法。如果: 请求报文使用 GET 方法并且请求报文中包含一个 &lsquo;If-Modified-Since:&rsquo; 首部行，那么，这个 HTTP 请求报文就是一个条件 GET 请求报文 。</li>
</ul>
</li>
</ul>
<h2 id="英特网中的电子邮件">英特网中的电子邮件</h2>
<h2 id="dns英特网的目录服务">DNS：英特网的目录服务</h2>
<h2 id="p2p-文件分发">P2P 文件分发</h2>
<h2 id="视频流和内容分发网络">视频流和内容分发网络</h2>

  
  </div>
</article>


    <footer id="footer">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
  <div class="footer-left">
    Copyright  &copy; 2021  Y.CH.Y 
    <span id="busuanzi_container_page_pv">Page PV : <span id="busuanzi_value_page_pv"></span></span>
    <span id="busuanzi_container_site_uv">Site UV : <span id="busuanzi_value_site_uv"></span></span>
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">Home</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
