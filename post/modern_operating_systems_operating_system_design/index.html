<!DOCTYPE html>
<html lang="en-us">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> 现代操作系统::操作系统设计 | Y.CH.Y</title>
  <link rel = 'canonical' href = '/post/modern_operating_systems_operating_system_design/'>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="现代操作系统::操作系统设计" />
<meta property="og:description" content="操作系统设计  设计问题的本质  目标  定义抽象概念  进程、文件、线程、信号量   提供基本操作  每一个抽象概念可以通过具体数据结构的形式来实例化。用户可以创建进程、文件、信号量等。基本操作则处理这些数据结构。例如，用户可以读写文件。基本操作以系统调用的形式实现。从用户的观点来看，操作系统的核心是由抽象概念与其上的基本操作所构成的，而基本操作则可通过系统调用加以利用。   确保隔离  用户之间的隔离 虚拟机之间的隔离 进程之间的隔离 故障隔离 资源共享   管理硬件  提供一个框架，统一管理不同型号的硬件资源     难点  已经发展成了极其复杂的程序 必须处理并发和并发导致竞争条件、死锁等问题。 必须处理可能有敌意的用户 需要提供在不同用户之间共享资源的能力 设计人员需要思考未来的操作系统设计方向 需要提供想当程度的通用性 可移植性 需要保持向后兼容     接口设计  指导原则  简单：一个简单的接口更加易于理解并且更加易于以无差错的方式实现 完备：接口必须能够做用户需要做的一切事情，也就是说，它必须是完备的 效率：如果一个功能特性或者系统调用不能够有效地实现，或许就不值得包含它。   范型  用户界面范型：不管选择什么范型，重要的是所有应用程序都要使用它。因此，系统设计者需要提供库和工具包给应用程序开发人员，使他们能够访问产生一致的外观与感觉的程序。没有工具，应用开发者做出来的东西可能完全不同。 执行范型：  算法范型：启动一个程序是为了执行某个功能，而该功能是事先知道的或者是从其参数获知的。 事件驱动范型：在这里程序执行某种初始化（例如通过显示某个屏幕），然后等待操作系统告诉它第一个事件。事件经常是键盘敲击或鼠标移动。这一设计对干高度交互式的程序是十分有益的。   数据范型：  一切皆磁带：在早期的 FORTRAN 批处理系统中，所有一切都是作为连续的磁带来建立模型。用于读入的卡片组被看作输入磁带，用于穿孔的卡片组被看作输出磁带，井且打印机给出被看作输出磁带。磁盘文件也被看作磁带 一切皆文件：UNIX 用”所有一切都是文件”的模型一步发展了这一思想。使用这一范型，所有 I/O 设备都被看作文件，井且可以像普通文件一样打开和操作。 一切皆对象：Windows 试图使所有一切看起来像是一个对象。一旦一个进程获得了一个指向文件、进程、信号量、 邮箱或者其他内核对象的有效句柄，它就可以在其上执行操作。这一范型甚至比 UNIX 更加一般化，井且比 FORTRAN 要一般化得多。 一切皆文档：Web 背后的范型是充满了文档的超空间，每一个文档具有一个 URL。通过键人一个 URL 或者点击被 URL 所支持的条目，你就可以得到该文档。     系统调用接口  操作系统应该提供恰好够用的系统调用，井且每个系统调用都应该尽可能简单 在某些情况下，系统调用可能需要若干变体，但是通常比较好的实现是具有处理一般情况的一个系统调用，而由不同的库过程向程序员隐藏这一事实。 添加更多的代码就是添加更多的程序错误 不要隐藏能力，如果硬件具有极其高效的方法做某事，它就应该以简单的方法展露给程序员 任何面向连接的机制与无连接的机制之间的权衡在于建立连接的机制（例如打开文件）要求的额外开销， 与系统调用接口有关的另一个问题是接口的可见性。 POSIX 强制的系统调用列表很容易找到。Microsoft 从未将 Windows 系统调用列表公开。作为替代，Win API 和其他 API 被公开了，但是这些 API 包含大量的库调用（超过 10000 个），只有很少数是其正的系统调用     实现  系统结构  分层系统：对于一个新系统，选择走这一路线的设计人员应该首先非常仔细地选择各个层次，井且定义每个层次的功能。底层应该总是试图隐藏硬件最糟糕的特异性 外内核：他们的观点基干端到端问题，某件事情必须由用户程序本身去完成，在一个较低的层次做同样的事情就是浪费。端到端问题可以扩展到几乎所有操作系统。它主张不要让操作系统做用户程序本身可以做的任何事情。 在让操作系统做每件事情和让操作系统什么也不做之间的折衷是让操作系统做一点事情。这一设计导致微内核的出现，它让操作系统的大部分作为用户级的服务器进程而运行，在所有设计中这是最模块化和最灵活的。在灵活性上的极限是让每个设备驱动程序也作为一个用户进程而运行，从而完全保护内核和其他驱动程序，但是让设备驱动程序运行在内核会增加模块化程度。 可扩展的系统：将更多的模块放到内核中，但是以一种“受保护的”方式。可扩展的系统自身井不是构造一个操作系统的方法。然而，通过以一个只是包含保护机制的 朵小系统为开端，然后每次将受保护的模块添加到内核中，直到达到期望的功能，对千手边的应用而言一个最小的系统就建立起来了 。 内核线程：无论选择哪种结构模型，允许存在与任何用户进程相隔离的内核线程是很方便的。这些线程可以在后台运行，将脏页面写入磁盘，在内存和磁盘之间交换进程，如此等等。实际上，内核本身可以完全由这样的线程构成，所以当一个用户发出系统调用时，用户的线程并不是在内核模式中运行，而是阻塞井且将控制传给一个内核线程，该内核线程接管控制以完成工作。      " />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/modern_operating_systems_operating_system_design/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-07-23T02:11:01+08:00" />
<meta property="article:modified_time" content="2021-07-23T02:11:01+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="现代操作系统::操作系统设计"/>
<meta name="twitter:description" content="操作系统设计  设计问题的本质  目标  定义抽象概念  进程、文件、线程、信号量   提供基本操作  每一个抽象概念可以通过具体数据结构的形式来实例化。用户可以创建进程、文件、信号量等。基本操作则处理这些数据结构。例如，用户可以读写文件。基本操作以系统调用的形式实现。从用户的观点来看，操作系统的核心是由抽象概念与其上的基本操作所构成的，而基本操作则可通过系统调用加以利用。   确保隔离  用户之间的隔离 虚拟机之间的隔离 进程之间的隔离 故障隔离 资源共享   管理硬件  提供一个框架，统一管理不同型号的硬件资源     难点  已经发展成了极其复杂的程序 必须处理并发和并发导致竞争条件、死锁等问题。 必须处理可能有敌意的用户 需要提供在不同用户之间共享资源的能力 设计人员需要思考未来的操作系统设计方向 需要提供想当程度的通用性 可移植性 需要保持向后兼容     接口设计  指导原则  简单：一个简单的接口更加易于理解并且更加易于以无差错的方式实现 完备：接口必须能够做用户需要做的一切事情，也就是说，它必须是完备的 效率：如果一个功能特性或者系统调用不能够有效地实现，或许就不值得包含它。   范型  用户界面范型：不管选择什么范型，重要的是所有应用程序都要使用它。因此，系统设计者需要提供库和工具包给应用程序开发人员，使他们能够访问产生一致的外观与感觉的程序。没有工具，应用开发者做出来的东西可能完全不同。 执行范型：  算法范型：启动一个程序是为了执行某个功能，而该功能是事先知道的或者是从其参数获知的。 事件驱动范型：在这里程序执行某种初始化（例如通过显示某个屏幕），然后等待操作系统告诉它第一个事件。事件经常是键盘敲击或鼠标移动。这一设计对干高度交互式的程序是十分有益的。   数据范型：  一切皆磁带：在早期的 FORTRAN 批处理系统中，所有一切都是作为连续的磁带来建立模型。用于读入的卡片组被看作输入磁带，用于穿孔的卡片组被看作输出磁带，井且打印机给出被看作输出磁带。磁盘文件也被看作磁带 一切皆文件：UNIX 用”所有一切都是文件”的模型一步发展了这一思想。使用这一范型，所有 I/O 设备都被看作文件，井且可以像普通文件一样打开和操作。 一切皆对象：Windows 试图使所有一切看起来像是一个对象。一旦一个进程获得了一个指向文件、进程、信号量、 邮箱或者其他内核对象的有效句柄，它就可以在其上执行操作。这一范型甚至比 UNIX 更加一般化，井且比 FORTRAN 要一般化得多。 一切皆文档：Web 背后的范型是充满了文档的超空间，每一个文档具有一个 URL。通过键人一个 URL 或者点击被 URL 所支持的条目，你就可以得到该文档。     系统调用接口  操作系统应该提供恰好够用的系统调用，井且每个系统调用都应该尽可能简单 在某些情况下，系统调用可能需要若干变体，但是通常比较好的实现是具有处理一般情况的一个系统调用，而由不同的库过程向程序员隐藏这一事实。 添加更多的代码就是添加更多的程序错误 不要隐藏能力，如果硬件具有极其高效的方法做某事，它就应该以简单的方法展露给程序员 任何面向连接的机制与无连接的机制之间的权衡在于建立连接的机制（例如打开文件）要求的额外开销， 与系统调用接口有关的另一个问题是接口的可见性。 POSIX 强制的系统调用列表很容易找到。Microsoft 从未将 Windows 系统调用列表公开。作为替代，Win API 和其他 API 被公开了，但是这些 API 包含大量的库调用（超过 10000 个），只有很少数是其正的系统调用     实现  系统结构  分层系统：对于一个新系统，选择走这一路线的设计人员应该首先非常仔细地选择各个层次，井且定义每个层次的功能。底层应该总是试图隐藏硬件最糟糕的特异性 外内核：他们的观点基干端到端问题，某件事情必须由用户程序本身去完成，在一个较低的层次做同样的事情就是浪费。端到端问题可以扩展到几乎所有操作系统。它主张不要让操作系统做用户程序本身可以做的任何事情。 在让操作系统做每件事情和让操作系统什么也不做之间的折衷是让操作系统做一点事情。这一设计导致微内核的出现，它让操作系统的大部分作为用户级的服务器进程而运行，在所有设计中这是最模块化和最灵活的。在灵活性上的极限是让每个设备驱动程序也作为一个用户进程而运行，从而完全保护内核和其他驱动程序，但是让设备驱动程序运行在内核会增加模块化程度。 可扩展的系统：将更多的模块放到内核中，但是以一种“受保护的”方式。可扩展的系统自身井不是构造一个操作系统的方法。然而，通过以一个只是包含保护机制的 朵小系统为开端，然后每次将受保护的模块添加到内核中，直到达到期望的功能，对千手边的应用而言一个最小的系统就建立起来了 。 内核线程：无论选择哪种结构模型，允许存在与任何用户进程相隔离的内核线程是很方便的。这些线程可以在后台运行，将脏页面写入磁盘，在内存和磁盘之间交换进程，如此等等。实际上，内核本身可以完全由这样的线程构成，所以当一个用户发出系统调用时，用户的线程并不是在内核模式中运行，而是阻塞井且将控制传给一个内核线程，该内核线程接管控制以完成工作。      "/>

  
  
    
  
  
  <link rel="stylesheet" href="/css/styles.ace637160e3ee466ac48adf2107be5e9e0b7f168aff4b05023ac0c573f8200b3f1ced7d604b86d1b519cf620f8b1bc3c13abec114d6d055da6327e8e79ac3dfb.css" integrity="sha512-rOY3Fg4&#43;5GasSK3yEHvl6eC38Wiv9LBQI6wMVz&#43;CALPxztfWBLhtG1Gc9iD4sbw8E6vsEU1tBV2mMn6Oeaw9&#43;w=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="/images/favicon.ico" />

  
  
  
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-X1L70M4MM0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="/">
  
    <div id="logo" style="background-image: url(/images/logo.png)"></div>
  
  <div id="title">
    <h1>Y.CH.Y</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">Home</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <h2 id="操作系统设计">操作系统设计</h2>
<ul>
<li>设计问题的本质
<ul>
<li>目标
<ul>
<li>定义抽象概念
<ul>
<li>进程、文件、线程、信号量</li>
</ul>
</li>
<li>提供基本操作
<ul>
<li>每一个抽象概念可以通过具体数据结构的形式来实例化。用户可以创建进程、文件、信号量等。基本操作则处理这些数据结构。例如，用户可以读写文件。基本操作以系统调用的形式实现。从用户的观点来看，操作系统的核心是由抽象概念与其上的基本操作所构成的，而基本操作则可通过系统调用加以利用。</li>
</ul>
</li>
<li>确保隔离
<ul>
<li>用户之间的隔离</li>
<li>虚拟机之间的隔离</li>
<li>进程之间的隔离</li>
<li>故障隔离</li>
<li>资源共享</li>
</ul>
</li>
<li>管理硬件
<ul>
<li>提供一个框架，统一管理不同型号的硬件资源</li>
</ul>
</li>
</ul>
</li>
<li>难点
<ul>
<li>已经发展成了极其复杂的程序</li>
<li>必须处理并发和并发导致竞争条件、死锁等问题。</li>
<li>必须处理可能有敌意的用户</li>
<li>需要提供在不同用户之间共享资源的能力</li>
<li>设计人员需要思考未来的操作系统设计方向</li>
<li>需要提供想当程度的通用性</li>
<li>可移植性</li>
<li>需要保持向后兼容</li>
</ul>
</li>
</ul>
</li>
<li>接口设计
<ul>
<li>指导原则
<ul>
<li>简单：一个简单的接口更加易于理解并且更加易于以无差错的方式实现</li>
<li>完备：接口必须能够做用户需要做的一切事情，也就是说，它必须是完备的</li>
<li>效率：如果一个功能特性或者系统调用不能够有效地实现，或许就不值得包含它。</li>
</ul>
</li>
<li>范型
<ul>
<li>用户界面范型：不管选择什么范型，重要的是所有应用程序都要使用它。因此，系统设计者需要提供库和工具包给应用程序开发人员，使他们能够访问产生一致的外观与感觉的程序。没有工具，应用开发者做出来的东西可能完全不同。</li>
<li>执行范型：
<ul>
<li>算法范型：启动一个程序是为了执行某个功能，而该功能是事先知道的或者是从其参数获知的。</li>
<li>事件驱动范型：在这里程序执行某种初始化（例如通过显示某个屏幕），然后等待操作系统告诉它第一个事件。事件经常是键盘敲击或鼠标移动。这一设计对干高度交互式的程序是十分有益的。</li>
</ul>
</li>
<li>数据范型：
<ul>
<li>一切皆磁带：在早期的 FORTRAN 批处理系统中，所有一切都是作为连续的磁带来建立模型。用于读入的卡片组被看作输入磁带，用于穿孔的卡片组被看作输出磁带，井且打印机给出被看作输出磁带。磁盘文件也被看作磁带</li>
<li>一切皆文件：UNIX 用”所有一切都是文件”的模型一步发展了这一思想。使用这一范型，所有 I/O 设备都被看作文件，井且可以像普通文件一样打开和操作。</li>
<li>一切皆对象：Windows 试图使所有一切看起来像是一个对象。一旦一个进程获得了一个指向文件、进程、信号量、 邮箱或者其他内核对象的有效句柄，它就可以在其上执行操作。这一范型甚至比 UNIX 更加一般化，井且比 FORTRAN 要一般化得多。</li>
<li>一切皆文档：Web 背后的范型是充满了文档的超空间，每一个文档具有一个 URL。通过键人一个 URL 或者点击被 URL 所支持的条目，你就可以得到该文档。</li>
</ul>
</li>
</ul>
</li>
<li>系统调用接口
<ul>
<li>操作系统应该提供恰好够用的系统调用，井且每个系统调用都应该尽可能简单</li>
<li>在某些情况下，系统调用可能需要若干变体，但是通常比较好的实现是具有处理一般情况的一个系统调用，而由不同的库过程向程序员隐藏这一事实。</li>
<li>添加更多的代码就是添加更多的程序错误</li>
<li>不要隐藏能力，如果硬件具有极其高效的方法做某事，它就应该以简单的方法展露给程序员</li>
<li>任何面向连接的机制与无连接的机制之间的权衡在于建立连接的机制（例如打开文件）要求的额外开销，</li>
<li>与系统调用接口有关的另一个问题是接口的可见性。 POSIX 强制的系统调用列表很容易找到。Microsoft 从未将 Windows 系统调用列表公开。作为替代，Win API 和其他 API 被公开了，但是这些 API 包含大量的库调用（超过 10000 个），只有很少数是其正的系统调用</li>
</ul>
</li>
</ul>
</li>
<li>实现
<ul>
<li>系统结构
<ul>
<li>分层系统：对于一个新系统，选择走这一路线的设计人员应该首先非常仔细地选择各个层次，井且定义每个层次的功能。底层应该总是试图隐藏硬件最糟糕的特异性</li>
<li>外内核：他们的观点基干端到端问题，某件事情必须由用户程序本身去完成，在一个较低的层次做同样的事情就是浪费。端到端问题可以扩展到几乎所有操作系统。它主张不要让操作系统做用户程序本身可以做的任何事情。</li>
<li>在让操作系统做每件事情和让操作系统什么也不做之间的折衷是让操作系统做一点事情。这一设计导致微内核的出现，它让操作系统的大部分作为用户级的服务器进程而运行，在所有设计中这是最模块化和最灵活的。在灵活性上的极限是让每个设备驱动程序也作为一个用户进程而运行，从而完全保护内核和其他驱动程序，但是让设备驱动程序运行在内核会增加模块化程度。</li>
<li>可扩展的系统：将更多的模块放到内核中，但是以一种“受保护的”方式。可扩展的系统自身井不是构造一个操作系统的方法。然而，通过以一个只是包含保护机制的 朵小系统为开端，然后每次将受保护的模块添加到内核中，直到达到期望的功能，对千手边的应用而言一个最小的系统就建立起来了 。</li>
<li>内核线程：无论选择哪种结构模型，允许存在与任何用户进程相隔离的内核线程是很方便的。这些线程可以在后台运行，将脏页面写入磁盘，在内存和磁盘之间交换进程，如此等等。实际上，内核本身可以完全由这样的线程构成，所以当一个用户发出系统调用时，用户的线程并不是在内核模式中运行，而是阻塞井且将控制传给一个内核线程，该内核线程接管控制以完成工作。</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
</li>
</ul>

  
  </div>
</article>


    <footer id="footer">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
  <div class="footer-left">
    Copyright  &copy; 2021  Y.CH.Y 
    <span id="busuanzi_container_page_pv">Page PV : <span id="busuanzi_value_page_pv"></span></span>
    <span id="busuanzi_container_site_uv">Site UV : <span id="busuanzi_value_site_uv"></span></span>
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">Home</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
