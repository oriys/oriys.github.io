<!DOCTYPE html>
<html lang="en-us">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> APUE::Threads | Y.CH.Y</title>
  <link rel = 'canonical' href = '/post/advanced_programming_in_the_unix_environment_threads/'>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="APUE::Threads" />
<meta property="og:description" content="Threads  Thread Concepts  simplify code that deals with asynchronous events by assigning a separate thread to handle each event type Threads automatically have access to the same memory address space and file descriptors Some problems can be partitioned so that overall program throughput can be improved interactive programs can realize improved response time by using multiple threads The benefits of a multithreaded programming model can be realized even if your program is running on a uniprocessor A thread consists of the information necessary to represent an execution context within a process  a thread ID that identifies the thread within a process a set of register values a stack a scheduling priority and policy a signal mask an errno variable thread-specific data   Everything within a process is sharable among the threads in a process  text of the executable program the program’s global and heap memory, the stacks the file descriptors     Thread Identification  every thread has a thread ID the thread ID has significance only within the context of the process to which it belongs A thread ID is represented by the pthread_t data type   Thread Creation  When a thread is created, there is no guarantee which will run first: the newly created thread or the calling thread The memory location pointed to by tidp is set to the thread ID of the newly created thread when pthread_create returns successfully pthread functions usually return an error code when they fail." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/advanced_programming_in_the_unix_environment_threads/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-01-11T00:43:37+08:00" />
<meta property="article:modified_time" content="2021-01-11T00:43:37+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="APUE::Threads"/>
<meta name="twitter:description" content="Threads  Thread Concepts  simplify code that deals with asynchronous events by assigning a separate thread to handle each event type Threads automatically have access to the same memory address space and file descriptors Some problems can be partitioned so that overall program throughput can be improved interactive programs can realize improved response time by using multiple threads The benefits of a multithreaded programming model can be realized even if your program is running on a uniprocessor A thread consists of the information necessary to represent an execution context within a process  a thread ID that identifies the thread within a process a set of register values a stack a scheduling priority and policy a signal mask an errno variable thread-specific data   Everything within a process is sharable among the threads in a process  text of the executable program the program’s global and heap memory, the stacks the file descriptors     Thread Identification  every thread has a thread ID the thread ID has significance only within the context of the process to which it belongs A thread ID is represented by the pthread_t data type   Thread Creation  When a thread is created, there is no guarantee which will run first: the newly created thread or the calling thread The memory location pointed to by tidp is set to the thread ID of the newly created thread when pthread_create returns successfully pthread functions usually return an error code when they fail."/>

  
  
    
  
  
  <link rel="stylesheet" href="/css/styles.ace637160e3ee466ac48adf2107be5e9e0b7f168aff4b05023ac0c573f8200b3f1ced7d604b86d1b519cf620f8b1bc3c13abec114d6d055da6327e8e79ac3dfb.css" integrity="sha512-rOY3Fg4&#43;5GasSK3yEHvl6eC38Wiv9LBQI6wMVz&#43;CALPxztfWBLhtG1Gc9iD4sbw8E6vsEU1tBV2mMn6Oeaw9&#43;w=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="/images/favicon.ico" />

  
  
  
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-X1L70M4MM0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="/">
  
    <div id="logo" style="background-image: url(/images/logo.png)"></div>
  
  <div id="title">
    <h1>Y.CH.Y</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">Home</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <h2 id="threads">Threads</h2>
<ul>
<li>Thread Concepts
<ul>
<li>simplify code that deals with asynchronous events by assigning a separate thread to handle each event type</li>
<li>Threads automatically have access to the same memory address space and file descriptors</li>
<li>Some problems can be partitioned so that overall program throughput can be improved</li>
<li>interactive programs can realize improved response time by using multiple threads</li>
<li>The benefits of a multithreaded programming model can be realized even if your program is running on a uniprocessor</li>
<li>A thread consists of the information necessary to represent an execution context within a process
<ul>
<li>a thread ID that identifies the thread within a process</li>
<li>a set of register values</li>
<li>a stack</li>
<li>a scheduling priority and policy</li>
<li>a signal mask</li>
<li>an errno variable</li>
<li>thread-specific data</li>
</ul>
</li>
<li>Everything within a process is sharable among the threads in a process
<ul>
<li>text of the executable program</li>
<li>the program’s global and heap memory, the stacks</li>
<li>the file descriptors</li>
</ul>
</li>
</ul>
</li>
<li>Thread Identification
<ul>
<li>every thread has a thread ID</li>
<li>the thread ID has significance only within the context of the process to which it belongs</li>
<li>A thread ID is represented by the pthread_t data type</li>
</ul>
</li>
<li>Thread Creation
<ul>
<li>When a thread is created, there is no guarantee which will run first: the newly created thread or the calling thread</li>
<li>The memory location pointed to by tidp is set to the thread ID of the newly created thread when pthread_create returns successfully</li>
<li>pthread functions usually return an error code when they fail. They don’t set errno like the other POSIX functions</li>
</ul>
</li>
<li>Thread Termination
<ul>
<li>If any thread within a process calls exit, _Exit, or _exit, then the entire process terminates</li>
<li>the default action is to terminate the process, a signal sent to a thread will terminate the entire process</li>
<li>A single thread can exit in three ways, thereby stopping its flow of control, without terminating the entire process
<ul>
<li>The thread can simply return from the start routine. The return value is the thread’s exit code</li>
<li>The thread can be canceled by another thread in the same process</li>
<li>The thread can call pthread_exit</li>
</ul>
</li>
<li>One thread can request that another in the same process be canceled by calling the pthread_cancel function
<ul>
<li>However, a thread can elect to ignore or otherwise control how it is canceled</li>
<li>thread_cancel doesn’t wait for the thread to terminate; it merely makes the request</li>
</ul>
</li>
<li>A thread can arrange for functions to be called when it exits pthread_cleanup_push
<ul>
<li>Makes a call to pthread_exit</li>
<li>Responds to a cancellation request</li>
<li>Makes a call to pthread_cleanup_pop with a nonzero execute argument</li>
</ul>
</li>
<li>Thread Synchronization
<ul>
<li>When multiple threads of control share the same memory, we need to make sure that each thread sees a consistent view of its data</li>
<li>Mutexes
<ul>
<li>A mutex is basically a lock that we set (lock) before accessing a shared resource and release (unlock) when we’re done</li>
<li>we must first initialize it by either setting it to the constant PTHREAD_MUTEX_INITIALIZER (for statically allocated mutexes only) or calling pthread_mutex_init</li>
<li>To lock a mutex, we call pthread_mutex_lock</li>
<li>To unlock a mutex, we call pthread_mutex_unlock</li>
</ul>
</li>
</ul>
</li>
<li>Deadlock Avoidance
<ul>
<li>Deadlocks can be avoided by carefully controlling the order in which mutexes are locked</li>
<li>assume that you have two mutexes, A and B, that you need to lock at the same time. If all threads always lock mutex A before mutex B, no deadlock can occur from the use of the two mutexes</li>
</ul>
</li>
<li>pthread_mutex_timedlock
<ul>
<li>The timeout specifies how long we are willing to wait in terms of absolute time (as opposed to relative time; we specify that we are willing to block until time X instead of saying that we are willing to block for Y seconds)</li>
</ul>
</li>
<li>Reader–writer locks
<ul>
<li>Only one thread at a time can hold a reader–writer lock in write mode, but multiple threads can hold a reader–writer lock in read mode at the same time</li>
<li>Reader–writer locks are well suited for situations in which data structures are read more often than they are modified</li>
</ul>
</li>
<li>Reader–Writer Locking with Timeouts
<ul>
<li>pthread_rwlock_timedwrlock</li>
</ul>
</li>
<li>Condition Variables
<ul>
<li>When used with mutexes, condition variables allow threads to wait in a race-free way for arbitrary conditions to occur</li>
</ul>
</li>
<li>Spin Locks
<ul>
<li>the process is blocked by busy-waiting (spinning) until the lock can be acquired
<ul>
<li>A spin lock could be used in situations where locks are held for short periods of times and threads don’t want to incur the cost of being descheduled</li>
</ul>
</li>
<li>Many mutex implementations are so efficient that the performance of applications using mutex locks is equivalent to their performance if they had used spin locks</li>
<li>The interfaces for spin locks are similar to those for mutexes, making it relatively easy to replace one with the other</li>
<li>if a spin lock is currently unlocked, then the pthread_spin_lock function can lock it without spinning. If the thread already has it locked, the results are undefined. The call to pthread_spin_lock could fail with the EDEADLK error (or some other error), or the call could spin indefinitely. The behavior depends on the implementation. If we try to unlock a spin lock that is not locked, the results are also undefined</li>
</ul>
</li>
<li>Barriers
<ul>
<li>Barriers are a synchronization mechanism that can be used to coordinate multiple threads working in parallel</li>
<li>A barrier allows each thread to wait until all cooperating threads have reached the same point, and then continue executing from there</li>
</ul>
</li>
</ul>
</li>
</ul>

  
  </div>
</article>


    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2021  Y.CH.Y 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">Home</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
