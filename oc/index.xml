<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ocs | Y.CH.Y</title><link>/oc/</link><atom:link href="/oc/index.xml" rel="self" type="application/rss+xml"/><description>Ocs</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Y.CH.Y</copyright><lastBuildDate>Thu, 16 Sep 2021 09:06:25 +0800</lastBuildDate><item><title>MIT::6.824::Introduction</title><link>/oc/mit_6_824_introduction/</link><pubDate>Thu, 16 Sep 2021 09:06:25 +0800</pubDate><guid>/oc/mit_6_824_introduction/</guid><description>&lt;h2 id="介绍">介绍&lt;/h2>
&lt;ul>
&lt;li>什么是分布式系统
&lt;ul>
&lt;li>多台通过网络交互的主机&lt;/li>
&lt;li>大型网站的存储、MapReduce、点对点共享等&lt;/li>
&lt;li>许多关键基础设施是分布式的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>为什么要构建分布式系统
&lt;ul>
&lt;li>连接在物理上隔离的主机，实现数据共享、文件共享&lt;/li>
&lt;li>通过并行增加容量&lt;/li>
&lt;li>通过复制加强容错&lt;/li>
&lt;li>通过隔离实现数据安全(对外提供一个有限的接口)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>历史背景
&lt;ul>
&lt;li>局域网(1980s)
&lt;ul>
&lt;li>DNS，email，AFS&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>数据中心、大型网站(1990s)
&lt;ul>
&lt;li>网页搜索、购物&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>云计算(2000s)
&lt;ul>
&lt;li>大数据、机器学习&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>依然是活跃的领域(当前)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>挑战
&lt;ul>
&lt;li>并发部分多，交互复杂&lt;/li>
&lt;li>必须应对部分失败&lt;/li>
&lt;li>难以实现性能潜力&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>为什么要上 6.824
&lt;ul>
&lt;li>有趣 —— 难题，强大的解决方案&lt;/li>
&lt;li>被真实系统使用 —— 由大型网站的兴起驱动&lt;/li>
&lt;li>活跃的研究领域 —— 重要的未解决问题&lt;/li>
&lt;li>动手实践 —— 在实验中构建真正的系统&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>焦点：这是一门关于应用程序基础设施的课程。
&lt;ul>
&lt;li>存储&lt;/li>
&lt;li>计算&lt;/li>
&lt;li>通信&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>重要目标
&lt;ul>
&lt;li>利用抽象隐匿分布式系统的复杂性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>容错
&lt;ul>
&lt;li>可用性:尽管失败，应用程序仍能取得进展
&lt;ul>
&lt;li>复制&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>故障恢复:恢复故障后应用程序将正常运行
&lt;ul>
&lt;li>日志记录&lt;/li>
&lt;li>故障转移&lt;/li>
&lt;li>持久化存储&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>一致性：通用基础设施需要明确定义的行为
&lt;ul>
&lt;li>写后读一致性&lt;/li>
&lt;li>副本之间的数据延迟&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>性能：可扩展的吞吐量
&lt;ul>
&lt;li>N x 服务器 -&amp;gt; 通过并行 CPU、磁盘、网络的 N x 总吞吐量。&lt;/li>
&lt;li>随着 N 的增长，扩展越来越难&lt;/li>
&lt;li>长尾效应&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>容错、一致性和性能是敌人
&lt;ul>
&lt;li>强大的容错能力需要通信
&lt;ul>
&lt;li>例如，将数据发送到备份&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>强一致性需要通信
&lt;ul>
&lt;li>例如，Get() 必须检查最近的 Put()。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>许多设计仅提供弱一致性以提高速度。
&lt;ul>
&lt;li>例如 Get() 不返回最新的 Put()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>许多设计点在一致性/性能范围内是可能的！&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MapReduce
&lt;ul>
&lt;li>Google 经常需要在 TB 数据集上的进行几个小时的计算，例如建立搜索索引，或排序，或分析网络结构&lt;/li>
&lt;li>方便非专家编写程序构建分布式系统&lt;/li>
&lt;li>程序员只是定义了 Map 和 Reduce 函数 ，编写通常相当简单的顺序代码&lt;/li>
&lt;li>MR 负责并隐藏分发的各个方面&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MapReduce 的抽象视图
&lt;ul>
&lt;li>输入(已经)分成 M 个文件&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>Input1 -&amp;gt; Map -&amp;gt; a,1 b,1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Input2 -&amp;gt; Map -&amp;gt; b,1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Input3 -&amp;gt; Map -&amp;gt; a,1 c,1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| | |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| | -&amp;gt; Reduce -&amp;gt; c,1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| -----&amp;gt; Reduce -&amp;gt; b,2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---------&amp;gt; Reduce -&amp;gt; a,2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>MR 为每个输入文件调用 Map()，生成一组 k2,v2 “中间”数据，每个 Map() 调用都是一个“任务”，MR 收集给定 k2 的所有中间 v2，并将每个键 + 值传递给 Reduce 调用最终输出是一组来自 Reduce()s 的 &amp;lt;k2,v3&amp;gt; 对&lt;/li>
&lt;li>统计单词
&lt;ul>
&lt;li>输入是数千个文本文件&lt;/li>
&lt;li>Map(k, v)
&lt;ul>
&lt;li>把 v 拆分成单词 word&lt;/li>
&lt;li>对每个 word w
&lt;ul>
&lt;li>emit(w,&amp;ldquo;1&amp;rdquo;)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Reduce(k，v)
&lt;ul>
&lt;li>emit(len(v))&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MapReduce 扩展良好：
&lt;ul>
&lt;li>N 台&amp;rsquo;worker&amp;rsquo;计算机提供 N x 吞吐量。&lt;/li>
&lt;li>Map()s 可以并行运行，因为它们不交互。&lt;/li>
&lt;li>Reduce()s 也是如此。&lt;/li>
&lt;li>因此，您可以通过购买更多计算机来获得更多吞吐量。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MapReduce 隐藏了很多细节
&lt;ul>
&lt;li>将应用程序代码发送到服务器&lt;/li>
&lt;li>跟踪完成了哪些任务&lt;/li>
&lt;li>将数据从 Maps 移动到 Reduces&lt;/li>
&lt;li>平衡服务器负载&lt;/li>
&lt;li>从故障中恢复&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MapReduce 的限制
&lt;ul>
&lt;li>没有交互或状态(除了通过中间输出)&lt;/li>
&lt;li>没有迭代，没有多阶段流水线&lt;/li>
&lt;li>没有实时或流处理。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>输入和输出存储在 GFS 集群文件系统上
&lt;ul>
&lt;li>MR 需要巨大的并行输入和输出吞吐量。&lt;/li>
&lt;li>GFS 将文件拆分到多个服务器上，大小为 64 MB
&lt;ul>
&lt;li>Map()并行读取&lt;/li>
&lt;li>Reduce()并行写入&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>GFS 还会在 2 或 3 个服务器上复制每个文件&lt;/li>
&lt;li>拥有 GFS 是 MapReduce 的一大胜利&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>什么可能会限制性能？
&lt;ul>
&lt;li>我们关心，因为这是优化的事情。&lt;/li>
&lt;li>中央处理器？记忆？磁盘？网络？&lt;/li>
&lt;li>2004 年，作者受到网络容量的限制。
&lt;ul>
&lt;li>MR 通过网络发送什么？
&lt;ul>
&lt;li>Map 从 GFS 读取输入。&lt;/li>
&lt;li>Reduce 读取 Map 输出。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可以和输入一样大，例如用于排序。&lt;/li>
&lt;li>reduce 将输出文件写入 GFS。&lt;/li>
&lt;li>在 MR 的 all-to-all shuffle 中，一半的流量通过根交换机。&lt;/li>
&lt;li>论文中的根交换机：100 到 200 吉比特/秒，总计
&lt;ul>
&lt;li>1800 台机器，所以 55 兆/秒/机器。&lt;/li>
&lt;li>55 很小，例如远低于磁盘或 RAM 速度。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>今天：网络和根交换机相对于 CPU/磁盘要快得多。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>一些细节&lt;/li>
&lt;li>一个 coordinator，负责向 worker 分发任务并记住进度。&lt;/li>
&lt;li>coordinator 将 Map 任务交给 worker，直到所有 Maps 完成
&lt;ul>
&lt;li>将输出(中间数据)映射到本地磁盘&lt;/li>
&lt;li>将每个 Reduce 任务的输出按散列映射到一个文件中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>所有 Maps 完成后，coordinator 下发 Reduce 任务
&lt;ul>
&lt;li>每个 Reduce 从(所有)Map worker 获取其中间输出&lt;/li>
&lt;li>每个 Reduce 任务在 GFS 上写入一个单独的输出文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MR 如何最大限度地 reduce 网络使用？
&lt;ul>
&lt;li>Coordinator 尝试在存储其输入的 GFS 服务器上运行每个 Map 任务。
&lt;ul>
&lt;li>所有计算机都运行 GFS 和 MR 工作线程&lt;/li>
&lt;li>所以输入是从本地磁盘(通过 GFS)读取的，而不是通过网络读取。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>中间数据仅通过网络一次。
&lt;ul>
&lt;li>Map worker 写入本地磁盘。&lt;/li>
&lt;li>Reduce worker 直接从 Map workers 读取，而不是通过 GFS。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将中间数据分区为包含许多键的文件。
&lt;ul>
&lt;li>R 远小于键的数量。&lt;/li>
&lt;li>大型网络传输效率更高。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MR 如何获得良好的负载平衡？
&lt;ul>
&lt;li>如果 N-1 个服务器必须等待 1 个慢速服务器完成，则既浪费又慢。&lt;/li>
&lt;li>但有些任务可能需要比其他任务更长的时间。&lt;/li>
&lt;li>解决方案：任务比 worker 多得多。
&lt;ul>
&lt;li>coordinator 向完成先前任务的 worker 分发新任务。&lt;/li>
&lt;li>因此，没有任何任务如此之大，以至于会影响完成时间(希望如此)。&lt;/li>
&lt;li>因此，较快的服务器比较慢的服务器完成更多的任务，同时完成。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>容错呢
&lt;ul>
&lt;li>即如果 worker 在 MR 工作期间崩溃怎么办？&lt;/li>
&lt;li>我们希望对应用程序员完全隐藏故障！&lt;/li>
&lt;li>MR 是否必须从头开始重新运行整个工作？
&lt;ul>
&lt;li>为什么不？&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MR 只重新运行失败的 Map()s 和 Reduce()s。
&lt;ul>
&lt;li>假设 MR 运行 Map 两次，其中一个 Reduce 看到第一次运行的输出，
&lt;ul>
&lt;li>另一个 Reduce 看到第二次运行的输出？&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>正确性需要重新执行以产生完全相同的输出。&lt;/li>
&lt;li>所以 Map 和 Reduce 必须是纯函数：
&lt;ul>
&lt;li>他们只被允许查看他们的参数&lt;/li>
&lt;li>无状态，无文件 I/O，无交互，无外部通信。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果你想允许非功能性的 Map 或 Reduce 怎么办？
&lt;ul>
&lt;li>worker 失败将需要重新执行整个工作，
&lt;ul>
&lt;li>或者您需要创建同步的全局检查点。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>worker 崩溃恢复的详细信息
&lt;ul>
&lt;li>Map worker 崩溃
coordinator 通知 worker 不再响应 ping
coordinator 知道它在那个 worker 上运行了哪些 Map 任务
这些任务的中间输出现在丢失了，必须重新创建
coordinator 告诉其他 worker 运行这些任务
如果 Reduces 已经获取了中间数据，则可以省略重新运行&lt;/li>
&lt;li>reduce worker 崩溃。
完成的任务没问题——存储在 GFS 中，带有副本。
coordinator 重新启动其他 worker 的 worker 未完成的任务。&lt;/li>
&lt;li>其他故障/问题：
&lt;ul>
&lt;li>如果 coordinator 给两个 worker 相同的 Map() 任务怎么办？
也许 coordinator 错误地认为一名 worker 死亡。
它只会告诉 Reduce worker 其中之一。&lt;/li>
&lt;li>如果 coordinator 给两个 worker 相同的 Reduce() 任务怎么办？
他们都会尝试在 GFS 上写入相同的输出文件！
原子 GFS 重命名可防止混合；一个完整的文件将可见。&lt;/li>
&lt;li>如果一个 worker 很慢——一个“落后者”怎么办？
也许是由于 flakey 硬件。
coordinator 启动最后几个任务的第二个副本。&lt;/li>
&lt;li>如果 worker 由于硬件或软件损坏而计算出错误的输出怎么办？
太糟糕了！MR 假设“故障停止”CPU 和软件。&lt;/li>
&lt;li>如果 coordinator 崩溃怎么办？
&lt;ul>
&lt;li>重跑整个任务&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>当前状态
&lt;ul>
&lt;li>极具影响力(Hadoop、Spark 等)。&lt;/li>
&lt;li>可能不再在 Google 使用。&lt;/li>
&lt;li>被 Flume / FlumeJava 取代(参见 Chambers 等人的论文)。&lt;/li>
&lt;li>GFS 替换为 Colossus(没有很好的描述)和 BigTable。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>结论
&lt;ul>
&lt;li>MapReduce 一手让大集群计算流行起来。&lt;/li>
&lt;li>不是最有效或最灵活的。&lt;/li>
&lt;li>缩放良好。&lt;/li>
&lt;li>易于编程——隐藏故障和数据移动。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item></channel></rss>