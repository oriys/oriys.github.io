<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ocs | Y.CH.Y</title>
    <link>/oc/</link>
      <atom:link href="/oc/index.xml" rel="self" type="application/rss+xml" />
    <description>Ocs</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Y.CH.Y</copyright><lastBuildDate>Thu, 16 Sep 2021 09:06:25 +0800</lastBuildDate>
    <item>
      <title>MIT::6.824::Introduction</title>
      <link>/oc/mit_6_824_introduction/</link>
      <pubDate>Thu, 16 Sep 2021 09:06:25 +0800</pubDate>
      <guid>/oc/mit_6_824_introduction/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;什么是分布式系统
&lt;ul&gt;
&lt;li&gt;多台通过网络交互的主机&lt;/li&gt;
&lt;li&gt;大型网站的存储、MapReduce、点对点共享等&lt;/li&gt;
&lt;li&gt;许多关键基础设施是分布式的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为什么要构建分布式系统
&lt;ul&gt;
&lt;li&gt;连接在物理上隔离的主机，实现数据共享、文件共享&lt;/li&gt;
&lt;li&gt;通过并行增加容量&lt;/li&gt;
&lt;li&gt;通过复制加强容错&lt;/li&gt;
&lt;li&gt;通过隔离实现数据安全(对外提供一个有限的接口)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;历史背景
&lt;ul&gt;
&lt;li&gt;局域网(1980s)
&lt;ul&gt;
&lt;li&gt;DNS，email，AFS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据中心、大型网站(1990s)
&lt;ul&gt;
&lt;li&gt;网页搜索、购物&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;云计算(2000s)
&lt;ul&gt;
&lt;li&gt;大数据、机器学习&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;依然是活跃的领域(当前)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;挑战
&lt;ul&gt;
&lt;li&gt;并发部分多，交互复杂&lt;/li&gt;
&lt;li&gt;必须应对部分失败&lt;/li&gt;
&lt;li&gt;难以实现性能潜力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为什么要上 6.824
&lt;ul&gt;
&lt;li&gt;有趣 —— 难题，强大的解决方案&lt;/li&gt;
&lt;li&gt;被真实系统使用 —— 由大型网站的兴起驱动&lt;/li&gt;
&lt;li&gt;活跃的研究领域 —— 重要的未解决问题&lt;/li&gt;
&lt;li&gt;动手实践 —— 在实验中构建真正的系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;焦点：这是一门关于应用程序基础设施的课程。
&lt;ul&gt;
&lt;li&gt;存储&lt;/li&gt;
&lt;li&gt;计算&lt;/li&gt;
&lt;li&gt;通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重要目标
&lt;ul&gt;
&lt;li&gt;利用抽象隐匿分布式系统的复杂性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;容错
&lt;ul&gt;
&lt;li&gt;可用性:尽管失败，应用程序仍能取得进展
&lt;ul&gt;
&lt;li&gt;复制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;故障恢复:恢复故障后应用程序将正常运行
&lt;ul&gt;
&lt;li&gt;日志记录&lt;/li&gt;
&lt;li&gt;故障转移&lt;/li&gt;
&lt;li&gt;持久化存储&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一致性：通用基础设施需要明确定义的行为
&lt;ul&gt;
&lt;li&gt;写后读一致性&lt;/li&gt;
&lt;li&gt;副本之间的数据延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能：可扩展的吞吐量
&lt;ul&gt;
&lt;li&gt;N x 服务器 -&amp;gt; 通过并行 CPU、磁盘、网络的 N x 总吞吐量。&lt;/li&gt;
&lt;li&gt;随着 N 的增长，扩展越来越难&lt;/li&gt;
&lt;li&gt;长尾效应&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;容错、一致性和性能是敌人
&lt;ul&gt;
&lt;li&gt;强大的容错能力需要通信
&lt;ul&gt;
&lt;li&gt;例如，将数据发送到备份&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;强一致性需要通信
&lt;ul&gt;
&lt;li&gt;例如，Get() 必须检查最近的 Put()。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;许多设计仅提供弱一致性以提高速度。
&lt;ul&gt;
&lt;li&gt;例如 Get() 不返回最新的 Put()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;许多设计点在一致性/性能范围内是可能的！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MapReduce
&lt;ul&gt;
&lt;li&gt;Google 经常需要在 TB 数据集上的进行几个小时的计算，例如建立搜索索引，或排序，或分析网络结构&lt;/li&gt;
&lt;li&gt;方便非专家编写程序构建分布式系统&lt;/li&gt;
&lt;li&gt;程序员只是定义了 Map 和 Reduce 函数 ，编写通常相当简单的顺序代码&lt;/li&gt;
&lt;li&gt;MR 负责并隐藏分发的各个方面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MapReduce 的抽象视图
&lt;ul&gt;
&lt;li&gt;输入(已经)分成 M 个文件&lt;/li&gt;
&lt;li&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;Input1 -&amp;gt; Map -&amp;gt; a,1 b,1
Input2 -&amp;gt; Map -&amp;gt; b,1
Input3 -&amp;gt; Map -&amp;gt; a,1 c,1
| | |
| | -&amp;gt; Reduce -&amp;gt; c,1
| -----&amp;gt; Reduce -&amp;gt; b,2
---------&amp;gt; Reduce -&amp;gt; a,2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;MR 为每个输入文件调用 Map()，生成一组 k2,v2 “中间”数据，每个 Map() 调用都是一个“任务”，MR 收集给定 k2 的所有中间 v2，并将每个键 + 值传递给 Reduce 调用最终输出是一组来自 Reduce()s 的 &amp;lt;k2,v3&amp;gt; 对&lt;/li&gt;
&lt;li&gt;统计单词
&lt;ul&gt;
&lt;li&gt;输入是数千个文本文件&lt;/li&gt;
&lt;li&gt;Map(k, v)
&lt;ul&gt;
&lt;li&gt;把 v 拆分成单词 word&lt;/li&gt;
&lt;li&gt;对每个 word w
&lt;ul&gt;
&lt;li&gt;emit(w,&amp;ldquo;1&amp;rdquo;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reduce(k，v)
&lt;ul&gt;
&lt;li&gt;emit(len(v))&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MapReduce 扩展良好：
&lt;ul&gt;
&lt;li&gt;N 台&amp;rsquo;worker&amp;rsquo;计算机提供 N x 吞吐量。&lt;/li&gt;
&lt;li&gt;Map()s 可以并行运行，因为它们不交互。&lt;/li&gt;
&lt;li&gt;Reduce()s 也是如此。&lt;/li&gt;
&lt;li&gt;因此，您可以通过购买更多计算机来获得更多吞吐量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MapReduce 隐藏了很多细节
&lt;ul&gt;
&lt;li&gt;将应用程序代码发送到服务器&lt;/li&gt;
&lt;li&gt;跟踪完成了哪些任务&lt;/li&gt;
&lt;li&gt;将数据从 Maps 移动到 Reduces&lt;/li&gt;
&lt;li&gt;平衡服务器负载&lt;/li&gt;
&lt;li&gt;从故障中恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MapReduce 的限制
&lt;ul&gt;
&lt;li&gt;没有交互或状态(除了通过中间输出)&lt;/li&gt;
&lt;li&gt;没有迭代，没有多阶段流水线&lt;/li&gt;
&lt;li&gt;没有实时或流处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;输入和输出存储在 GFS 集群文件系统上
&lt;ul&gt;
&lt;li&gt;MR 需要巨大的并行输入和输出吞吐量。&lt;/li&gt;
&lt;li&gt;GFS 将文件拆分到多个服务器上，大小为 64 MB
&lt;ul&gt;
&lt;li&gt;Map()并行读取&lt;/li&gt;
&lt;li&gt;Reduce()并行写入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GFS 还会在 2 或 3 个服务器上复制每个文件&lt;/li&gt;
&lt;li&gt;拥有 GFS 是 MapReduce 的一大胜利&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;什么可能会限制性能？
&lt;ul&gt;
&lt;li&gt;我们关心，因为这是优化的事情。&lt;/li&gt;
&lt;li&gt;中央处理器？记忆？磁盘？网络？&lt;/li&gt;
&lt;li&gt;2004 年，作者受到网络容量的限制。
&lt;ul&gt;
&lt;li&gt;MR 通过网络发送什么？
&lt;ul&gt;
&lt;li&gt;Map 从 GFS 读取输入。&lt;/li&gt;
&lt;li&gt;Reduce 读取 Map 输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以和输入一样大，例如用于排序。&lt;/li&gt;
&lt;li&gt;reduce 将输出文件写入 GFS。&lt;/li&gt;
&lt;li&gt;在 MR 的 all-to-all shuffle 中，一半的流量通过根交换机。&lt;/li&gt;
&lt;li&gt;论文中的根交换机：100 到 200 吉比特/秒，总计
&lt;ul&gt;
&lt;li&gt;1800 台机器，所以 55 兆/秒/机器。&lt;/li&gt;
&lt;li&gt;55 很小，例如远低于磁盘或 RAM 速度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;今天：网络和根交换机相对于 CPU/磁盘要快得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一些细节&lt;/li&gt;
&lt;li&gt;一个 coordinator，负责向 worker 分发任务并记住进度。&lt;/li&gt;
&lt;li&gt;coordinator 将 Map 任务交给 worker，直到所有 Maps 完成
&lt;ul&gt;
&lt;li&gt;将输出(中间数据)映射到本地磁盘&lt;/li&gt;
&lt;li&gt;将每个 Reduce 任务的输出按散列映射到一个文件中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所有 Maps 完成后，coordinator 下发 Reduce 任务
&lt;ul&gt;
&lt;li&gt;每个 Reduce 从(所有)Map worker 获取其中间输出&lt;/li&gt;
&lt;li&gt;每个 Reduce 任务在 GFS 上写入一个单独的输出文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MR 如何最大限度地 reduce 网络使用？
&lt;ul&gt;
&lt;li&gt;Coordinator 尝试在存储其输入的 GFS 服务器上运行每个 Map 任务。
&lt;ul&gt;
&lt;li&gt;所有计算机都运行 GFS 和 MR 工作线程&lt;/li&gt;
&lt;li&gt;所以输入是从本地磁盘(通过 GFS)读取的，而不是通过网络读取。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中间数据仅通过网络一次。
&lt;ul&gt;
&lt;li&gt;Map worker 写入本地磁盘。&lt;/li&gt;
&lt;li&gt;Reduce worker 直接从 Map workers 读取，而不是通过 GFS。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将中间数据分区为包含许多键的文件。
&lt;ul&gt;
&lt;li&gt;R 远小于键的数量。&lt;/li&gt;
&lt;li&gt;大型网络传输效率更高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MR 如何获得良好的负载平衡？
&lt;ul&gt;
&lt;li&gt;如果 N-1 个服务器必须等待 1 个慢速服务器完成，则既浪费又慢。&lt;/li&gt;
&lt;li&gt;但有些任务可能需要比其他任务更长的时间。&lt;/li&gt;
&lt;li&gt;解决方案：任务比 worker 多得多。
&lt;ul&gt;
&lt;li&gt;coordinator 向完成先前任务的 worker 分发新任务。&lt;/li&gt;
&lt;li&gt;因此，没有任何任务如此之大，以至于会影响完成时间(希望如此)。&lt;/li&gt;
&lt;li&gt;因此，较快的服务器比较慢的服务器完成更多的任务，同时完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;容错呢
&lt;ul&gt;
&lt;li&gt;即如果 worker 在 MR 工作期间崩溃怎么办？&lt;/li&gt;
&lt;li&gt;我们希望对应用程序员完全隐藏故障！&lt;/li&gt;
&lt;li&gt;MR 是否必须从头开始重新运行整个工作？
&lt;ul&gt;
&lt;li&gt;为什么不？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MR 只重新运行失败的 Map()s 和 Reduce()s。
&lt;ul&gt;
&lt;li&gt;假设 MR 运行 Map 两次，其中一个 Reduce 看到第一次运行的输出，
&lt;ul&gt;
&lt;li&gt;另一个 Reduce 看到第二次运行的输出？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正确性需要重新执行以产生完全相同的输出。&lt;/li&gt;
&lt;li&gt;所以 Map 和 Reduce 必须是纯函数：
&lt;ul&gt;
&lt;li&gt;他们只被允许查看他们的参数&lt;/li&gt;
&lt;li&gt;无状态，无文件 I/O，无交互，无外部通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果你想允许非功能性的 Map 或 Reduce 怎么办？
&lt;ul&gt;
&lt;li&gt;worker 失败将需要重新执行整个工作，
&lt;ul&gt;
&lt;li&gt;或者您需要创建同步的全局检查点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;worker 崩溃恢复的详细信息
&lt;ul&gt;
&lt;li&gt;Map worker 崩溃
coordinator 通知 worker 不再响应 ping
coordinator 知道它在那个 worker 上运行了哪些 Map 任务
这些任务的中间输出现在丢失了，必须重新创建
coordinator 告诉其他 worker 运行这些任务
如果 Reduces 已经获取了中间数据，则可以省略重新运行&lt;/li&gt;
&lt;li&gt;reduce worker 崩溃。
完成的任务没问题——存储在 GFS 中，带有副本。
coordinator 重新启动其他 worker 的 worker 未完成的任务。&lt;/li&gt;
&lt;li&gt;其他故障/问题：
&lt;ul&gt;
&lt;li&gt;如果 coordinator 给两个 worker 相同的 Map() 任务怎么办？
也许 coordinator 错误地认为一名 worker 死亡。
它只会告诉 Reduce worker 其中之一。&lt;/li&gt;
&lt;li&gt;如果 coordinator 给两个 worker 相同的 Reduce() 任务怎么办？
他们都会尝试在 GFS 上写入相同的输出文件！
原子 GFS 重命名可防止混合；一个完整的文件将可见。&lt;/li&gt;
&lt;li&gt;如果一个 worker 很慢——一个“落后者”怎么办？
也许是由于 flakey 硬件。
coordinator 启动最后几个任务的第二个副本。&lt;/li&gt;
&lt;li&gt;如果 worker 由于硬件或软件损坏而计算出错误的输出怎么办？
太糟糕了！MR 假设“故障停止”CPU 和软件。&lt;/li&gt;
&lt;li&gt;如果 coordinator 崩溃怎么办？
&lt;ul&gt;
&lt;li&gt;重跑整个任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当前状态
&lt;ul&gt;
&lt;li&gt;极具影响力(Hadoop、Spark 等)。&lt;/li&gt;
&lt;li&gt;可能不再在 Google 使用。&lt;/li&gt;
&lt;li&gt;被 Flume / FlumeJava 取代(参见 Chambers 等人的论文)。&lt;/li&gt;
&lt;li&gt;GFS 替换为 Colossus(没有很好的描述)和 BigTable。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结论
&lt;ul&gt;
&lt;li&gt;MapReduce 一手让大集群计算流行起来。&lt;/li&gt;
&lt;li&gt;不是最有效或最灵活的。&lt;/li&gt;
&lt;li&gt;缩放良好。&lt;/li&gt;
&lt;li&gt;易于编程——隐藏故障和数据移动。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>