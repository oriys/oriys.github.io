<!DOCTYPE html>
<html lang="en-us">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> CMU::15-445/645::Tree Indexes 笔记 | Y.CH.Y</title>
  <link rel = 'canonical' href = '/courses/cmu_15_445_06_note/'>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="CMU::15-445/645::Tree Indexes 笔记" />
<meta property="og:description" content="树形索引第一部分 表索引 在数据库系统中，有许多不同的数据结构，可以用于内部元数据、核心数据存储、临时数据结构或表索引等目的。对于表索引，可能涉及到带有范围扫描的查询。
表索引是一个表的列的子集的副本，它被组织和(或)排序，以使用这些属性的子集进行有效的访问。因此，DBMS 可以查询表索引的辅助数据结构，而不是进行顺序扫描，以更快地找到元组。DBMS 确保表和索引的内容在逻辑上总是同步的。
在每个数据库要创建的索引数量之间存在着一个权衡。尽管更多的索引使得查询速度更快，但索引也会使用存储空间并需要维护。DBMS 的工作是找出用于执行查询的最佳索引。
B&#43;树 B&#43;Tree 是一种自平衡的树形数据结构，它可以保持数据的分类，并允许在 O(log(n))中进行搜索、顺序访问、插入和删除。它为面向磁盘的 DBMS 的读/写大型数据块而优化。
几乎所有支持保序索引的现代 DBMS 都使用 B&#43;Tree。有一种特定的数据结构叫做 B-Tree，但是人们也用这个词来泛指一类数据结构。原始的 B-Tree 和 B&#43;Tree 之间的主要区别是，B-Tree 在所有节点中存储键和值，而 B&#43;Tree 只在叶节点中存储值。现代 B&#43;Tree 的实现结合了其他 B-Tree 变体的特征，例如 B\(^{link}\)-Tree 中使用的兄弟姐妹指针。
从形式上看，B&#43;树是一棵具有以下特性的 M-way 搜索树。
 它是完全平衡的（即，每个叶子节点都在相同的深度）。 除根以外的每个内部节点至少有一半是满的（M/2 - 1 &lt;= 键的数量 &lt;= M - 1）。 每个有 k 个键的内部节点都有 k&#43;1 个非空子节点。  B&#43;Tree 中的每个节点都包含一个键/值对数组。这些对中的键是由索引所基于的属性派生的。这些值将根据一个节点是内部节点还是叶子节点而有所不同。对于内部节点，值数组将包含指向其他节点的指针。叶子节点值的两种方法是记录 ID 和元组数据。记录 ID 指的是一个指向元组位置的指针。有元组数据的叶子节点在每个节点中存储元组的实际内容。
每个节点的数组都（几乎）是按键排序的。
实践中节点中键和值是分开存储的
插入 要在 B&#43;树中插入一个新的条目，必须沿着树向下遍历，并使用内部节点来确定将值插入哪个叶子节点。
 找到正确的叶子 L。 按排序顺序将新条目添加到 L 中。  如果 L 有足够的空间，操作就完成了。 否则将 L 分成两个结点 L 和 L2。均匀地重新分配条目，并将中间的键复制上去。 将指向 L2 的索引条目插入 L 的父节点中。   要分割一个内部节点，均匀地重新分配条目，但要把中间的键向上推。  可视化演示网址" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/courses/cmu_15_445_06_note/" /><meta property="article:section" content="courses" />
<meta property="article:published_time" content="2021-08-05T08:41:54+08:00" />
<meta property="article:modified_time" content="2021-08-05T08:41:54+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CMU::15-445/645::Tree Indexes 笔记"/>
<meta name="twitter:description" content="树形索引第一部分 表索引 在数据库系统中，有许多不同的数据结构，可以用于内部元数据、核心数据存储、临时数据结构或表索引等目的。对于表索引，可能涉及到带有范围扫描的查询。
表索引是一个表的列的子集的副本，它被组织和(或)排序，以使用这些属性的子集进行有效的访问。因此，DBMS 可以查询表索引的辅助数据结构，而不是进行顺序扫描，以更快地找到元组。DBMS 确保表和索引的内容在逻辑上总是同步的。
在每个数据库要创建的索引数量之间存在着一个权衡。尽管更多的索引使得查询速度更快，但索引也会使用存储空间并需要维护。DBMS 的工作是找出用于执行查询的最佳索引。
B&#43;树 B&#43;Tree 是一种自平衡的树形数据结构，它可以保持数据的分类，并允许在 O(log(n))中进行搜索、顺序访问、插入和删除。它为面向磁盘的 DBMS 的读/写大型数据块而优化。
几乎所有支持保序索引的现代 DBMS 都使用 B&#43;Tree。有一种特定的数据结构叫做 B-Tree，但是人们也用这个词来泛指一类数据结构。原始的 B-Tree 和 B&#43;Tree 之间的主要区别是，B-Tree 在所有节点中存储键和值，而 B&#43;Tree 只在叶节点中存储值。现代 B&#43;Tree 的实现结合了其他 B-Tree 变体的特征，例如 B\(^{link}\)-Tree 中使用的兄弟姐妹指针。
从形式上看，B&#43;树是一棵具有以下特性的 M-way 搜索树。
 它是完全平衡的（即，每个叶子节点都在相同的深度）。 除根以外的每个内部节点至少有一半是满的（M/2 - 1 &lt;= 键的数量 &lt;= M - 1）。 每个有 k 个键的内部节点都有 k&#43;1 个非空子节点。  B&#43;Tree 中的每个节点都包含一个键/值对数组。这些对中的键是由索引所基于的属性派生的。这些值将根据一个节点是内部节点还是叶子节点而有所不同。对于内部节点，值数组将包含指向其他节点的指针。叶子节点值的两种方法是记录 ID 和元组数据。记录 ID 指的是一个指向元组位置的指针。有元组数据的叶子节点在每个节点中存储元组的实际内容。
每个节点的数组都（几乎）是按键排序的。
实践中节点中键和值是分开存储的
插入 要在 B&#43;树中插入一个新的条目，必须沿着树向下遍历，并使用内部节点来确定将值插入哪个叶子节点。
 找到正确的叶子 L。 按排序顺序将新条目添加到 L 中。  如果 L 有足够的空间，操作就完成了。 否则将 L 分成两个结点 L 和 L2。均匀地重新分配条目，并将中间的键复制上去。 将指向 L2 的索引条目插入 L 的父节点中。   要分割一个内部节点，均匀地重新分配条目，但要把中间的键向上推。  可视化演示网址"/>

  
  
    
  
  
  <link rel="stylesheet" href="/css/styles.ace637160e3ee466ac48adf2107be5e9e0b7f168aff4b05023ac0c573f8200b3f1ced7d604b86d1b519cf620f8b1bc3c13abec114d6d055da6327e8e79ac3dfb.css" integrity="sha512-rOY3Fg4&#43;5GasSK3yEHvl6eC38Wiv9LBQI6wMVz&#43;CALPxztfWBLhtG1Gc9iD4sbw8E6vsEU1tBV2mMn6Oeaw9&#43;w=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="/images/favicon.ico" />

  
  
  
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-X1L70M4MM0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="/">
  
    <div id="logo" style="background-image: url(/images/logo.png)"></div>
  
  <div id="title">
    <h1>Y.CH.Y</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/algorithm">算法</a></li>
      
        <li><a href="/outline">大纲</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <h2 id="树形索引第一部分">树形索引第一部分</h2>
<p><img src="https://i.imgur.com/RK21nhh.png" alt="img"></p>
<h3 id="表索引">表索引</h3>
<p>在数据库系统中，有许多不同的数据结构，可以用于内部元数据、核心数据存储、临时数据结构或表索引等目的。对于表索引，可能涉及到带有范围扫描的查询。</p>
<p>表索引是一个表的列的子集的副本，它被组织和(或)排序，以使用这些属性的子集进行有效的访问。因此，DBMS 可以查询表索引的辅助数据结构，而不是进行顺序扫描，以更快地找到元组。DBMS 确保表和索引的内容在逻辑上总是同步的。</p>
<p>在每个数据库要创建的索引数量之间存在着一个权衡。尽管更多的索引使得查询速度更快，但索引也会使用存储空间并需要维护。DBMS 的工作是找出用于执行查询的最佳索引。</p>
<h3 id="b树">B+树</h3>
<p>B+Tree 是一种自平衡的树形数据结构，它可以保持数据的分类，并允许在 O(log(n))中进行搜索、顺序访问、插入和删除。它为面向磁盘的 DBMS 的读/写大型数据块而优化。</p>
<p>几乎所有支持保序索引的现代 DBMS 都使用 B+Tree。有一种特定的数据结构叫做 B-Tree，但是人们也用这个词来泛指一类数据结构。原始的 B-Tree 和 B+Tree 之间的主要区别是，B-Tree 在所有节点中存储键和值，而 B+Tree 只在叶节点中存储值。现代 B+Tree 的实现结合了其他 B-Tree 变体的特征，例如 B\(^{link}\)-Tree 中使用的兄弟姐妹指针。</p>
<p><img src="https://i.imgur.com/W8jH3GU.png" alt="img"></p>
<p>从形式上看，B+树是一棵具有以下特性的 M-way 搜索树。</p>
<ul>
<li>它是完全平衡的（即，每个叶子节点都在相同的深度）。</li>
<li>除根以外的每个内部节点至少有一半是满的（M/2 - 1 &lt;= 键的数量 &lt;= M - 1）。</li>
<li>每个有 k 个键的内部节点都有 k+1 个非空子节点。</li>
</ul>
<p>B+Tree 中的每个节点都包含一个键/值对数组。这些对中的键是由索引所基于的属性派生的。这些值将根据一个节点是内部节点还是叶子节点而有所不同。对于内部节点，值数组将包含指向其他节点的指针。叶子节点值的两种方法是记录 ID 和元组数据。记录 ID 指的是一个指向元组位置的指针。有元组数据的叶子节点在每个节点中存储元组的实际内容。</p>
<p>每个节点的数组都（几乎）是按键排序的。</p>
<p><img src="https://i.imgur.com/gerdPnT.png" alt="img"></p>
<p>实践中节点中键和值是分开存储的</p>
<p><img src="https://i.imgur.com/qa9zakg.png" alt="img"></p>
<h4 id="插入">插入</h4>
<p>要在 B+树中插入一个新的条目，必须沿着树向下遍历，并使用内部节点来确定将值插入哪个叶子节点。</p>
<ul>
<li>找到正确的叶子 L。</li>
<li>按排序顺序将新条目添加到 L 中。
<ul>
<li>如果 L 有足够的空间，操作就完成了。</li>
<li>否则将 L 分成两个结点 L 和 L2。均匀地重新分配条目，并将中间的键复制上去。 将指向 L2 的索引条目插入 L 的父节点中。</li>
</ul>
</li>
<li>要分割一个内部节点，均匀地重新分配条目，但要把中间的键向上推。</li>
</ul>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">可视化演示网址</a></p>
<h4 id="删除">删除</h4>
<p>在插入过程中，当树变得太满时，我们偶尔不得不分割叶子，而如果删除导致树少于半满，我们必须进行合并，以重新平衡树。</p>
<ul>
<li>找到正确的叶子 L。</li>
<li>删除条目。
<ul>
<li>如果 L 至少有一半是满的，那么操作就完成了。</li>
<li>否则，你可以尝试重新分配，从兄弟姐妹那里借用。</li>
<li>如果重新分配失败，则合并 L 和同胞。</li>
</ul>
</li>
<li>如果合并发生了，你必须删除父类中指向 L 的条目。</li>
</ul>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">可视化演示网址</a></p>
<h4 id="条件选择">条件选择</h4>
<p>因为 B+Tree 是按排序的，查找时遍历速度很快，也不需要整个键。如果查询提供了搜索键的任何属性，DBMS 可以使用 B+Tree 索引。这与散列索引不同，散列索引需要搜索键中的所有属性。</p>
<h4 id="非唯一索引">非唯一索引</h4>
<p>像散列表一样，B+Trees 可以通过重复键或存储值列表来处理非唯一的索引。在重复键的方法中，使用相同的叶子节点布局，但重复的键被多次存储。 在值列表的方法中，每个键只存储一次，并保持一个唯一值的链接列表。</p>
<h4 id="重复键">重复键</h4>
<p>在 B+Tree 中，有两种方法来重复键。</p>
<p>第一种方法是将记录 ID 作为键的一部分来附加。由于每个元组的记录 ID 是唯一的，这将确保所有的键都是可识别的。DBMS 可以根据部分键来查找元组。</p>
<p>第二种方法是允许叶子节点溢出到包含重复键的溢出节点。 虽然没有多余的信息被存储，但这种方法的维护和修改更加复杂。</p>
<h4 id="聚簇索引">聚簇索引</h4>
<p>表按照主键指定的排序顺序存储，作为堆组织的或索引组织的存储。 由于一些 DBMS 总是使用聚簇索引，如果一个表没有明确的主键，它们会自动地将隐藏的行 ID 作为主键，但是其他的 DBMS 根本就不能使用它们。</p>
<h4 id="堆聚簇">堆聚簇</h4>
<p>元组在堆的页面中使用聚簇索引指定的顺序进行排序。如果聚类索引的属性被用来访问元组，DBMS 可以直接跳到这些页面。</p>
<h4 id="索引扫描页排序">索引扫描页排序</h4>
<p>由于直接从非聚簇索引中检索元组的效率很低，DBMS 可以首先找出它所需要的所有元组，然后根据它们的页面 id 进行排序。</p>

  
  </div>
</article>


    <footer id="footer">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
  <div class="footer-left">
    Copyright  &copy; 2021  Y.CH.Y 
    
    
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">首页</a></li>
         
        <li><a href="/algorithm">算法</a></li>
         
        <li><a href="/outline">大纲</a></li>
         
        <li><a href="/about">关于</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
